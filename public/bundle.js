/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qcz81ZjcxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgX193ZWJwYWNrX2FtZF9vcHRpb25zX18gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n        @@@@@@@            @@@@@@@         @@\n      @@       @@        @@       @@      @@@\n    @@   @@@ @@  @@    @@   @@@ @@  @@   @@@@@@ @@   @@@  @@ @@@      @@@@\n   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@   @@\n   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@@@@@@\n   @@  @@   @@@  @@   @@  @@   @@@  @@    @@@   @@   @@@  @@@   @@  @@@\n    @@   @@@ @@@@@     @@   @@@ @@@@@      @@@    @@@ @@  @@@@@@      @@@@@\n      @@                 @@                           @@  @@\n        @@@@@@@            @@@@@@@               @@@@@    @@\n                                                          */\n//. # sanctuary-type-identifiers\n//.\n//. A type is a set of values. Boolean, for example, is the type comprising\n//. `true` and `false`. A value may be a member of multiple types (`42` is a\n//. member of Number, PositiveNumber, Integer, and many other types).\n//.\n//. In certain situations it is useful to divide JavaScript values into\n//. non-overlapping types. The language provides two constructs for this\n//. purpose: the [`typeof`][1] operator and [`Object.prototype.toString`][2].\n//. Each has pros and cons, but neither supports user-defined types.\n//.\n//. sanctuary-type-identifiers comprises:\n//.\n//.   - an npm and browser -compatible package for deriving the\n//.     _type identifier_ of a JavaScript value; and\n//.   - a specification which authors may follow to specify type\n//.     identifiers for their types.\n//.\n//. ### Specification\n//.\n//. For a type to be compatible with the algorithm:\n//.\n//.   - every member of the type MUST have a `constructor` property\n//.     pointing to an object known as the _type representative_;\n//.\n//.   - the type representative MUST have a `@@type` property\n//.     (the _type identifier_); and\n//.\n//.   - the type identifier MUST be a string primitive and SHOULD have\n//.     format `'<namespace>/<name>[@<version>]'`, where:\n//.\n//.       - `<namespace>` MUST consist of one or more characters, and\n//.         SHOULD equal the name of the npm package which defines the\n//.         type (including [scope][3] where appropriate);\n//.\n//.       - `<name>` MUST consist of one or more characters, and SHOULD\n//.         be the unique name of the type; and\n//.\n//.       - `<version>` MUST consist of one or more digits, and SHOULD\n//.         represent the version of the type.\n//.\n//. If the type identifier does not conform to the format specified above,\n//. it is assumed that the entire string represents the _name_ of the type;\n//. _namespace_ will be `null` and _version_ will be `0`.\n//.\n//. If the _version_ is not given, it is assumed to be `0`.\n//.\n//. For example:\n//.\n//. ```javascript\n//. //  Identity :: a -> Identity a\n//. function Identity(x) {\n//.   if (!(this instanceof Identity)) return new Identity(x);\n//.   this.value = x;\n//. }\n//.\n//. Identity['@@type'] = 'my-package/Identity';\n//. ```\n//.\n//. Note that by using a constructor function the `constructor` property is set\n//. implicitly for each value created. Constructor functions are convenient for\n//. this reason, but are not required. This definition is also valid:\n//.\n//. ```javascript\n//. //  IdentityTypeRep :: TypeRep Identity\n//. var IdentityTypeRep = {\n//.   '@@type': 'my-package/Identity'\n//. };\n//.\n//. //  Identity :: a -> Identity a\n//. function Identity(x) {\n//.   return {constructor: IdentityTypeRep, value: x};\n//. }\n//. ```\n\n(function(f) {\n\n  'use strict';\n\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f();\n  } else if (\"function\" === 'function' && __webpack_require__(0) != null) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {\n    self.sanctuaryTypeIdentifiers = f();\n  }\n\n}(function() {\n\n  'use strict';\n\n  //  $$type :: String\n  var $$type = '@@type';\n\n  //  pattern :: RegExp\n  var pattern = new RegExp(\n    '^'\n  + '([\\\\s\\\\S]+)'   //  <namespace>\n  + '/'             //  SOLIDUS (U+002F)\n  + '([\\\\s\\\\S]+?)'  //  <name>\n  + '(?:'           //  optional non-capturing group {\n  +   '@'           //    COMMERCIAL AT (U+0040)\n  +   '([0-9]+)'    //    <version>\n  + ')?'            //  }\n  + '$'\n  );\n\n  //. ### Usage\n  //.\n  //. ```javascript\n  //. const type = require('sanctuary-type-identifiers');\n  //. ```\n  //.\n  //. ```javascript\n  //. > function Identity(x) {\n  //. .   if (!(this instanceof Identity)) return new Identity(x);\n  //. .   this.value = x;\n  //. . }\n  //. . Identity['@@type'] = 'my-package/Identity@1';\n  //.\n  //. > type.parse(type(Identity(0)))\n  //. {namespace: 'my-package', name: 'Identity', version: 1}\n  //. ```\n  //.\n  //. ### API\n  //.\n  //# type :: Any -> String\n  //.\n  //. Takes any value and returns a string which identifies its type. If the\n  //. value conforms to the [specification][4], the custom type identifier is\n  //. returned.\n  //.\n  //. ```javascript\n  //. > type(null)\n  //. 'Null'\n  //.\n  //. > type(true)\n  //. 'Boolean'\n  //.\n  //. > type(Identity(0))\n  //. 'my-package/Identity@1'\n  //. ```\n  function type(x) {\n    return x != null &&\n           x.constructor != null &&\n           x.constructor.prototype !== x &&\n           typeof x.constructor[$$type] === 'string' ?\n      x.constructor[$$type] :\n      Object.prototype.toString.call(x).slice('[object '.length, -']'.length);\n  }\n\n  //# type.parse :: String -> { namespace :: Nullable String, name :: String, version :: Number }\n  //.\n  //. Takes any string and parses it according to the [specification][4],\n  //. returning an object with `namespace`, `name`, and `version` fields.\n  //.\n  //. ```javascript\n  //. > type.parse('my-package/List@2')\n  //. {namespace: 'my-package', name: 'List', version: 2}\n  //.\n  //. > type.parse('nonsense!')\n  //. {namespace: null, name: 'nonsense!', version: 0}\n  //.\n  //. > type.parse(Identity['@@type'])\n  //. {namespace: 'my-package', name: 'Identity', version: 1}\n  //. ```\n  type.parse = function parse(s) {\n    var groups = pattern.exec(s);\n    return {\n      namespace: groups == null || groups[1] == null ? null : groups[1],\n      name:      groups == null                      ? s    : groups[2],\n      version:   groups == null || groups[3] == null ? 0    : Number(groups[3])\n    };\n  };\n\n  return type;\n\n}));\n\n//. [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\n//. [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n//. [3]: https://docs.npmjs.com/misc/scope\n//. [4]: #specification\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zYW5jdHVhcnktdHlwZS1pZGVudGlmaWVycy9pbmRleC5qcz9hNTBiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgICAgIEBAQEBAQEAgICAgICAgICAgICBAQEBAQEBAICAgICAgICAgQEBcbiAgICAgIEBAICAgICAgIEBAICAgICAgICBAQCAgICAgICBAQCAgICAgIEBAQFxuICAgIEBAICAgQEBAIEBAICBAQCAgICBAQCAgIEBAQCBAQCAgQEAgICBAQEBAQEAgQEAgICBAQEAgIEBAIEBAQCAgICAgIEBAQEBcbiAgIEBAICBAQCAgIEBAQCAgIEBAICBAQCAgQEAgICBAQEAgICBAQCAgIEBAQCAgIEBAICAgQEBAICBAQEAgICBAQCAgQEBAICAgQEBcbiAgIEBAICBAQCAgIEBAQCAgIEBAICBAQCAgQEAgICBAQEAgICBAQCAgIEBAQCAgIEBAICAgQEBAICBAQEAgICBAQCAgQEBAQEBAQEBcbiAgIEBAICBAQCAgIEBAQCAgQEAgICBAQCAgQEAgICBAQEAgIEBAICAgIEBAQCAgIEBAICAgQEBAICBAQEAgICBAQCAgQEBAXG4gICAgQEAgICBAQEAgQEBAQEAgICAgIEBAICAgQEBAIEBAQEBAICAgICAgQEBAICAgIEBAQCBAQCAgQEBAQEBAICAgICAgQEBAQEBcbiAgICAgIEBAICAgICAgICAgICAgICAgICBAQCAgICAgICAgICAgICAgICAgICAgICAgICAgIEBAICBAQFxuICAgICAgICBAQEBAQEBAICAgICAgICAgICAgQEBAQEBAQCAgICAgICAgICAgICAgIEBAQEBAICAgIEBAXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8vLiAjIHNhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzXG4vLy5cbi8vLiBBIHR5cGUgaXMgYSBzZXQgb2YgdmFsdWVzLiBCb29sZWFuLCBmb3IgZXhhbXBsZSwgaXMgdGhlIHR5cGUgY29tcHJpc2luZ1xuLy8uIGB0cnVlYCBhbmQgYGZhbHNlYC4gQSB2YWx1ZSBtYXkgYmUgYSBtZW1iZXIgb2YgbXVsdGlwbGUgdHlwZXMgKGA0MmAgaXMgYVxuLy8uIG1lbWJlciBvZiBOdW1iZXIsIFBvc2l0aXZlTnVtYmVyLCBJbnRlZ2VyLCBhbmQgbWFueSBvdGhlciB0eXBlcykuXG4vLy5cbi8vLiBJbiBjZXJ0YWluIHNpdHVhdGlvbnMgaXQgaXMgdXNlZnVsIHRvIGRpdmlkZSBKYXZhU2NyaXB0IHZhbHVlcyBpbnRvXG4vLy4gbm9uLW92ZXJsYXBwaW5nIHR5cGVzLiBUaGUgbGFuZ3VhZ2UgcHJvdmlkZXMgdHdvIGNvbnN0cnVjdHMgZm9yIHRoaXNcbi8vLiBwdXJwb3NlOiB0aGUgW2B0eXBlb2ZgXVsxXSBvcGVyYXRvciBhbmQgW2BPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYF1bMl0uXG4vLy4gRWFjaCBoYXMgcHJvcyBhbmQgY29ucywgYnV0IG5laXRoZXIgc3VwcG9ydHMgdXNlci1kZWZpbmVkIHR5cGVzLlxuLy8uXG4vLy4gc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMgY29tcHJpc2VzOlxuLy8uXG4vLy4gICAtIGFuIG5wbSBhbmQgYnJvd3NlciAtY29tcGF0aWJsZSBwYWNrYWdlIGZvciBkZXJpdmluZyB0aGVcbi8vLiAgICAgX3R5cGUgaWRlbnRpZmllcl8gb2YgYSBKYXZhU2NyaXB0IHZhbHVlOyBhbmRcbi8vLiAgIC0gYSBzcGVjaWZpY2F0aW9uIHdoaWNoIGF1dGhvcnMgbWF5IGZvbGxvdyB0byBzcGVjaWZ5IHR5cGVcbi8vLiAgICAgaWRlbnRpZmllcnMgZm9yIHRoZWlyIHR5cGVzLlxuLy8uXG4vLy4gIyMjIFNwZWNpZmljYXRpb25cbi8vLlxuLy8uIEZvciBhIHR5cGUgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBhbGdvcml0aG06XG4vLy5cbi8vLiAgIC0gZXZlcnkgbWVtYmVyIG9mIHRoZSB0eXBlIE1VU1QgaGF2ZSBhIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHlcbi8vLiAgICAgcG9pbnRpbmcgdG8gYW4gb2JqZWN0IGtub3duIGFzIHRoZSBfdHlwZSByZXByZXNlbnRhdGl2ZV87XG4vLy5cbi8vLiAgIC0gdGhlIHR5cGUgcmVwcmVzZW50YXRpdmUgTVVTVCBoYXZlIGEgYEBAdHlwZWAgcHJvcGVydHlcbi8vLiAgICAgKHRoZSBfdHlwZSBpZGVudGlmaWVyXyk7IGFuZFxuLy8uXG4vLy4gICAtIHRoZSB0eXBlIGlkZW50aWZpZXIgTVVTVCBiZSBhIHN0cmluZyBwcmltaXRpdmUgYW5kIFNIT1VMRCBoYXZlXG4vLy4gICAgIGZvcm1hdCBgJzxuYW1lc3BhY2U+LzxuYW1lPltAPHZlcnNpb24+XSdgLCB3aGVyZTpcbi8vLlxuLy8uICAgICAgIC0gYDxuYW1lc3BhY2U+YCBNVVNUIGNvbnNpc3Qgb2Ygb25lIG9yIG1vcmUgY2hhcmFjdGVycywgYW5kXG4vLy4gICAgICAgICBTSE9VTEQgZXF1YWwgdGhlIG5hbWUgb2YgdGhlIG5wbSBwYWNrYWdlIHdoaWNoIGRlZmluZXMgdGhlXG4vLy4gICAgICAgICB0eXBlIChpbmNsdWRpbmcgW3Njb3BlXVszXSB3aGVyZSBhcHByb3ByaWF0ZSk7XG4vLy5cbi8vLiAgICAgICAtIGA8bmFtZT5gIE1VU1QgY29uc2lzdCBvZiBvbmUgb3IgbW9yZSBjaGFyYWN0ZXJzLCBhbmQgU0hPVUxEXG4vLy4gICAgICAgICBiZSB0aGUgdW5pcXVlIG5hbWUgb2YgdGhlIHR5cGU7IGFuZFxuLy8uXG4vLy4gICAgICAgLSBgPHZlcnNpb24+YCBNVVNUIGNvbnNpc3Qgb2Ygb25lIG9yIG1vcmUgZGlnaXRzLCBhbmQgU0hPVUxEXG4vLy4gICAgICAgICByZXByZXNlbnQgdGhlIHZlcnNpb24gb2YgdGhlIHR5cGUuXG4vLy5cbi8vLiBJZiB0aGUgdHlwZSBpZGVudGlmaWVyIGRvZXMgbm90IGNvbmZvcm0gdG8gdGhlIGZvcm1hdCBzcGVjaWZpZWQgYWJvdmUsXG4vLy4gaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBlbnRpcmUgc3RyaW5nIHJlcHJlc2VudHMgdGhlIF9uYW1lXyBvZiB0aGUgdHlwZTtcbi8vLiBfbmFtZXNwYWNlXyB3aWxsIGJlIGBudWxsYCBhbmQgX3ZlcnNpb25fIHdpbGwgYmUgYDBgLlxuLy8uXG4vLy4gSWYgdGhlIF92ZXJzaW9uXyBpcyBub3QgZ2l2ZW4sIGl0IGlzIGFzc3VtZWQgdG8gYmUgYDBgLlxuLy8uXG4vLy4gRm9yIGV4YW1wbGU6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gLy8gIElkZW50aXR5IDo6IGEgLT4gSWRlbnRpdHkgYVxuLy8uIGZ1bmN0aW9uIElkZW50aXR5KHgpIHtcbi8vLiAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJZGVudGl0eSkpIHJldHVybiBuZXcgSWRlbnRpdHkoeCk7XG4vLy4gICB0aGlzLnZhbHVlID0geDtcbi8vLiB9XG4vLy5cbi8vLiBJZGVudGl0eVsnQEB0eXBlJ10gPSAnbXktcGFja2FnZS9JZGVudGl0eSc7XG4vLy4gYGBgXG4vLy5cbi8vLiBOb3RlIHRoYXQgYnkgdXNpbmcgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBpcyBzZXRcbi8vLiBpbXBsaWNpdGx5IGZvciBlYWNoIHZhbHVlIGNyZWF0ZWQuIENvbnN0cnVjdG9yIGZ1bmN0aW9ucyBhcmUgY29udmVuaWVudCBmb3Jcbi8vLiB0aGlzIHJlYXNvbiwgYnV0IGFyZSBub3QgcmVxdWlyZWQuIFRoaXMgZGVmaW5pdGlvbiBpcyBhbHNvIHZhbGlkOlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIC8vICBJZGVudGl0eVR5cGVSZXAgOjogVHlwZVJlcCBJZGVudGl0eVxuLy8uIHZhciBJZGVudGl0eVR5cGVSZXAgPSB7XG4vLy4gICAnQEB0eXBlJzogJ215LXBhY2thZ2UvSWRlbnRpdHknXG4vLy4gfTtcbi8vLlxuLy8uIC8vICBJZGVudGl0eSA6OiBhIC0+IElkZW50aXR5IGFcbi8vLiBmdW5jdGlvbiBJZGVudGl0eSh4KSB7XG4vLy4gICByZXR1cm4ge2NvbnN0cnVjdG9yOiBJZGVudGl0eVR5cGVSZXAsIHZhbHVlOiB4fTtcbi8vLiB9XG4vLy4gYGBgXG5cbihmdW5jdGlvbihmKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICE9IG51bGwpIHtcbiAgICBkZWZpbmUoW10sIGYpO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuc2FuY3R1YXJ5VHlwZUlkZW50aWZpZXJzID0gZigpO1xuICB9XG5cbn0oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vICAkJHR5cGUgOjogU3RyaW5nXG4gIHZhciAkJHR5cGUgPSAnQEB0eXBlJztcblxuICAvLyAgcGF0dGVybiA6OiBSZWdFeHBcbiAgdmFyIHBhdHRlcm4gPSBuZXcgUmVnRXhwKFxuICAgICdeJ1xuICArICcoW1xcXFxzXFxcXFNdKyknICAgLy8gIDxuYW1lc3BhY2U+XG4gICsgJy8nICAgICAgICAgICAgIC8vICBTT0xJRFVTIChVKzAwMkYpXG4gICsgJyhbXFxcXHNcXFxcU10rPyknICAvLyAgPG5hbWU+XG4gICsgJyg/OicgICAgICAgICAgIC8vICBvcHRpb25hbCBub24tY2FwdHVyaW5nIGdyb3VwIHtcbiAgKyAgICdAJyAgICAgICAgICAgLy8gICAgQ09NTUVSQ0lBTCBBVCAoVSswMDQwKVxuICArICAgJyhbMC05XSspJyAgICAvLyAgICA8dmVyc2lvbj5cbiAgKyAnKT8nICAgICAgICAgICAgLy8gIH1cbiAgKyAnJCdcbiAgKTtcblxuICAvLy4gIyMjIFVzYWdlXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gY29uc3QgdHlwZSA9IHJlcXVpcmUoJ3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzJyk7XG4gIC8vLiBgYGBcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGZ1bmN0aW9uIElkZW50aXR5KHgpIHtcbiAgLy8uIC4gICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSWRlbnRpdHkpKSByZXR1cm4gbmV3IElkZW50aXR5KHgpO1xuICAvLy4gLiAgIHRoaXMudmFsdWUgPSB4O1xuICAvLy4gLiB9XG4gIC8vLiAuIElkZW50aXR5WydAQHR5cGUnXSA9ICdteS1wYWNrYWdlL0lkZW50aXR5QDEnO1xuICAvLy5cbiAgLy8uID4gdHlwZS5wYXJzZSh0eXBlKElkZW50aXR5KDApKSlcbiAgLy8uIHtuYW1lc3BhY2U6ICdteS1wYWNrYWdlJywgbmFtZTogJ0lkZW50aXR5JywgdmVyc2lvbjogMX1cbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uICMjIyBBUElcbiAgLy8uXG4gIC8vIyB0eXBlIDo6IEFueSAtPiBTdHJpbmdcbiAgLy8uXG4gIC8vLiBUYWtlcyBhbnkgdmFsdWUgYW5kIHJldHVybnMgYSBzdHJpbmcgd2hpY2ggaWRlbnRpZmllcyBpdHMgdHlwZS4gSWYgdGhlXG4gIC8vLiB2YWx1ZSBjb25mb3JtcyB0byB0aGUgW3NwZWNpZmljYXRpb25dWzRdLCB0aGUgY3VzdG9tIHR5cGUgaWRlbnRpZmllciBpc1xuICAvLy4gcmV0dXJuZWQuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiB0eXBlKG51bGwpXG4gIC8vLiAnTnVsbCdcbiAgLy8uXG4gIC8vLiA+IHR5cGUodHJ1ZSlcbiAgLy8uICdCb29sZWFuJ1xuICAvLy5cbiAgLy8uID4gdHlwZShJZGVudGl0eSgwKSlcbiAgLy8uICdteS1wYWNrYWdlL0lkZW50aXR5QDEnXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gdHlwZSh4KSB7XG4gICAgcmV0dXJuIHggIT0gbnVsbCAmJlxuICAgICAgICAgICB4LmNvbnN0cnVjdG9yICE9IG51bGwgJiZcbiAgICAgICAgICAgeC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgIT09IHggJiZcbiAgICAgICAgICAgdHlwZW9mIHguY29uc3RydWN0b3JbJCR0eXBlXSA9PT0gJ3N0cmluZycgP1xuICAgICAgeC5jb25zdHJ1Y3RvclskJHR5cGVdIDpcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KS5zbGljZSgnW29iamVjdCAnLmxlbmd0aCwgLSddJy5sZW5ndGgpO1xuICB9XG5cbiAgLy8jIHR5cGUucGFyc2UgOjogU3RyaW5nIC0+IHsgbmFtZXNwYWNlIDo6IE51bGxhYmxlIFN0cmluZywgbmFtZSA6OiBTdHJpbmcsIHZlcnNpb24gOjogTnVtYmVyIH1cbiAgLy8uXG4gIC8vLiBUYWtlcyBhbnkgc3RyaW5nIGFuZCBwYXJzZXMgaXQgYWNjb3JkaW5nIHRvIHRoZSBbc3BlY2lmaWNhdGlvbl1bNF0sXG4gIC8vLiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYG5hbWVzcGFjZWAsIGBuYW1lYCwgYW5kIGB2ZXJzaW9uYCBmaWVsZHMuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiB0eXBlLnBhcnNlKCdteS1wYWNrYWdlL0xpc3RAMicpXG4gIC8vLiB7bmFtZXNwYWNlOiAnbXktcGFja2FnZScsIG5hbWU6ICdMaXN0JywgdmVyc2lvbjogMn1cbiAgLy8uXG4gIC8vLiA+IHR5cGUucGFyc2UoJ25vbnNlbnNlIScpXG4gIC8vLiB7bmFtZXNwYWNlOiBudWxsLCBuYW1lOiAnbm9uc2Vuc2UhJywgdmVyc2lvbjogMH1cbiAgLy8uXG4gIC8vLiA+IHR5cGUucGFyc2UoSWRlbnRpdHlbJ0BAdHlwZSddKVxuICAvLy4ge25hbWVzcGFjZTogJ215LXBhY2thZ2UnLCBuYW1lOiAnSWRlbnRpdHknLCB2ZXJzaW9uOiAxfVxuICAvLy4gYGBgXG4gIHR5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShzKSB7XG4gICAgdmFyIGdyb3VwcyA9IHBhdHRlcm4uZXhlYyhzKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZXNwYWNlOiBncm91cHMgPT0gbnVsbCB8fCBncm91cHNbMV0gPT0gbnVsbCA/IG51bGwgOiBncm91cHNbMV0sXG4gICAgICBuYW1lOiAgICAgIGdyb3VwcyA9PSBudWxsICAgICAgICAgICAgICAgICAgICAgID8gcyAgICA6IGdyb3Vwc1syXSxcbiAgICAgIHZlcnNpb246ICAgZ3JvdXBzID09IG51bGwgfHwgZ3JvdXBzWzNdID09IG51bGwgPyAwICAgIDogTnVtYmVyKGdyb3Vwc1szXSlcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiB0eXBlO1xuXG59KSk7XG5cbi8vLiBbMV06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy90eXBlb2Zcbi8vLiBbMl06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC90b1N0cmluZ1xuLy8uIFszXTogaHR0cHM6Ly9kb2NzLm5wbWpzLmNvbS9taXNjL3Njb3BlXG4vLy4gWzRdOiAjc3BlY2lmaWNhdGlvblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return h; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createElement\", function() { return h; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cloneElement\", function() { return cloneElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Component\", function() { return Component; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"render\", function() { return render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rerender\", function() { return rerender; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"options\", function() { return options; });\n/** Virtual DOM Node */\nfunction VNode() {}\n\n/** Global options\n *\t@public\n *\t@namespace options {Object}\n */\nvar options = {\n\n\t/** If `true`, `prop` changes trigger synchronous component updates.\n  *\t@name syncComponentUpdates\n  *\t@type Boolean\n  *\t@default true\n  */\n\t//syncComponentUpdates: true,\n\n\t/** Processes all created VNodes.\n  *\t@param {VNode} vnode\tA newly-created VNode to normalize/process\n  */\n\t//vnode(vnode) { }\n\n\t/** Hook invoked after a component is mounted. */\n\t// afterMount(component) { }\n\n\t/** Hook invoked after the DOM is updated with a component's latest render. */\n\t// afterUpdate(component) { }\n\n\t/** Hook invoked immediately before a component is unmounted. */\n\t// beforeUnmount(component) { }\n};\n\nvar stack = [];\n\nvar EMPTY_CHILDREN = [];\n\n/**\n * JSX/hyperscript reviver.\n * @see http://jasonformat.com/wtf-is-jsx\n * Benchmarks: https://esbench.com/bench/57ee8f8e330ab09900a1a1a0\n *\n * Note: this is exported as both `h()` and `createElement()` for compatibility reasons.\n *\n * Creates a VNode (virtual DOM element). A tree of VNodes can be used as a lightweight representation\n * of the structure of a DOM tree. This structure can be realized by recursively comparing it against\n * the current _actual_ DOM structure, and applying only the differences.\n *\n * `h()`/`createElement()` accepts an element name, a list of attributes/props,\n * and optionally children to append to the element.\n *\n * @example The following DOM tree\n *\n * `<div id=\"foo\" name=\"bar\">Hello!</div>`\n *\n * can be constructed using this function as:\n *\n * `h('div', { id: 'foo', name : 'bar' }, 'Hello!');`\n *\n * @param {string} nodeName\tAn element name. Ex: `div`, `a`, `span`, etc.\n * @param {Object} attributes\tAny attributes/props to set on the created element.\n * @param rest\t\t\tAdditional arguments are taken to be children to append. Can be infinitely nested Arrays.\n *\n * @public\n */\nfunction h(nodeName, attributes) {\n\tvar children = EMPTY_CHILDREN,\n\t    lastSimple,\n\t    child,\n\t    simple,\n\t    i;\n\tfor (i = arguments.length; i-- > 2;) {\n\t\tstack.push(arguments[i]);\n\t}\n\tif (attributes && attributes.children != null) {\n\t\tif (!stack.length) stack.push(attributes.children);\n\t\tdelete attributes.children;\n\t}\n\twhile (stack.length) {\n\t\tif ((child = stack.pop()) && child.pop !== undefined) {\n\t\t\tfor (i = child.length; i--;) {\n\t\t\t\tstack.push(child[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (typeof child === 'boolean') child = null;\n\n\t\t\tif (simple = typeof nodeName !== 'function') {\n\t\t\t\tif (child == null) child = '';else if (typeof child === 'number') child = String(child);else if (typeof child !== 'string') simple = false;\n\t\t\t}\n\n\t\t\tif (simple && lastSimple) {\n\t\t\t\tchildren[children.length - 1] += child;\n\t\t\t} else if (children === EMPTY_CHILDREN) {\n\t\t\t\tchildren = [child];\n\t\t\t} else {\n\t\t\t\tchildren.push(child);\n\t\t\t}\n\n\t\t\tlastSimple = simple;\n\t\t}\n\t}\n\n\tvar p = new VNode();\n\tp.nodeName = nodeName;\n\tp.children = children;\n\tp.attributes = attributes == null ? undefined : attributes;\n\tp.key = attributes == null ? undefined : attributes.key;\n\n\t// if a \"vnode hook\" is defined, pass every created VNode to it\n\tif (options.vnode !== undefined) options.vnode(p);\n\n\treturn p;\n}\n\n/**\n *  Copy all properties from `props` onto `obj`.\n *  @param {Object} obj\t\tObject onto which properties should be copied.\n *  @param {Object} props\tObject from which to copy properties.\n *  @returns obj\n *  @private\n */\nfunction extend(obj, props) {\n  for (var i in props) {\n    obj[i] = props[i];\n  }return obj;\n}\n\n/**\n * Call a function asynchronously, as soon as possible. Makes\n * use of HTML Promise to schedule the callback if available,\n * otherwise falling back to `setTimeout` (mainly for IE<11).\n *\n * @param {Function} callback\n */\nvar defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {VNode} vnode\t\tThe virutal DOM element to clone\n * @param {Object} props\tAttributes/props to add when cloning\n * @param {VNode} rest\t\tAny additional arguments will be used as replacement children.\n */\nfunction cloneElement(vnode, props) {\n  return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);\n}\n\n// DOM properties that should NOT have \"px\" added when numeric\nvar IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;\n\n/** Managed queue of dirty components to be re-rendered */\n\nvar items = [];\n\nfunction enqueueRender(component) {\n\tif (!component._dirty && (component._dirty = true) && items.push(component) == 1) {\n\t\t(options.debounceRendering || defer)(rerender);\n\t}\n}\n\nfunction rerender() {\n\tvar p,\n\t    list = items;\n\titems = [];\n\twhile (p = list.pop()) {\n\t\tif (p._dirty) renderComponent(p);\n\t}\n}\n\n/**\n * Check if two nodes are equivalent.\n *\n * @param {Node} node\t\t\tDOM Node to compare\n * @param {VNode} vnode\t\t\tVirtual DOM node to compare\n * @param {boolean} [hyrdating=false]\tIf true, ignores component constructors when comparing.\n * @private\n */\nfunction isSameNodeType(node, vnode, hydrating) {\n  if (typeof vnode === 'string' || typeof vnode === 'number') {\n    return node.splitText !== undefined;\n  }\n  if (typeof vnode.nodeName === 'string') {\n    return !node._componentConstructor && isNamedNode(node, vnode.nodeName);\n  }\n  return hydrating || node._componentConstructor === vnode.nodeName;\n}\n\n/**\n * Check if an Element has a given nodeName, case-insensitively.\n *\n * @param {Element} node\tA DOM Element to inspect the name of.\n * @param {String} nodeName\tUnnormalized name to compare against.\n */\nfunction isNamedNode(node, nodeName) {\n  return node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();\n}\n\n/**\n * Reconstruct Component-style `props` from a VNode.\n * Ensures default/fallback values from `defaultProps`:\n * Own-properties of `defaultProps` not present in `vnode.attributes` are added.\n *\n * @param {VNode} vnode\n * @returns {Object} props\n */\nfunction getNodeProps(vnode) {\n  var props = extend({}, vnode.attributes);\n  props.children = vnode.children;\n\n  var defaultProps = vnode.nodeName.defaultProps;\n  if (defaultProps !== undefined) {\n    for (var i in defaultProps) {\n      if (props[i] === undefined) {\n        props[i] = defaultProps[i];\n      }\n    }\n  }\n\n  return props;\n}\n\n/** Create an element with the given nodeName.\n *\t@param {String} nodeName\n *\t@param {Boolean} [isSvg=false]\tIf `true`, creates an element within the SVG namespace.\n *\t@returns {Element} node\n */\nfunction createNode(nodeName, isSvg) {\n\tvar node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);\n\tnode.normalizedNodeName = nodeName;\n\treturn node;\n}\n\n/** Remove a child node from its parent if attached.\n *\t@param {Element} node\t\tThe node to remove\n */\nfunction removeNode(node) {\n\tvar parentNode = node.parentNode;\n\tif (parentNode) parentNode.removeChild(node);\n}\n\n/** Set a named attribute on the given Node, with special behavior for some names and event handlers.\n *\tIf `value` is `null`, the attribute/handler will be removed.\n *\t@param {Element} node\tAn element to mutate\n *\t@param {string} name\tThe name/key to set, such as an event or attribute name\n *\t@param {any} old\tThe last value that was set for this name/node pair\n *\t@param {any} value\tAn attribute value, such as a function to be used as an event handler\n *\t@param {Boolean} isSvg\tAre we currently diffing inside an svg?\n *\t@private\n */\nfunction setAccessor(node, name, old, value, isSvg) {\n\tif (name === 'className') name = 'class';\n\n\tif (name === 'key') {\n\t\t// ignore\n\t} else if (name === 'ref') {\n\t\tif (old) old(null);\n\t\tif (value) value(node);\n\t} else if (name === 'class' && !isSvg) {\n\t\tnode.className = value || '';\n\t} else if (name === 'style') {\n\t\tif (!value || typeof value === 'string' || typeof old === 'string') {\n\t\t\tnode.style.cssText = value || '';\n\t\t}\n\t\tif (value && typeof value === 'object') {\n\t\t\tif (typeof old !== 'string') {\n\t\t\t\tfor (var i in old) {\n\t\t\t\t\tif (!(i in value)) node.style[i] = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (var i in value) {\n\t\t\t\tnode.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];\n\t\t\t}\n\t\t}\n\t} else if (name === 'dangerouslySetInnerHTML') {\n\t\tif (value) node.innerHTML = value.__html || '';\n\t} else if (name[0] == 'o' && name[1] == 'n') {\n\t\tvar useCapture = name !== (name = name.replace(/Capture$/, ''));\n\t\tname = name.toLowerCase().substring(2);\n\t\tif (value) {\n\t\t\tif (!old) node.addEventListener(name, eventProxy, useCapture);\n\t\t} else {\n\t\t\tnode.removeEventListener(name, eventProxy, useCapture);\n\t\t}\n\t\t(node._listeners || (node._listeners = {}))[name] = value;\n\t} else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {\n\t\tsetProperty(node, name, value == null ? '' : value);\n\t\tif (value == null || value === false) node.removeAttribute(name);\n\t} else {\n\t\tvar ns = isSvg && name !== (name = name.replace(/^xlink\\:?/, ''));\n\t\tif (value == null || value === false) {\n\t\t\tif (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());else node.removeAttribute(name);\n\t\t} else if (typeof value !== 'function') {\n\t\t\tif (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);else node.setAttribute(name, value);\n\t\t}\n\t}\n}\n\n/** Attempt to set a DOM property to the given value.\n *\tIE & FF throw for certain property-value combinations.\n */\nfunction setProperty(node, name, value) {\n\ttry {\n\t\tnode[name] = value;\n\t} catch (e) {}\n}\n\n/** Proxy an event to hooked event handlers\n *\t@private\n */\nfunction eventProxy(e) {\n\treturn this._listeners[e.type](options.event && options.event(e) || e);\n}\n\n/** Queue of components that have been mounted and are awaiting componentDidMount */\nvar mounts = [];\n\n/** Diff recursion count, used to track the end of the diff cycle. */\nvar diffLevel = 0;\n\n/** Global flag indicating if the diff is currently within an SVG */\nvar isSvgMode = false;\n\n/** Global flag indicating if the diff is performing hydration */\nvar hydrating = false;\n\n/** Invoke queued componentDidMount lifecycle methods */\nfunction flushMounts() {\n\tvar c;\n\twhile (c = mounts.pop()) {\n\t\tif (options.afterMount) options.afterMount(c);\n\t\tif (c.componentDidMount) c.componentDidMount();\n\t}\n}\n\n/** Apply differences in a given vnode (and it's deep children) to a real DOM Node.\n *\t@param {Element} [dom=null]\t\tA DOM node to mutate into the shape of the `vnode`\n *\t@param {VNode} vnode\t\t\tA VNode (with descendants forming a tree) representing the desired DOM structure\n *\t@returns {Element} dom\t\t\tThe created/mutated element\n *\t@private\n */\nfunction diff(dom, vnode, context, mountAll, parent, componentRoot) {\n\t// diffLevel having been 0 here indicates initial entry into the diff (not a subdiff)\n\tif (!diffLevel++) {\n\t\t// when first starting the diff, check if we're diffing an SVG or within an SVG\n\t\tisSvgMode = parent != null && parent.ownerSVGElement !== undefined;\n\n\t\t// hydration is indicated by the existing element to be diffed not having a prop cache\n\t\thydrating = dom != null && !('__preactattr_' in dom);\n\t}\n\n\tvar ret = idiff(dom, vnode, context, mountAll, componentRoot);\n\n\t// append the element if its a new parent\n\tif (parent && ret.parentNode !== parent) parent.appendChild(ret);\n\n\t// diffLevel being reduced to 0 means we're exiting the diff\n\tif (! --diffLevel) {\n\t\thydrating = false;\n\t\t// invoke queued componentDidMount lifecycle methods\n\t\tif (!componentRoot) flushMounts();\n\t}\n\n\treturn ret;\n}\n\n/** Internals of `diff()`, separated to allow bypassing diffLevel / mount flushing. */\nfunction idiff(dom, vnode, context, mountAll, componentRoot) {\n\tvar out = dom,\n\t    prevSvgMode = isSvgMode;\n\n\t// empty values (null, undefined, booleans) render as empty Text nodes\n\tif (vnode == null || typeof vnode === 'boolean') vnode = '';\n\n\t// Fast case: Strings & Numbers create/update Text nodes.\n\tif (typeof vnode === 'string' || typeof vnode === 'number') {\n\n\t\t// update if it's already a Text node:\n\t\tif (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {\n\t\t\t/* istanbul ignore if */ /* Browser quirk that can't be covered: https://github.com/developit/preact/commit/fd4f21f5c45dfd75151bd27b4c217d8003aa5eb9 */\n\t\t\tif (dom.nodeValue != vnode) {\n\t\t\t\tdom.nodeValue = vnode;\n\t\t\t}\n\t\t} else {\n\t\t\t// it wasn't a Text node: replace it with one and recycle the old Element\n\t\t\tout = document.createTextNode(vnode);\n\t\t\tif (dom) {\n\t\t\t\tif (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n\t\t\t\trecollectNodeTree(dom, true);\n\t\t\t}\n\t\t}\n\n\t\tout['__preactattr_'] = true;\n\n\t\treturn out;\n\t}\n\n\t// If the VNode represents a Component, perform a component diff:\n\tvar vnodeName = vnode.nodeName;\n\tif (typeof vnodeName === 'function') {\n\t\treturn buildComponentFromVNode(dom, vnode, context, mountAll);\n\t}\n\n\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\tisSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;\n\n\t// If there's no existing element or it's the wrong type, create a new one:\n\tvnodeName = String(vnodeName);\n\tif (!dom || !isNamedNode(dom, vnodeName)) {\n\t\tout = createNode(vnodeName, isSvgMode);\n\n\t\tif (dom) {\n\t\t\t// move children into the replacement node\n\t\t\twhile (dom.firstChild) {\n\t\t\t\tout.appendChild(dom.firstChild);\n\t\t\t} // if the previous Element was mounted into the DOM, replace it inline\n\t\t\tif (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n\n\t\t\t// recycle the old element (skips non-Element node types)\n\t\t\trecollectNodeTree(dom, true);\n\t\t}\n\t}\n\n\tvar fc = out.firstChild,\n\t    props = out['__preactattr_'],\n\t    vchildren = vnode.children;\n\n\tif (props == null) {\n\t\tprops = out['__preactattr_'] = {};\n\t\tfor (var a = out.attributes, i = a.length; i--;) {\n\t\t\tprops[a[i].name] = a[i].value;\n\t\t}\n\t}\n\n\t// Optimization: fast-path for elements containing a single TextNode:\n\tif (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {\n\t\tif (fc.nodeValue != vchildren[0]) {\n\t\t\tfc.nodeValue = vchildren[0];\n\t\t}\n\t}\n\t// otherwise, if there are existing or new children, diff them:\n\telse if (vchildren && vchildren.length || fc != null) {\n\t\t\tinnerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);\n\t\t}\n\n\t// Apply attributes/props from VNode to the DOM Element:\n\tdiffAttributes(out, vnode.attributes, props);\n\n\t// restore previous SVG mode: (in case we're exiting an SVG namespace)\n\tisSvgMode = prevSvgMode;\n\n\treturn out;\n}\n\n/** Apply child and attribute changes between a VNode and a DOM Node to the DOM.\n *\t@param {Element} dom\t\t\tElement whose children should be compared & mutated\n *\t@param {Array} vchildren\t\tArray of VNodes to compare to `dom.childNodes`\n *\t@param {Object} context\t\t\tImplicitly descendant context object (from most recent `getChildContext()`)\n *\t@param {Boolean} mountAll\n *\t@param {Boolean} isHydrating\tIf `true`, consumes externally created elements similar to hydration\n */\nfunction innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {\n\tvar originalChildren = dom.childNodes,\n\t    children = [],\n\t    keyed = {},\n\t    keyedLen = 0,\n\t    min = 0,\n\t    len = originalChildren.length,\n\t    childrenLen = 0,\n\t    vlen = vchildren ? vchildren.length : 0,\n\t    j,\n\t    c,\n\t    f,\n\t    vchild,\n\t    child;\n\n\t// Build up a map of keyed children and an Array of unkeyed children:\n\tif (len !== 0) {\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar _child = originalChildren[i],\n\t\t\t    props = _child['__preactattr_'],\n\t\t\t    key = vlen && props ? _child._component ? _child._component.__key : props.key : null;\n\t\t\tif (key != null) {\n\t\t\t\tkeyedLen++;\n\t\t\t\tkeyed[key] = _child;\n\t\t\t} else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {\n\t\t\t\tchildren[childrenLen++] = _child;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (vlen !== 0) {\n\t\tfor (var i = 0; i < vlen; i++) {\n\t\t\tvchild = vchildren[i];\n\t\t\tchild = null;\n\n\t\t\t// attempt to find a node based on key matching\n\t\t\tvar key = vchild.key;\n\t\t\tif (key != null) {\n\t\t\t\tif (keyedLen && keyed[key] !== undefined) {\n\t\t\t\t\tchild = keyed[key];\n\t\t\t\t\tkeyed[key] = undefined;\n\t\t\t\t\tkeyedLen--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// attempt to pluck a node of the same type from the existing children\n\t\t\telse if (!child && min < childrenLen) {\n\t\t\t\t\tfor (j = min; j < childrenLen; j++) {\n\t\t\t\t\t\tif (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {\n\t\t\t\t\t\t\tchild = c;\n\t\t\t\t\t\t\tchildren[j] = undefined;\n\t\t\t\t\t\t\tif (j === childrenLen - 1) childrenLen--;\n\t\t\t\t\t\t\tif (j === min) min++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// morph the matched/found/created DOM child to match vchild (deep)\n\t\t\tchild = idiff(child, vchild, context, mountAll);\n\n\t\t\tf = originalChildren[i];\n\t\t\tif (child && child !== dom && child !== f) {\n\t\t\t\tif (f == null) {\n\t\t\t\t\tdom.appendChild(child);\n\t\t\t\t} else if (child === f.nextSibling) {\n\t\t\t\t\tremoveNode(f);\n\t\t\t\t} else {\n\t\t\t\t\tdom.insertBefore(child, f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// remove unused keyed children:\n\tif (keyedLen) {\n\t\tfor (var i in keyed) {\n\t\t\tif (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);\n\t\t}\n\t}\n\n\t// remove orphaned unkeyed children:\n\twhile (min <= childrenLen) {\n\t\tif ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);\n\t}\n}\n\n/** Recursively recycle (or just unmount) a node and its descendants.\n *\t@param {Node} node\t\t\t\t\t\tDOM node to start unmount/removal from\n *\t@param {Boolean} [unmountOnly=false]\tIf `true`, only triggers unmount lifecycle, skips removal\n */\nfunction recollectNodeTree(node, unmountOnly) {\n\tvar component = node._component;\n\tif (component) {\n\t\t// if node is owned by a Component, unmount that component (ends up recursing back here)\n\t\tunmountComponent(component);\n\t} else {\n\t\t// If the node's VNode had a ref function, invoke it with null here.\n\t\t// (this is part of the React spec, and smart for unsetting references)\n\t\tif (node['__preactattr_'] != null && node['__preactattr_'].ref) node['__preactattr_'].ref(null);\n\n\t\tif (unmountOnly === false || node['__preactattr_'] == null) {\n\t\t\tremoveNode(node);\n\t\t}\n\n\t\tremoveChildren(node);\n\t}\n}\n\n/** Recollect/unmount all children.\n *\t- we use .lastChild here because it causes less reflow than .firstChild\n *\t- it's also cheaper than accessing the .childNodes Live NodeList\n */\nfunction removeChildren(node) {\n\tnode = node.lastChild;\n\twhile (node) {\n\t\tvar next = node.previousSibling;\n\t\trecollectNodeTree(node, true);\n\t\tnode = next;\n\t}\n}\n\n/** Apply differences in attributes from a VNode to the given DOM Element.\n *\t@param {Element} dom\t\tElement with attributes to diff `attrs` against\n *\t@param {Object} attrs\t\tThe desired end-state key-value attribute pairs\n *\t@param {Object} old\t\t\tCurrent/previous attributes (from previous VNode or element's prop cache)\n */\nfunction diffAttributes(dom, attrs, old) {\n\tvar name;\n\n\t// remove attributes no longer present on the vnode by setting them to undefined\n\tfor (name in old) {\n\t\tif (!(attrs && attrs[name] != null) && old[name] != null) {\n\t\t\tsetAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);\n\t\t}\n\t}\n\n\t// add new & update changed attributes\n\tfor (name in attrs) {\n\t\tif (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {\n\t\t\tsetAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);\n\t\t}\n\t}\n}\n\n/** Retains a pool of Components for re-use, keyed on component name.\n *\tNote: since component names are not unique or even necessarily available, these are primarily a form of sharding.\n *\t@private\n */\nvar components = {};\n\n/** Reclaim a component for later re-use by the recycler. */\nfunction collectComponent(component) {\n\tvar name = component.constructor.name;\n\t(components[name] || (components[name] = [])).push(component);\n}\n\n/** Create a component. Normalizes differences between PFC's and classful Components. */\nfunction createComponent(Ctor, props, context) {\n\tvar list = components[Ctor.name],\n\t    inst;\n\n\tif (Ctor.prototype && Ctor.prototype.render) {\n\t\tinst = new Ctor(props, context);\n\t\tComponent.call(inst, props, context);\n\t} else {\n\t\tinst = new Component(props, context);\n\t\tinst.constructor = Ctor;\n\t\tinst.render = doRender;\n\t}\n\n\tif (list) {\n\t\tfor (var i = list.length; i--;) {\n\t\t\tif (list[i].constructor === Ctor) {\n\t\t\t\tinst.nextBase = list[i].nextBase;\n\t\t\t\tlist.splice(i, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn inst;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n\n/** Set a component's `props` (generally derived from JSX attributes).\n *\t@param {Object} props\n *\t@param {Object} [opts]\n *\t@param {boolean} [opts.renderSync=false]\tIf `true` and {@link options.syncComponentUpdates} is `true`, triggers synchronous rendering.\n *\t@param {boolean} [opts.render=true]\t\t\tIf `false`, no render will be triggered.\n */\nfunction setComponentProps(component, props, opts, context, mountAll) {\n\tif (component._disable) return;\n\tcomponent._disable = true;\n\n\tif (component.__ref = props.ref) delete props.ref;\n\tif (component.__key = props.key) delete props.key;\n\n\tif (!component.base || mountAll) {\n\t\tif (component.componentWillMount) component.componentWillMount();\n\t} else if (component.componentWillReceiveProps) {\n\t\tcomponent.componentWillReceiveProps(props, context);\n\t}\n\n\tif (context && context !== component.context) {\n\t\tif (!component.prevContext) component.prevContext = component.context;\n\t\tcomponent.context = context;\n\t}\n\n\tif (!component.prevProps) component.prevProps = component.props;\n\tcomponent.props = props;\n\n\tcomponent._disable = false;\n\n\tif (opts !== 0) {\n\t\tif (opts === 1 || options.syncComponentUpdates !== false || !component.base) {\n\t\t\trenderComponent(component, 1, mountAll);\n\t\t} else {\n\t\t\tenqueueRender(component);\n\t\t}\n\t}\n\n\tif (component.__ref) component.__ref(component);\n}\n\n/** Render a Component, triggering necessary lifecycle events and taking High-Order Components into account.\n *\t@param {Component} component\n *\t@param {Object} [opts]\n *\t@param {boolean} [opts.build=false]\t\tIf `true`, component will build and store a DOM node if not already associated with one.\n *\t@private\n */\nfunction renderComponent(component, opts, mountAll, isChild) {\n\tif (component._disable) return;\n\n\tvar props = component.props,\n\t    state = component.state,\n\t    context = component.context,\n\t    previousProps = component.prevProps || props,\n\t    previousState = component.prevState || state,\n\t    previousContext = component.prevContext || context,\n\t    isUpdate = component.base,\n\t    nextBase = component.nextBase,\n\t    initialBase = isUpdate || nextBase,\n\t    initialChildComponent = component._component,\n\t    skip = false,\n\t    rendered,\n\t    inst,\n\t    cbase;\n\n\t// if updating\n\tif (isUpdate) {\n\t\tcomponent.props = previousProps;\n\t\tcomponent.state = previousState;\n\t\tcomponent.context = previousContext;\n\t\tif (opts !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {\n\t\t\tskip = true;\n\t\t} else if (component.componentWillUpdate) {\n\t\t\tcomponent.componentWillUpdate(props, state, context);\n\t\t}\n\t\tcomponent.props = props;\n\t\tcomponent.state = state;\n\t\tcomponent.context = context;\n\t}\n\n\tcomponent.prevProps = component.prevState = component.prevContext = component.nextBase = null;\n\tcomponent._dirty = false;\n\n\tif (!skip) {\n\t\trendered = component.render(props, state, context);\n\n\t\t// context to pass to the child, can be updated via (grand-)parent component\n\t\tif (component.getChildContext) {\n\t\t\tcontext = extend(extend({}, context), component.getChildContext());\n\t\t}\n\n\t\tvar childComponent = rendered && rendered.nodeName,\n\t\t    toUnmount,\n\t\t    base;\n\n\t\tif (typeof childComponent === 'function') {\n\t\t\t// set up high order component link\n\n\t\t\tvar childProps = getNodeProps(rendered);\n\t\t\tinst = initialChildComponent;\n\n\t\t\tif (inst && inst.constructor === childComponent && childProps.key == inst.__key) {\n\t\t\t\tsetComponentProps(inst, childProps, 1, context, false);\n\t\t\t} else {\n\t\t\t\ttoUnmount = inst;\n\n\t\t\t\tcomponent._component = inst = createComponent(childComponent, childProps, context);\n\t\t\t\tinst.nextBase = inst.nextBase || nextBase;\n\t\t\t\tinst._parentComponent = component;\n\t\t\t\tsetComponentProps(inst, childProps, 0, context, false);\n\t\t\t\trenderComponent(inst, 1, mountAll, true);\n\t\t\t}\n\n\t\t\tbase = inst.base;\n\t\t} else {\n\t\t\tcbase = initialBase;\n\n\t\t\t// destroy high order component link\n\t\t\ttoUnmount = initialChildComponent;\n\t\t\tif (toUnmount) {\n\t\t\t\tcbase = component._component = null;\n\t\t\t}\n\n\t\t\tif (initialBase || opts === 1) {\n\t\t\t\tif (cbase) cbase._component = null;\n\t\t\t\tbase = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);\n\t\t\t}\n\t\t}\n\n\t\tif (initialBase && base !== initialBase && inst !== initialChildComponent) {\n\t\t\tvar baseParent = initialBase.parentNode;\n\t\t\tif (baseParent && base !== baseParent) {\n\t\t\t\tbaseParent.replaceChild(base, initialBase);\n\n\t\t\t\tif (!toUnmount) {\n\t\t\t\t\tinitialBase._component = null;\n\t\t\t\t\trecollectNodeTree(initialBase, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (toUnmount) {\n\t\t\tunmountComponent(toUnmount);\n\t\t}\n\n\t\tcomponent.base = base;\n\t\tif (base && !isChild) {\n\t\t\tvar componentRef = component,\n\t\t\t    t = component;\n\t\t\twhile (t = t._parentComponent) {\n\t\t\t\t(componentRef = t).base = base;\n\t\t\t}\n\t\t\tbase._component = componentRef;\n\t\t\tbase._componentConstructor = componentRef.constructor;\n\t\t}\n\t}\n\n\tif (!isUpdate || mountAll) {\n\t\tmounts.unshift(component);\n\t} else if (!skip) {\n\t\t// Ensure that pending componentDidMount() hooks of child components\n\t\t// are called before the componentDidUpdate() hook in the parent.\n\t\t// Note: disabled as it causes duplicate hooks, see https://github.com/developit/preact/issues/750\n\t\t// flushMounts();\n\n\t\tif (component.componentDidUpdate) {\n\t\t\tcomponent.componentDidUpdate(previousProps, previousState, previousContext);\n\t\t}\n\t\tif (options.afterUpdate) options.afterUpdate(component);\n\t}\n\n\tif (component._renderCallbacks != null) {\n\t\twhile (component._renderCallbacks.length) {\n\t\t\tcomponent._renderCallbacks.pop().call(component);\n\t\t}\n\t}\n\n\tif (!diffLevel && !isChild) flushMounts();\n}\n\n/** Apply the Component referenced by a VNode to the DOM.\n *\t@param {Element} dom\tThe DOM node to mutate\n *\t@param {VNode} vnode\tA Component-referencing VNode\n *\t@returns {Element} dom\tThe created/mutated element\n *\t@private\n */\nfunction buildComponentFromVNode(dom, vnode, context, mountAll) {\n\tvar c = dom && dom._component,\n\t    originalComponent = c,\n\t    oldDom = dom,\n\t    isDirectOwner = c && dom._componentConstructor === vnode.nodeName,\n\t    isOwner = isDirectOwner,\n\t    props = getNodeProps(vnode);\n\twhile (c && !isOwner && (c = c._parentComponent)) {\n\t\tisOwner = c.constructor === vnode.nodeName;\n\t}\n\n\tif (c && isOwner && (!mountAll || c._component)) {\n\t\tsetComponentProps(c, props, 3, context, mountAll);\n\t\tdom = c.base;\n\t} else {\n\t\tif (originalComponent && !isDirectOwner) {\n\t\t\tunmountComponent(originalComponent);\n\t\t\tdom = oldDom = null;\n\t\t}\n\n\t\tc = createComponent(vnode.nodeName, props, context);\n\t\tif (dom && !c.nextBase) {\n\t\t\tc.nextBase = dom;\n\t\t\t// passing dom/oldDom as nextBase will recycle it if unused, so bypass recycling on L229:\n\t\t\toldDom = null;\n\t\t}\n\t\tsetComponentProps(c, props, 1, context, mountAll);\n\t\tdom = c.base;\n\n\t\tif (oldDom && dom !== oldDom) {\n\t\t\toldDom._component = null;\n\t\t\trecollectNodeTree(oldDom, false);\n\t\t}\n\t}\n\n\treturn dom;\n}\n\n/** Remove a component from the DOM and recycle it.\n *\t@param {Component} component\tThe Component instance to unmount\n *\t@private\n */\nfunction unmountComponent(component) {\n\tif (options.beforeUnmount) options.beforeUnmount(component);\n\n\tvar base = component.base;\n\n\tcomponent._disable = true;\n\n\tif (component.componentWillUnmount) component.componentWillUnmount();\n\n\tcomponent.base = null;\n\n\t// recursively tear down & recollect high-order component children:\n\tvar inner = component._component;\n\tif (inner) {\n\t\tunmountComponent(inner);\n\t} else if (base) {\n\t\tif (base['__preactattr_'] && base['__preactattr_'].ref) base['__preactattr_'].ref(null);\n\n\t\tcomponent.nextBase = base;\n\n\t\tremoveNode(base);\n\t\tcollectComponent(component);\n\n\t\tremoveChildren(base);\n\t}\n\n\tif (component.__ref) component.__ref(null);\n}\n\n/** Base Component class.\n *\tProvides `setState()` and `forceUpdate()`, which trigger rendering.\n *\t@public\n *\n *\t@example\n *\tclass MyFoo extends Component {\n *\t\trender(props, state) {\n *\t\t\treturn <div />;\n *\t\t}\n *\t}\n */\nfunction Component(props, context) {\n\tthis._dirty = true;\n\n\t/** @public\n  *\t@type {object}\n  */\n\tthis.context = context;\n\n\t/** @public\n  *\t@type {object}\n  */\n\tthis.props = props;\n\n\t/** @public\n  *\t@type {object}\n  */\n\tthis.state = this.state || {};\n}\n\nextend(Component.prototype, {\n\n\t/** Returns a `boolean` indicating if the component should re-render when receiving the given `props` and `state`.\n  *\t@param {object} nextProps\n  *\t@param {object} nextState\n  *\t@param {object} nextContext\n  *\t@returns {Boolean} should the component re-render\n  *\t@name shouldComponentUpdate\n  *\t@function\n  */\n\n\t/** Update component state by copying properties from `state` to `this.state`.\n  *\t@param {object} state\t\tA hash of state properties to update with new values\n  *\t@param {function} callback\tA function to be called once component state is updated\n  */\n\tsetState: function setState(state, callback) {\n\t\tvar s = this.state;\n\t\tif (!this.prevState) this.prevState = extend({}, s);\n\t\textend(s, typeof state === 'function' ? state(s, this.props) : state);\n\t\tif (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);\n\t\tenqueueRender(this);\n\t},\n\n\n\t/** Immediately perform a synchronous re-render of the component.\n  *\t@param {function} callback\t\tA function to be called after component is re-rendered.\n  *\t@private\n  */\n\tforceUpdate: function forceUpdate(callback) {\n\t\tif (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);\n\t\trenderComponent(this, 2);\n\t},\n\n\n\t/** Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n  *\tVirtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n  *\t@param {object} props\t\tProps (eg: JSX attributes) received from parent element/component\n  *\t@param {object} state\t\tThe component's current state\n  *\t@param {object} context\t\tContext object (if a parent component has provided context)\n  *\t@returns VNode\n  */\n\trender: function render() {}\n});\n\n/** Render JSX into a `parent` Element.\n *\t@param {VNode} vnode\t\tA (JSX) VNode to render\n *\t@param {Element} parent\t\tDOM element to render into\n *\t@param {Element} [merge]\tAttempt to re-use an existing DOM tree rooted at `merge`\n *\t@public\n *\n *\t@example\n *\t// render a div into <body>:\n *\trender(<div id=\"hello\">hello!</div>, document.body);\n *\n *\t@example\n *\t// render a \"Thing\" component into #foo:\n *\tconst Thing = ({ name }) => <span>{ name }</span>;\n *\trender(<Thing name=\"one\" />, document.querySelector('#foo'));\n */\nfunction render(vnode, parent, merge) {\n  return diff(merge, vnode, {}, false, parent, false);\n}\n\nvar preact = {\n\th: h,\n\tcreateElement: h,\n\tcloneElement: cloneElement,\n\tComponent: Component,\n\trender: render,\n\trerender: rerender,\n\toptions: options\n};\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (preact);\n//# sourceMappingURL=preact.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcmVhY3QvZGlzdC9wcmVhY3QuZXNtLmpzP2FjYzkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFZpcnR1YWwgRE9NIE5vZGUgKi9cbmZ1bmN0aW9uIFZOb2RlKCkge31cblxuLyoqIEdsb2JhbCBvcHRpb25zXG4gKlx0QHB1YmxpY1xuICpcdEBuYW1lc3BhY2Ugb3B0aW9ucyB7T2JqZWN0fVxuICovXG52YXIgb3B0aW9ucyA9IHtcblxuXHQvKiogSWYgYHRydWVgLCBgcHJvcGAgY2hhbmdlcyB0cmlnZ2VyIHN5bmNocm9ub3VzIGNvbXBvbmVudCB1cGRhdGVzLlxuICAqXHRAbmFtZSBzeW5jQ29tcG9uZW50VXBkYXRlc1xuICAqXHRAdHlwZSBCb29sZWFuXG4gICpcdEBkZWZhdWx0IHRydWVcbiAgKi9cblx0Ly9zeW5jQ29tcG9uZW50VXBkYXRlczogdHJ1ZSxcblxuXHQvKiogUHJvY2Vzc2VzIGFsbCBjcmVhdGVkIFZOb2Rlcy5cbiAgKlx0QHBhcmFtIHtWTm9kZX0gdm5vZGVcdEEgbmV3bHktY3JlYXRlZCBWTm9kZSB0byBub3JtYWxpemUvcHJvY2Vzc1xuICAqL1xuXHQvL3Zub2RlKHZub2RlKSB7IH1cblxuXHQvKiogSG9vayBpbnZva2VkIGFmdGVyIGEgY29tcG9uZW50IGlzIG1vdW50ZWQuICovXG5cdC8vIGFmdGVyTW91bnQoY29tcG9uZW50KSB7IH1cblxuXHQvKiogSG9vayBpbnZva2VkIGFmdGVyIHRoZSBET00gaXMgdXBkYXRlZCB3aXRoIGEgY29tcG9uZW50J3MgbGF0ZXN0IHJlbmRlci4gKi9cblx0Ly8gYWZ0ZXJVcGRhdGUoY29tcG9uZW50KSB7IH1cblxuXHQvKiogSG9vayBpbnZva2VkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuICovXG5cdC8vIGJlZm9yZVVubW91bnQoY29tcG9uZW50KSB7IH1cbn07XG5cbnZhciBzdGFjayA9IFtdO1xuXG52YXIgRU1QVFlfQ0hJTERSRU4gPSBbXTtcblxuLyoqXG4gKiBKU1gvaHlwZXJzY3JpcHQgcmV2aXZlci5cbiAqIEBzZWUgaHR0cDovL2phc29uZm9ybWF0LmNvbS93dGYtaXMtanN4XG4gKiBCZW5jaG1hcmtzOiBodHRwczovL2VzYmVuY2guY29tL2JlbmNoLzU3ZWU4ZjhlMzMwYWIwOTkwMGExYTFhMFxuICpcbiAqIE5vdGU6IHRoaXMgaXMgZXhwb3J0ZWQgYXMgYm90aCBgaCgpYCBhbmQgYGNyZWF0ZUVsZW1lbnQoKWAgZm9yIGNvbXBhdGliaWxpdHkgcmVhc29ucy5cbiAqXG4gKiBDcmVhdGVzIGEgVk5vZGUgKHZpcnR1YWwgRE9NIGVsZW1lbnQpLiBBIHRyZWUgb2YgVk5vZGVzIGNhbiBiZSB1c2VkIGFzIGEgbGlnaHR3ZWlnaHQgcmVwcmVzZW50YXRpb25cbiAqIG9mIHRoZSBzdHJ1Y3R1cmUgb2YgYSBET00gdHJlZS4gVGhpcyBzdHJ1Y3R1cmUgY2FuIGJlIHJlYWxpemVkIGJ5IHJlY3Vyc2l2ZWx5IGNvbXBhcmluZyBpdCBhZ2FpbnN0XG4gKiB0aGUgY3VycmVudCBfYWN0dWFsXyBET00gc3RydWN0dXJlLCBhbmQgYXBwbHlpbmcgb25seSB0aGUgZGlmZmVyZW5jZXMuXG4gKlxuICogYGgoKWAvYGNyZWF0ZUVsZW1lbnQoKWAgYWNjZXB0cyBhbiBlbGVtZW50IG5hbWUsIGEgbGlzdCBvZiBhdHRyaWJ1dGVzL3Byb3BzLFxuICogYW5kIG9wdGlvbmFsbHkgY2hpbGRyZW4gdG8gYXBwZW5kIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIEBleGFtcGxlIFRoZSBmb2xsb3dpbmcgRE9NIHRyZWVcbiAqXG4gKiBgPGRpdiBpZD1cImZvb1wiIG5hbWU9XCJiYXJcIj5IZWxsbyE8L2Rpdj5gXG4gKlxuICogY2FuIGJlIGNvbnN0cnVjdGVkIHVzaW5nIHRoaXMgZnVuY3Rpb24gYXM6XG4gKlxuICogYGgoJ2RpdicsIHsgaWQ6ICdmb28nLCBuYW1lIDogJ2JhcicgfSwgJ0hlbGxvIScpO2BcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWVcdEFuIGVsZW1lbnQgbmFtZS4gRXg6IGBkaXZgLCBgYWAsIGBzcGFuYCwgZXRjLlxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXNcdEFueSBhdHRyaWJ1dGVzL3Byb3BzIHRvIHNldCBvbiB0aGUgY3JlYXRlZCBlbGVtZW50LlxuICogQHBhcmFtIHJlc3RcdFx0XHRBZGRpdGlvbmFsIGFyZ3VtZW50cyBhcmUgdGFrZW4gdG8gYmUgY2hpbGRyZW4gdG8gYXBwZW5kLiBDYW4gYmUgaW5maW5pdGVseSBuZXN0ZWQgQXJyYXlzLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaChub2RlTmFtZSwgYXR0cmlidXRlcykge1xuXHR2YXIgY2hpbGRyZW4gPSBFTVBUWV9DSElMRFJFTixcblx0ICAgIGxhc3RTaW1wbGUsXG5cdCAgICBjaGlsZCxcblx0ICAgIHNpbXBsZSxcblx0ICAgIGk7XG5cdGZvciAoaSA9IGFyZ3VtZW50cy5sZW5ndGg7IGktLSA+IDI7KSB7XG5cdFx0c3RhY2sucHVzaChhcmd1bWVudHNbaV0pO1xuXHR9XG5cdGlmIChhdHRyaWJ1dGVzICYmIGF0dHJpYnV0ZXMuY2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdGlmICghc3RhY2subGVuZ3RoKSBzdGFjay5wdXNoKGF0dHJpYnV0ZXMuY2hpbGRyZW4pO1xuXHRcdGRlbGV0ZSBhdHRyaWJ1dGVzLmNoaWxkcmVuO1xuXHR9XG5cdHdoaWxlIChzdGFjay5sZW5ndGgpIHtcblx0XHRpZiAoKGNoaWxkID0gc3RhY2sucG9wKCkpICYmIGNoaWxkLnBvcCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRmb3IgKGkgPSBjaGlsZC5sZW5ndGg7IGktLTspIHtcblx0XHRcdFx0c3RhY2sucHVzaChjaGlsZFtpXSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0eXBlb2YgY2hpbGQgPT09ICdib29sZWFuJykgY2hpbGQgPSBudWxsO1xuXG5cdFx0XHRpZiAoc2ltcGxlID0gdHlwZW9mIG5vZGVOYW1lICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGlmIChjaGlsZCA9PSBudWxsKSBjaGlsZCA9ICcnO2Vsc2UgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIGNoaWxkID0gU3RyaW5nKGNoaWxkKTtlbHNlIGlmICh0eXBlb2YgY2hpbGQgIT09ICdzdHJpbmcnKSBzaW1wbGUgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHNpbXBsZSAmJiBsYXN0U2ltcGxlKSB7XG5cdFx0XHRcdGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdICs9IGNoaWxkO1xuXHRcdFx0fSBlbHNlIGlmIChjaGlsZHJlbiA9PT0gRU1QVFlfQ0hJTERSRU4pIHtcblx0XHRcdFx0Y2hpbGRyZW4gPSBbY2hpbGRdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cdFx0XHR9XG5cblx0XHRcdGxhc3RTaW1wbGUgPSBzaW1wbGU7XG5cdFx0fVxuXHR9XG5cblx0dmFyIHAgPSBuZXcgVk5vZGUoKTtcblx0cC5ub2RlTmFtZSA9IG5vZGVOYW1lO1xuXHRwLmNoaWxkcmVuID0gY2hpbGRyZW47XG5cdHAuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGF0dHJpYnV0ZXM7XG5cdHAua2V5ID0gYXR0cmlidXRlcyA9PSBudWxsID8gdW5kZWZpbmVkIDogYXR0cmlidXRlcy5rZXk7XG5cblx0Ly8gaWYgYSBcInZub2RlIGhvb2tcIiBpcyBkZWZpbmVkLCBwYXNzIGV2ZXJ5IGNyZWF0ZWQgVk5vZGUgdG8gaXRcblx0aWYgKG9wdGlvbnMudm5vZGUgIT09IHVuZGVmaW5lZCkgb3B0aW9ucy52bm9kZShwKTtcblxuXHRyZXR1cm4gcDtcbn1cblxuLyoqXG4gKiAgQ29weSBhbGwgcHJvcGVydGllcyBmcm9tIGBwcm9wc2Agb250byBgb2JqYC5cbiAqICBAcGFyYW0ge09iamVjdH0gb2JqXHRcdE9iamVjdCBvbnRvIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIGNvcGllZC5cbiAqICBAcGFyYW0ge09iamVjdH0gcHJvcHNcdE9iamVjdCBmcm9tIHdoaWNoIHRvIGNvcHkgcHJvcGVydGllcy5cbiAqICBAcmV0dXJucyBvYmpcbiAqICBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBleHRlbmQob2JqLCBwcm9wcykge1xuICBmb3IgKHZhciBpIGluIHByb3BzKSB7XG4gICAgb2JqW2ldID0gcHJvcHNbaV07XG4gIH1yZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiBhc3luY2hyb25vdXNseSwgYXMgc29vbiBhcyBwb3NzaWJsZS4gTWFrZXNcbiAqIHVzZSBvZiBIVE1MIFByb21pc2UgdG8gc2NoZWR1bGUgdGhlIGNhbGxiYWNrIGlmIGF2YWlsYWJsZSxcbiAqIG90aGVyd2lzZSBmYWxsaW5nIGJhY2sgdG8gYHNldFRpbWVvdXRgIChtYWlubHkgZm9yIElFPDExKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG52YXIgZGVmZXIgPSB0eXBlb2YgUHJvbWlzZSA9PSAnZnVuY3Rpb24nID8gUHJvbWlzZS5yZXNvbHZlKCkudGhlbi5iaW5kKFByb21pc2UucmVzb2x2ZSgpKSA6IHNldFRpbWVvdXQ7XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBnaXZlbiBWTm9kZSwgb3B0aW9uYWxseSBhZGRpbmcgYXR0cmlidXRlcy9wcm9wcyBhbmQgcmVwbGFjaW5nIGl0cyBjaGlsZHJlbi5cbiAqIEBwYXJhbSB7Vk5vZGV9IHZub2RlXHRcdFRoZSB2aXJ1dGFsIERPTSBlbGVtZW50IHRvIGNsb25lXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcdEF0dHJpYnV0ZXMvcHJvcHMgdG8gYWRkIHdoZW4gY2xvbmluZ1xuICogQHBhcmFtIHtWTm9kZX0gcmVzdFx0XHRBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgd2lsbCBiZSB1c2VkIGFzIHJlcGxhY2VtZW50IGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQodm5vZGUsIHByb3BzKSB7XG4gIHJldHVybiBoKHZub2RlLm5vZGVOYW1lLCBleHRlbmQoZXh0ZW5kKHt9LCB2bm9kZS5hdHRyaWJ1dGVzKSwgcHJvcHMpLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IHZub2RlLmNoaWxkcmVuKTtcbn1cblxuLy8gRE9NIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgTk9UIGhhdmUgXCJweFwiIGFkZGVkIHdoZW4gbnVtZXJpY1xudmFyIElTX05PTl9ESU1FTlNJT05BTCA9IC9hY2l0fGV4KD86c3xnfG58cHwkKXxycGh8b3dzfG1uY3xudHd8aW5lW2NoXXx6b298Xm9yZC9pO1xuXG4vKiogTWFuYWdlZCBxdWV1ZSBvZiBkaXJ0eSBjb21wb25lbnRzIHRvIGJlIHJlLXJlbmRlcmVkICovXG5cbnZhciBpdGVtcyA9IFtdO1xuXG5mdW5jdGlvbiBlbnF1ZXVlUmVuZGVyKGNvbXBvbmVudCkge1xuXHRpZiAoIWNvbXBvbmVudC5fZGlydHkgJiYgKGNvbXBvbmVudC5fZGlydHkgPSB0cnVlKSAmJiBpdGVtcy5wdXNoKGNvbXBvbmVudCkgPT0gMSkge1xuXHRcdChvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nIHx8IGRlZmVyKShyZXJlbmRlcik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVyZW5kZXIoKSB7XG5cdHZhciBwLFxuXHQgICAgbGlzdCA9IGl0ZW1zO1xuXHRpdGVtcyA9IFtdO1xuXHR3aGlsZSAocCA9IGxpc3QucG9wKCkpIHtcblx0XHRpZiAocC5fZGlydHkpIHJlbmRlckNvbXBvbmVudChwKTtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byBub2RlcyBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcdFx0XHRET00gTm9kZSB0byBjb21wYXJlXG4gKiBAcGFyYW0ge1ZOb2RlfSB2bm9kZVx0XHRcdFZpcnR1YWwgRE9NIG5vZGUgdG8gY29tcGFyZVxuICogQHBhcmFtIHtib29sZWFufSBbaHlyZGF0aW5nPWZhbHNlXVx0SWYgdHJ1ZSwgaWdub3JlcyBjb21wb25lbnQgY29uc3RydWN0b3JzIHdoZW4gY29tcGFyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNTYW1lTm9kZVR5cGUobm9kZSwgdm5vZGUsIGh5ZHJhdGluZykge1xuICBpZiAodHlwZW9mIHZub2RlID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygdm5vZGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIG5vZGUuc3BsaXRUZXh0ICE9PSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiB2bm9kZS5ub2RlTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gIW5vZGUuX2NvbXBvbmVudENvbnN0cnVjdG9yICYmIGlzTmFtZWROb2RlKG5vZGUsIHZub2RlLm5vZGVOYW1lKTtcbiAgfVxuICByZXR1cm4gaHlkcmF0aW5nIHx8IG5vZGUuX2NvbXBvbmVudENvbnN0cnVjdG9yID09PSB2bm9kZS5ub2RlTmFtZTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBFbGVtZW50IGhhcyBhIGdpdmVuIG5vZGVOYW1lLCBjYXNlLWluc2Vuc2l0aXZlbHkuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXHRBIERPTSBFbGVtZW50IHRvIGluc3BlY3QgdGhlIG5hbWUgb2YuXG4gKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWVcdFVubm9ybWFsaXplZCBuYW1lIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAqL1xuZnVuY3Rpb24gaXNOYW1lZE5vZGUobm9kZSwgbm9kZU5hbWUpIHtcbiAgcmV0dXJuIG5vZGUubm9ybWFsaXplZE5vZGVOYW1lID09PSBub2RlTmFtZSB8fCBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogUmVjb25zdHJ1Y3QgQ29tcG9uZW50LXN0eWxlIGBwcm9wc2AgZnJvbSBhIFZOb2RlLlxuICogRW5zdXJlcyBkZWZhdWx0L2ZhbGxiYWNrIHZhbHVlcyBmcm9tIGBkZWZhdWx0UHJvcHNgOlxuICogT3duLXByb3BlcnRpZXMgb2YgYGRlZmF1bHRQcm9wc2Agbm90IHByZXNlbnQgaW4gYHZub2RlLmF0dHJpYnV0ZXNgIGFyZSBhZGRlZC5cbiAqXG4gKiBAcGFyYW0ge1ZOb2RlfSB2bm9kZVxuICogQHJldHVybnMge09iamVjdH0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZVByb3BzKHZub2RlKSB7XG4gIHZhciBwcm9wcyA9IGV4dGVuZCh7fSwgdm5vZGUuYXR0cmlidXRlcyk7XG4gIHByb3BzLmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG5cbiAgdmFyIGRlZmF1bHRQcm9wcyA9IHZub2RlLm5vZGVOYW1lLmRlZmF1bHRQcm9wcztcbiAgaWYgKGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yICh2YXIgaSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW2ldID0gZGVmYXVsdFByb3BzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wcztcbn1cblxuLyoqIENyZWF0ZSBhbiBlbGVtZW50IHdpdGggdGhlIGdpdmVuIG5vZGVOYW1lLlxuICpcdEBwYXJhbSB7U3RyaW5nfSBub2RlTmFtZVxuICpcdEBwYXJhbSB7Qm9vbGVhbn0gW2lzU3ZnPWZhbHNlXVx0SWYgYHRydWVgLCBjcmVhdGVzIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBTVkcgbmFtZXNwYWNlLlxuICpcdEByZXR1cm5zIHtFbGVtZW50fSBub2RlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUobm9kZU5hbWUsIGlzU3ZnKSB7XG5cdHZhciBub2RlID0gaXNTdmcgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgbm9kZU5hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG5cdG5vZGUubm9ybWFsaXplZE5vZGVOYW1lID0gbm9kZU5hbWU7XG5cdHJldHVybiBub2RlO1xufVxuXG4vKiogUmVtb3ZlIGEgY2hpbGQgbm9kZSBmcm9tIGl0cyBwYXJlbnQgaWYgYXR0YWNoZWQuXG4gKlx0QHBhcmFtIHtFbGVtZW50fSBub2RlXHRcdFRoZSBub2RlIHRvIHJlbW92ZVxuICovXG5mdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0dmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuXG4vKiogU2V0IGEgbmFtZWQgYXR0cmlidXRlIG9uIHRoZSBnaXZlbiBOb2RlLCB3aXRoIHNwZWNpYWwgYmVoYXZpb3IgZm9yIHNvbWUgbmFtZXMgYW5kIGV2ZW50IGhhbmRsZXJzLlxuICpcdElmIGB2YWx1ZWAgaXMgYG51bGxgLCB0aGUgYXR0cmlidXRlL2hhbmRsZXIgd2lsbCBiZSByZW1vdmVkLlxuICpcdEBwYXJhbSB7RWxlbWVudH0gbm9kZVx0QW4gZWxlbWVudCB0byBtdXRhdGVcbiAqXHRAcGFyYW0ge3N0cmluZ30gbmFtZVx0VGhlIG5hbWUva2V5IHRvIHNldCwgc3VjaCBhcyBhbiBldmVudCBvciBhdHRyaWJ1dGUgbmFtZVxuICpcdEBwYXJhbSB7YW55fSBvbGRcdFRoZSBsYXN0IHZhbHVlIHRoYXQgd2FzIHNldCBmb3IgdGhpcyBuYW1lL25vZGUgcGFpclxuICpcdEBwYXJhbSB7YW55fSB2YWx1ZVx0QW4gYXR0cmlidXRlIHZhbHVlLCBzdWNoIGFzIGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBhcyBhbiBldmVudCBoYW5kbGVyXG4gKlx0QHBhcmFtIHtCb29sZWFufSBpc1N2Z1x0QXJlIHdlIGN1cnJlbnRseSBkaWZmaW5nIGluc2lkZSBhbiBzdmc/XG4gKlx0QHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0QWNjZXNzb3Iobm9kZSwgbmFtZSwgb2xkLCB2YWx1ZSwgaXNTdmcpIHtcblx0aWYgKG5hbWUgPT09ICdjbGFzc05hbWUnKSBuYW1lID0gJ2NsYXNzJztcblxuXHRpZiAobmFtZSA9PT0gJ2tleScpIHtcblx0XHQvLyBpZ25vcmVcblx0fSBlbHNlIGlmIChuYW1lID09PSAncmVmJykge1xuXHRcdGlmIChvbGQpIG9sZChudWxsKTtcblx0XHRpZiAodmFsdWUpIHZhbHVlKG5vZGUpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGFzcycgJiYgIWlzU3ZnKSB7XG5cdFx0bm9kZS5jbGFzc05hbWUgPSB2YWx1ZSB8fCAnJztcblx0fSBlbHNlIGlmIChuYW1lID09PSAnc3R5bGUnKSB7XG5cdFx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBvbGQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRub2RlLnN0eWxlLmNzc1RleHQgPSB2YWx1ZSB8fCAnJztcblx0XHR9XG5cdFx0aWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRmb3IgKHZhciBpIGluIG9sZCkge1xuXHRcdFx0XHRcdGlmICghKGkgaW4gdmFsdWUpKSBub2RlLnN0eWxlW2ldID0gJyc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgaW4gdmFsdWUpIHtcblx0XHRcdFx0bm9kZS5zdHlsZVtpXSA9IHR5cGVvZiB2YWx1ZVtpXSA9PT0gJ251bWJlcicgJiYgSVNfTk9OX0RJTUVOU0lPTkFMLnRlc3QoaSkgPT09IGZhbHNlID8gdmFsdWVbaV0gKyAncHgnIDogdmFsdWVbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcpIHtcblx0XHRpZiAodmFsdWUpIG5vZGUuaW5uZXJIVE1MID0gdmFsdWUuX19odG1sIHx8ICcnO1xuXHR9IGVsc2UgaWYgKG5hbWVbMF0gPT0gJ28nICYmIG5hbWVbMV0gPT0gJ24nKSB7XG5cdFx0dmFyIHVzZUNhcHR1cmUgPSBuYW1lICE9PSAobmFtZSA9IG5hbWUucmVwbGFjZSgvQ2FwdHVyZSQvLCAnJykpO1xuXHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDIpO1xuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0aWYgKCFvbGQpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudFByb3h5LCB1c2VDYXB0dXJlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGV2ZW50UHJveHksIHVzZUNhcHR1cmUpO1xuXHRcdH1cblx0XHQobm9kZS5fbGlzdGVuZXJzIHx8IChub2RlLl9saXN0ZW5lcnMgPSB7fSkpW25hbWVdID0gdmFsdWU7XG5cdH0gZWxzZSBpZiAobmFtZSAhPT0gJ2xpc3QnICYmIG5hbWUgIT09ICd0eXBlJyAmJiAhaXNTdmcgJiYgbmFtZSBpbiBub2RlKSB7XG5cdFx0c2V0UHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWUpO1xuXHRcdGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSBmYWxzZSkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIG5zID0gaXNTdmcgJiYgbmFtZSAhPT0gKG5hbWUgPSBuYW1lLnJlcGxhY2UoL154bGlua1xcOj8vLCAnJykpO1xuXHRcdGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSBmYWxzZSkge1xuXHRcdFx0aWYgKG5zKSBub2RlLnJlbW92ZUF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgbmFtZS50b0xvd2VyQ2FzZSgpKTtlbHNlIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRpZiAobnMpIG5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBuYW1lLnRvTG93ZXJDYXNlKCksIHZhbHVlKTtlbHNlIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqIEF0dGVtcHQgdG8gc2V0IGEgRE9NIHByb3BlcnR5IHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAqXHRJRSAmIEZGIHRocm93IGZvciBjZXJ0YWluIHByb3BlcnR5LXZhbHVlIGNvbWJpbmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gc2V0UHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUpIHtcblx0dHJ5IHtcblx0XHRub2RlW25hbWVdID0gdmFsdWU7XG5cdH0gY2F0Y2ggKGUpIHt9XG59XG5cbi8qKiBQcm94eSBhbiBldmVudCB0byBob29rZWQgZXZlbnQgaGFuZGxlcnNcbiAqXHRAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBldmVudFByb3h5KGUpIHtcblx0cmV0dXJuIHRoaXMuX2xpc3RlbmVyc1tlLnR5cGVdKG9wdGlvbnMuZXZlbnQgJiYgb3B0aW9ucy5ldmVudChlKSB8fCBlKTtcbn1cblxuLyoqIFF1ZXVlIG9mIGNvbXBvbmVudHMgdGhhdCBoYXZlIGJlZW4gbW91bnRlZCBhbmQgYXJlIGF3YWl0aW5nIGNvbXBvbmVudERpZE1vdW50ICovXG52YXIgbW91bnRzID0gW107XG5cbi8qKiBEaWZmIHJlY3Vyc2lvbiBjb3VudCwgdXNlZCB0byB0cmFjayB0aGUgZW5kIG9mIHRoZSBkaWZmIGN5Y2xlLiAqL1xudmFyIGRpZmZMZXZlbCA9IDA7XG5cbi8qKiBHbG9iYWwgZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBkaWZmIGlzIGN1cnJlbnRseSB3aXRoaW4gYW4gU1ZHICovXG52YXIgaXNTdmdNb2RlID0gZmFsc2U7XG5cbi8qKiBHbG9iYWwgZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBkaWZmIGlzIHBlcmZvcm1pbmcgaHlkcmF0aW9uICovXG52YXIgaHlkcmF0aW5nID0gZmFsc2U7XG5cbi8qKiBJbnZva2UgcXVldWVkIGNvbXBvbmVudERpZE1vdW50IGxpZmVjeWNsZSBtZXRob2RzICovXG5mdW5jdGlvbiBmbHVzaE1vdW50cygpIHtcblx0dmFyIGM7XG5cdHdoaWxlIChjID0gbW91bnRzLnBvcCgpKSB7XG5cdFx0aWYgKG9wdGlvbnMuYWZ0ZXJNb3VudCkgb3B0aW9ucy5hZnRlck1vdW50KGMpO1xuXHRcdGlmIChjLmNvbXBvbmVudERpZE1vdW50KSBjLmNvbXBvbmVudERpZE1vdW50KCk7XG5cdH1cbn1cblxuLyoqIEFwcGx5IGRpZmZlcmVuY2VzIGluIGEgZ2l2ZW4gdm5vZGUgKGFuZCBpdCdzIGRlZXAgY2hpbGRyZW4pIHRvIGEgcmVhbCBET00gTm9kZS5cbiAqXHRAcGFyYW0ge0VsZW1lbnR9IFtkb209bnVsbF1cdFx0QSBET00gbm9kZSB0byBtdXRhdGUgaW50byB0aGUgc2hhcGUgb2YgdGhlIGB2bm9kZWBcbiAqXHRAcGFyYW0ge1ZOb2RlfSB2bm9kZVx0XHRcdEEgVk5vZGUgKHdpdGggZGVzY2VuZGFudHMgZm9ybWluZyBhIHRyZWUpIHJlcHJlc2VudGluZyB0aGUgZGVzaXJlZCBET00gc3RydWN0dXJlXG4gKlx0QHJldHVybnMge0VsZW1lbnR9IGRvbVx0XHRcdFRoZSBjcmVhdGVkL211dGF0ZWQgZWxlbWVudFxuICpcdEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRpZmYoZG9tLCB2bm9kZSwgY29udGV4dCwgbW91bnRBbGwsIHBhcmVudCwgY29tcG9uZW50Um9vdCkge1xuXHQvLyBkaWZmTGV2ZWwgaGF2aW5nIGJlZW4gMCBoZXJlIGluZGljYXRlcyBpbml0aWFsIGVudHJ5IGludG8gdGhlIGRpZmYgKG5vdCBhIHN1YmRpZmYpXG5cdGlmICghZGlmZkxldmVsKyspIHtcblx0XHQvLyB3aGVuIGZpcnN0IHN0YXJ0aW5nIHRoZSBkaWZmLCBjaGVjayBpZiB3ZSdyZSBkaWZmaW5nIGFuIFNWRyBvciB3aXRoaW4gYW4gU1ZHXG5cdFx0aXNTdmdNb2RlID0gcGFyZW50ICE9IG51bGwgJiYgcGFyZW50Lm93bmVyU1ZHRWxlbWVudCAhPT0gdW5kZWZpbmVkO1xuXG5cdFx0Ly8gaHlkcmF0aW9uIGlzIGluZGljYXRlZCBieSB0aGUgZXhpc3RpbmcgZWxlbWVudCB0byBiZSBkaWZmZWQgbm90IGhhdmluZyBhIHByb3AgY2FjaGVcblx0XHRoeWRyYXRpbmcgPSBkb20gIT0gbnVsbCAmJiAhKCdfX3ByZWFjdGF0dHJfJyBpbiBkb20pO1xuXHR9XG5cblx0dmFyIHJldCA9IGlkaWZmKGRvbSwgdm5vZGUsIGNvbnRleHQsIG1vdW50QWxsLCBjb21wb25lbnRSb290KTtcblxuXHQvLyBhcHBlbmQgdGhlIGVsZW1lbnQgaWYgaXRzIGEgbmV3IHBhcmVudFxuXHRpZiAocGFyZW50ICYmIHJldC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHBhcmVudC5hcHBlbmRDaGlsZChyZXQpO1xuXG5cdC8vIGRpZmZMZXZlbCBiZWluZyByZWR1Y2VkIHRvIDAgbWVhbnMgd2UncmUgZXhpdGluZyB0aGUgZGlmZlxuXHRpZiAoISAtLWRpZmZMZXZlbCkge1xuXHRcdGh5ZHJhdGluZyA9IGZhbHNlO1xuXHRcdC8vIGludm9rZSBxdWV1ZWQgY29tcG9uZW50RGlkTW91bnQgbGlmZWN5Y2xlIG1ldGhvZHNcblx0XHRpZiAoIWNvbXBvbmVudFJvb3QpIGZsdXNoTW91bnRzKCk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG4vKiogSW50ZXJuYWxzIG9mIGBkaWZmKClgLCBzZXBhcmF0ZWQgdG8gYWxsb3cgYnlwYXNzaW5nIGRpZmZMZXZlbCAvIG1vdW50IGZsdXNoaW5nLiAqL1xuZnVuY3Rpb24gaWRpZmYoZG9tLCB2bm9kZSwgY29udGV4dCwgbW91bnRBbGwsIGNvbXBvbmVudFJvb3QpIHtcblx0dmFyIG91dCA9IGRvbSxcblx0ICAgIHByZXZTdmdNb2RlID0gaXNTdmdNb2RlO1xuXG5cdC8vIGVtcHR5IHZhbHVlcyAobnVsbCwgdW5kZWZpbmVkLCBib29sZWFucykgcmVuZGVyIGFzIGVtcHR5IFRleHQgbm9kZXNcblx0aWYgKHZub2RlID09IG51bGwgfHwgdHlwZW9mIHZub2RlID09PSAnYm9vbGVhbicpIHZub2RlID0gJyc7XG5cblx0Ly8gRmFzdCBjYXNlOiBTdHJpbmdzICYgTnVtYmVycyBjcmVhdGUvdXBkYXRlIFRleHQgbm9kZXMuXG5cdGlmICh0eXBlb2Ygdm5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2bm9kZSA9PT0gJ251bWJlcicpIHtcblxuXHRcdC8vIHVwZGF0ZSBpZiBpdCdzIGFscmVhZHkgYSBUZXh0IG5vZGU6XG5cdFx0aWYgKGRvbSAmJiBkb20uc3BsaXRUZXh0ICE9PSB1bmRlZmluZWQgJiYgZG9tLnBhcmVudE5vZGUgJiYgKCFkb20uX2NvbXBvbmVudCB8fCBjb21wb25lbnRSb290KSkge1xuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovIC8qIEJyb3dzZXIgcXVpcmsgdGhhdCBjYW4ndCBiZSBjb3ZlcmVkOiBodHRwczovL2dpdGh1Yi5jb20vZGV2ZWxvcGl0L3ByZWFjdC9jb21taXQvZmQ0ZjIxZjVjNDVkZmQ3NTE1MWJkMjdiNGMyMTdkODAwM2FhNWViOSAqL1xuXHRcdFx0aWYgKGRvbS5ub2RlVmFsdWUgIT0gdm5vZGUpIHtcblx0XHRcdFx0ZG9tLm5vZGVWYWx1ZSA9IHZub2RlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpdCB3YXNuJ3QgYSBUZXh0IG5vZGU6IHJlcGxhY2UgaXQgd2l0aCBvbmUgYW5kIHJlY3ljbGUgdGhlIG9sZCBFbGVtZW50XG5cdFx0XHRvdXQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2bm9kZSk7XG5cdFx0XHRpZiAoZG9tKSB7XG5cdFx0XHRcdGlmIChkb20ucGFyZW50Tm9kZSkgZG9tLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG91dCwgZG9tKTtcblx0XHRcdFx0cmVjb2xsZWN0Tm9kZVRyZWUoZG9tLCB0cnVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvdXRbJ19fcHJlYWN0YXR0cl8nXSA9IHRydWU7XG5cblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cblx0Ly8gSWYgdGhlIFZOb2RlIHJlcHJlc2VudHMgYSBDb21wb25lbnQsIHBlcmZvcm0gYSBjb21wb25lbnQgZGlmZjpcblx0dmFyIHZub2RlTmFtZSA9IHZub2RlLm5vZGVOYW1lO1xuXHRpZiAodHlwZW9mIHZub2RlTmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBidWlsZENvbXBvbmVudEZyb21WTm9kZShkb20sIHZub2RlLCBjb250ZXh0LCBtb3VudEFsbCk7XG5cdH1cblxuXHQvLyBUcmFja3MgZW50ZXJpbmcgYW5kIGV4aXRpbmcgU1ZHIG5hbWVzcGFjZSB3aGVuIGRlc2NlbmRpbmcgdGhyb3VnaCB0aGUgdHJlZS5cblx0aXNTdmdNb2RlID0gdm5vZGVOYW1lID09PSAnc3ZnJyA/IHRydWUgOiB2bm9kZU5hbWUgPT09ICdmb3JlaWduT2JqZWN0JyA/IGZhbHNlIDogaXNTdmdNb2RlO1xuXG5cdC8vIElmIHRoZXJlJ3Mgbm8gZXhpc3RpbmcgZWxlbWVudCBvciBpdCdzIHRoZSB3cm9uZyB0eXBlLCBjcmVhdGUgYSBuZXcgb25lOlxuXHR2bm9kZU5hbWUgPSBTdHJpbmcodm5vZGVOYW1lKTtcblx0aWYgKCFkb20gfHwgIWlzTmFtZWROb2RlKGRvbSwgdm5vZGVOYW1lKSkge1xuXHRcdG91dCA9IGNyZWF0ZU5vZGUodm5vZGVOYW1lLCBpc1N2Z01vZGUpO1xuXG5cdFx0aWYgKGRvbSkge1xuXHRcdFx0Ly8gbW92ZSBjaGlsZHJlbiBpbnRvIHRoZSByZXBsYWNlbWVudCBub2RlXG5cdFx0XHR3aGlsZSAoZG9tLmZpcnN0Q2hpbGQpIHtcblx0XHRcdFx0b3V0LmFwcGVuZENoaWxkKGRvbS5maXJzdENoaWxkKTtcblx0XHRcdH0gLy8gaWYgdGhlIHByZXZpb3VzIEVsZW1lbnQgd2FzIG1vdW50ZWQgaW50byB0aGUgRE9NLCByZXBsYWNlIGl0IGlubGluZVxuXHRcdFx0aWYgKGRvbS5wYXJlbnROb2RlKSBkb20ucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQob3V0LCBkb20pO1xuXG5cdFx0XHQvLyByZWN5Y2xlIHRoZSBvbGQgZWxlbWVudCAoc2tpcHMgbm9uLUVsZW1lbnQgbm9kZSB0eXBlcylcblx0XHRcdHJlY29sbGVjdE5vZGVUcmVlKGRvbSwgdHJ1ZSk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIGZjID0gb3V0LmZpcnN0Q2hpbGQsXG5cdCAgICBwcm9wcyA9IG91dFsnX19wcmVhY3RhdHRyXyddLFxuXHQgICAgdmNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG5cblx0aWYgKHByb3BzID09IG51bGwpIHtcblx0XHRwcm9wcyA9IG91dFsnX19wcmVhY3RhdHRyXyddID0ge307XG5cdFx0Zm9yICh2YXIgYSA9IG91dC5hdHRyaWJ1dGVzLCBpID0gYS5sZW5ndGg7IGktLTspIHtcblx0XHRcdHByb3BzW2FbaV0ubmFtZV0gPSBhW2ldLnZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdC8vIE9wdGltaXphdGlvbjogZmFzdC1wYXRoIGZvciBlbGVtZW50cyBjb250YWluaW5nIGEgc2luZ2xlIFRleHROb2RlOlxuXHRpZiAoIWh5ZHJhdGluZyAmJiB2Y2hpbGRyZW4gJiYgdmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgdmNoaWxkcmVuWzBdID09PSAnc3RyaW5nJyAmJiBmYyAhPSBudWxsICYmIGZjLnNwbGl0VGV4dCAhPT0gdW5kZWZpbmVkICYmIGZjLm5leHRTaWJsaW5nID09IG51bGwpIHtcblx0XHRpZiAoZmMubm9kZVZhbHVlICE9IHZjaGlsZHJlblswXSkge1xuXHRcdFx0ZmMubm9kZVZhbHVlID0gdmNoaWxkcmVuWzBdO1xuXHRcdH1cblx0fVxuXHQvLyBvdGhlcndpc2UsIGlmIHRoZXJlIGFyZSBleGlzdGluZyBvciBuZXcgY2hpbGRyZW4sIGRpZmYgdGhlbTpcblx0ZWxzZSBpZiAodmNoaWxkcmVuICYmIHZjaGlsZHJlbi5sZW5ndGggfHwgZmMgIT0gbnVsbCkge1xuXHRcdFx0aW5uZXJEaWZmTm9kZShvdXQsIHZjaGlsZHJlbiwgY29udGV4dCwgbW91bnRBbGwsIGh5ZHJhdGluZyB8fCBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKTtcblx0XHR9XG5cblx0Ly8gQXBwbHkgYXR0cmlidXRlcy9wcm9wcyBmcm9tIFZOb2RlIHRvIHRoZSBET00gRWxlbWVudDpcblx0ZGlmZkF0dHJpYnV0ZXMob3V0LCB2bm9kZS5hdHRyaWJ1dGVzLCBwcm9wcyk7XG5cblx0Ly8gcmVzdG9yZSBwcmV2aW91cyBTVkcgbW9kZTogKGluIGNhc2Ugd2UncmUgZXhpdGluZyBhbiBTVkcgbmFtZXNwYWNlKVxuXHRpc1N2Z01vZGUgPSBwcmV2U3ZnTW9kZTtcblxuXHRyZXR1cm4gb3V0O1xufVxuXG4vKiogQXBwbHkgY2hpbGQgYW5kIGF0dHJpYnV0ZSBjaGFuZ2VzIGJldHdlZW4gYSBWTm9kZSBhbmQgYSBET00gTm9kZSB0byB0aGUgRE9NLlxuICpcdEBwYXJhbSB7RWxlbWVudH0gZG9tXHRcdFx0RWxlbWVudCB3aG9zZSBjaGlsZHJlbiBzaG91bGQgYmUgY29tcGFyZWQgJiBtdXRhdGVkXG4gKlx0QHBhcmFtIHtBcnJheX0gdmNoaWxkcmVuXHRcdEFycmF5IG9mIFZOb2RlcyB0byBjb21wYXJlIHRvIGBkb20uY2hpbGROb2Rlc2BcbiAqXHRAcGFyYW0ge09iamVjdH0gY29udGV4dFx0XHRcdEltcGxpY2l0bHkgZGVzY2VuZGFudCBjb250ZXh0IG9iamVjdCAoZnJvbSBtb3N0IHJlY2VudCBgZ2V0Q2hpbGRDb250ZXh0KClgKVxuICpcdEBwYXJhbSB7Qm9vbGVhbn0gbW91bnRBbGxcbiAqXHRAcGFyYW0ge0Jvb2xlYW59IGlzSHlkcmF0aW5nXHRJZiBgdHJ1ZWAsIGNvbnN1bWVzIGV4dGVybmFsbHkgY3JlYXRlZCBlbGVtZW50cyBzaW1pbGFyIHRvIGh5ZHJhdGlvblxuICovXG5mdW5jdGlvbiBpbm5lckRpZmZOb2RlKGRvbSwgdmNoaWxkcmVuLCBjb250ZXh0LCBtb3VudEFsbCwgaXNIeWRyYXRpbmcpIHtcblx0dmFyIG9yaWdpbmFsQ2hpbGRyZW4gPSBkb20uY2hpbGROb2Rlcyxcblx0ICAgIGNoaWxkcmVuID0gW10sXG5cdCAgICBrZXllZCA9IHt9LFxuXHQgICAga2V5ZWRMZW4gPSAwLFxuXHQgICAgbWluID0gMCxcblx0ICAgIGxlbiA9IG9yaWdpbmFsQ2hpbGRyZW4ubGVuZ3RoLFxuXHQgICAgY2hpbGRyZW5MZW4gPSAwLFxuXHQgICAgdmxlbiA9IHZjaGlsZHJlbiA/IHZjaGlsZHJlbi5sZW5ndGggOiAwLFxuXHQgICAgaixcblx0ICAgIGMsXG5cdCAgICBmLFxuXHQgICAgdmNoaWxkLFxuXHQgICAgY2hpbGQ7XG5cblx0Ly8gQnVpbGQgdXAgYSBtYXAgb2Yga2V5ZWQgY2hpbGRyZW4gYW5kIGFuIEFycmF5IG9mIHVua2V5ZWQgY2hpbGRyZW46XG5cdGlmIChsZW4gIT09IDApIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR2YXIgX2NoaWxkID0gb3JpZ2luYWxDaGlsZHJlbltpXSxcblx0XHRcdCAgICBwcm9wcyA9IF9jaGlsZFsnX19wcmVhY3RhdHRyXyddLFxuXHRcdFx0ICAgIGtleSA9IHZsZW4gJiYgcHJvcHMgPyBfY2hpbGQuX2NvbXBvbmVudCA/IF9jaGlsZC5fY29tcG9uZW50Ll9fa2V5IDogcHJvcHMua2V5IDogbnVsbDtcblx0XHRcdGlmIChrZXkgIT0gbnVsbCkge1xuXHRcdFx0XHRrZXllZExlbisrO1xuXHRcdFx0XHRrZXllZFtrZXldID0gX2NoaWxkO1xuXHRcdFx0fSBlbHNlIGlmIChwcm9wcyB8fCAoX2NoaWxkLnNwbGl0VGV4dCAhPT0gdW5kZWZpbmVkID8gaXNIeWRyYXRpbmcgPyBfY2hpbGQubm9kZVZhbHVlLnRyaW0oKSA6IHRydWUgOiBpc0h5ZHJhdGluZykpIHtcblx0XHRcdFx0Y2hpbGRyZW5bY2hpbGRyZW5MZW4rK10gPSBfY2hpbGQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKHZsZW4gIT09IDApIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZsZW47IGkrKykge1xuXHRcdFx0dmNoaWxkID0gdmNoaWxkcmVuW2ldO1xuXHRcdFx0Y2hpbGQgPSBudWxsO1xuXG5cdFx0XHQvLyBhdHRlbXB0IHRvIGZpbmQgYSBub2RlIGJhc2VkIG9uIGtleSBtYXRjaGluZ1xuXHRcdFx0dmFyIGtleSA9IHZjaGlsZC5rZXk7XG5cdFx0XHRpZiAoa2V5ICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKGtleWVkTGVuICYmIGtleWVkW2tleV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGNoaWxkID0ga2V5ZWRba2V5XTtcblx0XHRcdFx0XHRrZXllZFtrZXldID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdGtleWVkTGVuLS07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGF0dGVtcHQgdG8gcGx1Y2sgYSBub2RlIG9mIHRoZSBzYW1lIHR5cGUgZnJvbSB0aGUgZXhpc3RpbmcgY2hpbGRyZW5cblx0XHRcdGVsc2UgaWYgKCFjaGlsZCAmJiBtaW4gPCBjaGlsZHJlbkxlbikge1xuXHRcdFx0XHRcdGZvciAoaiA9IG1pbjsgaiA8IGNoaWxkcmVuTGVuOyBqKyspIHtcblx0XHRcdFx0XHRcdGlmIChjaGlsZHJlbltqXSAhPT0gdW5kZWZpbmVkICYmIGlzU2FtZU5vZGVUeXBlKGMgPSBjaGlsZHJlbltqXSwgdmNoaWxkLCBpc0h5ZHJhdGluZykpIHtcblx0XHRcdFx0XHRcdFx0Y2hpbGQgPSBjO1xuXHRcdFx0XHRcdFx0XHRjaGlsZHJlbltqXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0aWYgKGogPT09IGNoaWxkcmVuTGVuIC0gMSkgY2hpbGRyZW5MZW4tLTtcblx0XHRcdFx0XHRcdFx0aWYgKGogPT09IG1pbikgbWluKys7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBtb3JwaCB0aGUgbWF0Y2hlZC9mb3VuZC9jcmVhdGVkIERPTSBjaGlsZCB0byBtYXRjaCB2Y2hpbGQgKGRlZXApXG5cdFx0XHRjaGlsZCA9IGlkaWZmKGNoaWxkLCB2Y2hpbGQsIGNvbnRleHQsIG1vdW50QWxsKTtcblxuXHRcdFx0ZiA9IG9yaWdpbmFsQ2hpbGRyZW5baV07XG5cdFx0XHRpZiAoY2hpbGQgJiYgY2hpbGQgIT09IGRvbSAmJiBjaGlsZCAhPT0gZikge1xuXHRcdFx0XHRpZiAoZiA9PSBudWxsKSB7XG5cdFx0XHRcdFx0ZG9tLmFwcGVuZENoaWxkKGNoaWxkKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjaGlsZCA9PT0gZi5uZXh0U2libGluZykge1xuXHRcdFx0XHRcdHJlbW92ZU5vZGUoZik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZG9tLmluc2VydEJlZm9yZShjaGlsZCwgZik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyByZW1vdmUgdW51c2VkIGtleWVkIGNoaWxkcmVuOlxuXHRpZiAoa2V5ZWRMZW4pIHtcblx0XHRmb3IgKHZhciBpIGluIGtleWVkKSB7XG5cdFx0XHRpZiAoa2V5ZWRbaV0gIT09IHVuZGVmaW5lZCkgcmVjb2xsZWN0Tm9kZVRyZWUoa2V5ZWRbaV0sIGZhbHNlKTtcblx0XHR9XG5cdH1cblxuXHQvLyByZW1vdmUgb3JwaGFuZWQgdW5rZXllZCBjaGlsZHJlbjpcblx0d2hpbGUgKG1pbiA8PSBjaGlsZHJlbkxlbikge1xuXHRcdGlmICgoY2hpbGQgPSBjaGlsZHJlbltjaGlsZHJlbkxlbi0tXSkgIT09IHVuZGVmaW5lZCkgcmVjb2xsZWN0Tm9kZVRyZWUoY2hpbGQsIGZhbHNlKTtcblx0fVxufVxuXG4vKiogUmVjdXJzaXZlbHkgcmVjeWNsZSAob3IganVzdCB1bm1vdW50KSBhIG5vZGUgYW5kIGl0cyBkZXNjZW5kYW50cy5cbiAqXHRAcGFyYW0ge05vZGV9IG5vZGVcdFx0XHRcdFx0XHRET00gbm9kZSB0byBzdGFydCB1bm1vdW50L3JlbW92YWwgZnJvbVxuICpcdEBwYXJhbSB7Qm9vbGVhbn0gW3VubW91bnRPbmx5PWZhbHNlXVx0SWYgYHRydWVgLCBvbmx5IHRyaWdnZXJzIHVubW91bnQgbGlmZWN5Y2xlLCBza2lwcyByZW1vdmFsXG4gKi9cbmZ1bmN0aW9uIHJlY29sbGVjdE5vZGVUcmVlKG5vZGUsIHVubW91bnRPbmx5KSB7XG5cdHZhciBjb21wb25lbnQgPSBub2RlLl9jb21wb25lbnQ7XG5cdGlmIChjb21wb25lbnQpIHtcblx0XHQvLyBpZiBub2RlIGlzIG93bmVkIGJ5IGEgQ29tcG9uZW50LCB1bm1vdW50IHRoYXQgY29tcG9uZW50IChlbmRzIHVwIHJlY3Vyc2luZyBiYWNrIGhlcmUpXG5cdFx0dW5tb3VudENvbXBvbmVudChjb21wb25lbnQpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIElmIHRoZSBub2RlJ3MgVk5vZGUgaGFkIGEgcmVmIGZ1bmN0aW9uLCBpbnZva2UgaXQgd2l0aCBudWxsIGhlcmUuXG5cdFx0Ly8gKHRoaXMgaXMgcGFydCBvZiB0aGUgUmVhY3Qgc3BlYywgYW5kIHNtYXJ0IGZvciB1bnNldHRpbmcgcmVmZXJlbmNlcylcblx0XHRpZiAobm9kZVsnX19wcmVhY3RhdHRyXyddICE9IG51bGwgJiYgbm9kZVsnX19wcmVhY3RhdHRyXyddLnJlZikgbm9kZVsnX19wcmVhY3RhdHRyXyddLnJlZihudWxsKTtcblxuXHRcdGlmICh1bm1vdW50T25seSA9PT0gZmFsc2UgfHwgbm9kZVsnX19wcmVhY3RhdHRyXyddID09IG51bGwpIHtcblx0XHRcdHJlbW92ZU5vZGUobm9kZSk7XG5cdFx0fVxuXG5cdFx0cmVtb3ZlQ2hpbGRyZW4obm9kZSk7XG5cdH1cbn1cblxuLyoqIFJlY29sbGVjdC91bm1vdW50IGFsbCBjaGlsZHJlbi5cbiAqXHQtIHdlIHVzZSAubGFzdENoaWxkIGhlcmUgYmVjYXVzZSBpdCBjYXVzZXMgbGVzcyByZWZsb3cgdGhhbiAuZmlyc3RDaGlsZFxuICpcdC0gaXQncyBhbHNvIGNoZWFwZXIgdGhhbiBhY2Nlc3NpbmcgdGhlIC5jaGlsZE5vZGVzIExpdmUgTm9kZUxpc3RcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2hpbGRyZW4obm9kZSkge1xuXHRub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG5cdHdoaWxlIChub2RlKSB7XG5cdFx0dmFyIG5leHQgPSBub2RlLnByZXZpb3VzU2libGluZztcblx0XHRyZWNvbGxlY3ROb2RlVHJlZShub2RlLCB0cnVlKTtcblx0XHRub2RlID0gbmV4dDtcblx0fVxufVxuXG4vKiogQXBwbHkgZGlmZmVyZW5jZXMgaW4gYXR0cmlidXRlcyBmcm9tIGEgVk5vZGUgdG8gdGhlIGdpdmVuIERPTSBFbGVtZW50LlxuICpcdEBwYXJhbSB7RWxlbWVudH0gZG9tXHRcdEVsZW1lbnQgd2l0aCBhdHRyaWJ1dGVzIHRvIGRpZmYgYGF0dHJzYCBhZ2FpbnN0XG4gKlx0QHBhcmFtIHtPYmplY3R9IGF0dHJzXHRcdFRoZSBkZXNpcmVkIGVuZC1zdGF0ZSBrZXktdmFsdWUgYXR0cmlidXRlIHBhaXJzXG4gKlx0QHBhcmFtIHtPYmplY3R9IG9sZFx0XHRcdEN1cnJlbnQvcHJldmlvdXMgYXR0cmlidXRlcyAoZnJvbSBwcmV2aW91cyBWTm9kZSBvciBlbGVtZW50J3MgcHJvcCBjYWNoZSlcbiAqL1xuZnVuY3Rpb24gZGlmZkF0dHJpYnV0ZXMoZG9tLCBhdHRycywgb2xkKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIHJlbW92ZSBhdHRyaWJ1dGVzIG5vIGxvbmdlciBwcmVzZW50IG9uIHRoZSB2bm9kZSBieSBzZXR0aW5nIHRoZW0gdG8gdW5kZWZpbmVkXG5cdGZvciAobmFtZSBpbiBvbGQpIHtcblx0XHRpZiAoIShhdHRycyAmJiBhdHRyc1tuYW1lXSAhPSBudWxsKSAmJiBvbGRbbmFtZV0gIT0gbnVsbCkge1xuXHRcdFx0c2V0QWNjZXNzb3IoZG9tLCBuYW1lLCBvbGRbbmFtZV0sIG9sZFtuYW1lXSA9IHVuZGVmaW5lZCwgaXNTdmdNb2RlKTtcblx0XHR9XG5cdH1cblxuXHQvLyBhZGQgbmV3ICYgdXBkYXRlIGNoYW5nZWQgYXR0cmlidXRlc1xuXHRmb3IgKG5hbWUgaW4gYXR0cnMpIHtcblx0XHRpZiAobmFtZSAhPT0gJ2NoaWxkcmVuJyAmJiBuYW1lICE9PSAnaW5uZXJIVE1MJyAmJiAoIShuYW1lIGluIG9sZCkgfHwgYXR0cnNbbmFtZV0gIT09IChuYW1lID09PSAndmFsdWUnIHx8IG5hbWUgPT09ICdjaGVja2VkJyA/IGRvbVtuYW1lXSA6IG9sZFtuYW1lXSkpKSB7XG5cdFx0XHRzZXRBY2Nlc3Nvcihkb20sIG5hbWUsIG9sZFtuYW1lXSwgb2xkW25hbWVdID0gYXR0cnNbbmFtZV0sIGlzU3ZnTW9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKiBSZXRhaW5zIGEgcG9vbCBvZiBDb21wb25lbnRzIGZvciByZS11c2UsIGtleWVkIG9uIGNvbXBvbmVudCBuYW1lLlxuICpcdE5vdGU6IHNpbmNlIGNvbXBvbmVudCBuYW1lcyBhcmUgbm90IHVuaXF1ZSBvciBldmVuIG5lY2Vzc2FyaWx5IGF2YWlsYWJsZSwgdGhlc2UgYXJlIHByaW1hcmlseSBhIGZvcm0gb2Ygc2hhcmRpbmcuXG4gKlx0QHByaXZhdGVcbiAqL1xudmFyIGNvbXBvbmVudHMgPSB7fTtcblxuLyoqIFJlY2xhaW0gYSBjb21wb25lbnQgZm9yIGxhdGVyIHJlLXVzZSBieSB0aGUgcmVjeWNsZXIuICovXG5mdW5jdGlvbiBjb2xsZWN0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuXHR2YXIgbmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lO1xuXHQoY29tcG9uZW50c1tuYW1lXSB8fCAoY29tcG9uZW50c1tuYW1lXSA9IFtdKSkucHVzaChjb21wb25lbnQpO1xufVxuXG4vKiogQ3JlYXRlIGEgY29tcG9uZW50LiBOb3JtYWxpemVzIGRpZmZlcmVuY2VzIGJldHdlZW4gUEZDJ3MgYW5kIGNsYXNzZnVsIENvbXBvbmVudHMuICovXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQoQ3RvciwgcHJvcHMsIGNvbnRleHQpIHtcblx0dmFyIGxpc3QgPSBjb21wb25lbnRzW0N0b3IubmFtZV0sXG5cdCAgICBpbnN0O1xuXG5cdGlmIChDdG9yLnByb3RvdHlwZSAmJiBDdG9yLnByb3RvdHlwZS5yZW5kZXIpIHtcblx0XHRpbnN0ID0gbmV3IEN0b3IocHJvcHMsIGNvbnRleHQpO1xuXHRcdENvbXBvbmVudC5jYWxsKGluc3QsIHByb3BzLCBjb250ZXh0KTtcblx0fSBlbHNlIHtcblx0XHRpbnN0ID0gbmV3IENvbXBvbmVudChwcm9wcywgY29udGV4dCk7XG5cdFx0aW5zdC5jb25zdHJ1Y3RvciA9IEN0b3I7XG5cdFx0aW5zdC5yZW5kZXIgPSBkb1JlbmRlcjtcblx0fVxuXG5cdGlmIChsaXN0KSB7XG5cdFx0Zm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoOyBpLS07KSB7XG5cdFx0XHRpZiAobGlzdFtpXS5jb25zdHJ1Y3RvciA9PT0gQ3Rvcikge1xuXHRcdFx0XHRpbnN0Lm5leHRCYXNlID0gbGlzdFtpXS5uZXh0QmFzZTtcblx0XHRcdFx0bGlzdC5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gaW5zdDtcbn1cblxuLyoqIFRoZSBgLnJlbmRlcigpYCBtZXRob2QgZm9yIGEgUEZDIGJhY2tpbmcgaW5zdGFuY2UuICovXG5mdW5jdGlvbiBkb1JlbmRlcihwcm9wcywgc3RhdGUsIGNvbnRleHQpIHtcblx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpO1xufVxuXG4vKiogU2V0IGEgY29tcG9uZW50J3MgYHByb3BzYCAoZ2VuZXJhbGx5IGRlcml2ZWQgZnJvbSBKU1ggYXR0cmlidXRlcykuXG4gKlx0QHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKlx0QHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICpcdEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMucmVuZGVyU3luYz1mYWxzZV1cdElmIGB0cnVlYCBhbmQge0BsaW5rIG9wdGlvbnMuc3luY0NvbXBvbmVudFVwZGF0ZXN9IGlzIGB0cnVlYCwgdHJpZ2dlcnMgc3luY2hyb25vdXMgcmVuZGVyaW5nLlxuICpcdEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMucmVuZGVyPXRydWVdXHRcdFx0SWYgYGZhbHNlYCwgbm8gcmVuZGVyIHdpbGwgYmUgdHJpZ2dlcmVkLlxuICovXG5mdW5jdGlvbiBzZXRDb21wb25lbnRQcm9wcyhjb21wb25lbnQsIHByb3BzLCBvcHRzLCBjb250ZXh0LCBtb3VudEFsbCkge1xuXHRpZiAoY29tcG9uZW50Ll9kaXNhYmxlKSByZXR1cm47XG5cdGNvbXBvbmVudC5fZGlzYWJsZSA9IHRydWU7XG5cblx0aWYgKGNvbXBvbmVudC5fX3JlZiA9IHByb3BzLnJlZikgZGVsZXRlIHByb3BzLnJlZjtcblx0aWYgKGNvbXBvbmVudC5fX2tleSA9IHByb3BzLmtleSkgZGVsZXRlIHByb3BzLmtleTtcblxuXHRpZiAoIWNvbXBvbmVudC5iYXNlIHx8IG1vdW50QWxsKSB7XG5cdFx0aWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsTW91bnQpIGNvbXBvbmVudC5jb21wb25lbnRXaWxsTW91bnQoKTtcblx0fSBlbHNlIGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykge1xuXHRcdGNvbXBvbmVudC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHByb3BzLCBjb250ZXh0KTtcblx0fVxuXG5cdGlmIChjb250ZXh0ICYmIGNvbnRleHQgIT09IGNvbXBvbmVudC5jb250ZXh0KSB7XG5cdFx0aWYgKCFjb21wb25lbnQucHJldkNvbnRleHQpIGNvbXBvbmVudC5wcmV2Q29udGV4dCA9IGNvbXBvbmVudC5jb250ZXh0O1xuXHRcdGNvbXBvbmVudC5jb250ZXh0ID0gY29udGV4dDtcblx0fVxuXG5cdGlmICghY29tcG9uZW50LnByZXZQcm9wcykgY29tcG9uZW50LnByZXZQcm9wcyA9IGNvbXBvbmVudC5wcm9wcztcblx0Y29tcG9uZW50LnByb3BzID0gcHJvcHM7XG5cblx0Y29tcG9uZW50Ll9kaXNhYmxlID0gZmFsc2U7XG5cblx0aWYgKG9wdHMgIT09IDApIHtcblx0XHRpZiAob3B0cyA9PT0gMSB8fCBvcHRpb25zLnN5bmNDb21wb25lbnRVcGRhdGVzICE9PSBmYWxzZSB8fCAhY29tcG9uZW50LmJhc2UpIHtcblx0XHRcdHJlbmRlckNvbXBvbmVudChjb21wb25lbnQsIDEsIG1vdW50QWxsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZW5xdWV1ZVJlbmRlcihjb21wb25lbnQpO1xuXHRcdH1cblx0fVxuXG5cdGlmIChjb21wb25lbnQuX19yZWYpIGNvbXBvbmVudC5fX3JlZihjb21wb25lbnQpO1xufVxuXG4vKiogUmVuZGVyIGEgQ29tcG9uZW50LCB0cmlnZ2VyaW5nIG5lY2Vzc2FyeSBsaWZlY3ljbGUgZXZlbnRzIGFuZCB0YWtpbmcgSGlnaC1PcmRlciBDb21wb25lbnRzIGludG8gYWNjb3VudC5cbiAqXHRAcGFyYW0ge0NvbXBvbmVudH0gY29tcG9uZW50XG4gKlx0QHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICpcdEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuYnVpbGQ9ZmFsc2VdXHRcdElmIGB0cnVlYCwgY29tcG9uZW50IHdpbGwgYnVpbGQgYW5kIHN0b3JlIGEgRE9NIG5vZGUgaWYgbm90IGFscmVhZHkgYXNzb2NpYXRlZCB3aXRoIG9uZS5cbiAqXHRAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnQoY29tcG9uZW50LCBvcHRzLCBtb3VudEFsbCwgaXNDaGlsZCkge1xuXHRpZiAoY29tcG9uZW50Ll9kaXNhYmxlKSByZXR1cm47XG5cblx0dmFyIHByb3BzID0gY29tcG9uZW50LnByb3BzLFxuXHQgICAgc3RhdGUgPSBjb21wb25lbnQuc3RhdGUsXG5cdCAgICBjb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQsXG5cdCAgICBwcmV2aW91c1Byb3BzID0gY29tcG9uZW50LnByZXZQcm9wcyB8fCBwcm9wcyxcblx0ICAgIHByZXZpb3VzU3RhdGUgPSBjb21wb25lbnQucHJldlN0YXRlIHx8IHN0YXRlLFxuXHQgICAgcHJldmlvdXNDb250ZXh0ID0gY29tcG9uZW50LnByZXZDb250ZXh0IHx8IGNvbnRleHQsXG5cdCAgICBpc1VwZGF0ZSA9IGNvbXBvbmVudC5iYXNlLFxuXHQgICAgbmV4dEJhc2UgPSBjb21wb25lbnQubmV4dEJhc2UsXG5cdCAgICBpbml0aWFsQmFzZSA9IGlzVXBkYXRlIHx8IG5leHRCYXNlLFxuXHQgICAgaW5pdGlhbENoaWxkQ29tcG9uZW50ID0gY29tcG9uZW50Ll9jb21wb25lbnQsXG5cdCAgICBza2lwID0gZmFsc2UsXG5cdCAgICByZW5kZXJlZCxcblx0ICAgIGluc3QsXG5cdCAgICBjYmFzZTtcblxuXHQvLyBpZiB1cGRhdGluZ1xuXHRpZiAoaXNVcGRhdGUpIHtcblx0XHRjb21wb25lbnQucHJvcHMgPSBwcmV2aW91c1Byb3BzO1xuXHRcdGNvbXBvbmVudC5zdGF0ZSA9IHByZXZpb3VzU3RhdGU7XG5cdFx0Y29tcG9uZW50LmNvbnRleHQgPSBwcmV2aW91c0NvbnRleHQ7XG5cdFx0aWYgKG9wdHMgIT09IDIgJiYgY29tcG9uZW50LnNob3VsZENvbXBvbmVudFVwZGF0ZSAmJiBjb21wb25lbnQuc2hvdWxkQ29tcG9uZW50VXBkYXRlKHByb3BzLCBzdGF0ZSwgY29udGV4dCkgPT09IGZhbHNlKSB7XG5cdFx0XHRza2lwID0gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKGNvbXBvbmVudC5jb21wb25lbnRXaWxsVXBkYXRlKSB7XG5cdFx0XHRjb21wb25lbnQuY29tcG9uZW50V2lsbFVwZGF0ZShwcm9wcywgc3RhdGUsIGNvbnRleHQpO1xuXHRcdH1cblx0XHRjb21wb25lbnQucHJvcHMgPSBwcm9wcztcblx0XHRjb21wb25lbnQuc3RhdGUgPSBzdGF0ZTtcblx0XHRjb21wb25lbnQuY29udGV4dCA9IGNvbnRleHQ7XG5cdH1cblxuXHRjb21wb25lbnQucHJldlByb3BzID0gY29tcG9uZW50LnByZXZTdGF0ZSA9IGNvbXBvbmVudC5wcmV2Q29udGV4dCA9IGNvbXBvbmVudC5uZXh0QmFzZSA9IG51bGw7XG5cdGNvbXBvbmVudC5fZGlydHkgPSBmYWxzZTtcblxuXHRpZiAoIXNraXApIHtcblx0XHRyZW5kZXJlZCA9IGNvbXBvbmVudC5yZW5kZXIocHJvcHMsIHN0YXRlLCBjb250ZXh0KTtcblxuXHRcdC8vIGNvbnRleHQgdG8gcGFzcyB0byB0aGUgY2hpbGQsIGNhbiBiZSB1cGRhdGVkIHZpYSAoZ3JhbmQtKXBhcmVudCBjb21wb25lbnRcblx0XHRpZiAoY29tcG9uZW50LmdldENoaWxkQ29udGV4dCkge1xuXHRcdFx0Y29udGV4dCA9IGV4dGVuZChleHRlbmQoe30sIGNvbnRleHQpLCBjb21wb25lbnQuZ2V0Q2hpbGRDb250ZXh0KCkpO1xuXHRcdH1cblxuXHRcdHZhciBjaGlsZENvbXBvbmVudCA9IHJlbmRlcmVkICYmIHJlbmRlcmVkLm5vZGVOYW1lLFxuXHRcdCAgICB0b1VubW91bnQsXG5cdFx0ICAgIGJhc2U7XG5cblx0XHRpZiAodHlwZW9mIGNoaWxkQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvLyBzZXQgdXAgaGlnaCBvcmRlciBjb21wb25lbnQgbGlua1xuXG5cdFx0XHR2YXIgY2hpbGRQcm9wcyA9IGdldE5vZGVQcm9wcyhyZW5kZXJlZCk7XG5cdFx0XHRpbnN0ID0gaW5pdGlhbENoaWxkQ29tcG9uZW50O1xuXG5cdFx0XHRpZiAoaW5zdCAmJiBpbnN0LmNvbnN0cnVjdG9yID09PSBjaGlsZENvbXBvbmVudCAmJiBjaGlsZFByb3BzLmtleSA9PSBpbnN0Ll9fa2V5KSB7XG5cdFx0XHRcdHNldENvbXBvbmVudFByb3BzKGluc3QsIGNoaWxkUHJvcHMsIDEsIGNvbnRleHQsIGZhbHNlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRvVW5tb3VudCA9IGluc3Q7XG5cblx0XHRcdFx0Y29tcG9uZW50Ll9jb21wb25lbnQgPSBpbnN0ID0gY3JlYXRlQ29tcG9uZW50KGNoaWxkQ29tcG9uZW50LCBjaGlsZFByb3BzLCBjb250ZXh0KTtcblx0XHRcdFx0aW5zdC5uZXh0QmFzZSA9IGluc3QubmV4dEJhc2UgfHwgbmV4dEJhc2U7XG5cdFx0XHRcdGluc3QuX3BhcmVudENvbXBvbmVudCA9IGNvbXBvbmVudDtcblx0XHRcdFx0c2V0Q29tcG9uZW50UHJvcHMoaW5zdCwgY2hpbGRQcm9wcywgMCwgY29udGV4dCwgZmFsc2UpO1xuXHRcdFx0XHRyZW5kZXJDb21wb25lbnQoaW5zdCwgMSwgbW91bnRBbGwsIHRydWUpO1xuXHRcdFx0fVxuXG5cdFx0XHRiYXNlID0gaW5zdC5iYXNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYmFzZSA9IGluaXRpYWxCYXNlO1xuXG5cdFx0XHQvLyBkZXN0cm95IGhpZ2ggb3JkZXIgY29tcG9uZW50IGxpbmtcblx0XHRcdHRvVW5tb3VudCA9IGluaXRpYWxDaGlsZENvbXBvbmVudDtcblx0XHRcdGlmICh0b1VubW91bnQpIHtcblx0XHRcdFx0Y2Jhc2UgPSBjb21wb25lbnQuX2NvbXBvbmVudCA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpbml0aWFsQmFzZSB8fCBvcHRzID09PSAxKSB7XG5cdFx0XHRcdGlmIChjYmFzZSkgY2Jhc2UuX2NvbXBvbmVudCA9IG51bGw7XG5cdFx0XHRcdGJhc2UgPSBkaWZmKGNiYXNlLCByZW5kZXJlZCwgY29udGV4dCwgbW91bnRBbGwgfHwgIWlzVXBkYXRlLCBpbml0aWFsQmFzZSAmJiBpbml0aWFsQmFzZS5wYXJlbnROb2RlLCB0cnVlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaW5pdGlhbEJhc2UgJiYgYmFzZSAhPT0gaW5pdGlhbEJhc2UgJiYgaW5zdCAhPT0gaW5pdGlhbENoaWxkQ29tcG9uZW50KSB7XG5cdFx0XHR2YXIgYmFzZVBhcmVudCA9IGluaXRpYWxCYXNlLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoYmFzZVBhcmVudCAmJiBiYXNlICE9PSBiYXNlUGFyZW50KSB7XG5cdFx0XHRcdGJhc2VQYXJlbnQucmVwbGFjZUNoaWxkKGJhc2UsIGluaXRpYWxCYXNlKTtcblxuXHRcdFx0XHRpZiAoIXRvVW5tb3VudCkge1xuXHRcdFx0XHRcdGluaXRpYWxCYXNlLl9jb21wb25lbnQgPSBudWxsO1xuXHRcdFx0XHRcdHJlY29sbGVjdE5vZGVUcmVlKGluaXRpYWxCYXNlLCBmYWxzZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodG9Vbm1vdW50KSB7XG5cdFx0XHR1bm1vdW50Q29tcG9uZW50KHRvVW5tb3VudCk7XG5cdFx0fVxuXG5cdFx0Y29tcG9uZW50LmJhc2UgPSBiYXNlO1xuXHRcdGlmIChiYXNlICYmICFpc0NoaWxkKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50UmVmID0gY29tcG9uZW50LFxuXHRcdFx0ICAgIHQgPSBjb21wb25lbnQ7XG5cdFx0XHR3aGlsZSAodCA9IHQuX3BhcmVudENvbXBvbmVudCkge1xuXHRcdFx0XHQoY29tcG9uZW50UmVmID0gdCkuYmFzZSA9IGJhc2U7XG5cdFx0XHR9XG5cdFx0XHRiYXNlLl9jb21wb25lbnQgPSBjb21wb25lbnRSZWY7XG5cdFx0XHRiYXNlLl9jb21wb25lbnRDb25zdHJ1Y3RvciA9IGNvbXBvbmVudFJlZi5jb25zdHJ1Y3Rvcjtcblx0XHR9XG5cdH1cblxuXHRpZiAoIWlzVXBkYXRlIHx8IG1vdW50QWxsKSB7XG5cdFx0bW91bnRzLnVuc2hpZnQoY29tcG9uZW50KTtcblx0fSBlbHNlIGlmICghc2tpcCkge1xuXHRcdC8vIEVuc3VyZSB0aGF0IHBlbmRpbmcgY29tcG9uZW50RGlkTW91bnQoKSBob29rcyBvZiBjaGlsZCBjb21wb25lbnRzXG5cdFx0Ly8gYXJlIGNhbGxlZCBiZWZvcmUgdGhlIGNvbXBvbmVudERpZFVwZGF0ZSgpIGhvb2sgaW4gdGhlIHBhcmVudC5cblx0XHQvLyBOb3RlOiBkaXNhYmxlZCBhcyBpdCBjYXVzZXMgZHVwbGljYXRlIGhvb2tzLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9wcmVhY3QvaXNzdWVzLzc1MFxuXHRcdC8vIGZsdXNoTW91bnRzKCk7XG5cblx0XHRpZiAoY29tcG9uZW50LmNvbXBvbmVudERpZFVwZGF0ZSkge1xuXHRcdFx0Y29tcG9uZW50LmNvbXBvbmVudERpZFVwZGF0ZShwcmV2aW91c1Byb3BzLCBwcmV2aW91c1N0YXRlLCBwcmV2aW91c0NvbnRleHQpO1xuXHRcdH1cblx0XHRpZiAob3B0aW9ucy5hZnRlclVwZGF0ZSkgb3B0aW9ucy5hZnRlclVwZGF0ZShjb21wb25lbnQpO1xuXHR9XG5cblx0aWYgKGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzICE9IG51bGwpIHtcblx0XHR3aGlsZSAoY29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRjb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcy5wb3AoKS5jYWxsKGNvbXBvbmVudCk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFkaWZmTGV2ZWwgJiYgIWlzQ2hpbGQpIGZsdXNoTW91bnRzKCk7XG59XG5cbi8qKiBBcHBseSB0aGUgQ29tcG9uZW50IHJlZmVyZW5jZWQgYnkgYSBWTm9kZSB0byB0aGUgRE9NLlxuICpcdEBwYXJhbSB7RWxlbWVudH0gZG9tXHRUaGUgRE9NIG5vZGUgdG8gbXV0YXRlXG4gKlx0QHBhcmFtIHtWTm9kZX0gdm5vZGVcdEEgQ29tcG9uZW50LXJlZmVyZW5jaW5nIFZOb2RlXG4gKlx0QHJldHVybnMge0VsZW1lbnR9IGRvbVx0VGhlIGNyZWF0ZWQvbXV0YXRlZCBlbGVtZW50XG4gKlx0QHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYnVpbGRDb21wb25lbnRGcm9tVk5vZGUoZG9tLCB2bm9kZSwgY29udGV4dCwgbW91bnRBbGwpIHtcblx0dmFyIGMgPSBkb20gJiYgZG9tLl9jb21wb25lbnQsXG5cdCAgICBvcmlnaW5hbENvbXBvbmVudCA9IGMsXG5cdCAgICBvbGREb20gPSBkb20sXG5cdCAgICBpc0RpcmVjdE93bmVyID0gYyAmJiBkb20uX2NvbXBvbmVudENvbnN0cnVjdG9yID09PSB2bm9kZS5ub2RlTmFtZSxcblx0ICAgIGlzT3duZXIgPSBpc0RpcmVjdE93bmVyLFxuXHQgICAgcHJvcHMgPSBnZXROb2RlUHJvcHModm5vZGUpO1xuXHR3aGlsZSAoYyAmJiAhaXNPd25lciAmJiAoYyA9IGMuX3BhcmVudENvbXBvbmVudCkpIHtcblx0XHRpc093bmVyID0gYy5jb25zdHJ1Y3RvciA9PT0gdm5vZGUubm9kZU5hbWU7XG5cdH1cblxuXHRpZiAoYyAmJiBpc093bmVyICYmICghbW91bnRBbGwgfHwgYy5fY29tcG9uZW50KSkge1xuXHRcdHNldENvbXBvbmVudFByb3BzKGMsIHByb3BzLCAzLCBjb250ZXh0LCBtb3VudEFsbCk7XG5cdFx0ZG9tID0gYy5iYXNlO1xuXHR9IGVsc2Uge1xuXHRcdGlmIChvcmlnaW5hbENvbXBvbmVudCAmJiAhaXNEaXJlY3RPd25lcikge1xuXHRcdFx0dW5tb3VudENvbXBvbmVudChvcmlnaW5hbENvbXBvbmVudCk7XG5cdFx0XHRkb20gPSBvbGREb20gPSBudWxsO1xuXHRcdH1cblxuXHRcdGMgPSBjcmVhdGVDb21wb25lbnQodm5vZGUubm9kZU5hbWUsIHByb3BzLCBjb250ZXh0KTtcblx0XHRpZiAoZG9tICYmICFjLm5leHRCYXNlKSB7XG5cdFx0XHRjLm5leHRCYXNlID0gZG9tO1xuXHRcdFx0Ly8gcGFzc2luZyBkb20vb2xkRG9tIGFzIG5leHRCYXNlIHdpbGwgcmVjeWNsZSBpdCBpZiB1bnVzZWQsIHNvIGJ5cGFzcyByZWN5Y2xpbmcgb24gTDIyOTpcblx0XHRcdG9sZERvbSA9IG51bGw7XG5cdFx0fVxuXHRcdHNldENvbXBvbmVudFByb3BzKGMsIHByb3BzLCAxLCBjb250ZXh0LCBtb3VudEFsbCk7XG5cdFx0ZG9tID0gYy5iYXNlO1xuXG5cdFx0aWYgKG9sZERvbSAmJiBkb20gIT09IG9sZERvbSkge1xuXHRcdFx0b2xkRG9tLl9jb21wb25lbnQgPSBudWxsO1xuXHRcdFx0cmVjb2xsZWN0Tm9kZVRyZWUob2xkRG9tLCBmYWxzZSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRvbTtcbn1cblxuLyoqIFJlbW92ZSBhIGNvbXBvbmVudCBmcm9tIHRoZSBET00gYW5kIHJlY3ljbGUgaXQuXG4gKlx0QHBhcmFtIHtDb21wb25lbnR9IGNvbXBvbmVudFx0VGhlIENvbXBvbmVudCBpbnN0YW5jZSB0byB1bm1vdW50XG4gKlx0QHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudChjb21wb25lbnQpIHtcblx0aWYgKG9wdGlvbnMuYmVmb3JlVW5tb3VudCkgb3B0aW9ucy5iZWZvcmVVbm1vdW50KGNvbXBvbmVudCk7XG5cblx0dmFyIGJhc2UgPSBjb21wb25lbnQuYmFzZTtcblxuXHRjb21wb25lbnQuX2Rpc2FibGUgPSB0cnVlO1xuXG5cdGlmIChjb21wb25lbnQuY29tcG9uZW50V2lsbFVubW91bnQpIGNvbXBvbmVudC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXG5cdGNvbXBvbmVudC5iYXNlID0gbnVsbDtcblxuXHQvLyByZWN1cnNpdmVseSB0ZWFyIGRvd24gJiByZWNvbGxlY3QgaGlnaC1vcmRlciBjb21wb25lbnQgY2hpbGRyZW46XG5cdHZhciBpbm5lciA9IGNvbXBvbmVudC5fY29tcG9uZW50O1xuXHRpZiAoaW5uZXIpIHtcblx0XHR1bm1vdW50Q29tcG9uZW50KGlubmVyKTtcblx0fSBlbHNlIGlmIChiYXNlKSB7XG5cdFx0aWYgKGJhc2VbJ19fcHJlYWN0YXR0cl8nXSAmJiBiYXNlWydfX3ByZWFjdGF0dHJfJ10ucmVmKSBiYXNlWydfX3ByZWFjdGF0dHJfJ10ucmVmKG51bGwpO1xuXG5cdFx0Y29tcG9uZW50Lm5leHRCYXNlID0gYmFzZTtcblxuXHRcdHJlbW92ZU5vZGUoYmFzZSk7XG5cdFx0Y29sbGVjdENvbXBvbmVudChjb21wb25lbnQpO1xuXG5cdFx0cmVtb3ZlQ2hpbGRyZW4oYmFzZSk7XG5cdH1cblxuXHRpZiAoY29tcG9uZW50Ll9fcmVmKSBjb21wb25lbnQuX19yZWYobnVsbCk7XG59XG5cbi8qKiBCYXNlIENvbXBvbmVudCBjbGFzcy5cbiAqXHRQcm92aWRlcyBgc2V0U3RhdGUoKWAgYW5kIGBmb3JjZVVwZGF0ZSgpYCwgd2hpY2ggdHJpZ2dlciByZW5kZXJpbmcuXG4gKlx0QHB1YmxpY1xuICpcbiAqXHRAZXhhbXBsZVxuICpcdGNsYXNzIE15Rm9vIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAqXHRcdHJlbmRlcihwcm9wcywgc3RhdGUpIHtcbiAqXHRcdFx0cmV0dXJuIDxkaXYgLz47XG4gKlx0XHR9XG4gKlx0fVxuICovXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQpIHtcblx0dGhpcy5fZGlydHkgPSB0cnVlO1xuXG5cdC8qKiBAcHVibGljXG4gICpcdEB0eXBlIHtvYmplY3R9XG4gICovXG5cdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG5cblx0LyoqIEBwdWJsaWNcbiAgKlx0QHR5cGUge29iamVjdH1cbiAgKi9cblx0dGhpcy5wcm9wcyA9IHByb3BzO1xuXG5cdC8qKiBAcHVibGljXG4gICpcdEB0eXBlIHtvYmplY3R9XG4gICovXG5cdHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlIHx8IHt9O1xufVxuXG5leHRlbmQoQ29tcG9uZW50LnByb3RvdHlwZSwge1xuXG5cdC8qKiBSZXR1cm5zIGEgYGJvb2xlYW5gIGluZGljYXRpbmcgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgcmUtcmVuZGVyIHdoZW4gcmVjZWl2aW5nIHRoZSBnaXZlbiBgcHJvcHNgIGFuZCBgc3RhdGVgLlxuICAqXHRAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICpcdEBwYXJhbSB7b2JqZWN0fSBuZXh0U3RhdGVcbiAgKlx0QHBhcmFtIHtvYmplY3R9IG5leHRDb250ZXh0XG4gICpcdEByZXR1cm5zIHtCb29sZWFufSBzaG91bGQgdGhlIGNvbXBvbmVudCByZS1yZW5kZXJcbiAgKlx0QG5hbWUgc2hvdWxkQ29tcG9uZW50VXBkYXRlXG4gICpcdEBmdW5jdGlvblxuICAqL1xuXG5cdC8qKiBVcGRhdGUgY29tcG9uZW50IHN0YXRlIGJ5IGNvcHlpbmcgcHJvcGVydGllcyBmcm9tIGBzdGF0ZWAgdG8gYHRoaXMuc3RhdGVgLlxuICAqXHRAcGFyYW0ge29iamVjdH0gc3RhdGVcdFx0QSBoYXNoIG9mIHN0YXRlIHByb3BlcnRpZXMgdG8gdXBkYXRlIHdpdGggbmV3IHZhbHVlc1xuICAqXHRAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1x0QSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBjb21wb25lbnQgc3RhdGUgaXMgdXBkYXRlZFxuICAqL1xuXHRzZXRTdGF0ZTogZnVuY3Rpb24gc2V0U3RhdGUoc3RhdGUsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHMgPSB0aGlzLnN0YXRlO1xuXHRcdGlmICghdGhpcy5wcmV2U3RhdGUpIHRoaXMucHJldlN0YXRlID0gZXh0ZW5kKHt9LCBzKTtcblx0XHRleHRlbmQocywgdHlwZW9mIHN0YXRlID09PSAnZnVuY3Rpb24nID8gc3RhdGUocywgdGhpcy5wcm9wcykgOiBzdGF0ZSk7XG5cdFx0aWYgKGNhbGxiYWNrKSAodGhpcy5fcmVuZGVyQ2FsbGJhY2tzID0gdGhpcy5fcmVuZGVyQ2FsbGJhY2tzIHx8IFtdKS5wdXNoKGNhbGxiYWNrKTtcblx0XHRlbnF1ZXVlUmVuZGVyKHRoaXMpO1xuXHR9LFxuXG5cblx0LyoqIEltbWVkaWF0ZWx5IHBlcmZvcm0gYSBzeW5jaHJvbm91cyByZS1yZW5kZXIgb2YgdGhlIGNvbXBvbmVudC5cbiAgKlx0QHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcdFx0QSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHJlLXJlbmRlcmVkLlxuICAqXHRAcHJpdmF0ZVxuICAqL1xuXHRmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoY2FsbGJhY2spIHtcblx0XHRpZiAoY2FsbGJhY2spICh0aGlzLl9yZW5kZXJDYWxsYmFja3MgPSB0aGlzLl9yZW5kZXJDYWxsYmFja3MgfHwgW10pLnB1c2goY2FsbGJhY2spO1xuXHRcdHJlbmRlckNvbXBvbmVudCh0aGlzLCAyKTtcblx0fSxcblxuXG5cdC8qKiBBY2NlcHRzIGBwcm9wc2AgYW5kIGBzdGF0ZWAsIGFuZCByZXR1cm5zIGEgbmV3IFZpcnR1YWwgRE9NIHRyZWUgdG8gYnVpbGQuXG4gICpcdFZpcnR1YWwgRE9NIGlzIGdlbmVyYWxseSBjb25zdHJ1Y3RlZCB2aWEgW0pTWF0oaHR0cDovL2phc29uZm9ybWF0LmNvbS93dGYtaXMtanN4KS5cbiAgKlx0QHBhcmFtIHtvYmplY3R9IHByb3BzXHRcdFByb3BzIChlZzogSlNYIGF0dHJpYnV0ZXMpIHJlY2VpdmVkIGZyb20gcGFyZW50IGVsZW1lbnQvY29tcG9uZW50XG4gICpcdEBwYXJhbSB7b2JqZWN0fSBzdGF0ZVx0XHRUaGUgY29tcG9uZW50J3MgY3VycmVudCBzdGF0ZVxuICAqXHRAcGFyYW0ge29iamVjdH0gY29udGV4dFx0XHRDb250ZXh0IG9iamVjdCAoaWYgYSBwYXJlbnQgY29tcG9uZW50IGhhcyBwcm92aWRlZCBjb250ZXh0KVxuICAqXHRAcmV0dXJucyBWTm9kZVxuICAqL1xuXHRyZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHt9XG59KTtcblxuLyoqIFJlbmRlciBKU1ggaW50byBhIGBwYXJlbnRgIEVsZW1lbnQuXG4gKlx0QHBhcmFtIHtWTm9kZX0gdm5vZGVcdFx0QSAoSlNYKSBWTm9kZSB0byByZW5kZXJcbiAqXHRAcGFyYW0ge0VsZW1lbnR9IHBhcmVudFx0XHRET00gZWxlbWVudCB0byByZW5kZXIgaW50b1xuICpcdEBwYXJhbSB7RWxlbWVudH0gW21lcmdlXVx0QXR0ZW1wdCB0byByZS11c2UgYW4gZXhpc3RpbmcgRE9NIHRyZWUgcm9vdGVkIGF0IGBtZXJnZWBcbiAqXHRAcHVibGljXG4gKlxuICpcdEBleGFtcGxlXG4gKlx0Ly8gcmVuZGVyIGEgZGl2IGludG8gPGJvZHk+OlxuICpcdHJlbmRlcig8ZGl2IGlkPVwiaGVsbG9cIj5oZWxsbyE8L2Rpdj4sIGRvY3VtZW50LmJvZHkpO1xuICpcbiAqXHRAZXhhbXBsZVxuICpcdC8vIHJlbmRlciBhIFwiVGhpbmdcIiBjb21wb25lbnQgaW50byAjZm9vOlxuICpcdGNvbnN0IFRoaW5nID0gKHsgbmFtZSB9KSA9PiA8c3Bhbj57IG5hbWUgfTwvc3Bhbj47XG4gKlx0cmVuZGVyKDxUaGluZyBuYW1lPVwib25lXCIgLz4sIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNmb28nKSk7XG4gKi9cbmZ1bmN0aW9uIHJlbmRlcih2bm9kZSwgcGFyZW50LCBtZXJnZSkge1xuICByZXR1cm4gZGlmZihtZXJnZSwgdm5vZGUsIHt9LCBmYWxzZSwgcGFyZW50LCBmYWxzZSk7XG59XG5cbnZhciBwcmVhY3QgPSB7XG5cdGg6IGgsXG5cdGNyZWF0ZUVsZW1lbnQ6IGgsXG5cdGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50LFxuXHRDb21wb25lbnQ6IENvbXBvbmVudCxcblx0cmVuZGVyOiByZW5kZXIsXG5cdHJlcmVuZGVyOiByZXJlbmRlcixcblx0b3B0aW9uczogb3B0aW9uc1xufTtcblxuZXhwb3J0IHsgaCwgaCBhcyBjcmVhdGVFbGVtZW50LCBjbG9uZUVsZW1lbnQsIENvbXBvbmVudCwgcmVuZGVyLCByZXJlbmRlciwgb3B0aW9ucyB9O1xuZXhwb3J0IGRlZmF1bHQgcHJlYWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJlYWN0LmVzbS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3ByZWFjdC9kaXN0L3ByZWFjdC5lc20uanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*              ___                 ______\n               /  /\\               /  ___/\\\n        ______/  / / _______    __/  /___\\/\n       /  ___   / / /  ___  \\  /_   __/\\\n      /  /\\_/  / / /  /__/  /\\ \\/  /\\_\\/\n     /  / //  / / /  ______/ / /  / /\n    /  /_//  / / /  /______\\/ /  / /\n    \\_______/ /  \\_______/\\  /__/ /\n     \\______\\/    \\______\\/  \\__*/\n\n//. # sanctuary-def\n//.\n//. sanctuary-def is a run-time type system for JavaScript. It facilitates\n//. the definition of curried JavaScript functions which are explicit about\n//. the number of arguments to which they may be applied and the types of\n//. those arguments.\n//.\n//. It is conventional to import the package as `$`:\n//.\n//. ```javascript\n//. const $ = require('sanctuary-def');\n//. ```\n//.\n//. The next step is to define an environment. An environment is an array\n//. of [types][]. [`env`][] is an environment containing all the built-in\n//. JavaScript types. It may be used as the basis for environments which\n//. include custom types in addition to the built-in types:\n//.\n//. ```javascript\n//. //    Integer :: Type\n//. const Integer = ...;\n//.\n//. //    NonZeroInteger :: Type\n//. const NonZeroInteger = ...;\n//.\n//. //    env :: Array Type\n//. const env = $.env.concat([Integer, NonZeroInteger]);\n//. ```\n//.\n//. Type constructors such as `List :: Type -> Type` cannot be included in\n//. an environment as they're not of the correct type. One could, though,\n//. use a type constructor to define a fixed number of concrete types:\n//.\n//. ```javascript\n//. //    env :: Array Type\n//. const env = $.env.concat([\n//.   List($.Number),               // :: Type\n//.   List($.String),               // :: Type\n//.   List(List($.Number)),         // :: Type\n//.   List(List($.String)),         // :: Type\n//.   List(List(List($.Number))),   // :: Type\n//.   List(List(List($.String))),   // :: Type\n//. ]);\n//. ```\n//.\n//. Not only would this be tedious, but one could never enumerate all possible\n//. types as there are infinitely many. Instead, one should use [`Unknown`][]:\n//.\n//. ```javascript\n//. //    env :: Array Type\n//. const env = $.env.concat([List($.Unknown)]);\n//. ```\n//.\n//. The next step is to define a `def` function for the environment:\n//.\n//. ```javascript\n//. const def = $.create({checkTypes: true, env: env});\n//. ```\n//.\n//. The `checkTypes` option determines whether type checking is enabled.\n//. This allows one to only pay the performance cost of run-time type checking\n//. during development. For example:\n//.\n//. ```javascript\n//. const def = $.create({\n//.   checkTypes: process.env.NODE_ENV === 'development',\n//.   env: env,\n//. });\n//. ```\n//.\n//. `def` is a function for defining functions. For example:\n//.\n//. ```javascript\n//. //    add :: Number -> Number -> Number\n//. const add =\n//. def('add', {}, [$.Number, $.Number, $.Number], (x, y) => x + y);\n//. ```\n//.\n//. `[$.Number, $.Number, $.Number]` specifies that `add` takes two arguments\n//. of type `Number` and returns a value of type `Number`.\n//.\n//. Applying `add` to two arguments gives the expected result:\n//.\n//. ```javascript\n//. add(2, 2);\n//. // => 4\n//. ```\n//.\n//. Applying `add` to greater than two arguments results in an exception being\n//. thrown:\n//.\n//. ```javascript\n//. add(2, 2, 2);\n//. // ! TypeError: add requires two arguments; received three arguments\n//. ```\n//.\n//. Applying `add` to fewer than two arguments results in a function\n//. awaiting the remaining arguments. This is known as partial application.\n//. Partial application is convenient as it allows more specific functions\n//. to be defined in terms of more general ones:\n//.\n//. ```javascript\n//. //    inc :: Number -> Number\n//. const inc = add(1);\n//.\n//. inc(7);\n//. // => 8\n//. ```\n//.\n//. JavaScript's implicit type coercion often obfuscates the source of type\n//. errors. Consider the following function:\n//.\n//. ```javascript\n//. //    _add :: (Number, Number) -> Number\n//. const _add = (x, y) => x + y;\n//. ```\n//.\n//. The type signature indicates that `_add` takes two arguments of type\n//. `Number`, but this is not enforced. This allows type errors to be silently\n//. ignored:\n//.\n//. ```javascript\n//. _add('2', '2');\n//. // => '22'\n//. ```\n//.\n//. `add`, on the other hand, throws if applied to arguments of the wrong\n//. types:\n//.\n//. ```javascript\n//. add('2', '2');\n//. // ! TypeError: Invalid value\n//. //\n//. //   add :: Number -> Number -> Number\n//. //          ^^^^^^\n//. //            1\n//. //\n//. //   1)  \"2\" :: String\n//. //\n//. //   The value at position 1 is not a member of Number.\n//. ```\n//.\n//. Type checking is performed as arguments are provided (rather than once all\n//. arguments have been provided), so type errors are reported early:\n//.\n//. ```javascript\n//. add('X');\n//. // ! TypeError: Invalid value\n//. //\n//. //   add :: Number -> Number -> Number\n//. //          ^^^^^^\n//. //            1\n//. //\n//. //   1)  \"X\" :: String\n//. //\n//. //   The value at position 1 is not a member of Number.\n//. ```\n\n(function(f) {\n\n  'use strict';\n\n  /* istanbul ignore else */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f(__webpack_require__(13),\n                       __webpack_require__(1));\n  } else if (\"function\" === 'function' && __webpack_require__(0) != null) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(13), __webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {\n    self.sanctuaryDef = f(self.sanctuaryTypeClasses,\n                          self.sanctuaryTypeIdentifiers);\n  }\n\n}(function(Z, type) {\n\n  'use strict';\n\n  //# __ :: Placeholder\n  //.\n  //. The special placeholder value.\n  //.\n  //. One may wish to partially apply a function whose parameters are in the\n  //. \"wrong\" order. Functions defined via sanctuary-def accommodate this by\n  //. accepting placeholders for arguments yet to be provided. For example:\n  //.\n  //. ```javascript\n  //. //    concatS :: String -> String -> String\n  //. const concatS =\n  //. def('concatS', {}, [$.String, $.String, $.String], (x, y) => x + y);\n  //.\n  //. //    exclaim :: String -> String\n  //. const exclaim = concatS($.__, '!');\n  //.\n  //. exclaim('ahoy');\n  //. // => 'ahoy!'\n  //. ```\n  var __ = {'@@functional/placeholder': true};\n\n  var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n  var MIN_SAFE_INTEGER = -MAX_SAFE_INTEGER;\n\n  var slice             = Array.prototype.slice;\n  var hasOwnProperty    = Object.prototype.hasOwnProperty;\n\n  function Either(tag, value) {\n    this.isLeft = tag === 'Left';\n    this.isRight = tag === 'Right';\n    this.value = value;\n  }\n\n  Either['@@type'] = 'sanctuary-def/Either';\n\n  Either.prototype['fantasy-land/map'] = function(f) {\n    return this.isLeft ? this : Right(f(this.value));\n  };\n\n  Either.prototype['fantasy-land/chain'] = function(f) {\n    return this.isLeft ? this : f(this.value);\n  };\n\n  //  Left :: a -> Either a b\n  function Left(x) { return new Either('Left', x); }\n\n  //  Right :: b -> Either a b\n  function Right(x) { return new Either('Right', x); }\n\n  //  K :: a -> b -> a\n  function K(x) { return function(y) { return x; }; }\n\n  //  always2 :: a -> (b, c) -> a\n  function always2(x) { return function(y, z) { return x; }; }\n\n  //  id :: a -> a\n  function id(x) { return x; }\n\n  //  init :: Array a -> Array a\n  function init(xs) { return xs.slice(0, -1); }\n\n  //  isEmpty :: Array a -> Boolean\n  function isEmpty(xs) { return xs.length === 0; }\n\n  //  isPrefix :: Array a -> Array a -> Boolean\n  function isPrefix(candidate) {\n    return function(xs) {\n      if (candidate.length > xs.length) return false;\n      for (var idx = 0; idx < candidate.length; idx += 1) {\n        if (candidate[idx] !== xs[idx]) return false;\n      }\n      return true;\n    };\n  }\n\n  //  last :: Array a -> a\n  function last(xs) { return xs[xs.length - 1]; }\n\n  //  memberOf :: Array a -> a -> Boolean\n  function memberOf(xs) {\n    return function(y) {\n      return xs.some(function(x) { return Z.equals(x, y); });\n    };\n  }\n\n  //  or :: (Array a, Array a) -> Array a\n  function or(xs, ys) { return isEmpty(xs) ? ys : xs; }\n\n  //  range :: (Number, Number) -> Array Number\n  function range(start, stop) {\n    var result = [];\n    for (var n = start; n < stop; n += 1) result.push(n);\n    return result;\n  }\n\n  //  singleton :: (String, a) -> StrMap a\n  function singleton(k, v) {\n    var result = {};\n    result[k] = v;\n    return result;\n  }\n\n  //  strRepeat :: (String, Integer) -> String\n  function strRepeat(s, times) {\n    return Array(times + 1).join(s);\n  }\n\n  //  r :: Char -> String -> String\n  function r(c) {\n    return function(s) {\n      return strRepeat(c, s.length);\n    };\n  }\n\n  //  _ :: String -> String\n  var _ = r(' ');\n\n  //  stripOutermostParens :: String -> String\n  function stripOutermostParens(s) {\n    return s.slice('('.length, -')'.length);\n  }\n\n  //  toMarkdownList :: (String, String, a -> String, Array a) -> String\n  function toMarkdownList(empty, s, f, xs) {\n    return isEmpty(xs) ?\n      empty :\n      Z.reduce(function(s, x) { return s + '  - ' + f(x) + '\\n'; }, s, xs);\n  }\n\n  //  trimTrailingSpaces :: String -> String\n  function trimTrailingSpaces(s) {\n    return s.replace(/[ ]+$/gm, '');\n  }\n\n  //  unless :: (Boolean, (a -> a), a) -> a\n  function unless(bool, f, x) {\n    return bool ? x : f(x);\n  }\n\n  //  when :: (Boolean, (a -> a), a) -> a\n  function when(bool, f, x) {\n    return bool ? f(x) : x;\n  }\n\n  //  wrap :: String -> String -> String -> String\n  function wrap(prefix) {\n    return function(suffix) {\n      return function(s) {\n        return prefix + s + suffix;\n      };\n    };\n  }\n\n  //  parenthesize :: String -> String\n  var parenthesize = wrap('(')(')');\n\n  //  q :: String -> String\n  var q = wrap('\\u2018')('\\u2019');\n\n  //  stripNamespace :: String -> String\n  function stripNamespace(s) { return s.slice(s.indexOf('/') + 1); }\n\n  //  _Type :: ... -> Type\n  function _Type(\n    type,       // :: String\n    name,       // :: String\n    url,        // :: String\n    format,     // :: (String -> String, String -> String -> String) -> String\n    test,       // :: Any -> Boolean\n    keys,       // :: Array String\n    types       // :: StrMap { extractor :: a -> Array b, type :: Type }\n  ) {\n    this._test = test;\n    this.format = format;\n    this.keys = keys;\n    this.name = name;\n    this.type = type;\n    this.types = types;\n    this.url = url;\n  }\n\n  _Type['@@type'] = 'sanctuary-def/Type';\n\n  _Type.prototype.validate = function(x) {\n    if (!this._test(x)) return Left({value: x, propPath: []});\n    for (var idx = 0; idx < this.keys.length; idx += 1) {\n      var k = this.keys[idx];\n      var t = this.types[k];\n      for (var idx2 = 0, ys = t.extractor(x); idx2 < ys.length; idx2 += 1) {\n        var result = t.type.validate(ys[idx2]);\n        if (result.isLeft) {\n          var value = result.value.value;\n          var propPath = Z.concat([k], result.value.propPath);\n          return Left({value: value, propPath: propPath});\n        }\n      }\n    }\n    return Right(x);\n  };\n\n  _Type.prototype.toString = function() {\n    return this.format(id, K(id));\n  };\n\n  var BINARY        = 'BINARY';\n  var FUNCTION      = 'FUNCTION';\n  var INCONSISTENT  = 'INCONSISTENT';\n  var NULLARY       = 'NULLARY';\n  var RECORD        = 'RECORD';\n  var UNARY         = 'UNARY';\n  var UNKNOWN       = 'UNKNOWN';\n  var VARIABLE      = 'VARIABLE';\n\n  //  Inconsistent :: Type\n  var Inconsistent =\n  new _Type(INCONSISTENT, '', '', always2('???'), K(false), [], {});\n\n  //  typeEq :: String -> a -> Boolean\n  function typeEq(name) {\n    return function(x) {\n      return type(x) === name;\n    };\n  }\n\n  //  typeofEq :: String -> a -> Boolean\n  function typeofEq(typeof_) {\n    return function(x) {\n      // eslint-disable-next-line valid-typeof\n      return typeof x === typeof_;\n    };\n  }\n\n  //  functionUrl :: String -> String\n  function functionUrl(name) {\n    var version = '0.14.0';  // updated programmatically\n    return 'https://github.com/sanctuary-js/sanctuary-def/tree/v' + version +\n           '#' + stripNamespace(name);\n  }\n\n  //  NullaryTypeWithUrl :: (String, Any -> Boolean) -> Type\n  function NullaryTypeWithUrl(name, test) {\n    return NullaryType(name, functionUrl(name), test);\n  }\n\n  //  EnumTypeWithUrl :: (String, Array Any) -> Type\n  function EnumTypeWithUrl(name, members) {\n    return EnumType(name, functionUrl(name), members);\n  }\n\n  //  UnaryTypeWithUrl ::\n  //    (String, Any -> Boolean, t a -> Array a) -> (Type -> Type)\n  function UnaryTypeWithUrl(name, test, _1) {\n    return UnaryType(name, functionUrl(name), test, _1);\n  }\n\n  //  BinaryTypeWithUrl ::\n  //    (String, Any -> Boolean, t a b -> Array a, t a b -> Array b) ->\n  //      ((Type, Type) -> Type)\n  function BinaryTypeWithUrl(name, test, _1, _2) {\n    return BinaryType(name, functionUrl(name), test, _1, _2);\n  }\n\n  //. ### Types\n  //.\n  //. Conceptually, a type is a set of values. One can think of a value of\n  //. type `Type` as a function of type `Any -> Boolean` which tests values\n  //. for membership in the set (though this is an oversimplification).\n\n  //# Any :: Type\n  //.\n  //. Type comprising every JavaScript value.\n  var Any = NullaryTypeWithUrl('sanctuary-def/Any', K(true));\n\n  //# AnyFunction :: Type\n  //.\n  //. Type comprising every Function value.\n  var AnyFunction = NullaryTypeWithUrl('Function', typeofEq('function'));\n\n  //# Arguments :: Type\n  //.\n  //. Type comprising every [`arguments`][arguments] object.\n  var Arguments = NullaryTypeWithUrl('Arguments', typeEq('Arguments'));\n\n  //# Array :: Type -> Type\n  //.\n  //. Constructor for homogeneous Array types.\n  var Array_ = UnaryTypeWithUrl('Array', typeEq('Array'), id);\n\n  //# Boolean :: Type\n  //.\n  //. Type comprising `true` and `false`.\n  var Boolean_ = NullaryTypeWithUrl('Boolean', typeofEq('boolean'));\n\n  //# Date :: Type\n  //.\n  //. Type comprising every Date value.\n  var Date_ = NullaryTypeWithUrl('Date', typeEq('Date'));\n\n  //# Error :: Type\n  //.\n  //. Type comprising every Error value, including values of more specific\n  //. constructors such as [`SyntaxError`][] and [`TypeError`][].\n  var Error_ = NullaryTypeWithUrl('Error', typeEq('Error'));\n\n  //# FiniteNumber :: Type\n  //.\n  //. Type comprising every [`ValidNumber`][] value except `Infinity` and\n  //. `-Infinity`.\n  var FiniteNumber = NullaryTypeWithUrl(\n    'sanctuary-def/FiniteNumber',\n    function(x) { return ValidNumber._test(x) && isFinite(x); }\n  );\n\n  //# Function :: Array Type -> Type\n  //.\n  //. Constructor for Function types.\n  //.\n  //. Examples:\n  //.\n  //.   - `$.Function([$.Date, $.String])` represents the `Date -> String`\n  //.     type; and\n  //.   - `$.Function([a, b, a])` represents the `(a, b) -> a` type.\n  function Function_(types) {\n    function format(outer, inner) {\n      var xs = types.map(function(t, idx) {\n        return unless(t.type === RECORD || isEmpty(t.keys),\n                      stripOutermostParens,\n                      inner('$' + String(idx + 1))(String(t)));\n      });\n      var parenthesize = wrap(outer('('))(outer(')'));\n      return parenthesize(unless(types.length === 2,\n                                 parenthesize,\n                                 init(xs).join(outer(', '))) +\n                          outer(' -> ') +\n                          last(xs));\n    }\n\n    var test = AnyFunction._test;\n\n    var $keys = [];\n    var $types = {};\n    types.forEach(function(t, idx) {\n      var k = '$' + String(idx + 1);\n      $keys.push(k);\n      $types[k] = {extractor: K([]), type: t};\n    });\n\n    return new _Type(FUNCTION, '', '', format, test, $keys, $types);\n  }\n\n  //# GlobalRegExp :: Type\n  //.\n  //. Type comprising every [`RegExp`][] value whose `global` flag is `true`.\n  //.\n  //. See also [`NonGlobalRegExp`][].\n  var GlobalRegExp = NullaryTypeWithUrl(\n    'sanctuary-def/GlobalRegExp',\n    function(x) { return RegExp_._test(x) && x.global; }\n  );\n\n  //# Integer :: Type\n  //.\n  //. Type comprising every integer in the range\n  //. [[`Number.MIN_SAFE_INTEGER`][min] .. [`Number.MAX_SAFE_INTEGER`][max]].\n  var Integer = NullaryTypeWithUrl(\n    'sanctuary-def/Integer',\n    function(x) {\n      return ValidNumber._test(x) &&\n             Math.floor(x) === x &&\n             x >= MIN_SAFE_INTEGER &&\n             x <= MAX_SAFE_INTEGER;\n    }\n  );\n\n  //# NegativeFiniteNumber :: Type\n  //.\n  //. Type comprising every [`FiniteNumber`][] value less than zero.\n  var NegativeFiniteNumber = NullaryTypeWithUrl(\n    'sanctuary-def/NegativeFiniteNumber',\n    function(x) { return FiniteNumber._test(x) && x < 0; }\n  );\n\n  //# NegativeInteger :: Type\n  //.\n  //. Type comprising every [`Integer`][] value less than zero.\n  var NegativeInteger = NullaryTypeWithUrl(\n    'sanctuary-def/NegativeInteger',\n    function(x) { return Integer._test(x) && x < 0; }\n  );\n\n  //# NegativeNumber :: Type\n  //.\n  //. Type comprising every [`Number`][] value less than zero.\n  var NegativeNumber = NullaryTypeWithUrl(\n    'sanctuary-def/NegativeNumber',\n    function(x) { return Number_._test(x) && x < 0; }\n  );\n\n  //# NonEmpty :: Type -> Type\n  //.\n  //. Constructor for non-empty types. `$.NonEmpty($.String)`, for example, is\n  //. the type comprising every [`String`][] value except `''`.\n  //.\n  //. The given type must satisfy the [Monoid][] and [Setoid][] specifications.\n  var NonEmpty = UnaryType(\n    'sanctuary-def/NonEmpty',\n    functionUrl('NonEmpty'),\n    function(x) {\n      return Z.Monoid.test(x) &&\n             Z.Setoid.test(x) &&\n             !Z.equals(x, Z.empty(x.constructor));\n    },\n    function(monoid) { return [monoid]; }\n  );\n\n  //# NonGlobalRegExp :: Type\n  //.\n  //. Type comprising every [`RegExp`][] value whose `global` flag is `false`.\n  //.\n  //. See also [`GlobalRegExp`][].\n  var NonGlobalRegExp = NullaryTypeWithUrl(\n    'sanctuary-def/NonGlobalRegExp',\n    function(x) { return RegExp_._test(x) && !x.global; }\n  );\n\n  //# NonNegativeInteger :: Type\n  //.\n  //. Type comprising every non-negative [`Integer`][] value (including `-0`).\n  //. Also known as the set of natural numbers under ISO 80000-2:2009.\n  var NonNegativeInteger = NullaryTypeWithUrl(\n    'sanctuary-def/NonNegativeInteger',\n    function(x) { return Integer._test(x) && x >= 0; }\n  );\n\n  //# NonZeroFiniteNumber :: Type\n  //.\n  //. Type comprising every [`FiniteNumber`][] value except `0` and `-0`.\n  var NonZeroFiniteNumber = NullaryTypeWithUrl(\n    'sanctuary-def/NonZeroFiniteNumber',\n    function(x) { return FiniteNumber._test(x) && x !== 0; }\n  );\n\n  //# NonZeroInteger :: Type\n  //.\n  //. Type comprising every [`Integer`][] value except `0` and `-0`.\n  var NonZeroInteger = NullaryTypeWithUrl(\n    'sanctuary-def/NonZeroInteger',\n    function(x) { return Integer._test(x) && x !== 0; }\n  );\n\n  //# NonZeroValidNumber :: Type\n  //.\n  //. Type comprising every [`ValidNumber`][] value except `0` and `-0`.\n  var NonZeroValidNumber = NullaryTypeWithUrl(\n    'sanctuary-def/NonZeroValidNumber',\n    function(x) { return ValidNumber._test(x) && x !== 0; }\n  );\n\n  //# Null :: Type\n  //.\n  //. Type whose sole member is `null`.\n  var Null = NullaryTypeWithUrl('Null', typeEq('Null'));\n\n  //# Nullable :: Type -> Type\n  //.\n  //. Constructor for types which include `null` as a member.\n  var Nullable = UnaryTypeWithUrl(\n    'sanctuary-def/Nullable',\n    K(true),\n    function(nullable) {\n      // eslint-disable-next-line eqeqeq\n      return nullable === null ? [] : [nullable];\n    }\n  );\n\n  //# Number :: Type\n  //.\n  //. Type comprising every primitive Number value (including `NaN`).\n  var Number_ = NullaryTypeWithUrl('Number', typeofEq('number'));\n\n  //# Object :: Type\n  //.\n  //. Type comprising every \"plain\" Object value. Specifically, values\n  //. created via:\n  //.\n  //.   - object literal syntax;\n  //.   - [`Object.create`][]; or\n  //.   - the `new` operator in conjunction with `Object` or a custom\n  //.     constructor function.\n  var Object_ = NullaryTypeWithUrl('Object', typeEq('Object'));\n\n  //# Pair :: Type -> Type -> Type\n  //.\n  //. Constructor for tuple types of length 2. Arrays are said to represent\n  //. tuples. `['foo', 42]` is a member of `Pair String Number`.\n  var Pair = BinaryTypeWithUrl(\n    'sanctuary-def/Pair',\n    function(x) { return typeEq('Array')(x) && x.length === 2; },\n    function(pair) { return [pair[0]]; },\n    function(pair) { return [pair[1]]; }\n  );\n\n  //# PositiveFiniteNumber :: Type\n  //.\n  //. Type comprising every [`FiniteNumber`][] value greater than zero.\n  var PositiveFiniteNumber = NullaryTypeWithUrl(\n    'sanctuary-def/PositiveFiniteNumber',\n    function(x) { return FiniteNumber._test(x) && x > 0; }\n  );\n\n  //# PositiveInteger :: Type\n  //.\n  //. Type comprising every [`Integer`][] value greater than zero.\n  var PositiveInteger = NullaryTypeWithUrl(\n    'sanctuary-def/PositiveInteger',\n    function(x) { return Integer._test(x) && x > 0; }\n  );\n\n  //# PositiveNumber :: Type\n  //.\n  //. Type comprising every [`Number`][] value greater than zero.\n  var PositiveNumber = NullaryTypeWithUrl(\n    'sanctuary-def/PositiveNumber',\n    function(x) { return Number_._test(x) && x > 0; }\n  );\n\n  //# RegExp :: Type\n  //.\n  //. Type comprising every RegExp value.\n  var RegExp_ = NullaryTypeWithUrl('RegExp', typeEq('RegExp'));\n\n  //# RegexFlags :: Type\n  //.\n  //. Type comprising the canonical RegExp flags:\n  //.\n  //.   - `''`\n  //.   - `'g'`\n  //.   - `'i'`\n  //.   - `'m'`\n  //.   - `'gi'`\n  //.   - `'gm'`\n  //.   - `'im'`\n  //.   - `'gim'`\n  var RegexFlags = EnumTypeWithUrl(\n    'sanctuary-def/RegexFlags',\n    ['', 'g', 'i', 'm', 'gi', 'gm', 'im', 'gim']\n  );\n\n  //# StrMap :: Type -> Type\n  //.\n  //. Constructor for homogeneous Object types.\n  //.\n  //. `{foo: 1, bar: 2, baz: 3}`, for example, is a member of `StrMap Number`;\n  //. `{foo: 1, bar: 2, baz: 'XXX'}` is not.\n  var StrMap = UnaryTypeWithUrl(\n    'sanctuary-def/StrMap',\n    Object_._test,\n    function(strMap) {\n      return Z.reduce(function(xs, x) { return xs.concat([x]); }, [], strMap);\n    }\n  );\n\n  //# String :: Type\n  //.\n  //. Type comprising every primitive String value.\n  var String_ = NullaryTypeWithUrl('String', typeofEq('string'));\n\n  //# Symbol :: Type\n  //.\n  //. Type comprising every Symbol value.\n  var Symbol_ = NullaryTypeWithUrl('Symbol', typeofEq('symbol'));\n\n  //# Type :: Type\n  //.\n  //. Type comprising every `Type` value.\n  var Type = NullaryTypeWithUrl('Type', typeEq('sanctuary-def/Type'));\n\n  //# TypeClass :: Type\n  //.\n  //. Type comprising every [`TypeClass`][] value.\n  var TypeClass =\n  NullaryTypeWithUrl('TypeClass', typeEq('sanctuary-type-classes/TypeClass'));\n\n  //# Undefined :: Type\n  //.\n  //. Type whose sole member is `undefined`.\n  var Undefined = NullaryTypeWithUrl('Undefined', typeEq('Undefined'));\n\n  //# Unknown :: Type\n  //.\n  //. Type used to represent missing type information. The type of `[]`,\n  //. for example, is `Array ???`.\n  //.\n  //. May be used with type constructors when defining environments. Given a\n  //. type constructor `List :: Type -> Type`, one could use `List($.Unknown)`\n  //. to include an infinite number of types in an environment:\n  //.\n  //.   - `List Number`\n  //.   - `List String`\n  //.   - `List (List Number)`\n  //.   - `List (List String)`\n  //.   - `List (List (List Number))`\n  //.   - `List (List (List String))`\n  //.   - `...`\n  var Unknown =\n  new _Type(UNKNOWN, '', '', always2('Unknown'), K(true), [], {});\n\n  //# ValidDate :: Type\n  //.\n  //. Type comprising every [`Date`][] value except `new Date(NaN)`.\n  var ValidDate = NullaryTypeWithUrl(\n    'sanctuary-def/ValidDate',\n    function(x) { return Date_._test(x) && !isNaN(x.valueOf()); }\n  );\n\n  //# ValidNumber :: Type\n  //.\n  //. Type comprising every [`Number`][] value except `NaN`.\n  var ValidNumber = NullaryTypeWithUrl(\n    'sanctuary-def/ValidNumber',\n    function(x) { return Number_._test(x) && !isNaN(x); }\n  );\n\n  //# env :: Array Type\n  //.\n  //. An array of [types][]:\n  //.\n  //.   - <code>[AnyFunction](#AnyFunction)</code>\n  //.   - <code>[Arguments](#Arguments)</code>\n  //.   - <code>[Array](#Array)([Unknown](#Unknown))</code>\n  //.   - <code>[Boolean](#Boolean)</code>\n  //.   - <code>[Date](#Date)</code>\n  //.   - <code>[Error](#Error)</code>\n  //.   - <code>[Null](#Null)</code>\n  //.   - <code>[Number](#Number)</code>\n  //.   - <code>[Object](#Object)</code>\n  //.   - <code>[RegExp](#RegExp)</code>\n  //.   - <code>[StrMap](#StrMap)([Unknown](#Unknown))</code>\n  //.   - <code>[String](#String)</code>\n  //.   - <code>[Symbol](#Symbol)</code>\n  //.   - <code>[Undefined](#Undefined)</code>\n  var env = [\n    AnyFunction,\n    Arguments,\n    Array_(Unknown),\n    Boolean_,\n    Date_,\n    Error_,\n    Null,\n    Number_,\n    Object_,\n    RegExp_,\n    StrMap(Unknown),\n    String_,\n    Symbol_,\n    Undefined\n  ];\n\n  //  Unchecked :: String -> Type\n  function Unchecked(s) { return NullaryType(s, '', K(true)); }\n\n  var def = _create({checkTypes: true, env: env});\n\n  //  arity :: (Number, Function) -> Function\n  function arity(n, f) {\n    return (\n      n === 0 ?\n        function() {\n          return f.apply(this, arguments);\n        } :\n      n === 1 ?\n        function($1) {\n          return f.apply(this, arguments);\n        } :\n      n === 2 ?\n        function($1, $2) {\n          return f.apply(this, arguments);\n        } :\n      n === 3 ?\n        function($1, $2, $3) {\n          return f.apply(this, arguments);\n        } :\n      n === 4 ?\n        function($1, $2, $3, $4) {\n          return f.apply(this, arguments);\n        } :\n      n === 5 ?\n        function($1, $2, $3, $4, $5) {\n          return f.apply(this, arguments);\n        } :\n      n === 6 ?\n        function($1, $2, $3, $4, $5, $6) {\n          return f.apply(this, arguments);\n        } :\n      n === 7 ?\n        function($1, $2, $3, $4, $5, $6, $7) {\n          return f.apply(this, arguments);\n        } :\n      n === 8 ?\n        function($1, $2, $3, $4, $5, $6, $7, $8) {\n          return f.apply(this, arguments);\n        } :\n      // else\n        function($1, $2, $3, $4, $5, $6, $7, $8, $9) {\n          return f.apply(this, arguments);\n        }\n    );\n  }\n\n  //  numArgs :: Number -> String\n  function numArgs(n) {\n    switch (n) {\n      case  0:  return  'zero arguments';\n      case  1:  return   'one argument';\n      case  2:  return   'two arguments';\n      case  3:  return 'three arguments';\n      case  4:  return  'four arguments';\n      case  5:  return  'five arguments';\n      case  6:  return   'six arguments';\n      case  7:  return 'seven arguments';\n      case  8:  return 'eight arguments';\n      case  9:  return  'nine arguments';\n      default:  return  n + ' arguments';\n    }\n  }\n\n  //  expandUnknown :: ... -> Array Type\n  function expandUnknown(\n    env,            // :: Array Type\n    seen,           // :: Array Object\n    value,          // :: Any\n    r               // :: { extractor :: a -> Array b, type :: Type }\n  ) {\n    return r.type.type === UNKNOWN ?\n      _determineActualTypes(env, seen, r.extractor(value)) :\n      [r.type];\n  }\n\n  //  _determineActualTypes :: ... -> Array Type\n  function _determineActualTypes(\n    env,            // :: Array Type\n    seen,           // :: Array Object\n    values          // :: Array Any\n  ) {\n    function refine(types, value) {\n      var seen$;\n      if (typeof value === 'object' && value != null ||\n          typeof value === 'function') {\n        //  Abort if a circular reference is encountered; add the current\n        //  object to the array of seen objects otherwise.\n        if (seen.indexOf(value) >= 0) return [];\n        seen$ = Z.concat(seen, [value]);\n      } else {\n        seen$ = seen;\n      }\n      return Z.chain(function(t) {\n        return (\n          t.name === 'sanctuary-def/Nullable' || t.validate(value).isLeft ?\n            [] :\n          t.type === UNARY ?\n            Z.map(fromUnaryType(t),\n                  expandUnknown(env, seen$, value, t.types.$1)) :\n          t.type === BINARY ?\n            xprod(t,\n                  expandUnknown(env, seen$, value, t.types.$1),\n                  expandUnknown(env, seen$, value, t.types.$2)) :\n          // else\n            [t]\n        );\n      }, types);\n    }\n\n    return isEmpty(values) ?\n      [Unknown] :\n      or(Z.reduce(refine, env, values), [Inconsistent]);\n  }\n\n  //  isConsistent :: Type -> Boolean\n  function isConsistent(t) {\n    return t.type === UNARY   ? isConsistent(t.types.$1.type) :\n           t.type === BINARY  ? isConsistent(t.types.$1.type) &&\n                                isConsistent(t.types.$2.type) :\n           /* else */           t.type !== INCONSISTENT;\n  }\n\n  //  determineActualTypesStrict :: (Array Type, Array Any) -> Array Type\n  function determineActualTypesStrict(env, values) {\n    return _determineActualTypes(env, [], values)\n           .filter(isConsistent);\n  }\n\n  //  determineActualTypesLoose :: (Array Type, Array Any) -> Array Type\n  function determineActualTypesLoose(env, values) {\n    return _determineActualTypes(env, [], values)\n           .filter(function(t) { return t.type !== INCONSISTENT; });\n  }\n\n  //  TypeInfo = { name :: String\n  //             , constraints :: StrMap (Array TypeClass)\n  //             , types :: Array Type }\n  //\n  //  TypeVarMap = StrMap { types :: Array Type\n  //                      , valuesByPath :: StrMap (Array Any) }\n  //\n  //  PropPath = Array (Number | String)\n\n  //  updateTypeVarMap :: ... -> TypeVarMap\n  function updateTypeVarMap(\n    env,            // :: Array Type\n    typeVarMap,     // :: TypeVarMap\n    typeVar,        // :: Type\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    values          // :: Array Any\n  ) {\n    var $typeVarMap = {};\n    for (var typeVarName in typeVarMap) {\n      var entry = typeVarMap[typeVarName];\n      var $entry = {types: entry.types.slice(), valuesByPath: {}};\n      for (var k in entry.valuesByPath) {\n        $entry.valuesByPath[k] = entry.valuesByPath[k].slice();\n      }\n      $typeVarMap[typeVarName] = $entry;\n    }\n    if (!hasOwnProperty.call($typeVarMap, typeVar.name)) {\n      $typeVarMap[typeVar.name] = {types: env.slice(), valuesByPath: {}};\n    }\n\n    var key = JSON.stringify(Z.concat([index], propPath));\n    if (!hasOwnProperty.call($typeVarMap[typeVar.name].valuesByPath, key)) {\n      $typeVarMap[typeVar.name].valuesByPath[key] = [];\n    }\n\n    var isNullaryTypeVar = isEmpty(typeVar.keys);\n\n    values.forEach(function(value) {\n      $typeVarMap[typeVar.name].valuesByPath[key].push(value);\n      $typeVarMap[typeVar.name].types = Z.chain(\n        function(t) {\n          var xs;\n          var invalid = !test(env, t, value);\n          return (\n            invalid ?\n              [] :\n            t.type === UNARY ?\n              isNullaryTypeVar &&\n              t.types.$1.type.type === UNKNOWN &&\n              !isEmpty(xs = t.types.$1.extractor(value)) ?\n                Z.map(fromUnaryType(t),\n                      determineActualTypesStrict(env, xs)) :\n                [t] :\n            t.type === BINARY ?\n              isNullaryTypeVar ?\n                xprod(t,\n                      t.types.$1.type.type === UNKNOWN &&\n                      !isEmpty(xs = t.types.$1.extractor(value)) ?\n                        determineActualTypesStrict(env, xs) :\n                        [t.types.$1.type],\n                      t.types.$2.type.type === UNKNOWN &&\n                      !isEmpty(xs = t.types.$2.extractor(value)) ?\n                        determineActualTypesStrict(env, xs) :\n                        [t.types.$2.type]) :\n                [t] :\n            // else\n              [t]\n          );\n        },\n        $typeVarMap[typeVar.name].types\n      );\n    });\n\n    return $typeVarMap;\n  }\n\n  //  underlineTypeVars :: (TypeInfo, StrMap (Array Any)) -> String\n  function underlineTypeVars(typeInfo, valuesByPath) {\n    //  Note: Sorting these keys lexicographically is not \"correct\", but it\n    //  does the right thing for indexes less than 10.\n    var paths = Z.map(JSON.parse, Object.keys(valuesByPath).sort());\n    return underline(\n      typeInfo,\n      K(K(_)),\n      function(index) {\n        return function(f) {\n          return function(t) {\n            return function(propPath) {\n              var indexedPropPath = Z.concat([index], propPath);\n              return function(s) {\n                if (paths.some(isPrefix(indexedPropPath))) {\n                  var key = JSON.stringify(indexedPropPath);\n                  if (!hasOwnProperty.call(valuesByPath, key)) return s;\n                  if (!isEmpty(valuesByPath[key])) return f(s);\n                }\n                return _(s);\n              };\n            };\n          };\n        };\n      }\n    );\n  }\n\n  //  satisfactoryTypes ::\n  //    ... -> Either (() -> Error) { typeVarMap :: TypeVarMap\n  //                                , types :: Array Type }\n  function satisfactoryTypes(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    typeVarMap,     // :: TypeVarMap\n    expType,        // :: Type\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    values          // :: Array Any\n  ) {\n    var recur = satisfactoryTypes;\n\n    for (var idx = 0; idx < values.length; idx += 1) {\n      var result = expType.validate(values[idx]);\n      if (result.isLeft) {\n        return Left(function() {\n          return invalidValue(env,\n                              typeInfo,\n                              index,\n                              result.value.propPath,\n                              result.value.value);\n        });\n      }\n    }\n\n    switch (expType.type) {\n\n      case VARIABLE:\n        var typeVarName = expType.name;\n        var constraints = typeInfo.constraints;\n        if (hasOwnProperty.call(constraints, typeVarName)) {\n          var typeClasses = constraints[typeVarName];\n          for (idx = 0; idx < values.length; idx += 1) {\n            for (var idx2 = 0; idx2 < typeClasses.length; idx2 += 1) {\n              if (!typeClasses[idx2].test(values[idx])) {\n                return Left(function() {\n                  return typeClassConstraintViolation(\n                    env,\n                    typeInfo,\n                    typeClasses[idx2],\n                    index,\n                    propPath,\n                    values[idx],\n                    typeVarMap\n                  );\n                });\n              }\n            }\n          }\n        }\n\n        var typeVarMap$ = updateTypeVarMap(env,\n                                           typeVarMap,\n                                           expType,\n                                           index,\n                                           propPath,\n                                           values);\n\n        var okTypes = typeVarMap$[typeVarName].types;\n        return isEmpty(okTypes) && !isEmpty(values) ?\n          Left(function() {\n            return typeVarConstraintViolation(\n              env,\n              typeInfo,\n              index,\n              propPath,\n              typeVarMap$[typeVarName].valuesByPath\n            );\n          }) :\n          Z.reduce(function(e, t) {\n            return isEmpty(expType.keys) || isEmpty(t.keys) ?\n              e :\n              Z.chain(function(r) {\n                //  The `a` in `Functor f => f a` corresponds to the `a`\n                //  in `Maybe a` but to the `b` in `Either a b`. A type\n                //  variable's $1 will correspond to either $1 or $2 of\n                //  the actual type depending on the actual type's arity.\n                var offset = t.keys.length - expType.keys.length;\n                return expType.keys.reduce(function(e, k, idx) {\n                  var extractor = t.types[t.keys[offset + idx]].extractor;\n                  var innerValues = Z.chain(extractor, values);\n                  return Z.chain(\n                    function(r) {\n                      return recur(env,\n                                   typeInfo,\n                                   r.typeVarMap,\n                                   expType.types[k].type,\n                                   index,\n                                   Z.concat(propPath, [k]),\n                                   innerValues);\n                    },\n                    Z.reduce(function(e, x) {\n                      var t = expType.types[k].type;\n                      return Z.chain(function(r) {\n                        return test(env, t, x) ? Right(r) : Left(function() {\n                          var propPath$ = Z.concat(propPath, [k]);\n                          return t.type === VARIABLE ?\n                            typeVarConstraintViolation(\n                              env,\n                              typeInfo,\n                              index,\n                              propPath$,\n                              singleton(JSON.stringify(Z.concat([index],\n                                                                propPath$)),\n                                        [x])\n                            ) :\n                            invalidValue(env, typeInfo, index, propPath$, x);\n                        });\n                      }, e);\n                    }, e, innerValues)\n                  );\n                }, Right(r));\n              }, e);\n          }, Right({typeVarMap: typeVarMap$, types: okTypes}), okTypes);\n\n      case UNARY:\n        return Z.map(\n          function(result) {\n            return {\n              typeVarMap: result.typeVarMap,\n              types: Z.map(fromUnaryType(expType),\n                           or(result.types, [expType.types.$1.type]))\n            };\n          },\n          recur(env,\n                typeInfo,\n                typeVarMap,\n                expType.types.$1.type,\n                index,\n                Z.concat(propPath, ['$1']),\n                Z.chain(expType.types.$1.extractor, values))\n        );\n\n      case BINARY:\n        return Z.chain(\n          function(result) {\n            var $1s = result.types;\n            return Z.map(\n              function(result) {\n                var $2s = result.types;\n                return {\n                  typeVarMap: result.typeVarMap,\n                  types: xprod(expType,\n                               or($1s, [expType.types.$1.type]),\n                               or($2s, [expType.types.$2.type]))\n                };\n              },\n              recur(env,\n                    typeInfo,\n                    result.typeVarMap,\n                    expType.types.$2.type,\n                    index,\n                    Z.concat(propPath, ['$2']),\n                    Z.chain(expType.types.$2.extractor, values))\n            );\n          },\n          recur(env,\n                typeInfo,\n                typeVarMap,\n                expType.types.$1.type,\n                index,\n                Z.concat(propPath, ['$1']),\n                Z.chain(expType.types.$1.extractor, values))\n        );\n\n      case RECORD:\n        return Z.reduce(function(e, k) {\n          return Z.chain(function(r) {\n            return recur(env,\n                         typeInfo,\n                         r.typeVarMap,\n                         expType.types[k].type,\n                         index,\n                         Z.concat(propPath, [k]),\n                         Z.chain(expType.types[k].extractor, values));\n          }, e);\n        }, Right({typeVarMap: typeVarMap, types: [expType]}), expType.keys);\n\n      default:\n        return Right({typeVarMap: typeVarMap, types: [expType]});\n    }\n  }\n\n  //# test :: Array Type -> Type -> a -> Boolean\n  //.\n  //. Takes an environment, a type, and any value. Returns `true` if the value\n  //. is a member of the type; `false` otherwise.\n  //.\n  //. The environment is only significant if the type contains\n  //. [type variables][].\n  //.\n  //. One may define a more restrictive type in terms of a more general one:\n  //.\n  //. ```javascript\n  //. //    NonNegativeInteger :: Type\n  //. const NonNegativeInteger = $.NullaryType(\n  //.   'my-package/NonNegativeInteger',\n  //.   'http://example.com/my-package#NonNegativeInteger',\n  //.   x => $.test([], $.Integer, x) && x >= 0\n  //. );\n  //. ```\n  //.\n  //. Using types as predicates is useful in other contexts too. One could,\n  //. for example, define a [record type][] for each endpoint of a REST API\n  //. and validate the bodies of incoming POST requests against these types.\n  function test(env, t, x) {\n    var typeInfo = {name: 'name', constraints: {}, types: [t]};\n    return satisfactoryTypes(env, typeInfo, {}, t, 0, [], [x]).isRight;\n  }\n\n  //. ### Type constructors\n  //.\n  //. sanctuary-def provides several functions for defining types.\n\n  //# NullaryType :: String -> String -> (Any -> Boolean) -> Type\n  //.\n  //. Type constructor for types with no type variables (such as [`Number`][]).\n  //.\n  //. To define a nullary type `t` one must provide:\n  //.\n  //.   - the name of `t` (exposed as `t.name`);\n  //.\n  //.   - the documentation URL of `t` (exposed as `t.url`); and\n  //.\n  //.   - a predicate which accepts any JavaScript value and returns `true` if\n  //.     (and only if) the value is a member of `t`.\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. //    Integer :: Type\n  //. const Integer = $.NullaryType(\n  //.   'my-package/Integer',\n  //.   'http://example.com/my-package#Integer',\n  //.   x => typeof x === 'number' &&\n  //.        Math.floor(x) === x &&\n  //.        x >= Number.MIN_SAFE_INTEGER &&\n  //.        x <= Number.MAX_SAFE_INTEGER\n  //. );\n  //.\n  //. //    NonZeroInteger :: Type\n  //. const NonZeroInteger = $.NullaryType(\n  //.   'my-package/NonZeroInteger',\n  //.   'http://example.com/my-package#NonZeroInteger',\n  //.   x => $.test([], Integer, x) && x !== 0\n  //. );\n  //.\n  //. //    rem :: Integer -> NonZeroInteger -> Integer\n  //. const rem =\n  //. def('rem', {}, [Integer, NonZeroInteger, Integer], (x, y) => x % y);\n  //.\n  //. rem(42, 5);\n  //. // => 2\n  //.\n  //. rem(0.5);\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   rem :: Integer -> NonZeroInteger -> Integer\n  //. //          ^^^^^^^\n  //. //             1\n  //. //\n  //. //   1)  0.5 :: Number\n  //. //\n  //. //   The value at position 1 is not a member of Integer.\n  //.\n  //. rem(42, 0);\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   rem :: Integer -> NonZeroInteger -> Integer\n  //. //                     ^^^^^^^^^^^^^^\n  //. //                           1\n  //. //\n  //. //   1)  0 :: Number\n  //. //\n  //. //   The value at position 1 is not a member of NonZeroInteger.\n  //. ```\n  function NullaryType(name, url, test) {\n    function format(outer, inner) {\n      return outer(stripNamespace(name));\n    }\n    return new _Type(NULLARY, name, url, format, test, [], {});\n  }\n\n  var CheckedNullaryType =\n  def('NullaryType',\n      {},\n      [String_, String_, Function_([Any, Boolean_]), Type],\n      NullaryType);\n\n  //# UnaryType :: String -> String -> (Any -> Boolean) -> (t a -> Array a) -> (Type -> Type)\n  //.\n  //. Type constructor for types with one type variable (such as [`Array`][]).\n  //.\n  //. To define a unary type `t a` one must provide:\n  //.\n  //.   - the name of `t` (exposed as `t.name`);\n  //.\n  //.   - the documentation URL of `t` (exposed as `t.url`);\n  //.\n  //.   - a predicate which accepts any JavaScript value and returns `true`\n  //.     if (and only if) the value is a member of `t x` for some type `x`;\n  //.\n  //.   - a function which takes any value of type `t a` and returns an array\n  //.     of the values of type `a` contained in the `t` (exposed as\n  //.     `t.types.$1.extractor`); and\n  //.\n  //.   - the type of `a` (exposed as `t.types.$1.type`).\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. const type = require('sanctuary-type-identifiers');\n  //.\n  //. //    maybeTypeIdent :: String\n  //. const maybeTypeIdent = 'my-package/Maybe';\n  //.\n  //. //    Maybe :: Type -> Type\n  //. const Maybe = $.UnaryType(\n  //.   maybeTypeIdent,\n  //.   'http://example.com/my-package#Maybe',\n  //.   x => type(x) === maybeTypeIdent,\n  //.   maybe => maybe.isJust ? [maybe.value] : []\n  //. );\n  //.\n  //. //    MaybeTypeRep :: TypeRep Maybe\n  //. const MaybeTypeRep = {'@@type': maybeTypeIdent};\n  //.\n  //. //    Nothing :: Maybe a\n  //. const Nothing = {\n  //.   constructor: MaybeTypeRep,\n  //.   isJust: false,\n  //.   isNothing: true,\n  //.   toString: () => 'Nothing',\n  //. };\n  //.\n  //. //    Just :: a -> Maybe a\n  //. const Just = x => ({\n  //.   constructor: MaybeTypeRep,\n  //.   isJust: true,\n  //.   isNothing: false,\n  //.   toString: () => 'Just(' + Z.toString(x) + ')',\n  //.   value: x,\n  //. });\n  //.\n  //. //    fromMaybe :: a -> Maybe a -> a\n  //. const fromMaybe =\n  //. def('fromMaybe', {}, [a, Maybe(a), a], (x, m) => m.isJust ? m.value : x);\n  //.\n  //. fromMaybe(0, Just(42));\n  //. // => 42\n  //.\n  //. fromMaybe(0, Nothing);\n  //. // => 0\n  //.\n  //. fromMaybe(0, Just('XXX'));\n  //. // ! TypeError: Type-variable constraint violation\n  //. //\n  //. //   fromMaybe :: a -> Maybe a -> a\n  //. //                ^          ^\n  //. //                1          2\n  //. //\n  //. //   1)  0 :: Number\n  //. //\n  //. //   2)  \"XXX\" :: String\n  //. //\n  //. //   Since there is no type of which all the above values are members, the type-variable constraint has been violated.\n  //. ```\n  function UnaryType(name, url, test, _1) {\n    return function($1) {\n      function format(outer, inner) {\n        return outer('(' + stripNamespace(name) + ' ') +\n               inner('$1')(String($1)) + outer(')');\n      }\n      var types = {$1: {extractor: _1, type: $1}};\n      return new _Type(UNARY, name, url, format, test, ['$1'], types);\n    };\n  }\n\n  var CheckedUnaryType =\n  def('UnaryType',\n      {},\n      [String_,\n       String_,\n       Function_([Any, Boolean_]),\n       Function_([Unchecked('t a'), Array_(Unchecked('a'))]),\n       AnyFunction],\n      function(name, url, test, _1) {\n        return def(stripNamespace(name),\n                   {},\n                   [Type, Type],\n                   UnaryType(name, url, test, _1));\n      });\n\n  //  fromUnaryType :: Type -> (Type -> Type)\n  function fromUnaryType(t) {\n    return UnaryType(t.name, t.url, t._test, t.types.$1.extractor);\n  }\n\n  //# BinaryType :: String -> String -> (Any -> Boolean) -> (t a b -> Array a) -> (t a b -> Array b) -> (Type -> Type -> Type)\n  //.\n  //. Type constructor for types with two type variables (such as [`Pair`][]).\n  //.\n  //. To define a binary type `t a b` one must provide:\n  //.\n  //.   - the name of `t` (exposed as `t.name`);\n  //.\n  //.   - the documentation URL of `t` (exposed as `t.url`);\n  //.\n  //.   - a predicate which accepts any JavaScript value and returns `true`\n  //.     if (and only if) the value is a member of `t x y` for some types\n  //.     `x` and `y`;\n  //.\n  //.   - a function which takes any value of type `t a b` and returns an array\n  //.     of the values of type `a` contained in the `t` (exposed as\n  //.     `t.types.$1.extractor`);\n  //.\n  //.   - a function which takes any value of type `t a b` and returns an array\n  //.     of the values of type `b` contained in the `t` (exposed as\n  //.     `t.types.$2.extractor`);\n  //.\n  //.   - the type of `a` (exposed as `t.types.$1.type`); and\n  //.\n  //.   - the type of `b` (exposed as `t.types.$2.type`).\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. const type = require('sanctuary-type-identifiers');\n  //.\n  //. //    pairTypeIdent :: String\n  //. const pairTypeIdent = 'my-package/Pair';\n  //.\n  //. //    $Pair :: Type -> Type -> Type\n  //. const $Pair = $.BinaryType(\n  //.   pairTypeIdent,\n  //.   'http://example.com/my-package#Pair',\n  //.   x => type(x) === pairTypeIdent,\n  //.   pair => [pair[0]],\n  //.   pair => [pair[1]]\n  //. );\n  //.\n  //. //    PairTypeRep :: TypeRep Pair\n  //. const PairTypeRep = {'@@type': pairTypeIdent};\n  //.\n  //. //    Pair :: a -> b -> Pair a b\n  //. const Pair = def('Pair', {}, [a, b, $Pair(a, b)], (x, y) => ({\n  //.   '0': x,\n  //.   '1': y,\n  //.   constructor: PairTypeRep,\n  //.   length: 2,\n  //.   toString: () => 'Pair(' + Z.toString(x) + ', ' + Z.toString(y) + ')',\n  //. }));\n  //.\n  //. //    Rank :: Type\n  //. const Rank = $.NullaryType(\n  //.   'my-package/Rank',\n  //.   'http://example.com/my-package#Rank',\n  //.   x => typeof x === 'string' && /^([A23456789JQK]|10)$/.test(x)\n  //. );\n  //.\n  //. //    Suit :: Type\n  //. const Suit = $.NullaryType(\n  //.   'my-package/Suit',\n  //.   'http://example.com/my-package#Suit',\n  //.   x => typeof x === 'string' && /^[\\u2660\\u2663\\u2665\\u2666]$/.test(x)\n  //. );\n  //.\n  //. //    Card :: Type\n  //. const Card = $Pair(Rank, Suit);\n  //.\n  //. //    showCard :: Card -> String\n  //. const showCard =\n  //. def('showCard', {}, [Card, $.String], card => card[0] + card[1]);\n  //.\n  //. showCard(Pair('A', ''));\n  //. // => 'A'\n  //.\n  //. showCard(Pair('X', ''));\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   showCard :: Pair Rank Suit -> String\n  //. //                    ^^^^\n  //. //                     1\n  //. //\n  //. //   1)  \"X\" :: String\n  //. //\n  //. //   The value at position 1 is not a member of Rank.\n  //. ```\n  function BinaryType(name, url, test, _1, _2) {\n    return function($1, $2) {\n      function format(outer, inner) {\n        return outer('(' + stripNamespace(name) + ' ') +\n               inner('$1')(String($1)) + outer(' ') +\n               inner('$2')(String($2)) + outer(')');\n      }\n      var types = {$1: {extractor: _1, type: $1},\n                   $2: {extractor: _2, type: $2}};\n      return new _Type(BINARY, name, url, format, test, ['$1', '$2'], types);\n    };\n  }\n\n  var CheckedBinaryType =\n  def('BinaryType',\n      {},\n      [String_,\n       String_,\n       Function_([Any, Boolean_]),\n       Function_([Unchecked('t a b'), Array_(Unchecked('a'))]),\n       Function_([Unchecked('t a b'), Array_(Unchecked('b'))]),\n       AnyFunction],\n      function(name, url, test, _1, _2) {\n        return def(stripNamespace(name),\n                   {},\n                   [Type, Type, Type],\n                   BinaryType(name, url, test, _1, _2));\n      });\n\n  //  xprod :: (Type, Array Type, Array Type) -> Array Type\n  function xprod(t, $1s, $2s) {\n    var specialize = BinaryType(t.name,\n                                t.url,\n                                t._test,\n                                t.types.$1.extractor,\n                                t.types.$2.extractor);\n    var $types = [];\n    $1s.forEach(function($1) {\n      $2s.forEach(function($2) {\n        $types.push(specialize($1, $2));\n      });\n    });\n    return $types;\n  }\n\n  //# EnumType :: String -> String -> Array Any -> Type\n  //.\n  //. Type constructor for [enumerated types][] (such as [`RegexFlags`][]).\n  //.\n  //. To define an enumerated type `t` one must provide:\n  //.\n  //.   - the name of `t` (exposed as `t.name`);\n  //.\n  //.   - the documentation URL of `t` (exposed as `t.url`); and\n  //.\n  //.   - an array of distinct values.\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. //    Denomination :: Type\n  //. const Denomination = $.EnumType(\n  //.   'my-package/Denomination',\n  //.   'http://example.com/my-package#Denomination',\n  //.   [10, 20, 50, 100, 200]\n  //. );\n  //. ```\n  function EnumType(name, url, members) {\n    return NullaryType(name, url, memberOf(members));\n  }\n\n  var CheckedEnumType =\n  def('EnumType', {}, [String_, String_, Array_(Any), Type], EnumType);\n\n  //# RecordType :: StrMap Type -> Type\n  //.\n  //. `RecordType` is used to construct record types. The type definition\n  //. specifies the name and type of each required field.\n  //.\n  //. To define a record type one must provide:\n  //.\n  //.   - an object mapping field name to type.\n  //.\n  //. For example:\n  //.\n  //. ```javascript\n  //. //    Point :: Type\n  //. const Point = $.RecordType({x: $.FiniteNumber, y: $.FiniteNumber});\n  //.\n  //. //    dist :: Point -> Point -> FiniteNumber\n  //. const dist =\n  //. def('dist', {}, [Point, Point, $.FiniteNumber],\n  //.     (p, q) => Math.sqrt(Math.pow(p.x - q.x, 2) +\n  //.                         Math.pow(p.y - q.y, 2)));\n  //.\n  //. dist({x: 0, y: 0}, {x: 3, y: 4});\n  //. // => 5\n  //.\n  //. dist({x: 0, y: 0}, {x: 3, y: 4, color: 'red'});\n  //. // => 5\n  //.\n  //. dist({x: 0, y: 0}, {x: NaN, y: NaN});\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   dist :: { x :: FiniteNumber, y :: FiniteNumber } -> { x :: FiniteNumber, y :: FiniteNumber } -> FiniteNumber\n  //. //                                                              ^^^^^^^^^^^^\n  //. //                                                                   1\n  //. //\n  //. //   1)  NaN :: Number\n  //. //\n  //. //   The value at position 1 is not a member of FiniteNumber.\n  //.\n  //. dist(0);\n  //. // ! TypeError: Invalid value\n  //. //\n  //. //   dist :: { x :: FiniteNumber, y :: FiniteNumber } -> { x :: FiniteNumber, y :: FiniteNumber } -> FiniteNumber\n  //. //           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  //. //                              1\n  //. //\n  //. //   1)  0 :: Number\n  //. //\n  //. //   The value at position 1 is not a member of { x :: FiniteNumber, y :: FiniteNumber }.\n  //. ```\n  function RecordType(fields) {\n    var keys = Object.keys(fields).sort();\n\n    function format(outer, inner) {\n      return wrap(outer('{'))(outer(' }'))(Z.map(function(k) {\n        var t = fields[k];\n        return outer(' ' + k + ' :: ') +\n               unless(t.type === RECORD || isEmpty(t.keys),\n                      stripOutermostParens,\n                      inner(k)(String(t)));\n      }, keys).join(outer(',')));\n    }\n\n    function test(x) {\n      return x != null &&\n             keys.every(function(k) { return hasOwnProperty.call(x, k); });\n    }\n\n    var $types = {};\n    keys.forEach(function(k) {\n      $types[k] = {extractor: function(x) { return [x[k]]; }, type: fields[k]};\n    });\n\n    return new _Type(RECORD, '', '', format, test, keys, $types);\n  }\n\n  var CheckedRecordType =\n  def('RecordType', {}, [StrMap(Type), Type], RecordType);\n\n  //# TypeVariable :: String -> Type\n  //.\n  //. Polymorphism is powerful. Not being able to define a function for\n  //. all types would be very limiting indeed: one couldn't even define the\n  //. identity function!\n  //.\n  //. Before defining a polymorphic function one must define one or more type\n  //. variables:\n  //.\n  //. ```javascript\n  //. const a = $.TypeVariable('a');\n  //. const b = $.TypeVariable('b');\n  //.\n  //. //    id :: a -> a\n  //. const id = def('id', {}, [a, a], x => x);\n  //.\n  //. id(42);\n  //. // => 42\n  //.\n  //. id(null);\n  //. // => null\n  //. ```\n  //.\n  //. The same type variable may be used in multiple positions, creating a\n  //. constraint:\n  //.\n  //. ```javascript\n  //. //    cmp :: a -> a -> Number\n  //. const cmp =\n  //. def('cmp', {}, [a, a, $.Number], (x, y) => x < y ? -1 : x > y ? 1 : 0);\n  //.\n  //. cmp(42, 42);\n  //. // => 0\n  //.\n  //. cmp('a', 'z');\n  //. // => -1\n  //.\n  //. cmp('z', 'a');\n  //. // => 1\n  //.\n  //. cmp(0, '1');\n  //. // ! TypeError: Type-variable constraint violation\n  //. //\n  //. //   cmp :: a -> a -> Number\n  //. //          ^    ^\n  //. //          1    2\n  //. //\n  //. //   1)  0 :: Number\n  //. //\n  //. //   2)  \"1\" :: String\n  //. //\n  //. //   Since there is no type of which all the above values are members, the type-variable constraint has been violated.\n  //. ```\n  function TypeVariable(name) {\n    return new _Type(VARIABLE, name, '', always2(name), K(true), [], {});\n  }\n\n  var CheckedTypeVariable =\n  def('TypeVariable', {}, [String_, Type], TypeVariable);\n\n  //# UnaryTypeVariable :: String -> (Type -> Type)\n  //.\n  //. Combines [`UnaryType`][] and [`TypeVariable`][].\n  //.\n  //. To define a unary type variable `t a` one must provide:\n  //.\n  //.   - a name (conventionally matching `^[a-z]$`); and\n  //.\n  //.   - the type of `a` (exposed as `t.types.$1.type`).\n  //.\n  //. Consider the type of a generalized `map`:\n  //.\n  //. ```haskell\n  //. map :: Functor f => (a -> b) -> f a -> f b\n  //. ```\n  //.\n  //. `f` is a unary type variable. With two (nullary) type variables, one\n  //. unary type variable, and one [type class][] it's possible to define a\n  //. fully polymorphic `map` function:\n  //.\n  //. ```javascript\n  //. const $ = require('sanctuary-def');\n  //. const Z = require('sanctuary-type-classes');\n  //.\n  //. const a = $.TypeVariable('a');\n  //. const b = $.TypeVariable('b');\n  //. const f = $.UnaryTypeVariable('f');\n  //.\n  //. //    map :: Functor f => (a -> b) -> f a -> f b\n  //. const map =\n  //. def('map',\n  //.     {f: [Z.Functor]},\n  //.     [$.Function([a, b]), f(a), f(b)],\n  //.     Z.map);\n  //. ```\n  //.\n  //. Whereas a regular type variable is fully resolved (`a` might become\n  //. `Array (Array String)`, for example), a unary type variable defers to\n  //. its type argument, which may itself be a type variable. The type argument\n  //. corresponds to the type argument of a unary type or the *second* type\n  //. argument of a binary type. The second type argument of `Map k v`, for\n  //. example, is `v`. One could replace `Functor => f` with `Map k` or with\n  //. `Map Integer`, but not with `Map`.\n  //.\n  //. This shallow inspection makes it possible to constrain a value's \"outer\"\n  //. and \"inner\" types independently.\n  function UnaryTypeVariable(name) {\n    return function($1) {\n      function format(outer, inner) {\n        return outer('(' + name + ' ') + inner('$1')(String($1)) + outer(')');\n      }\n      var types = {$1: {extractor: K([]), type: $1}};\n      return new _Type(VARIABLE, name, '', format, K(true), ['$1'], types);\n    };\n  }\n\n  var CheckedUnaryTypeVariable =\n  def('UnaryTypeVariable',\n      {},\n      [String_, AnyFunction],\n      function(name) {\n        return def(name, {}, [Type, Type], UnaryTypeVariable(name));\n      });\n\n  //# BinaryTypeVariable :: String -> (Type -> Type -> Type)\n  //.\n  //. Combines [`BinaryType`][] and [`TypeVariable`][].\n  //.\n  //. To define a binary type variable `t a b` one must provide:\n  //.\n  //.   - a name (conventionally matching `^[a-z]$`);\n  //.\n  //.   - the type of `a` (exposed as `t.types.$1.type`); and\n  //.\n  //.   - the type of `b` (exposed as `t.types.$2.type`).\n  //.\n  //. The more detailed explanation of [`UnaryTypeVariable`][] also applies to\n  //. `BinaryTypeVariable`.\n  function BinaryTypeVariable(name) {\n    return function($1, $2) {\n      function format(outer, inner) {\n        return outer('(' + name + ' ') + inner('$1')(String($1)) + outer(' ') +\n                                         inner('$2')(String($2)) + outer(')');\n      }\n      var keys = ['$1', '$2'];\n      var types = {$1: {extractor: K([]), type: $1},\n                   $2: {extractor: K([]), type: $2}};\n      return new _Type(VARIABLE, name, '', format, K(true), keys, types);\n    };\n  }\n\n  var CheckedBinaryTypeVariable =\n  def('BinaryTypeVariable',\n      {},\n      [String_, AnyFunction],\n      function(name) {\n        return def(name, {}, [Type, Type, Type], BinaryTypeVariable(name));\n      });\n\n  //# Thunk :: Type -> Type\n  //.\n  //. `$.Thunk(T)` is shorthand for `$.Function([T])`, the type comprising\n  //. every nullary function (thunk) which returns a value of type `T`.\n  var Thunk =\n  def('Thunk',\n      {},\n      [Type, Type],\n      function(t) { return Function_([t]); });\n\n  //# Predicate :: Type -> Type\n  //.\n  //. `$.Predicate(T)` is shorthand for `$.Function([T, $.Boolean])`, the type\n  //. comprising every predicate function which takes a value of type `T`.\n  var Predicate =\n  def('Predicate',\n      {},\n      [Type, Type],\n      function(t) { return Function_([t, Boolean_]); });\n\n  //. ### Type classes\n  //.\n  //. `concatS`, defined earlier, is a function which concatenates two strings.\n  //. This is overly restrictive, since other types support concatenation\n  //. (Array, for example).\n  //.\n  //. One could use a type variable to define a polymorphic \"concat\" function:\n  //.\n  //. ```javascript\n  //. //    _concat :: a -> a -> a\n  //. const _concat =\n  //. def('_concat', {}, [a, a, a], (x, y) => x.concat(y));\n  //.\n  //. _concat('fizz', 'buzz');\n  //. // => 'fizzbuzz'\n  //.\n  //. _concat([1, 2], [3, 4]);\n  //. // => [1, 2, 3, 4]\n  //.\n  //. _concat([1, 2], 'buzz');\n  //. // ! TypeError: Type-variable constraint violation\n  //. //\n  //. //   _concat :: a -> a -> a\n  //. //              ^    ^\n  //. //              1    2\n  //. //\n  //. //   1)  [1, 2] :: Array Number\n  //. //\n  //. //   2)  \"buzz\" :: String\n  //. //\n  //. //   Since there is no type of which all the above values are members, the type-variable constraint has been violated.\n  //. ```\n  //.\n  //. The type of `_concat` is misleading: it suggests that it can operate on\n  //. any two values of *any* one type. In fact there's an implicit constraint,\n  //. since the type must support concatenation (in [mathematical][semigroup]\n  //. terms, the type must have a [semigroup][FL:Semigroup]). The run-time type\n  //. errors that result when this constraint is violated are not particularly\n  //. descriptive:\n  //.\n  //. ```javascript\n  //. _concat({}, {});\n  //. // ! TypeError: undefined is not a function\n  //.\n  //. _concat(null, null);\n  //. // ! TypeError: Cannot read property 'concat' of null\n  //. ```\n  //.\n  //. The solution is to constrain `a` by first defining a [`TypeClass`][]\n  //. value, then specifying the constraint in the definition of the \"concat\"\n  //. function:\n  //.\n  //. ```javascript\n  //. const Z = require('sanctuary-type-classes');\n  //.\n  //. //    Semigroup :: TypeClass\n  //. const Semigroup = Z.TypeClass(\n  //.   'my-package/Semigroup',\n  //.   'http://example.com/my-package#Semigroup',\n  //.   [],\n  //.   x => x != null && typeof x.concat === 'function'\n  //. );\n  //.\n  //. //    concat :: Semigroup a => a -> a -> a\n  //. const concat =\n  //. def('concat', {a: [Semigroup]}, [a, a, a], (x, y) => x.concat(y));\n  //.\n  //. concat([1, 2], [3, 4]);\n  //. // => [1, 2, 3, 4]\n  //.\n  //. concat({}, {});\n  //. // ! TypeError: Type-class constraint violation\n  //. //\n  //. //   concat :: Semigroup a => a -> a -> a\n  //. //             ^^^^^^^^^^^    ^\n  //. //                            1\n  //. //\n  //. //   1)  {} :: Object, StrMap ???\n  //. //\n  //. //   concat requires a to satisfy the Semigroup type-class constraint; the value at position 1 does not.\n  //. //\n  //. //   See http://example.com/my-package#Semigroup for information about the my-package/Semigroup type class.\n  //.\n  //. concat(null, null);\n  //. // ! TypeError: Type-class constraint violation\n  //. //\n  //. //   concat :: Semigroup a => a -> a -> a\n  //. //             ^^^^^^^^^^^    ^\n  //. //                            1\n  //. //\n  //. //   1)  null :: Null\n  //. //\n  //. //   concat requires a to satisfy the Semigroup type-class constraint; the value at position 1 does not.\n  //. //\n  //. //   See http://example.com/my-package#Semigroup for information about the my-package/Semigroup type class.\n  //. ```\n  //.\n  //. Multiple constraints may be placed on a type variable by including\n  //. multiple `TypeClass` values in the array (e.g. `{a: [Foo, Bar, Baz]}`).\n\n  //  checkValue :: ... -> Undefined\n  function checkValue(\n    env,                // :: Array Type\n    typeInfo,           // :: TypeInfo\n    $typeVarMapBox,     // :: Box TypeVarMap\n    index,              // :: Integer\n    propPath,           // :: PropPath\n    t,                  // :: Type\n    value               // :: Any\n  ) {\n    if (t.type === VARIABLE) {\n      $typeVarMapBox[0] =\n        updateTypeVarMap(env, $typeVarMapBox[0], t, index, propPath, [value]);\n      if (isEmpty($typeVarMapBox[0][t.name].types)) {\n        throw typeVarConstraintViolation(\n          env,\n          typeInfo,\n          index,\n          propPath,\n          $typeVarMapBox[0][t.name].valuesByPath\n        );\n      }\n    } else if (!test(env, t, value)) {\n      throw invalidValue(env, typeInfo, index, propPath, value);\n    }\n  }\n\n  //  wrapFunction :: ... -> Function\n  function wrapFunction(\n    env,                // :: Array Type\n    typeInfo,           // :: TypeInfo\n    $typeVarMapBox,     // :: Box TypeVarMap\n    index,              // :: Integer\n    f                   // :: Function\n  ) {\n    var expType = typeInfo.types[index];\n    var numArgsExpected = expType.keys.length - 1;\n    return arity(numArgsExpected, function() {\n      var args = slice.call(arguments);\n      if (args.length !== numArgsExpected) {\n        throw invalidArgumentsLength(typeInfo, index, numArgsExpected, args);\n      }\n      function checkValue$(propPath, t, x) {\n        checkValue(env, typeInfo, $typeVarMapBox, index, propPath, t, x);\n      }\n      init(expType.keys).forEach(function(k, idx) {\n        checkValue$([k], expType.types[k].type, args[idx]);\n      });\n\n      var output = f.apply(this, arguments);\n      var k = last(expType.keys);\n      checkValue$([k], expType.types[k].type, output);\n      return output;\n    });\n  }\n\n  //  wrapFunctionCond ::\n  //    Array Type -> TypeInfo -> Box TypeVarMap -> Integer -> a -> a\n  function wrapFunctionCond(env, typeInfo, $typeVarMapBox, index, value) {\n    return typeInfo.types[index].type === FUNCTION ?\n      wrapFunction(env, typeInfo, $typeVarMapBox, index, value) :\n      value;\n  }\n\n  //  wrapFunctions :: ... -> Array Any\n  function wrapFunctions(\n    env,                // :: Array Type\n    typeInfo,           // :: TypeInfo\n    $typeVarMapBox,     // :: Box TypeVarMap\n    values              // :: Array Any\n  ) {\n    return values.map(function(value, idx) {\n      return wrapFunctionCond(env, typeInfo, $typeVarMapBox, idx, value);\n    });\n  }\n\n  //  tooManyArguments :: (TypeInfo, Integer) -> Error\n  //\n  //  This function is used in `curry` when a function defined via `def`\n  //  is applied to too many arguments.\n  function tooManyArguments(typeInfo, numArgsReceived) {\n    var numArgsExpected = typeInfo.types.length - 1;\n    return new TypeError(trimTrailingSpaces(\n      'Function applied to too many arguments\\n\\n' +\n      typeSignature(typeInfo) + '\\n\\n' +\n      q(typeInfo.name) + ' expected' +\n      (numArgsExpected > 0 ? ' at most ' : ' ') + numArgs(numArgsExpected) +\n      ' but received ' + numArgs(numArgsReceived) + '.\\n'\n    ));\n  }\n\n  //  constraintsRepr :: ... -> String\n  function constraintsRepr(\n    constraints,    // :: StrMap (Array TypeClass)\n    outer,          // :: String -> String\n    inner           // :: String -> TypeClass -> String -> String\n  ) {\n    var $reprs = [];\n    Object.keys(constraints).sort().forEach(function(k) {\n      var f = inner(k);\n      constraints[k].forEach(function(typeClass) {\n        $reprs.push(f(typeClass)(stripNamespace(typeClass.name) + ' ' + k));\n      });\n    });\n    return when($reprs.length > 0,\n                function(s) { return s + outer(' => '); },\n                when($reprs.length > 1,\n                     wrap(outer('('))(outer(')')),\n                     $reprs.join(outer(', '))));\n  }\n\n  //  label :: String -> String -> String\n  function label(label) {\n    return function(s) {\n      var delta = s.length - label.length;\n      return strRepeat(' ', Math.floor(delta / 2)) + label +\n             strRepeat(' ', Math.ceil(delta / 2));\n    };\n  }\n\n  //  typeVarNames :: Type -> Array String\n  function typeVarNames(t) {\n    return Z.concat(\n      t.type === VARIABLE ? [t.name] : [],\n      Z.chain(function(k) { return typeVarNames(t.types[k].type); }, t.keys)\n    );\n  }\n\n  //  showTypeWith :: TypeInfo -> Type -> String\n  function showTypeWith(typeInfo) {\n    var names = Z.chain(typeVarNames, typeInfo.types);\n    return function(t) {\n      var code = 'a'.charCodeAt(0);\n      return unless(\n        t.type === FUNCTION || t.type === RECORD || isEmpty(t.keys),\n        stripOutermostParens,\n        String(t).replace(/\\bUnknown\\b/g, function() {\n          // eslint-disable-next-line no-plusplus\n          do var name = String.fromCharCode(code++);\n          while (names.indexOf(name) >= 0);\n          return name;\n        })\n      );\n    };\n  }\n\n  //  showTypeQuoted :: Type -> String\n  function showTypeQuoted(t) {\n    return q(unless(t.type === RECORD || isEmpty(t.keys),\n                    stripOutermostParens,\n                    String(t)));\n  }\n\n  //  showValuesAndTypes :: ... -> String\n  function showValuesAndTypes(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    values,         // :: Array Any\n    pos             // :: Integer\n  ) {\n    var showType = showTypeWith(typeInfo);\n    return String(pos) + ')  ' + Z.map(function(x) {\n      var types = determineActualTypesLoose(env, [x]);\n      return Z.toString(x) + ' :: ' + Z.map(showType, types).join(', ');\n    }, values).join('\\n    ');\n  }\n\n  //  typeSignature :: TypeInfo -> String\n  function typeSignature(typeInfo) {\n    var reprs = Z.map(showTypeWith(typeInfo), typeInfo.types);\n    var arity = reprs.length - 1;\n    return typeInfo.name + ' :: ' +\n             constraintsRepr(typeInfo.constraints, id, K(K(id))) +\n             when(arity === 0, parenthesize, init(reprs).join(' -> ')) +\n             ' -> ' + last(reprs);\n  }\n\n  //  _underline :: ... -> String\n  function _underline(\n    t,              // :: Type\n    propPath,       // :: PropPath\n    formatType3     // :: Type -> Array String -> String -> String\n  ) {\n    return unless(t.type === RECORD ||\n                    isEmpty(t.keys) ||\n                    t.type === FUNCTION && isEmpty(propPath) ||\n                    !isEmpty(propPath),\n                  stripOutermostParens,\n                  formatType3(t)(propPath)(t.format(_, function(k) {\n                    return K(_underline(t.types[k].type,\n                                        Z.concat(propPath, [k]),\n                                        formatType3));\n                  })));\n  }\n\n  //  underline :: ... -> String\n  function underline(\n    typeInfo,               // :: TypeInfo\n    underlineConstraint,    // :: String -> TypeClass -> String -> String\n    formatType5\n    // :: Integer -> (String -> String) -> Type -> PropPath -> String -> String\n  ) {\n    var st = typeInfo.types.reduce(function(st, t, index) {\n      var formatType4 = formatType5(index);\n      var counter = st.counter;\n      function replace(s) { return label(String(counter += 1))(s); }\n      return {\n        carets: Z.concat(st.carets, [_underline(t, [], formatType4(r('^')))]),\n        numbers: Z.concat(st.numbers,\n                          [_underline(t, [], formatType4(replace))]),\n        counter: counter\n      };\n    }, {carets: [], numbers: [], counter: 0});\n\n    return typeSignature(typeInfo) + '\\n' +\n           _(typeInfo.name + ' :: ') +\n             constraintsRepr(typeInfo.constraints, _, underlineConstraint) +\n             st.carets.join(_(' -> ')) + '\\n' +\n           _(typeInfo.name + ' :: ') +\n             constraintsRepr(typeInfo.constraints, _, K(K(_))) +\n             st.numbers.join(_(' -> ')) + '\\n';\n  }\n\n  //  resolvePropPath :: (Type, Array String) -> Type\n  function resolvePropPath(t, propPath) {\n    return Z.reduce(function(t, prop) { return t.types[prop].type; },\n                    t,\n                    propPath);\n  }\n\n  //  formatType6 ::\n  //    PropPath -> Integer -> (String -> String) ->\n  //      Type -> PropPath -> String -> String\n  function formatType6(indexedPropPath) {\n    return function(index_) {\n      return function(f) {\n        return function(t) {\n          return function(propPath_) {\n            var indexedPropPath_ = Z.concat([index_], propPath_);\n            var p = isPrefix(indexedPropPath_)(indexedPropPath);\n            var q = isPrefix(indexedPropPath)(indexedPropPath_);\n            return p && q ? f : p ? id : _;\n          };\n        };\n      };\n    };\n  }\n\n  //  see :: (String, { name :: String, url :: String? }) -> String\n  function see(label, record) {\n    return record.url == null || record.url === '' ?\n           '' :\n           '\\nSee ' + record.url +\n           ' for information about the ' + record.name + ' ' + label + '.\\n';\n  }\n\n  //  typeClassConstraintViolation :: ... -> Error\n  function typeClassConstraintViolation(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    typeClass,      // :: TypeClass\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    value,          // :: Any\n    typeVarMap      // :: TypeVarMap\n  ) {\n    var expType = resolvePropPath(typeInfo.types[index], propPath);\n    return new TypeError(trimTrailingSpaces(\n      'Type-class constraint violation\\n\\n' +\n      underline(typeInfo,\n                function(tvn) {\n                  return function(tc) {\n                    return tvn === expType.name && tc.name === typeClass.name ?\n                      r('^') :\n                      _;\n                  };\n                },\n                formatType6(Z.concat([index], propPath))) +\n      '\\n' +\n      showValuesAndTypes(env, typeInfo, [value], 1) + '\\n\\n' +\n      q(typeInfo.name) + ' requires ' + q(expType.name) + ' to satisfy the ' +\n      stripNamespace(typeClass.name) + ' type-class constraint; ' +\n      'the value at position 1 does not.\\n' +\n      see('type class', typeClass)\n    ));\n  }\n\n  //  typeVarConstraintViolation :: ... -> Error\n  function typeVarConstraintViolation(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    valuesByPath    // :: StrMap (Array Any)\n  ) {\n    //  If we apply an a -> a -> a -> a function to Left('x'), Right(1), and\n    //  Right(null) we'd like to avoid underlining the first argument position,\n    //  since Left('x') is compatible with the other a values.\n    var key = JSON.stringify(Z.concat([index], propPath));\n    var values = valuesByPath[key];\n\n    //  Note: Sorting these keys lexicographically is not \"correct\", but it\n    //  does the right thing for indexes less than 10.\n    var keys = Object.keys(valuesByPath).sort().filter(function(k) {\n      var values_ = valuesByPath[k];\n      return (\n        //  Keep X, the position at which the violation was observed.\n        k === key ||\n        //  Keep positions whose values are incompatible with the values at X.\n        isEmpty(determineActualTypesStrict(env, Z.concat(values, values_)))\n      );\n    });\n\n    var underlinedTypeVars =\n    underlineTypeVars(typeInfo,\n                      Z.reduce(function($valuesByPath, k) {\n                        $valuesByPath[k] = valuesByPath[k];\n                        return $valuesByPath;\n                      }, {}, keys));\n\n    return new TypeError(trimTrailingSpaces(\n      values.length === 1 && isEmpty(determineActualTypesLoose(env, values)) ?\n        'Unrecognized value\\n\\n' +\n        underlinedTypeVars + '\\n' +\n        '1)  ' + Z.toString(values[0]) + ' :: (no types)\\n\\n' +\n        toMarkdownList(\n          'The environment is empty! ' +\n          'Polymorphic functions require a non-empty environment.\\n',\n          'The value at position 1 is not a member of any type in ' +\n          'the environment.\\n\\n' +\n          'The environment contains the following types:\\n\\n',\n          showTypeWith(typeInfo),\n          env\n        ) :\n      // else\n        'Type-variable constraint violation\\n\\n' +\n        underlinedTypeVars + '\\n' +\n        Z.reduce(function(st, k) {\n          var values = valuesByPath[k];\n          return isEmpty(values) ? st : {\n            idx: st.idx + 1,\n            s: st.s +\n               showValuesAndTypes(env, typeInfo, values, st.idx + 1) +\n               '\\n\\n'\n          };\n        }, {idx: 0, s: ''}, keys).s +\n        'Since there is no type of which all the above values are ' +\n        'members, the type-variable constraint has been violated.\\n'\n    ));\n  }\n\n  //  invalidValue :: ... -> Error\n  function invalidValue(\n    env,            // :: Array Type\n    typeInfo,       // :: TypeInfo\n    index,          // :: Integer\n    propPath,       // :: PropPath\n    value           // :: Any\n  ) {\n    var t = resolvePropPath(typeInfo.types[index], propPath);\n    return new TypeError(trimTrailingSpaces(\n      'Invalid value\\n\\n' +\n      underline(typeInfo,\n                K(K(_)),\n                formatType6(Z.concat([index], propPath))) +\n      '\\n' +\n      showValuesAndTypes(env, typeInfo, [value], 1) + '\\n\\n' +\n      'The value at position 1 is not a member of ' + showTypeQuoted(t) + '.' +\n      '\\n' +\n      see('type', t)\n    ));\n  }\n\n  //  invalidArgumentsLength :: ... -> Error\n  //\n  //  This function is used in `wrapFunction` to ensure that higher-order\n  //  functions defined via `def` only ever apply a function argument to\n  //  the correct number of arguments.\n  function invalidArgumentsLength(\n    typeInfo,           // :: TypeInfo\n    index,              // :: Integer\n    numArgsExpected,    // :: Integer\n    args                // :: Array Any\n  ) {\n    return new TypeError(trimTrailingSpaces(\n      q(typeInfo.name) + ' applied ' + showTypeQuoted(typeInfo.types[index]) +\n      ' to the wrong number of arguments\\n\\n' +\n      underline(\n        typeInfo,\n        K(K(_)),\n        function(index_) {\n          return function(f) {\n            return function(t) {\n              return function(propPath) {\n                return function(s) {\n                  return index_ === index ?\n                    String(t).replace(\n                      /^[(](.*) -> (.*)[)]$/,\n                      function(s, $1, $2) {\n                        return _('(') + f($1) + _(' -> ' + $2 + ')');\n                      }\n                    ) :\n                    _(s);\n                };\n              };\n            };\n          };\n        }\n      ) + '\\n' +\n      'Expected ' + numArgs(numArgsExpected) +\n      ' but received ' + numArgs(args.length) +\n      toMarkdownList('.\\n', ':\\n\\n', Z.toString, args)\n    ));\n  }\n\n  //  assertRight :: Either (() -> Error) a -> a !\n  function assertRight(either) {\n    if (either.isLeft) throw either.value();\n    return either.value;\n  }\n\n  //  curry :: ... -> Function\n  function curry(\n    opts,         // :: Options\n    typeInfo,     // :: TypeInfo\n    _typeVarMap,  // :: TypeVarMap\n    _values,      // :: Array Any\n    _indexes,     // :: Array Integer\n    impl          // :: Function\n  ) {\n    var n = typeInfo.types.length - 1;\n\n    var curried = arity(_indexes.length, function() {\n      if (opts.checkTypes) {\n        var delta = _indexes.length - arguments.length;\n        if (delta < 0) throw tooManyArguments(typeInfo, n - delta);\n      }\n      var typeVarMap = _typeVarMap;\n      var values = _values.slice();\n      var indexes = [];\n      for (var idx = 0; idx < _indexes.length; idx += 1) {\n        var index = _indexes[idx];\n\n        if (idx < arguments.length &&\n            !(typeof arguments[idx] === 'object' &&\n              arguments[idx] != null &&\n              arguments[idx]['@@functional/placeholder'] === true)) {\n\n          var value = arguments[idx];\n          if (opts.checkTypes) {\n            var result = satisfactoryTypes(opts.env,\n                                           typeInfo,\n                                           typeVarMap,\n                                           typeInfo.types[index],\n                                           index,\n                                           [],\n                                           [value]);\n            typeVarMap = assertRight(result).typeVarMap;\n          }\n          values[index] = value;\n        } else {\n          indexes.push(index);\n        }\n      }\n      if (isEmpty(indexes)) {\n        if (opts.checkTypes) {\n          var returnValue = impl.apply(this,\n                                       wrapFunctions(opts.env,\n                                                     typeInfo,\n                                                     [typeVarMap],\n                                                     values));\n          assertRight(satisfactoryTypes(opts.env,\n                                        typeInfo,\n                                        typeVarMap,\n                                        typeInfo.types[n],\n                                        n,\n                                        [],\n                                        [returnValue]));\n          return wrapFunctionCond(env, typeInfo, [typeVarMap], n, returnValue);\n        } else {\n          return impl.apply(this, values);\n        }\n      } else {\n        return curry(opts, typeInfo, typeVarMap, values, indexes, impl);\n      }\n    });\n\n    var showType = showTypeWith(typeInfo);\n    curried.inspect = curried.toString = function() {\n      var vReprs = [];\n      var tReprs = [];\n      for (var idx = 0, placeholders = 0; idx < n; idx += 1) {\n        if (_indexes.indexOf(idx) >= 0) {\n          placeholders += 1;\n          tReprs.push(showType(typeInfo.types[idx]));\n        } else {\n          while (placeholders > 0) {\n            vReprs.push('__');\n            placeholders -= 1;\n          }\n          vReprs.push(Z.toString(_values[idx]));\n        }\n      }\n      return typeInfo.name +\n             when(vReprs.length > 0, parenthesize, vReprs.join(', ')) +\n             ' :: ' +\n             constraintsRepr(typeInfo.constraints, id, K(K(id))) +\n             when(n === 0, parenthesize, tReprs.join(' -> ')) +\n             ' -> ' + showType(typeInfo.types[n]);\n    };\n\n    return curried;\n  }\n\n  function _create(opts) {\n    function def(name, constraints, expTypes, impl) {\n      var values = new Array(expTypes.length - 1);\n      if (values.length > 9) {\n        throw new RangeError(q(def.name) + ' cannot define a function ' +\n                             'with arity greater than nine');\n      }\n      return curry(opts,\n                   {name: name, constraints: constraints, types: expTypes},\n                   {},\n                   values,\n                   range(0, values.length),\n                   impl);\n    }\n    return def(def.name,\n               {},\n               [String_,\n                StrMap(Array_(TypeClass)),\n                NonEmpty(Array_(Type)),\n                AnyFunction,\n                AnyFunction],\n               def);\n  }\n\n  var create =\n  def('create',\n      {},\n      [RecordType({checkTypes: Boolean_, env: Array_(Any)}), AnyFunction],\n      _create);\n\n  //  fromUncheckedUnaryType :: (Type -> Type) -> (Type -> Type)\n  function fromUncheckedUnaryType(typeConstructor) {\n    var t = typeConstructor(Unknown);\n    var _1 = t.types.$1.extractor;\n    return CheckedUnaryType(t.name, t.url, t._test, _1);\n  }\n\n  //  fromUncheckedBinaryType :: ((Type, Type) -> Type) ->\n  //                             (Type -> Type -> Type)\n  function fromUncheckedBinaryType(typeConstructor) {\n    var t = typeConstructor(Unknown, Unknown);\n    var _1 = t.types.$1.extractor;\n    var _2 = t.types.$2.extractor;\n    return CheckedBinaryType(t.name, t.url, t._test, _1, _2);\n  }\n\n  return {\n    __: __,\n    Any: Any,\n    AnyFunction: AnyFunction,\n    Arguments: Arguments,\n    Array: fromUncheckedUnaryType(Array_),\n    Boolean: Boolean_,\n    Date: Date_,\n    Error: Error_,\n    FiniteNumber: FiniteNumber,\n    Function: def('Function', {}, [Array_(Type), Type], Function_),\n    GlobalRegExp: GlobalRegExp,\n    Integer: Integer,\n    NegativeFiniteNumber: NegativeFiniteNumber,\n    NegativeInteger: NegativeInteger,\n    NegativeNumber: NegativeNumber,\n    NonEmpty: NonEmpty,\n    NonGlobalRegExp: NonGlobalRegExp,\n    NonNegativeInteger: NonNegativeInteger,\n    NonZeroFiniteNumber: NonZeroFiniteNumber,\n    NonZeroInteger: NonZeroInteger,\n    NonZeroValidNumber: NonZeroValidNumber,\n    Null: Null,\n    Nullable: fromUncheckedUnaryType(Nullable),\n    Number: Number_,\n    Object: Object_,\n    Pair: fromUncheckedBinaryType(Pair),\n    PositiveFiniteNumber: PositiveFiniteNumber,\n    PositiveInteger: PositiveInteger,\n    PositiveNumber: PositiveNumber,\n    RegExp: RegExp_,\n    RegexFlags: RegexFlags,\n    StrMap: fromUncheckedUnaryType(StrMap),\n    String: String_,\n    Symbol: Symbol_,\n    Type: Type,\n    TypeClass: TypeClass,\n    Undefined: Undefined,\n    Unknown: Unknown,\n    ValidDate: ValidDate,\n    ValidNumber: ValidNumber,\n    env: env,\n    create: create,\n    test: def('test', {}, [Array_(Type), Type, Any, Boolean_], test),\n    NullaryType: CheckedNullaryType,\n    UnaryType: CheckedUnaryType,\n    BinaryType: CheckedBinaryType,\n    EnumType: CheckedEnumType,\n    RecordType: CheckedRecordType,\n    TypeVariable: CheckedTypeVariable,\n    UnaryTypeVariable: CheckedUnaryTypeVariable,\n    BinaryTypeVariable: CheckedBinaryTypeVariable,\n    Thunk: Thunk,\n    Predicate: Predicate\n  };\n\n}));\n\n//. [FL:Semigroup]:         https://github.com/fantasyland/fantasy-land#semigroup\n//. [Monoid]:               https://github.com/fantasyland/fantasy-land#monoid\n//. [Setoid]:               https://github.com/fantasyland/fantasy-land#setoid\n//. [`Array`]:              #Array\n//. [`BinaryType`]:         #BinaryType\n//. [`Date`]:               #Date\n//. [`FiniteNumber`]:       #FiniteNumber\n//. [`GlobalRegExp`]:       #GlobalRegExp\n//. [`Integer`]:            #Integer\n//. [`NonGlobalRegExp`]:    #NonGlobalRegExp\n//. [`Number`]:             #Number\n//. [`Object.create`]:      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\n//. [`Pair`]:               #Pair\n//. [`RegExp`]:             #RegExp\n//. [`RegexFlags`]:         #RegexFlags\n//. [`String`]:             #String\n//. [`SyntaxError`]:        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError\n//. [`TypeClass`]:          https://github.com/sanctuary-js/sanctuary-type-classes#TypeClass\n//. [`TypeError`]:          https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError\n//. [`TypeVariable`]:       #TypeVariable\n//. [`UnaryType`]:          #UnaryType\n//. [`UnaryTypeVariable`]:  #UnaryTypeVariable\n//. [`Unknown`]:            #Unknown\n//. [`ValidNumber`]:        #ValidNumber\n//. [`env`]:                #env\n//. [arguments]:            https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments\n//. [enumerated types]:     https://en.wikipedia.org/wiki/Enumerated_type\n//. [max]:                  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER\n//. [min]:                  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_SAFE_INTEGER\n//. [record type]:          #RecordType\n//. [semigroup]:            https://en.wikipedia.org/wiki/Semigroup\n//. [type class]:           #type-classes\n//. [type variables]:       #TypeVariable\n//. [types]:                #types\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zYW5jdHVhcnktZGVmL2luZGV4LmpzPzBiZDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICAgICAgICAgICAgIF9fXyAgICAgICAgICAgICAgICAgX19fX19fXG4gICAgICAgICAgICAgICAvICAvXFwgICAgICAgICAgICAgICAvICBfX18vXFxcbiAgICAgICAgX19fX19fLyAgLyAvIF9fX19fX18gICAgX18vICAvX19fXFwvXG4gICAgICAgLyAgX19fICAgLyAvIC8gIF9fXyAgXFwgIC9fICAgX18vXFxcbiAgICAgIC8gIC9cXF8vICAvIC8gLyAgL19fLyAgL1xcIFxcLyAgL1xcX1xcL1xuICAgICAvICAvIC8vICAvIC8gLyAgX19fX19fLyAvIC8gIC8gL1xuICAgIC8gIC9fLy8gIC8gLyAvICAvX19fX19fXFwvIC8gIC8gL1xuICAgIFxcX19fX19fXy8gLyAgXFxfX19fX19fL1xcICAvX18vIC9cbiAgICAgXFxfX19fX19cXC8gICAgXFxfX19fX19cXC8gIFxcX18qL1xuXG4vLy4gIyBzYW5jdHVhcnktZGVmXG4vLy5cbi8vLiBzYW5jdHVhcnktZGVmIGlzIGEgcnVuLXRpbWUgdHlwZSBzeXN0ZW0gZm9yIEphdmFTY3JpcHQuIEl0IGZhY2lsaXRhdGVzXG4vLy4gdGhlIGRlZmluaXRpb24gb2YgY3VycmllZCBKYXZhU2NyaXB0IGZ1bmN0aW9ucyB3aGljaCBhcmUgZXhwbGljaXQgYWJvdXRcbi8vLiB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byB3aGljaCB0aGV5IG1heSBiZSBhcHBsaWVkIGFuZCB0aGUgdHlwZXMgb2Zcbi8vLiB0aG9zZSBhcmd1bWVudHMuXG4vLy5cbi8vLiBJdCBpcyBjb252ZW50aW9uYWwgdG8gaW1wb3J0IHRoZSBwYWNrYWdlIGFzIGAkYDpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiBjb25zdCAkID0gcmVxdWlyZSgnc2FuY3R1YXJ5LWRlZicpO1xuLy8uIGBgYFxuLy8uXG4vLy4gVGhlIG5leHQgc3RlcCBpcyB0byBkZWZpbmUgYW4gZW52aXJvbm1lbnQuIEFuIGVudmlyb25tZW50IGlzIGFuIGFycmF5XG4vLy4gb2YgW3R5cGVzXVtdLiBbYGVudmBdW10gaXMgYW4gZW52aXJvbm1lbnQgY29udGFpbmluZyBhbGwgdGhlIGJ1aWx0LWluXG4vLy4gSmF2YVNjcmlwdCB0eXBlcy4gSXQgbWF5IGJlIHVzZWQgYXMgdGhlIGJhc2lzIGZvciBlbnZpcm9ubWVudHMgd2hpY2hcbi8vLiBpbmNsdWRlIGN1c3RvbSB0eXBlcyBpbiBhZGRpdGlvbiB0byB0aGUgYnVpbHQtaW4gdHlwZXM6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gLy8gICAgSW50ZWdlciA6OiBUeXBlXG4vLy4gY29uc3QgSW50ZWdlciA9IC4uLjtcbi8vLlxuLy8uIC8vICAgIE5vblplcm9JbnRlZ2VyIDo6IFR5cGVcbi8vLiBjb25zdCBOb25aZXJvSW50ZWdlciA9IC4uLjtcbi8vLlxuLy8uIC8vICAgIGVudiA6OiBBcnJheSBUeXBlXG4vLy4gY29uc3QgZW52ID0gJC5lbnYuY29uY2F0KFtJbnRlZ2VyLCBOb25aZXJvSW50ZWdlcl0pO1xuLy8uIGBgYFxuLy8uXG4vLy4gVHlwZSBjb25zdHJ1Y3RvcnMgc3VjaCBhcyBgTGlzdCA6OiBUeXBlIC0+IFR5cGVgIGNhbm5vdCBiZSBpbmNsdWRlZCBpblxuLy8uIGFuIGVudmlyb25tZW50IGFzIHRoZXkncmUgbm90IG9mIHRoZSBjb3JyZWN0IHR5cGUuIE9uZSBjb3VsZCwgdGhvdWdoLFxuLy8uIHVzZSBhIHR5cGUgY29uc3RydWN0b3IgdG8gZGVmaW5lIGEgZml4ZWQgbnVtYmVyIG9mIGNvbmNyZXRlIHR5cGVzOlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIC8vICAgIGVudiA6OiBBcnJheSBUeXBlXG4vLy4gY29uc3QgZW52ID0gJC5lbnYuY29uY2F0KFtcbi8vLiAgIExpc3QoJC5OdW1iZXIpLCAgICAgICAgICAgICAgIC8vIDo6IFR5cGVcbi8vLiAgIExpc3QoJC5TdHJpbmcpLCAgICAgICAgICAgICAgIC8vIDo6IFR5cGVcbi8vLiAgIExpc3QoTGlzdCgkLk51bWJlcikpLCAgICAgICAgIC8vIDo6IFR5cGVcbi8vLiAgIExpc3QoTGlzdCgkLlN0cmluZykpLCAgICAgICAgIC8vIDo6IFR5cGVcbi8vLiAgIExpc3QoTGlzdChMaXN0KCQuTnVtYmVyKSkpLCAgIC8vIDo6IFR5cGVcbi8vLiAgIExpc3QoTGlzdChMaXN0KCQuU3RyaW5nKSkpLCAgIC8vIDo6IFR5cGVcbi8vLiBdKTtcbi8vLiBgYGBcbi8vLlxuLy8uIE5vdCBvbmx5IHdvdWxkIHRoaXMgYmUgdGVkaW91cywgYnV0IG9uZSBjb3VsZCBuZXZlciBlbnVtZXJhdGUgYWxsIHBvc3NpYmxlXG4vLy4gdHlwZXMgYXMgdGhlcmUgYXJlIGluZmluaXRlbHkgbWFueS4gSW5zdGVhZCwgb25lIHNob3VsZCB1c2UgW2BVbmtub3duYF1bXTpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiAvLyAgICBlbnYgOjogQXJyYXkgVHlwZVxuLy8uIGNvbnN0IGVudiA9ICQuZW52LmNvbmNhdChbTGlzdCgkLlVua25vd24pXSk7XG4vLy4gYGBgXG4vLy5cbi8vLiBUaGUgbmV4dCBzdGVwIGlzIHRvIGRlZmluZSBhIGBkZWZgIGZ1bmN0aW9uIGZvciB0aGUgZW52aXJvbm1lbnQ6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gY29uc3QgZGVmID0gJC5jcmVhdGUoe2NoZWNrVHlwZXM6IHRydWUsIGVudjogZW52fSk7XG4vLy4gYGBgXG4vLy5cbi8vLiBUaGUgYGNoZWNrVHlwZXNgIG9wdGlvbiBkZXRlcm1pbmVzIHdoZXRoZXIgdHlwZSBjaGVja2luZyBpcyBlbmFibGVkLlxuLy8uIFRoaXMgYWxsb3dzIG9uZSB0byBvbmx5IHBheSB0aGUgcGVyZm9ybWFuY2UgY29zdCBvZiBydW4tdGltZSB0eXBlIGNoZWNraW5nXG4vLy4gZHVyaW5nIGRldmVsb3BtZW50LiBGb3IgZXhhbXBsZTpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiBjb25zdCBkZWYgPSAkLmNyZWF0ZSh7XG4vLy4gICBjaGVja1R5cGVzOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jyxcbi8vLiAgIGVudjogZW52LFxuLy8uIH0pO1xuLy8uIGBgYFxuLy8uXG4vLy4gYGRlZmAgaXMgYSBmdW5jdGlvbiBmb3IgZGVmaW5pbmcgZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiAvLyAgICBhZGQgOjogTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbi8vLiBjb25zdCBhZGQgPVxuLy8uIGRlZignYWRkJywge30sIFskLk51bWJlciwgJC5OdW1iZXIsICQuTnVtYmVyXSwgKHgsIHkpID0+IHggKyB5KTtcbi8vLiBgYGBcbi8vLlxuLy8uIGBbJC5OdW1iZXIsICQuTnVtYmVyLCAkLk51bWJlcl1gIHNwZWNpZmllcyB0aGF0IGBhZGRgIHRha2VzIHR3byBhcmd1bWVudHNcbi8vLiBvZiB0eXBlIGBOdW1iZXJgIGFuZCByZXR1cm5zIGEgdmFsdWUgb2YgdHlwZSBgTnVtYmVyYC5cbi8vLlxuLy8uIEFwcGx5aW5nIGBhZGRgIHRvIHR3byBhcmd1bWVudHMgZ2l2ZXMgdGhlIGV4cGVjdGVkIHJlc3VsdDpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiBhZGQoMiwgMik7XG4vLy4gLy8gPT4gNFxuLy8uIGBgYFxuLy8uXG4vLy4gQXBwbHlpbmcgYGFkZGAgdG8gZ3JlYXRlciB0aGFuIHR3byBhcmd1bWVudHMgcmVzdWx0cyBpbiBhbiBleGNlcHRpb24gYmVpbmdcbi8vLiB0aHJvd246XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gYWRkKDIsIDIsIDIpO1xuLy8uIC8vICEgVHlwZUVycm9yOiDigJhhZGTigJkgcmVxdWlyZXMgdHdvIGFyZ3VtZW50czsgcmVjZWl2ZWQgdGhyZWUgYXJndW1lbnRzXG4vLy4gYGBgXG4vLy5cbi8vLiBBcHBseWluZyBgYWRkYCB0byBmZXdlciB0aGFuIHR3byBhcmd1bWVudHMgcmVzdWx0cyBpbiBhIGZ1bmN0aW9uXG4vLy4gYXdhaXRpbmcgdGhlIHJlbWFpbmluZyBhcmd1bWVudHMuIFRoaXMgaXMga25vd24gYXMgcGFydGlhbCBhcHBsaWNhdGlvbi5cbi8vLiBQYXJ0aWFsIGFwcGxpY2F0aW9uIGlzIGNvbnZlbmllbnQgYXMgaXQgYWxsb3dzIG1vcmUgc3BlY2lmaWMgZnVuY3Rpb25zXG4vLy4gdG8gYmUgZGVmaW5lZCBpbiB0ZXJtcyBvZiBtb3JlIGdlbmVyYWwgb25lczpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiAvLyAgICBpbmMgOjogTnVtYmVyIC0+IE51bWJlclxuLy8uIGNvbnN0IGluYyA9IGFkZCgxKTtcbi8vLlxuLy8uIGluYyg3KTtcbi8vLiAvLyA9PiA4XG4vLy4gYGBgXG4vLy5cbi8vLiBKYXZhU2NyaXB0J3MgaW1wbGljaXQgdHlwZSBjb2VyY2lvbiBvZnRlbiBvYmZ1c2NhdGVzIHRoZSBzb3VyY2Ugb2YgdHlwZVxuLy8uIGVycm9ycy4gQ29uc2lkZXIgdGhlIGZvbGxvd2luZyBmdW5jdGlvbjpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiAvLyAgICBfYWRkIDo6IChOdW1iZXIsIE51bWJlcikgLT4gTnVtYmVyXG4vLy4gY29uc3QgX2FkZCA9ICh4LCB5KSA9PiB4ICsgeTtcbi8vLiBgYGBcbi8vLlxuLy8uIFRoZSB0eXBlIHNpZ25hdHVyZSBpbmRpY2F0ZXMgdGhhdCBgX2FkZGAgdGFrZXMgdHdvIGFyZ3VtZW50cyBvZiB0eXBlXG4vLy4gYE51bWJlcmAsIGJ1dCB0aGlzIGlzIG5vdCBlbmZvcmNlZC4gVGhpcyBhbGxvd3MgdHlwZSBlcnJvcnMgdG8gYmUgc2lsZW50bHlcbi8vLiBpZ25vcmVkOlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIF9hZGQoJzInLCAnMicpO1xuLy8uIC8vID0+ICcyMidcbi8vLiBgYGBcbi8vLlxuLy8uIGBhZGRgLCBvbiB0aGUgb3RoZXIgaGFuZCwgdGhyb3dzIGlmIGFwcGxpZWQgdG8gYXJndW1lbnRzIG9mIHRoZSB3cm9uZ1xuLy8uIHR5cGVzOlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIGFkZCgnMicsICcyJyk7XG4vLy4gLy8gISBUeXBlRXJyb3I6IEludmFsaWQgdmFsdWVcbi8vLiAvL1xuLy8uIC8vICAgYWRkIDo6IE51bWJlciAtPiBOdW1iZXIgLT4gTnVtYmVyXG4vLy4gLy8gICAgICAgICAgXl5eXl5eXG4vLy4gLy8gICAgICAgICAgICAxXG4vLy4gLy9cbi8vLiAvLyAgIDEpICBcIjJcIiA6OiBTdHJpbmdcbi8vLiAvL1xuLy8uIC8vICAgVGhlIHZhbHVlIGF0IHBvc2l0aW9uIDEgaXMgbm90IGEgbWVtYmVyIG9mIOKAmE51bWJlcuKAmS5cbi8vLiBgYGBcbi8vLlxuLy8uIFR5cGUgY2hlY2tpbmcgaXMgcGVyZm9ybWVkIGFzIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgKHJhdGhlciB0aGFuIG9uY2UgYWxsXG4vLy4gYXJndW1lbnRzIGhhdmUgYmVlbiBwcm92aWRlZCksIHNvIHR5cGUgZXJyb3JzIGFyZSByZXBvcnRlZCBlYXJseTpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiBhZGQoJ1gnKTtcbi8vLiAvLyAhIFR5cGVFcnJvcjogSW52YWxpZCB2YWx1ZVxuLy8uIC8vXG4vLy4gLy8gICBhZGQgOjogTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbi8vLiAvLyAgICAgICAgICBeXl5eXl5cbi8vLiAvLyAgICAgICAgICAgIDFcbi8vLiAvL1xuLy8uIC8vICAgMSkgIFwiWFwiIDo6IFN0cmluZ1xuLy8uIC8vXG4vLy4gLy8gICBUaGUgdmFsdWUgYXQgcG9zaXRpb24gMSBpcyBub3QgYSBtZW1iZXIgb2Yg4oCYTnVtYmVy4oCZLlxuLy8uIGBgYFxuXG4oZnVuY3Rpb24oZikge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZihyZXF1aXJlKCdzYW5jdHVhcnktdHlwZS1jbGFzc2VzJyksXG4gICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJ3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzJykpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCAhPSBudWxsKSB7XG4gICAgZGVmaW5lKFsnc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcycsICdzYW5jdHVhcnktdHlwZS1pZGVudGlmaWVycyddLCBmKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnNhbmN0dWFyeURlZiA9IGYoc2VsZi5zYW5jdHVhcnlUeXBlQ2xhc3NlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zYW5jdHVhcnlUeXBlSWRlbnRpZmllcnMpO1xuICB9XG5cbn0oZnVuY3Rpb24oWiwgdHlwZSkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyMgX18gOjogUGxhY2Vob2xkZXJcbiAgLy8uXG4gIC8vLiBUaGUgc3BlY2lhbCBwbGFjZWhvbGRlciB2YWx1ZS5cbiAgLy8uXG4gIC8vLiBPbmUgbWF5IHdpc2ggdG8gcGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb24gd2hvc2UgcGFyYW1ldGVycyBhcmUgaW4gdGhlXG4gIC8vLiBcIndyb25nXCIgb3JkZXIuIEZ1bmN0aW9ucyBkZWZpbmVkIHZpYSBzYW5jdHVhcnktZGVmIGFjY29tbW9kYXRlIHRoaXMgYnlcbiAgLy8uIGFjY2VwdGluZyBwbGFjZWhvbGRlcnMgZm9yIGFyZ3VtZW50cyB5ZXQgdG8gYmUgcHJvdmlkZWQuIEZvciBleGFtcGxlOlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uIC8vICAgIGNvbmNhdFMgOjogU3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgLy8uIGNvbnN0IGNvbmNhdFMgPVxuICAvLy4gZGVmKCdjb25jYXRTJywge30sIFskLlN0cmluZywgJC5TdHJpbmcsICQuU3RyaW5nXSwgKHgsIHkpID0+IHggKyB5KTtcbiAgLy8uXG4gIC8vLiAvLyAgICBleGNsYWltIDo6IFN0cmluZyAtPiBTdHJpbmdcbiAgLy8uIGNvbnN0IGV4Y2xhaW0gPSBjb25jYXRTKCQuX18sICchJyk7XG4gIC8vLlxuICAvLy4gZXhjbGFpbSgnYWhveScpO1xuICAvLy4gLy8gPT4gJ2Fob3khJ1xuICAvLy4gYGBgXG4gIHZhciBfXyA9IHsnQEBmdW5jdGlvbmFsL3BsYWNlaG9sZGVyJzogdHJ1ZX07XG5cbiAgdmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICB2YXIgTUlOX1NBRkVfSU5URUdFUiA9IC1NQVhfU0FGRV9JTlRFR0VSO1xuXG4gIHZhciBzbGljZSAgICAgICAgICAgICA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbiAgdmFyIGhhc093blByb3BlcnR5ICAgID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmdW5jdGlvbiBFaXRoZXIodGFnLCB2YWx1ZSkge1xuICAgIHRoaXMuaXNMZWZ0ID0gdGFnID09PSAnTGVmdCc7XG4gICAgdGhpcy5pc1JpZ2h0ID0gdGFnID09PSAnUmlnaHQnO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIEVpdGhlclsnQEB0eXBlJ10gPSAnc2FuY3R1YXJ5LWRlZi9FaXRoZXInO1xuXG4gIEVpdGhlci5wcm90b3R5cGVbJ2ZhbnRhc3ktbGFuZC9tYXAnXSA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gdGhpcy5pc0xlZnQgPyB0aGlzIDogUmlnaHQoZih0aGlzLnZhbHVlKSk7XG4gIH07XG5cbiAgRWl0aGVyLnByb3RvdHlwZVsnZmFudGFzeS1sYW5kL2NoYWluJ10gPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNMZWZ0ID8gdGhpcyA6IGYodGhpcy52YWx1ZSk7XG4gIH07XG5cbiAgLy8gIExlZnQgOjogYSAtPiBFaXRoZXIgYSBiXG4gIGZ1bmN0aW9uIExlZnQoeCkgeyByZXR1cm4gbmV3IEVpdGhlcignTGVmdCcsIHgpOyB9XG5cbiAgLy8gIFJpZ2h0IDo6IGIgLT4gRWl0aGVyIGEgYlxuICBmdW5jdGlvbiBSaWdodCh4KSB7IHJldHVybiBuZXcgRWl0aGVyKCdSaWdodCcsIHgpOyB9XG5cbiAgLy8gIEsgOjogYSAtPiBiIC0+IGFcbiAgZnVuY3Rpb24gSyh4KSB7IHJldHVybiBmdW5jdGlvbih5KSB7IHJldHVybiB4OyB9OyB9XG5cbiAgLy8gIGFsd2F5czIgOjogYSAtPiAoYiwgYykgLT4gYVxuICBmdW5jdGlvbiBhbHdheXMyKHgpIHsgcmV0dXJuIGZ1bmN0aW9uKHksIHopIHsgcmV0dXJuIHg7IH07IH1cblxuICAvLyAgaWQgOjogYSAtPiBhXG4gIGZ1bmN0aW9uIGlkKHgpIHsgcmV0dXJuIHg7IH1cblxuICAvLyAgaW5pdCA6OiBBcnJheSBhIC0+IEFycmF5IGFcbiAgZnVuY3Rpb24gaW5pdCh4cykgeyByZXR1cm4geHMuc2xpY2UoMCwgLTEpOyB9XG5cbiAgLy8gIGlzRW1wdHkgOjogQXJyYXkgYSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIGlzRW1wdHkoeHMpIHsgcmV0dXJuIHhzLmxlbmd0aCA9PT0gMDsgfVxuXG4gIC8vICBpc1ByZWZpeCA6OiBBcnJheSBhIC0+IEFycmF5IGEgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBpc1ByZWZpeChjYW5kaWRhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeHMpIHtcbiAgICAgIGlmIChjYW5kaWRhdGUubGVuZ3RoID4geHMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBjYW5kaWRhdGUubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgICAgICBpZiAoY2FuZGlkYXRlW2lkeF0gIT09IHhzW2lkeF0pIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cblxuICAvLyAgbGFzdCA6OiBBcnJheSBhIC0+IGFcbiAgZnVuY3Rpb24gbGFzdCh4cykgeyByZXR1cm4geHNbeHMubGVuZ3RoIC0gMV07IH1cblxuICAvLyAgbWVtYmVyT2YgOjogQXJyYXkgYSAtPiBhIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gbWVtYmVyT2YoeHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHhzLnNvbWUoZnVuY3Rpb24oeCkgeyByZXR1cm4gWi5lcXVhbHMoeCwgeSk7IH0pO1xuICAgIH07XG4gIH1cblxuICAvLyAgb3IgOjogKEFycmF5IGEsIEFycmF5IGEpIC0+IEFycmF5IGFcbiAgZnVuY3Rpb24gb3IoeHMsIHlzKSB7IHJldHVybiBpc0VtcHR5KHhzKSA/IHlzIDogeHM7IH1cblxuICAvLyAgcmFuZ2UgOjogKE51bWJlciwgTnVtYmVyKSAtPiBBcnJheSBOdW1iZXJcbiAgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3ApIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgbiA9IHN0YXJ0OyBuIDwgc3RvcDsgbiArPSAxKSByZXN1bHQucHVzaChuKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gIHNpbmdsZXRvbiA6OiAoU3RyaW5nLCBhKSAtPiBTdHJNYXAgYVxuICBmdW5jdGlvbiBzaW5nbGV0b24oaywgdikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICByZXN1bHRba10gPSB2O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyAgc3RyUmVwZWF0IDo6IChTdHJpbmcsIEludGVnZXIpIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBzdHJSZXBlYXQocywgdGltZXMpIHtcbiAgICByZXR1cm4gQXJyYXkodGltZXMgKyAxKS5qb2luKHMpO1xuICB9XG5cbiAgLy8gIHIgOjogQ2hhciAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIHIoYykge1xuICAgIHJldHVybiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gc3RyUmVwZWF0KGMsIHMubGVuZ3RoKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gIF8gOjogU3RyaW5nIC0+IFN0cmluZ1xuICB2YXIgXyA9IHIoJyAnKTtcblxuICAvLyAgc3RyaXBPdXRlcm1vc3RQYXJlbnMgOjogU3RyaW5nIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBzdHJpcE91dGVybW9zdFBhcmVucyhzKSB7XG4gICAgcmV0dXJuIHMuc2xpY2UoJygnLmxlbmd0aCwgLScpJy5sZW5ndGgpO1xuICB9XG5cbiAgLy8gIHRvTWFya2Rvd25MaXN0IDo6IChTdHJpbmcsIFN0cmluZywgYSAtPiBTdHJpbmcsIEFycmF5IGEpIC0+IFN0cmluZ1xuICBmdW5jdGlvbiB0b01hcmtkb3duTGlzdChlbXB0eSwgcywgZiwgeHMpIHtcbiAgICByZXR1cm4gaXNFbXB0eSh4cykgP1xuICAgICAgZW1wdHkgOlxuICAgICAgWi5yZWR1Y2UoZnVuY3Rpb24ocywgeCkgeyByZXR1cm4gcyArICcgIC0gJyArIGYoeCkgKyAnXFxuJzsgfSwgcywgeHMpO1xuICB9XG5cbiAgLy8gIHRyaW1UcmFpbGluZ1NwYWNlcyA6OiBTdHJpbmcgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIHRyaW1UcmFpbGluZ1NwYWNlcyhzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSgvWyBdKyQvZ20sICcnKTtcbiAgfVxuXG4gIC8vICB1bmxlc3MgOjogKEJvb2xlYW4sIChhIC0+IGEpLCBhKSAtPiBhXG4gIGZ1bmN0aW9uIHVubGVzcyhib29sLCBmLCB4KSB7XG4gICAgcmV0dXJuIGJvb2wgPyB4IDogZih4KTtcbiAgfVxuXG4gIC8vICB3aGVuIDo6IChCb29sZWFuLCAoYSAtPiBhKSwgYSkgLT4gYVxuICBmdW5jdGlvbiB3aGVuKGJvb2wsIGYsIHgpIHtcbiAgICByZXR1cm4gYm9vbCA/IGYoeCkgOiB4O1xuICB9XG5cbiAgLy8gIHdyYXAgOjogU3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIHdyYXAocHJlZml4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN1ZmZpeCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIHMgKyBzdWZmaXg7XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICAvLyAgcGFyZW50aGVzaXplIDo6IFN0cmluZyAtPiBTdHJpbmdcbiAgdmFyIHBhcmVudGhlc2l6ZSA9IHdyYXAoJygnKSgnKScpO1xuXG4gIC8vICBxIDo6IFN0cmluZyAtPiBTdHJpbmdcbiAgdmFyIHEgPSB3cmFwKCdcXHUyMDE4JykoJ1xcdTIwMTknKTtcblxuICAvLyAgc3RyaXBOYW1lc3BhY2UgOjogU3RyaW5nIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBzdHJpcE5hbWVzcGFjZShzKSB7IHJldHVybiBzLnNsaWNlKHMuaW5kZXhPZignLycpICsgMSk7IH1cblxuICAvLyAgX1R5cGUgOjogLi4uIC0+IFR5cGVcbiAgZnVuY3Rpb24gX1R5cGUoXG4gICAgdHlwZSwgICAgICAgLy8gOjogU3RyaW5nXG4gICAgbmFtZSwgICAgICAgLy8gOjogU3RyaW5nXG4gICAgdXJsLCAgICAgICAgLy8gOjogU3RyaW5nXG4gICAgZm9ybWF0LCAgICAgLy8gOjogKFN0cmluZyAtPiBTdHJpbmcsIFN0cmluZyAtPiBTdHJpbmcgLT4gU3RyaW5nKSAtPiBTdHJpbmdcbiAgICB0ZXN0LCAgICAgICAvLyA6OiBBbnkgLT4gQm9vbGVhblxuICAgIGtleXMsICAgICAgIC8vIDo6IEFycmF5IFN0cmluZ1xuICAgIHR5cGVzICAgICAgIC8vIDo6IFN0ck1hcCB7IGV4dHJhY3RvciA6OiBhIC0+IEFycmF5IGIsIHR5cGUgOjogVHlwZSB9XG4gICkge1xuICAgIHRoaXMuX3Rlc3QgPSB0ZXN0O1xuICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgIHRoaXMua2V5cyA9IGtleXM7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgfVxuXG4gIF9UeXBlWydAQHR5cGUnXSA9ICdzYW5jdHVhcnktZGVmL1R5cGUnO1xuXG4gIF9UeXBlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIXRoaXMuX3Rlc3QoeCkpIHJldHVybiBMZWZ0KHt2YWx1ZTogeCwgcHJvcFBhdGg6IFtdfSk7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgdGhpcy5rZXlzLmxlbmd0aDsgaWR4ICs9IDEpIHtcbiAgICAgIHZhciBrID0gdGhpcy5rZXlzW2lkeF07XG4gICAgICB2YXIgdCA9IHRoaXMudHlwZXNba107XG4gICAgICBmb3IgKHZhciBpZHgyID0gMCwgeXMgPSB0LmV4dHJhY3Rvcih4KTsgaWR4MiA8IHlzLmxlbmd0aDsgaWR4MiArPSAxKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0LnR5cGUudmFsaWRhdGUoeXNbaWR4Ml0pO1xuICAgICAgICBpZiAocmVzdWx0LmlzTGVmdCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZS52YWx1ZTtcbiAgICAgICAgICB2YXIgcHJvcFBhdGggPSBaLmNvbmNhdChba10sIHJlc3VsdC52YWx1ZS5wcm9wUGF0aCk7XG4gICAgICAgICAgcmV0dXJuIExlZnQoe3ZhbHVlOiB2YWx1ZSwgcHJvcFBhdGg6IHByb3BQYXRofSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFJpZ2h0KHgpO1xuICB9O1xuXG4gIF9UeXBlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZvcm1hdChpZCwgSyhpZCkpO1xuICB9O1xuXG4gIHZhciBCSU5BUlkgICAgICAgID0gJ0JJTkFSWSc7XG4gIHZhciBGVU5DVElPTiAgICAgID0gJ0ZVTkNUSU9OJztcbiAgdmFyIElOQ09OU0lTVEVOVCAgPSAnSU5DT05TSVNURU5UJztcbiAgdmFyIE5VTExBUlkgICAgICAgPSAnTlVMTEFSWSc7XG4gIHZhciBSRUNPUkQgICAgICAgID0gJ1JFQ09SRCc7XG4gIHZhciBVTkFSWSAgICAgICAgID0gJ1VOQVJZJztcbiAgdmFyIFVOS05PV04gICAgICAgPSAnVU5LTk9XTic7XG4gIHZhciBWQVJJQUJMRSAgICAgID0gJ1ZBUklBQkxFJztcblxuICAvLyAgSW5jb25zaXN0ZW50IDo6IFR5cGVcbiAgdmFyIEluY29uc2lzdGVudCA9XG4gIG5ldyBfVHlwZShJTkNPTlNJU1RFTlQsICcnLCAnJywgYWx3YXlzMignPz8/JyksIEsoZmFsc2UpLCBbXSwge30pO1xuXG4gIC8vICB0eXBlRXEgOjogU3RyaW5nIC0+IGEgLT4gQm9vbGVhblxuICBmdW5jdGlvbiB0eXBlRXEobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZSh4KSA9PT0gbmFtZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gIHR5cGVvZkVxIDo6IFN0cmluZyAtPiBhIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gdHlwZW9mRXEodHlwZW9mXykge1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdmFsaWQtdHlwZW9mXG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09IHR5cGVvZl87XG4gICAgfTtcbiAgfVxuXG4gIC8vICBmdW5jdGlvblVybCA6OiBTdHJpbmcgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIGZ1bmN0aW9uVXJsKG5hbWUpIHtcbiAgICB2YXIgdmVyc2lvbiA9ICcwLjE0LjAnOyAgLy8gdXBkYXRlZCBwcm9ncmFtbWF0aWNhbGx5XG4gICAgcmV0dXJuICdodHRwczovL2dpdGh1Yi5jb20vc2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS1kZWYvdHJlZS92JyArIHZlcnNpb24gK1xuICAgICAgICAgICAnIycgKyBzdHJpcE5hbWVzcGFjZShuYW1lKTtcbiAgfVxuXG4gIC8vICBOdWxsYXJ5VHlwZVdpdGhVcmwgOjogKFN0cmluZywgQW55IC0+IEJvb2xlYW4pIC0+IFR5cGVcbiAgZnVuY3Rpb24gTnVsbGFyeVR5cGVXaXRoVXJsKG5hbWUsIHRlc3QpIHtcbiAgICByZXR1cm4gTnVsbGFyeVR5cGUobmFtZSwgZnVuY3Rpb25VcmwobmFtZSksIHRlc3QpO1xuICB9XG5cbiAgLy8gIEVudW1UeXBlV2l0aFVybCA6OiAoU3RyaW5nLCBBcnJheSBBbnkpIC0+IFR5cGVcbiAgZnVuY3Rpb24gRW51bVR5cGVXaXRoVXJsKG5hbWUsIG1lbWJlcnMpIHtcbiAgICByZXR1cm4gRW51bVR5cGUobmFtZSwgZnVuY3Rpb25VcmwobmFtZSksIG1lbWJlcnMpO1xuICB9XG5cbiAgLy8gIFVuYXJ5VHlwZVdpdGhVcmwgOjpcbiAgLy8gICAgKFN0cmluZywgQW55IC0+IEJvb2xlYW4sIHQgYSAtPiBBcnJheSBhKSAtPiAoVHlwZSAtPiBUeXBlKVxuICBmdW5jdGlvbiBVbmFyeVR5cGVXaXRoVXJsKG5hbWUsIHRlc3QsIF8xKSB7XG4gICAgcmV0dXJuIFVuYXJ5VHlwZShuYW1lLCBmdW5jdGlvblVybChuYW1lKSwgdGVzdCwgXzEpO1xuICB9XG5cbiAgLy8gIEJpbmFyeVR5cGVXaXRoVXJsIDo6XG4gIC8vICAgIChTdHJpbmcsIEFueSAtPiBCb29sZWFuLCB0IGEgYiAtPiBBcnJheSBhLCB0IGEgYiAtPiBBcnJheSBiKSAtPlxuICAvLyAgICAgICgoVHlwZSwgVHlwZSkgLT4gVHlwZSlcbiAgZnVuY3Rpb24gQmluYXJ5VHlwZVdpdGhVcmwobmFtZSwgdGVzdCwgXzEsIF8yKSB7XG4gICAgcmV0dXJuIEJpbmFyeVR5cGUobmFtZSwgZnVuY3Rpb25VcmwobmFtZSksIHRlc3QsIF8xLCBfMik7XG4gIH1cblxuICAvLy4gIyMjIFR5cGVzXG4gIC8vLlxuICAvLy4gQ29uY2VwdHVhbGx5LCBhIHR5cGUgaXMgYSBzZXQgb2YgdmFsdWVzLiBPbmUgY2FuIHRoaW5rIG9mIGEgdmFsdWUgb2ZcbiAgLy8uIHR5cGUgYFR5cGVgIGFzIGEgZnVuY3Rpb24gb2YgdHlwZSBgQW55IC0+IEJvb2xlYW5gIHdoaWNoIHRlc3RzIHZhbHVlc1xuICAvLy4gZm9yIG1lbWJlcnNoaXAgaW4gdGhlIHNldCAodGhvdWdoIHRoaXMgaXMgYW4gb3ZlcnNpbXBsaWZpY2F0aW9uKS5cblxuICAvLyMgQW55IDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgSmF2YVNjcmlwdCB2YWx1ZS5cbiAgdmFyIEFueSA9IE51bGxhcnlUeXBlV2l0aFVybCgnc2FuY3R1YXJ5LWRlZi9BbnknLCBLKHRydWUpKTtcblxuICAvLyMgQW55RnVuY3Rpb24gOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBGdW5jdGlvbiB2YWx1ZS5cbiAgdmFyIEFueUZ1bmN0aW9uID0gTnVsbGFyeVR5cGVXaXRoVXJsKCdGdW5jdGlvbicsIHR5cGVvZkVxKCdmdW5jdGlvbicpKTtcblxuICAvLyMgQXJndW1lbnRzIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgW2Bhcmd1bWVudHNgXVthcmd1bWVudHNdIG9iamVjdC5cbiAgdmFyIEFyZ3VtZW50cyA9IE51bGxhcnlUeXBlV2l0aFVybCgnQXJndW1lbnRzJywgdHlwZUVxKCdBcmd1bWVudHMnKSk7XG5cbiAgLy8jIEFycmF5IDo6IFR5cGUgLT4gVHlwZVxuICAvLy5cbiAgLy8uIENvbnN0cnVjdG9yIGZvciBob21vZ2VuZW91cyBBcnJheSB0eXBlcy5cbiAgdmFyIEFycmF5XyA9IFVuYXJ5VHlwZVdpdGhVcmwoJ0FycmF5JywgdHlwZUVxKCdBcnJheScpLCBpZCk7XG5cbiAgLy8jIEJvb2xlYW4gOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBgdHJ1ZWAgYW5kIGBmYWxzZWAuXG4gIHZhciBCb29sZWFuXyA9IE51bGxhcnlUeXBlV2l0aFVybCgnQm9vbGVhbicsIHR5cGVvZkVxKCdib29sZWFuJykpO1xuXG4gIC8vIyBEYXRlIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgRGF0ZSB2YWx1ZS5cbiAgdmFyIERhdGVfID0gTnVsbGFyeVR5cGVXaXRoVXJsKCdEYXRlJywgdHlwZUVxKCdEYXRlJykpO1xuXG4gIC8vIyBFcnJvciA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IEVycm9yIHZhbHVlLCBpbmNsdWRpbmcgdmFsdWVzIG9mIG1vcmUgc3BlY2lmaWNcbiAgLy8uIGNvbnN0cnVjdG9ycyBzdWNoIGFzIFtgU3ludGF4RXJyb3JgXVtdIGFuZCBbYFR5cGVFcnJvcmBdW10uXG4gIHZhciBFcnJvcl8gPSBOdWxsYXJ5VHlwZVdpdGhVcmwoJ0Vycm9yJywgdHlwZUVxKCdFcnJvcicpKTtcblxuICAvLyMgRmluaXRlTnVtYmVyIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgW2BWYWxpZE51bWJlcmBdW10gdmFsdWUgZXhjZXB0IGBJbmZpbml0eWAgYW5kXG4gIC8vLiBgLUluZmluaXR5YC5cbiAgdmFyIEZpbml0ZU51bWJlciA9IE51bGxhcnlUeXBlV2l0aFVybChcbiAgICAnc2FuY3R1YXJ5LWRlZi9GaW5pdGVOdW1iZXInLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFZhbGlkTnVtYmVyLl90ZXN0KHgpICYmIGlzRmluaXRlKHgpOyB9XG4gICk7XG5cbiAgLy8jIEZ1bmN0aW9uIDo6IEFycmF5IFR5cGUgLT4gVHlwZVxuICAvLy5cbiAgLy8uIENvbnN0cnVjdG9yIGZvciBGdW5jdGlvbiB0eXBlcy5cbiAgLy8uXG4gIC8vLiBFeGFtcGxlczpcbiAgLy8uXG4gIC8vLiAgIC0gYCQuRnVuY3Rpb24oWyQuRGF0ZSwgJC5TdHJpbmddKWAgcmVwcmVzZW50cyB0aGUgYERhdGUgLT4gU3RyaW5nYFxuICAvLy4gICAgIHR5cGU7IGFuZFxuICAvLy4gICAtIGAkLkZ1bmN0aW9uKFthLCBiLCBhXSlgIHJlcHJlc2VudHMgdGhlIGAoYSwgYikgLT4gYWAgdHlwZS5cbiAgZnVuY3Rpb24gRnVuY3Rpb25fKHR5cGVzKSB7XG4gICAgZnVuY3Rpb24gZm9ybWF0KG91dGVyLCBpbm5lcikge1xuICAgICAgdmFyIHhzID0gdHlwZXMubWFwKGZ1bmN0aW9uKHQsIGlkeCkge1xuICAgICAgICByZXR1cm4gdW5sZXNzKHQudHlwZSA9PT0gUkVDT1JEIHx8IGlzRW1wdHkodC5rZXlzKSxcbiAgICAgICAgICAgICAgICAgICAgICBzdHJpcE91dGVybW9zdFBhcmVucyxcbiAgICAgICAgICAgICAgICAgICAgICBpbm5lcignJCcgKyBTdHJpbmcoaWR4ICsgMSkpKFN0cmluZyh0KSkpO1xuICAgICAgfSk7XG4gICAgICB2YXIgcGFyZW50aGVzaXplID0gd3JhcChvdXRlcignKCcpKShvdXRlcignKScpKTtcbiAgICAgIHJldHVybiBwYXJlbnRoZXNpemUodW5sZXNzKHR5cGVzLmxlbmd0aCA9PT0gMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudGhlc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXQoeHMpLmpvaW4ob3V0ZXIoJywgJykpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyKCcgLT4gJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0KHhzKSk7XG4gICAgfVxuXG4gICAgdmFyIHRlc3QgPSBBbnlGdW5jdGlvbi5fdGVzdDtcblxuICAgIHZhciAka2V5cyA9IFtdO1xuICAgIHZhciAkdHlwZXMgPSB7fTtcbiAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uKHQsIGlkeCkge1xuICAgICAgdmFyIGsgPSAnJCcgKyBTdHJpbmcoaWR4ICsgMSk7XG4gICAgICAka2V5cy5wdXNoKGspO1xuICAgICAgJHR5cGVzW2tdID0ge2V4dHJhY3RvcjogSyhbXSksIHR5cGU6IHR9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBfVHlwZShGVU5DVElPTiwgJycsICcnLCBmb3JtYXQsIHRlc3QsICRrZXlzLCAkdHlwZXMpO1xuICB9XG5cbiAgLy8jIEdsb2JhbFJlZ0V4cCA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFtgUmVnRXhwYF1bXSB2YWx1ZSB3aG9zZSBgZ2xvYmFsYCBmbGFnIGlzIGB0cnVlYC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYE5vbkdsb2JhbFJlZ0V4cGBdW10uXG4gIHZhciBHbG9iYWxSZWdFeHAgPSBOdWxsYXJ5VHlwZVdpdGhVcmwoXG4gICAgJ3NhbmN0dWFyeS1kZWYvR2xvYmFsUmVnRXhwJyxcbiAgICBmdW5jdGlvbih4KSB7IHJldHVybiBSZWdFeHBfLl90ZXN0KHgpICYmIHguZ2xvYmFsOyB9XG4gICk7XG5cbiAgLy8jIEludGVnZXIgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBpbnRlZ2VyIGluIHRoZSByYW5nZVxuICAvLy4gW1tgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJgXVttaW5dIC4uIFtgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgXVttYXhdXS5cbiAgdmFyIEludGVnZXIgPSBOdWxsYXJ5VHlwZVdpdGhVcmwoXG4gICAgJ3NhbmN0dWFyeS1kZWYvSW50ZWdlcicsXG4gICAgZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIFZhbGlkTnVtYmVyLl90ZXN0KHgpICYmXG4gICAgICAgICAgICAgTWF0aC5mbG9vcih4KSA9PT0geCAmJlxuICAgICAgICAgICAgIHggPj0gTUlOX1NBRkVfSU5URUdFUiAmJlxuICAgICAgICAgICAgIHggPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG4gICk7XG5cbiAgLy8jIE5lZ2F0aXZlRmluaXRlTnVtYmVyIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgW2BGaW5pdGVOdW1iZXJgXVtdIHZhbHVlIGxlc3MgdGhhbiB6ZXJvLlxuICB2YXIgTmVnYXRpdmVGaW5pdGVOdW1iZXIgPSBOdWxsYXJ5VHlwZVdpdGhVcmwoXG4gICAgJ3NhbmN0dWFyeS1kZWYvTmVnYXRpdmVGaW5pdGVOdW1iZXInLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIEZpbml0ZU51bWJlci5fdGVzdCh4KSAmJiB4IDwgMDsgfVxuICApO1xuXG4gIC8vIyBOZWdhdGl2ZUludGVnZXIgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBbYEludGVnZXJgXVtdIHZhbHVlIGxlc3MgdGhhbiB6ZXJvLlxuICB2YXIgTmVnYXRpdmVJbnRlZ2VyID0gTnVsbGFyeVR5cGVXaXRoVXJsKFxuICAgICdzYW5jdHVhcnktZGVmL05lZ2F0aXZlSW50ZWdlcicsXG4gICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gSW50ZWdlci5fdGVzdCh4KSAmJiB4IDwgMDsgfVxuICApO1xuXG4gIC8vIyBOZWdhdGl2ZU51bWJlciA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFtgTnVtYmVyYF1bXSB2YWx1ZSBsZXNzIHRoYW4gemVyby5cbiAgdmFyIE5lZ2F0aXZlTnVtYmVyID0gTnVsbGFyeVR5cGVXaXRoVXJsKFxuICAgICdzYW5jdHVhcnktZGVmL05lZ2F0aXZlTnVtYmVyJyxcbiAgICBmdW5jdGlvbih4KSB7IHJldHVybiBOdW1iZXJfLl90ZXN0KHgpICYmIHggPCAwOyB9XG4gICk7XG5cbiAgLy8jIE5vbkVtcHR5IDo6IFR5cGUgLT4gVHlwZVxuICAvLy5cbiAgLy8uIENvbnN0cnVjdG9yIGZvciBub24tZW1wdHkgdHlwZXMuIGAkLk5vbkVtcHR5KCQuU3RyaW5nKWAsIGZvciBleGFtcGxlLCBpc1xuICAvLy4gdGhlIHR5cGUgY29tcHJpc2luZyBldmVyeSBbYFN0cmluZ2BdW10gdmFsdWUgZXhjZXB0IGAnJ2AuXG4gIC8vLlxuICAvLy4gVGhlIGdpdmVuIHR5cGUgbXVzdCBzYXRpc2Z5IHRoZSBbTW9ub2lkXVtdIGFuZCBbU2V0b2lkXVtdIHNwZWNpZmljYXRpb25zLlxuICB2YXIgTm9uRW1wdHkgPSBVbmFyeVR5cGUoXG4gICAgJ3NhbmN0dWFyeS1kZWYvTm9uRW1wdHknLFxuICAgIGZ1bmN0aW9uVXJsKCdOb25FbXB0eScpLFxuICAgIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBaLk1vbm9pZC50ZXN0KHgpICYmXG4gICAgICAgICAgICAgWi5TZXRvaWQudGVzdCh4KSAmJlxuICAgICAgICAgICAgICFaLmVxdWFscyh4LCBaLmVtcHR5KHguY29uc3RydWN0b3IpKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uKG1vbm9pZCkgeyByZXR1cm4gW21vbm9pZF07IH1cbiAgKTtcblxuICAvLyMgTm9uR2xvYmFsUmVnRXhwIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgW2BSZWdFeHBgXVtdIHZhbHVlIHdob3NlIGBnbG9iYWxgIGZsYWcgaXMgYGZhbHNlYC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYEdsb2JhbFJlZ0V4cGBdW10uXG4gIHZhciBOb25HbG9iYWxSZWdFeHAgPSBOdWxsYXJ5VHlwZVdpdGhVcmwoXG4gICAgJ3NhbmN0dWFyeS1kZWYvTm9uR2xvYmFsUmVnRXhwJyxcbiAgICBmdW5jdGlvbih4KSB7IHJldHVybiBSZWdFeHBfLl90ZXN0KHgpICYmICF4Lmdsb2JhbDsgfVxuICApO1xuXG4gIC8vIyBOb25OZWdhdGl2ZUludGVnZXIgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBub24tbmVnYXRpdmUgW2BJbnRlZ2VyYF1bXSB2YWx1ZSAoaW5jbHVkaW5nIGAtMGApLlxuICAvLy4gQWxzbyBrbm93biBhcyB0aGUgc2V0IG9mIG5hdHVyYWwgbnVtYmVycyB1bmRlciBJU08gODAwMDAtMjoyMDA5LlxuICB2YXIgTm9uTmVnYXRpdmVJbnRlZ2VyID0gTnVsbGFyeVR5cGVXaXRoVXJsKFxuICAgICdzYW5jdHVhcnktZGVmL05vbk5lZ2F0aXZlSW50ZWdlcicsXG4gICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gSW50ZWdlci5fdGVzdCh4KSAmJiB4ID49IDA7IH1cbiAgKTtcblxuICAvLyMgTm9uWmVyb0Zpbml0ZU51bWJlciA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFtgRmluaXRlTnVtYmVyYF1bXSB2YWx1ZSBleGNlcHQgYDBgIGFuZCBgLTBgLlxuICB2YXIgTm9uWmVyb0Zpbml0ZU51bWJlciA9IE51bGxhcnlUeXBlV2l0aFVybChcbiAgICAnc2FuY3R1YXJ5LWRlZi9Ob25aZXJvRmluaXRlTnVtYmVyJyxcbiAgICBmdW5jdGlvbih4KSB7IHJldHVybiBGaW5pdGVOdW1iZXIuX3Rlc3QoeCkgJiYgeCAhPT0gMDsgfVxuICApO1xuXG4gIC8vIyBOb25aZXJvSW50ZWdlciA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFtgSW50ZWdlcmBdW10gdmFsdWUgZXhjZXB0IGAwYCBhbmQgYC0wYC5cbiAgdmFyIE5vblplcm9JbnRlZ2VyID0gTnVsbGFyeVR5cGVXaXRoVXJsKFxuICAgICdzYW5jdHVhcnktZGVmL05vblplcm9JbnRlZ2VyJyxcbiAgICBmdW5jdGlvbih4KSB7IHJldHVybiBJbnRlZ2VyLl90ZXN0KHgpICYmIHggIT09IDA7IH1cbiAgKTtcblxuICAvLyMgTm9uWmVyb1ZhbGlkTnVtYmVyIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgW2BWYWxpZE51bWJlcmBdW10gdmFsdWUgZXhjZXB0IGAwYCBhbmQgYC0wYC5cbiAgdmFyIE5vblplcm9WYWxpZE51bWJlciA9IE51bGxhcnlUeXBlV2l0aFVybChcbiAgICAnc2FuY3R1YXJ5LWRlZi9Ob25aZXJvVmFsaWROdW1iZXInLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFZhbGlkTnVtYmVyLl90ZXN0KHgpICYmIHggIT09IDA7IH1cbiAgKTtcblxuICAvLyMgTnVsbCA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSB3aG9zZSBzb2xlIG1lbWJlciBpcyBgbnVsbGAuXG4gIHZhciBOdWxsID0gTnVsbGFyeVR5cGVXaXRoVXJsKCdOdWxsJywgdHlwZUVxKCdOdWxsJykpO1xuXG4gIC8vIyBOdWxsYWJsZSA6OiBUeXBlIC0+IFR5cGVcbiAgLy8uXG4gIC8vLiBDb25zdHJ1Y3RvciBmb3IgdHlwZXMgd2hpY2ggaW5jbHVkZSBgbnVsbGAgYXMgYSBtZW1iZXIuXG4gIHZhciBOdWxsYWJsZSA9IFVuYXJ5VHlwZVdpdGhVcmwoXG4gICAgJ3NhbmN0dWFyeS1kZWYvTnVsbGFibGUnLFxuICAgIEsodHJ1ZSksXG4gICAgZnVuY3Rpb24obnVsbGFibGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgIHJldHVybiBudWxsYWJsZSA9PT0gbnVsbCA/IFtdIDogW251bGxhYmxlXTtcbiAgICB9XG4gICk7XG5cbiAgLy8jIE51bWJlciA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IHByaW1pdGl2ZSBOdW1iZXIgdmFsdWUgKGluY2x1ZGluZyBgTmFOYCkuXG4gIHZhciBOdW1iZXJfID0gTnVsbGFyeVR5cGVXaXRoVXJsKCdOdW1iZXInLCB0eXBlb2ZFcSgnbnVtYmVyJykpO1xuXG4gIC8vIyBPYmplY3QgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBcInBsYWluXCIgT2JqZWN0IHZhbHVlLiBTcGVjaWZpY2FsbHksIHZhbHVlc1xuICAvLy4gY3JlYXRlZCB2aWE6XG4gIC8vLlxuICAvLy4gICAtIG9iamVjdCBsaXRlcmFsIHN5bnRheDtcbiAgLy8uICAgLSBbYE9iamVjdC5jcmVhdGVgXVtdOyBvclxuICAvLy4gICAtIHRoZSBgbmV3YCBvcGVyYXRvciBpbiBjb25qdW5jdGlvbiB3aXRoIGBPYmplY3RgIG9yIGEgY3VzdG9tXG4gIC8vLiAgICAgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gIHZhciBPYmplY3RfID0gTnVsbGFyeVR5cGVXaXRoVXJsKCdPYmplY3QnLCB0eXBlRXEoJ09iamVjdCcpKTtcblxuICAvLyMgUGFpciA6OiBUeXBlIC0+IFR5cGUgLT4gVHlwZVxuICAvLy5cbiAgLy8uIENvbnN0cnVjdG9yIGZvciB0dXBsZSB0eXBlcyBvZiBsZW5ndGggMi4gQXJyYXlzIGFyZSBzYWlkIHRvIHJlcHJlc2VudFxuICAvLy4gdHVwbGVzLiBgWydmb28nLCA0Ml1gIGlzIGEgbWVtYmVyIG9mIGBQYWlyIFN0cmluZyBOdW1iZXJgLlxuICB2YXIgUGFpciA9IEJpbmFyeVR5cGVXaXRoVXJsKFxuICAgICdzYW5jdHVhcnktZGVmL1BhaXInLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHR5cGVFcSgnQXJyYXknKSh4KSAmJiB4Lmxlbmd0aCA9PT0gMjsgfSxcbiAgICBmdW5jdGlvbihwYWlyKSB7IHJldHVybiBbcGFpclswXV07IH0sXG4gICAgZnVuY3Rpb24ocGFpcikgeyByZXR1cm4gW3BhaXJbMV1dOyB9XG4gICk7XG5cbiAgLy8jIFBvc2l0aXZlRmluaXRlTnVtYmVyIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgW2BGaW5pdGVOdW1iZXJgXVtdIHZhbHVlIGdyZWF0ZXIgdGhhbiB6ZXJvLlxuICB2YXIgUG9zaXRpdmVGaW5pdGVOdW1iZXIgPSBOdWxsYXJ5VHlwZVdpdGhVcmwoXG4gICAgJ3NhbmN0dWFyeS1kZWYvUG9zaXRpdmVGaW5pdGVOdW1iZXInLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIEZpbml0ZU51bWJlci5fdGVzdCh4KSAmJiB4ID4gMDsgfVxuICApO1xuXG4gIC8vIyBQb3NpdGl2ZUludGVnZXIgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBbYEludGVnZXJgXVtdIHZhbHVlIGdyZWF0ZXIgdGhhbiB6ZXJvLlxuICB2YXIgUG9zaXRpdmVJbnRlZ2VyID0gTnVsbGFyeVR5cGVXaXRoVXJsKFxuICAgICdzYW5jdHVhcnktZGVmL1Bvc2l0aXZlSW50ZWdlcicsXG4gICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gSW50ZWdlci5fdGVzdCh4KSAmJiB4ID4gMDsgfVxuICApO1xuXG4gIC8vIyBQb3NpdGl2ZU51bWJlciA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFtgTnVtYmVyYF1bXSB2YWx1ZSBncmVhdGVyIHRoYW4gemVyby5cbiAgdmFyIFBvc2l0aXZlTnVtYmVyID0gTnVsbGFyeVR5cGVXaXRoVXJsKFxuICAgICdzYW5jdHVhcnktZGVmL1Bvc2l0aXZlTnVtYmVyJyxcbiAgICBmdW5jdGlvbih4KSB7IHJldHVybiBOdW1iZXJfLl90ZXN0KHgpICYmIHggPiAwOyB9XG4gICk7XG5cbiAgLy8jIFJlZ0V4cCA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFJlZ0V4cCB2YWx1ZS5cbiAgdmFyIFJlZ0V4cF8gPSBOdWxsYXJ5VHlwZVdpdGhVcmwoJ1JlZ0V4cCcsIHR5cGVFcSgnUmVnRXhwJykpO1xuXG4gIC8vIyBSZWdleEZsYWdzIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgdGhlIGNhbm9uaWNhbCBSZWdFeHAgZmxhZ3M6XG4gIC8vLlxuICAvLy4gICAtIGAnJ2BcbiAgLy8uICAgLSBgJ2cnYFxuICAvLy4gICAtIGAnaSdgXG4gIC8vLiAgIC0gYCdtJ2BcbiAgLy8uICAgLSBgJ2dpJ2BcbiAgLy8uICAgLSBgJ2dtJ2BcbiAgLy8uICAgLSBgJ2ltJ2BcbiAgLy8uICAgLSBgJ2dpbSdgXG4gIHZhciBSZWdleEZsYWdzID0gRW51bVR5cGVXaXRoVXJsKFxuICAgICdzYW5jdHVhcnktZGVmL1JlZ2V4RmxhZ3MnLFxuICAgIFsnJywgJ2cnLCAnaScsICdtJywgJ2dpJywgJ2dtJywgJ2ltJywgJ2dpbSddXG4gICk7XG5cbiAgLy8jIFN0ck1hcCA6OiBUeXBlIC0+IFR5cGVcbiAgLy8uXG4gIC8vLiBDb25zdHJ1Y3RvciBmb3IgaG9tb2dlbmVvdXMgT2JqZWN0IHR5cGVzLlxuICAvLy5cbiAgLy8uIGB7Zm9vOiAxLCBiYXI6IDIsIGJhejogM31gLCBmb3IgZXhhbXBsZSwgaXMgYSBtZW1iZXIgb2YgYFN0ck1hcCBOdW1iZXJgO1xuICAvLy4gYHtmb286IDEsIGJhcjogMiwgYmF6OiAnWFhYJ31gIGlzIG5vdC5cbiAgdmFyIFN0ck1hcCA9IFVuYXJ5VHlwZVdpdGhVcmwoXG4gICAgJ3NhbmN0dWFyeS1kZWYvU3RyTWFwJyxcbiAgICBPYmplY3RfLl90ZXN0LFxuICAgIGZ1bmN0aW9uKHN0ck1hcCkge1xuICAgICAgcmV0dXJuIFoucmVkdWNlKGZ1bmN0aW9uKHhzLCB4KSB7IHJldHVybiB4cy5jb25jYXQoW3hdKTsgfSwgW10sIHN0ck1hcCk7XG4gICAgfVxuICApO1xuXG4gIC8vIyBTdHJpbmcgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBwcmltaXRpdmUgU3RyaW5nIHZhbHVlLlxuICB2YXIgU3RyaW5nXyA9IE51bGxhcnlUeXBlV2l0aFVybCgnU3RyaW5nJywgdHlwZW9mRXEoJ3N0cmluZycpKTtcblxuICAvLyMgU3ltYm9sIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgU3ltYm9sIHZhbHVlLlxuICB2YXIgU3ltYm9sXyA9IE51bGxhcnlUeXBlV2l0aFVybCgnU3ltYm9sJywgdHlwZW9mRXEoJ3N5bWJvbCcpKTtcblxuICAvLyMgVHlwZSA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IGBUeXBlYCB2YWx1ZS5cbiAgdmFyIFR5cGUgPSBOdWxsYXJ5VHlwZVdpdGhVcmwoJ1R5cGUnLCB0eXBlRXEoJ3NhbmN0dWFyeS1kZWYvVHlwZScpKTtcblxuICAvLyMgVHlwZUNsYXNzIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgW2BUeXBlQ2xhc3NgXVtdIHZhbHVlLlxuICB2YXIgVHlwZUNsYXNzID1cbiAgTnVsbGFyeVR5cGVXaXRoVXJsKCdUeXBlQ2xhc3MnLCB0eXBlRXEoJ3NhbmN0dWFyeS10eXBlLWNsYXNzZXMvVHlwZUNsYXNzJykpO1xuXG4gIC8vIyBVbmRlZmluZWQgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgd2hvc2Ugc29sZSBtZW1iZXIgaXMgYHVuZGVmaW5lZGAuXG4gIHZhciBVbmRlZmluZWQgPSBOdWxsYXJ5VHlwZVdpdGhVcmwoJ1VuZGVmaW5lZCcsIHR5cGVFcSgnVW5kZWZpbmVkJykpO1xuXG4gIC8vIyBVbmtub3duIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIHVzZWQgdG8gcmVwcmVzZW50IG1pc3NpbmcgdHlwZSBpbmZvcm1hdGlvbi4gVGhlIHR5cGUgb2YgYFtdYCxcbiAgLy8uIGZvciBleGFtcGxlLCBpcyBgQXJyYXkgPz8/YC5cbiAgLy8uXG4gIC8vLiBNYXkgYmUgdXNlZCB3aXRoIHR5cGUgY29uc3RydWN0b3JzIHdoZW4gZGVmaW5pbmcgZW52aXJvbm1lbnRzLiBHaXZlbiBhXG4gIC8vLiB0eXBlIGNvbnN0cnVjdG9yIGBMaXN0IDo6IFR5cGUgLT4gVHlwZWAsIG9uZSBjb3VsZCB1c2UgYExpc3QoJC5Vbmtub3duKWBcbiAgLy8uIHRvIGluY2x1ZGUgYW4gaW5maW5pdGUgbnVtYmVyIG9mIHR5cGVzIGluIGFuIGVudmlyb25tZW50OlxuICAvLy5cbiAgLy8uICAgLSBgTGlzdCBOdW1iZXJgXG4gIC8vLiAgIC0gYExpc3QgU3RyaW5nYFxuICAvLy4gICAtIGBMaXN0IChMaXN0IE51bWJlcilgXG4gIC8vLiAgIC0gYExpc3QgKExpc3QgU3RyaW5nKWBcbiAgLy8uICAgLSBgTGlzdCAoTGlzdCAoTGlzdCBOdW1iZXIpKWBcbiAgLy8uICAgLSBgTGlzdCAoTGlzdCAoTGlzdCBTdHJpbmcpKWBcbiAgLy8uICAgLSBgLi4uYFxuICB2YXIgVW5rbm93biA9XG4gIG5ldyBfVHlwZShVTktOT1dOLCAnJywgJycsIGFsd2F5czIoJ1Vua25vd24nKSwgSyh0cnVlKSwgW10sIHt9KTtcblxuICAvLyMgVmFsaWREYXRlIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgW2BEYXRlYF1bXSB2YWx1ZSBleGNlcHQgYG5ldyBEYXRlKE5hTilgLlxuICB2YXIgVmFsaWREYXRlID0gTnVsbGFyeVR5cGVXaXRoVXJsKFxuICAgICdzYW5jdHVhcnktZGVmL1ZhbGlkRGF0ZScsXG4gICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gRGF0ZV8uX3Rlc3QoeCkgJiYgIWlzTmFOKHgudmFsdWVPZigpKTsgfVxuICApO1xuXG4gIC8vIyBWYWxpZE51bWJlciA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFtgTnVtYmVyYF1bXSB2YWx1ZSBleGNlcHQgYE5hTmAuXG4gIHZhciBWYWxpZE51bWJlciA9IE51bGxhcnlUeXBlV2l0aFVybChcbiAgICAnc2FuY3R1YXJ5LWRlZi9WYWxpZE51bWJlcicsXG4gICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gTnVtYmVyXy5fdGVzdCh4KSAmJiAhaXNOYU4oeCk7IH1cbiAgKTtcblxuICAvLyMgZW52IDo6IEFycmF5IFR5cGVcbiAgLy8uXG4gIC8vLiBBbiBhcnJheSBvZiBbdHlwZXNdW106XG4gIC8vLlxuICAvLy4gICAtIDxjb2RlPltBbnlGdW5jdGlvbl0oI0FueUZ1bmN0aW9uKTwvY29kZT5cbiAgLy8uICAgLSA8Y29kZT5bQXJndW1lbnRzXSgjQXJndW1lbnRzKTwvY29kZT5cbiAgLy8uICAgLSA8Y29kZT5bQXJyYXldKCNBcnJheSkoW1Vua25vd25dKCNVbmtub3duKSk8L2NvZGU+XG4gIC8vLiAgIC0gPGNvZGU+W0Jvb2xlYW5dKCNCb29sZWFuKTwvY29kZT5cbiAgLy8uICAgLSA8Y29kZT5bRGF0ZV0oI0RhdGUpPC9jb2RlPlxuICAvLy4gICAtIDxjb2RlPltFcnJvcl0oI0Vycm9yKTwvY29kZT5cbiAgLy8uICAgLSA8Y29kZT5bTnVsbF0oI051bGwpPC9jb2RlPlxuICAvLy4gICAtIDxjb2RlPltOdW1iZXJdKCNOdW1iZXIpPC9jb2RlPlxuICAvLy4gICAtIDxjb2RlPltPYmplY3RdKCNPYmplY3QpPC9jb2RlPlxuICAvLy4gICAtIDxjb2RlPltSZWdFeHBdKCNSZWdFeHApPC9jb2RlPlxuICAvLy4gICAtIDxjb2RlPltTdHJNYXBdKCNTdHJNYXApKFtVbmtub3duXSgjVW5rbm93bikpPC9jb2RlPlxuICAvLy4gICAtIDxjb2RlPltTdHJpbmddKCNTdHJpbmcpPC9jb2RlPlxuICAvLy4gICAtIDxjb2RlPltTeW1ib2xdKCNTeW1ib2wpPC9jb2RlPlxuICAvLy4gICAtIDxjb2RlPltVbmRlZmluZWRdKCNVbmRlZmluZWQpPC9jb2RlPlxuICB2YXIgZW52ID0gW1xuICAgIEFueUZ1bmN0aW9uLFxuICAgIEFyZ3VtZW50cyxcbiAgICBBcnJheV8oVW5rbm93biksXG4gICAgQm9vbGVhbl8sXG4gICAgRGF0ZV8sXG4gICAgRXJyb3JfLFxuICAgIE51bGwsXG4gICAgTnVtYmVyXyxcbiAgICBPYmplY3RfLFxuICAgIFJlZ0V4cF8sXG4gICAgU3RyTWFwKFVua25vd24pLFxuICAgIFN0cmluZ18sXG4gICAgU3ltYm9sXyxcbiAgICBVbmRlZmluZWRcbiAgXTtcblxuICAvLyAgVW5jaGVja2VkIDo6IFN0cmluZyAtPiBUeXBlXG4gIGZ1bmN0aW9uIFVuY2hlY2tlZChzKSB7IHJldHVybiBOdWxsYXJ5VHlwZShzLCAnJywgSyh0cnVlKSk7IH1cblxuICB2YXIgZGVmID0gX2NyZWF0ZSh7Y2hlY2tUeXBlczogdHJ1ZSwgZW52OiBlbnZ9KTtcblxuICAvLyAgYXJpdHkgOjogKE51bWJlciwgRnVuY3Rpb24pIC0+IEZ1bmN0aW9uXG4gIGZ1bmN0aW9uIGFyaXR5KG4sIGYpIHtcbiAgICByZXR1cm4gKFxuICAgICAgbiA9PT0gMCA/XG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gOlxuICAgICAgbiA9PT0gMSA/XG4gICAgICAgIGZ1bmN0aW9uKCQxKSB7XG4gICAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSA6XG4gICAgICBuID09PSAyID9cbiAgICAgICAgZnVuY3Rpb24oJDEsICQyKSB7XG4gICAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSA6XG4gICAgICBuID09PSAzID9cbiAgICAgICAgZnVuY3Rpb24oJDEsICQyLCAkMykge1xuICAgICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gOlxuICAgICAgbiA9PT0gNCA/XG4gICAgICAgIGZ1bmN0aW9uKCQxLCAkMiwgJDMsICQ0KSB7XG4gICAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSA6XG4gICAgICBuID09PSA1ID9cbiAgICAgICAgZnVuY3Rpb24oJDEsICQyLCAkMywgJDQsICQ1KSB7XG4gICAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSA6XG4gICAgICBuID09PSA2ID9cbiAgICAgICAgZnVuY3Rpb24oJDEsICQyLCAkMywgJDQsICQ1LCAkNikge1xuICAgICAgICAgIHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gOlxuICAgICAgbiA9PT0gNyA/XG4gICAgICAgIGZ1bmN0aW9uKCQxLCAkMiwgJDMsICQ0LCAkNSwgJDYsICQ3KSB7XG4gICAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSA6XG4gICAgICBuID09PSA4ID9cbiAgICAgICAgZnVuY3Rpb24oJDEsICQyLCAkMywgJDQsICQ1LCAkNiwgJDcsICQ4KSB7XG4gICAgICAgICAgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSA6XG4gICAgICAvLyBlbHNlXG4gICAgICAgIGZ1bmN0aW9uKCQxLCAkMiwgJDMsICQ0LCAkNSwgJDYsICQ3LCAkOCwgJDkpIHtcbiAgICAgICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8vICBudW1BcmdzIDo6IE51bWJlciAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gbnVtQXJncyhuKSB7XG4gICAgc3dpdGNoIChuKSB7XG4gICAgICBjYXNlICAwOiAgcmV0dXJuICAnemVybyBhcmd1bWVudHMnO1xuICAgICAgY2FzZSAgMTogIHJldHVybiAgICdvbmUgYXJndW1lbnQnO1xuICAgICAgY2FzZSAgMjogIHJldHVybiAgICd0d28gYXJndW1lbnRzJztcbiAgICAgIGNhc2UgIDM6ICByZXR1cm4gJ3RocmVlIGFyZ3VtZW50cyc7XG4gICAgICBjYXNlICA0OiAgcmV0dXJuICAnZm91ciBhcmd1bWVudHMnO1xuICAgICAgY2FzZSAgNTogIHJldHVybiAgJ2ZpdmUgYXJndW1lbnRzJztcbiAgICAgIGNhc2UgIDY6ICByZXR1cm4gICAnc2l4IGFyZ3VtZW50cyc7XG4gICAgICBjYXNlICA3OiAgcmV0dXJuICdzZXZlbiBhcmd1bWVudHMnO1xuICAgICAgY2FzZSAgODogIHJldHVybiAnZWlnaHQgYXJndW1lbnRzJztcbiAgICAgIGNhc2UgIDk6ICByZXR1cm4gICduaW5lIGFyZ3VtZW50cyc7XG4gICAgICBkZWZhdWx0OiAgcmV0dXJuICBuICsgJyBhcmd1bWVudHMnO1xuICAgIH1cbiAgfVxuXG4gIC8vICBleHBhbmRVbmtub3duIDo6IC4uLiAtPiBBcnJheSBUeXBlXG4gIGZ1bmN0aW9uIGV4cGFuZFVua25vd24oXG4gICAgZW52LCAgICAgICAgICAgIC8vIDo6IEFycmF5IFR5cGVcbiAgICBzZWVuLCAgICAgICAgICAgLy8gOjogQXJyYXkgT2JqZWN0XG4gICAgdmFsdWUsICAgICAgICAgIC8vIDo6IEFueVxuICAgIHIgICAgICAgICAgICAgICAvLyA6OiB7IGV4dHJhY3RvciA6OiBhIC0+IEFycmF5IGIsIHR5cGUgOjogVHlwZSB9XG4gICkge1xuICAgIHJldHVybiByLnR5cGUudHlwZSA9PT0gVU5LTk9XTiA/XG4gICAgICBfZGV0ZXJtaW5lQWN0dWFsVHlwZXMoZW52LCBzZWVuLCByLmV4dHJhY3Rvcih2YWx1ZSkpIDpcbiAgICAgIFtyLnR5cGVdO1xuICB9XG5cbiAgLy8gIF9kZXRlcm1pbmVBY3R1YWxUeXBlcyA6OiAuLi4gLT4gQXJyYXkgVHlwZVxuICBmdW5jdGlvbiBfZGV0ZXJtaW5lQWN0dWFsVHlwZXMoXG4gICAgZW52LCAgICAgICAgICAgIC8vIDo6IEFycmF5IFR5cGVcbiAgICBzZWVuLCAgICAgICAgICAgLy8gOjogQXJyYXkgT2JqZWN0XG4gICAgdmFsdWVzICAgICAgICAgIC8vIDo6IEFycmF5IEFueVxuICApIHtcbiAgICBmdW5jdGlvbiByZWZpbmUodHlwZXMsIHZhbHVlKSB7XG4gICAgICB2YXIgc2VlbiQ7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPSBudWxsIHx8XG4gICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICBBYm9ydCBpZiBhIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyBlbmNvdW50ZXJlZDsgYWRkIHRoZSBjdXJyZW50XG4gICAgICAgIC8vICBvYmplY3QgdG8gdGhlIGFycmF5IG9mIHNlZW4gb2JqZWN0cyBvdGhlcndpc2UuXG4gICAgICAgIGlmIChzZWVuLmluZGV4T2YodmFsdWUpID49IDApIHJldHVybiBbXTtcbiAgICAgICAgc2VlbiQgPSBaLmNvbmNhdChzZWVuLCBbdmFsdWVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZW4kID0gc2VlbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBaLmNoYWluKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0Lm5hbWUgPT09ICdzYW5jdHVhcnktZGVmL051bGxhYmxlJyB8fCB0LnZhbGlkYXRlKHZhbHVlKS5pc0xlZnQgP1xuICAgICAgICAgICAgW10gOlxuICAgICAgICAgIHQudHlwZSA9PT0gVU5BUlkgP1xuICAgICAgICAgICAgWi5tYXAoZnJvbVVuYXJ5VHlwZSh0KSxcbiAgICAgICAgICAgICAgICAgIGV4cGFuZFVua25vd24oZW52LCBzZWVuJCwgdmFsdWUsIHQudHlwZXMuJDEpKSA6XG4gICAgICAgICAgdC50eXBlID09PSBCSU5BUlkgP1xuICAgICAgICAgICAgeHByb2QodCxcbiAgICAgICAgICAgICAgICAgIGV4cGFuZFVua25vd24oZW52LCBzZWVuJCwgdmFsdWUsIHQudHlwZXMuJDEpLFxuICAgICAgICAgICAgICAgICAgZXhwYW5kVW5rbm93bihlbnYsIHNlZW4kLCB2YWx1ZSwgdC50eXBlcy4kMikpIDpcbiAgICAgICAgICAvLyBlbHNlXG4gICAgICAgICAgICBbdF1cbiAgICAgICAgKTtcbiAgICAgIH0sIHR5cGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNFbXB0eSh2YWx1ZXMpID9cbiAgICAgIFtVbmtub3duXSA6XG4gICAgICBvcihaLnJlZHVjZShyZWZpbmUsIGVudiwgdmFsdWVzKSwgW0luY29uc2lzdGVudF0pO1xuICB9XG5cbiAgLy8gIGlzQ29uc2lzdGVudCA6OiBUeXBlIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gaXNDb25zaXN0ZW50KHQpIHtcbiAgICByZXR1cm4gdC50eXBlID09PSBVTkFSWSAgID8gaXNDb25zaXN0ZW50KHQudHlwZXMuJDEudHlwZSkgOlxuICAgICAgICAgICB0LnR5cGUgPT09IEJJTkFSWSAgPyBpc0NvbnNpc3RlbnQodC50eXBlcy4kMS50eXBlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbnNpc3RlbnQodC50eXBlcy4kMi50eXBlKSA6XG4gICAgICAgICAgIC8qIGVsc2UgKi8gICAgICAgICAgIHQudHlwZSAhPT0gSU5DT05TSVNURU5UO1xuICB9XG5cbiAgLy8gIGRldGVybWluZUFjdHVhbFR5cGVzU3RyaWN0IDo6IChBcnJheSBUeXBlLCBBcnJheSBBbnkpIC0+IEFycmF5IFR5cGVcbiAgZnVuY3Rpb24gZGV0ZXJtaW5lQWN0dWFsVHlwZXNTdHJpY3QoZW52LCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gX2RldGVybWluZUFjdHVhbFR5cGVzKGVudiwgW10sIHZhbHVlcylcbiAgICAgICAgICAgLmZpbHRlcihpc0NvbnNpc3RlbnQpO1xuICB9XG5cbiAgLy8gIGRldGVybWluZUFjdHVhbFR5cGVzTG9vc2UgOjogKEFycmF5IFR5cGUsIEFycmF5IEFueSkgLT4gQXJyYXkgVHlwZVxuICBmdW5jdGlvbiBkZXRlcm1pbmVBY3R1YWxUeXBlc0xvb3NlKGVudiwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIF9kZXRlcm1pbmVBY3R1YWxUeXBlcyhlbnYsIFtdLCB2YWx1ZXMpXG4gICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24odCkgeyByZXR1cm4gdC50eXBlICE9PSBJTkNPTlNJU1RFTlQ7IH0pO1xuICB9XG5cbiAgLy8gIFR5cGVJbmZvID0geyBuYW1lIDo6IFN0cmluZ1xuICAvLyAgICAgICAgICAgICAsIGNvbnN0cmFpbnRzIDo6IFN0ck1hcCAoQXJyYXkgVHlwZUNsYXNzKVxuICAvLyAgICAgICAgICAgICAsIHR5cGVzIDo6IEFycmF5IFR5cGUgfVxuICAvL1xuICAvLyAgVHlwZVZhck1hcCA9IFN0ck1hcCB7IHR5cGVzIDo6IEFycmF5IFR5cGVcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgLCB2YWx1ZXNCeVBhdGggOjogU3RyTWFwIChBcnJheSBBbnkpIH1cbiAgLy9cbiAgLy8gIFByb3BQYXRoID0gQXJyYXkgKE51bWJlciB8IFN0cmluZylcblxuICAvLyAgdXBkYXRlVHlwZVZhck1hcCA6OiAuLi4gLT4gVHlwZVZhck1hcFxuICBmdW5jdGlvbiB1cGRhdGVUeXBlVmFyTWFwKFxuICAgIGVudiwgICAgICAgICAgICAvLyA6OiBBcnJheSBUeXBlXG4gICAgdHlwZVZhck1hcCwgICAgIC8vIDo6IFR5cGVWYXJNYXBcbiAgICB0eXBlVmFyLCAgICAgICAgLy8gOjogVHlwZVxuICAgIGluZGV4LCAgICAgICAgICAvLyA6OiBJbnRlZ2VyXG4gICAgcHJvcFBhdGgsICAgICAgIC8vIDo6IFByb3BQYXRoXG4gICAgdmFsdWVzICAgICAgICAgIC8vIDo6IEFycmF5IEFueVxuICApIHtcbiAgICB2YXIgJHR5cGVWYXJNYXAgPSB7fTtcbiAgICBmb3IgKHZhciB0eXBlVmFyTmFtZSBpbiB0eXBlVmFyTWFwKSB7XG4gICAgICB2YXIgZW50cnkgPSB0eXBlVmFyTWFwW3R5cGVWYXJOYW1lXTtcbiAgICAgIHZhciAkZW50cnkgPSB7dHlwZXM6IGVudHJ5LnR5cGVzLnNsaWNlKCksIHZhbHVlc0J5UGF0aDoge319O1xuICAgICAgZm9yICh2YXIgayBpbiBlbnRyeS52YWx1ZXNCeVBhdGgpIHtcbiAgICAgICAgJGVudHJ5LnZhbHVlc0J5UGF0aFtrXSA9IGVudHJ5LnZhbHVlc0J5UGF0aFtrXS5zbGljZSgpO1xuICAgICAgfVxuICAgICAgJHR5cGVWYXJNYXBbdHlwZVZhck5hbWVdID0gJGVudHJ5O1xuICAgIH1cbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoJHR5cGVWYXJNYXAsIHR5cGVWYXIubmFtZSkpIHtcbiAgICAgICR0eXBlVmFyTWFwW3R5cGVWYXIubmFtZV0gPSB7dHlwZXM6IGVudi5zbGljZSgpLCB2YWx1ZXNCeVBhdGg6IHt9fTtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gSlNPTi5zdHJpbmdpZnkoWi5jb25jYXQoW2luZGV4XSwgcHJvcFBhdGgpKTtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoJHR5cGVWYXJNYXBbdHlwZVZhci5uYW1lXS52YWx1ZXNCeVBhdGgsIGtleSkpIHtcbiAgICAgICR0eXBlVmFyTWFwW3R5cGVWYXIubmFtZV0udmFsdWVzQnlQYXRoW2tleV0gPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgaXNOdWxsYXJ5VHlwZVZhciA9IGlzRW1wdHkodHlwZVZhci5rZXlzKTtcblxuICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAkdHlwZVZhck1hcFt0eXBlVmFyLm5hbWVdLnZhbHVlc0J5UGF0aFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgJHR5cGVWYXJNYXBbdHlwZVZhci5uYW1lXS50eXBlcyA9IFouY2hhaW4oXG4gICAgICAgIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICB2YXIgeHM7XG4gICAgICAgICAgdmFyIGludmFsaWQgPSAhdGVzdChlbnYsIHQsIHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW52YWxpZCA/XG4gICAgICAgICAgICAgIFtdIDpcbiAgICAgICAgICAgIHQudHlwZSA9PT0gVU5BUlkgP1xuICAgICAgICAgICAgICBpc051bGxhcnlUeXBlVmFyICYmXG4gICAgICAgICAgICAgIHQudHlwZXMuJDEudHlwZS50eXBlID09PSBVTktOT1dOICYmXG4gICAgICAgICAgICAgICFpc0VtcHR5KHhzID0gdC50eXBlcy4kMS5leHRyYWN0b3IodmFsdWUpKSA/XG4gICAgICAgICAgICAgICAgWi5tYXAoZnJvbVVuYXJ5VHlwZSh0KSxcbiAgICAgICAgICAgICAgICAgICAgICBkZXRlcm1pbmVBY3R1YWxUeXBlc1N0cmljdChlbnYsIHhzKSkgOlxuICAgICAgICAgICAgICAgIFt0XSA6XG4gICAgICAgICAgICB0LnR5cGUgPT09IEJJTkFSWSA/XG4gICAgICAgICAgICAgIGlzTnVsbGFyeVR5cGVWYXIgP1xuICAgICAgICAgICAgICAgIHhwcm9kKHQsXG4gICAgICAgICAgICAgICAgICAgICAgdC50eXBlcy4kMS50eXBlLnR5cGUgPT09IFVOS05PV04gJiZcbiAgICAgICAgICAgICAgICAgICAgICAhaXNFbXB0eSh4cyA9IHQudHlwZXMuJDEuZXh0cmFjdG9yKHZhbHVlKSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZXJtaW5lQWN0dWFsVHlwZXNTdHJpY3QoZW52LCB4cykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgW3QudHlwZXMuJDEudHlwZV0sXG4gICAgICAgICAgICAgICAgICAgICAgdC50eXBlcy4kMi50eXBlLnR5cGUgPT09IFVOS05PV04gJiZcbiAgICAgICAgICAgICAgICAgICAgICAhaXNFbXB0eSh4cyA9IHQudHlwZXMuJDIuZXh0cmFjdG9yKHZhbHVlKSkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZXJtaW5lQWN0dWFsVHlwZXNTdHJpY3QoZW52LCB4cykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgW3QudHlwZXMuJDIudHlwZV0pIDpcbiAgICAgICAgICAgICAgICBbdF0gOlxuICAgICAgICAgICAgLy8gZWxzZVxuICAgICAgICAgICAgICBbdF1cbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICAkdHlwZVZhck1hcFt0eXBlVmFyLm5hbWVdLnR5cGVzXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuICR0eXBlVmFyTWFwO1xuICB9XG5cbiAgLy8gIHVuZGVybGluZVR5cGVWYXJzIDo6IChUeXBlSW5mbywgU3RyTWFwIChBcnJheSBBbnkpKSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gdW5kZXJsaW5lVHlwZVZhcnModHlwZUluZm8sIHZhbHVlc0J5UGF0aCkge1xuICAgIC8vICBOb3RlOiBTb3J0aW5nIHRoZXNlIGtleXMgbGV4aWNvZ3JhcGhpY2FsbHkgaXMgbm90IFwiY29ycmVjdFwiLCBidXQgaXRcbiAgICAvLyAgZG9lcyB0aGUgcmlnaHQgdGhpbmcgZm9yIGluZGV4ZXMgbGVzcyB0aGFuIDEwLlxuICAgIHZhciBwYXRocyA9IFoubWFwKEpTT04ucGFyc2UsIE9iamVjdC5rZXlzKHZhbHVlc0J5UGF0aCkuc29ydCgpKTtcbiAgICByZXR1cm4gdW5kZXJsaW5lKFxuICAgICAgdHlwZUluZm8sXG4gICAgICBLKEsoXykpLFxuICAgICAgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3BQYXRoKSB7XG4gICAgICAgICAgICAgIHZhciBpbmRleGVkUHJvcFBhdGggPSBaLmNvbmNhdChbaW5kZXhdLCBwcm9wUGF0aCk7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGhzLnNvbWUoaXNQcmVmaXgoaW5kZXhlZFByb3BQYXRoKSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBKU09OLnN0cmluZ2lmeShpbmRleGVkUHJvcFBhdGgpO1xuICAgICAgICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlc0J5UGF0aCwga2V5KSkgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzRW1wdHkodmFsdWVzQnlQYXRoW2tleV0pKSByZXR1cm4gZihzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8ocyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8vICBzYXRpc2ZhY3RvcnlUeXBlcyA6OlxuICAvLyAgICAuLi4gLT4gRWl0aGVyICgoKSAtPiBFcnJvcikgeyB0eXBlVmFyTWFwIDo6IFR5cGVWYXJNYXBcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgdHlwZXMgOjogQXJyYXkgVHlwZSB9XG4gIGZ1bmN0aW9uIHNhdGlzZmFjdG9yeVR5cGVzKFxuICAgIGVudiwgICAgICAgICAgICAvLyA6OiBBcnJheSBUeXBlXG4gICAgdHlwZUluZm8sICAgICAgIC8vIDo6IFR5cGVJbmZvXG4gICAgdHlwZVZhck1hcCwgICAgIC8vIDo6IFR5cGVWYXJNYXBcbiAgICBleHBUeXBlLCAgICAgICAgLy8gOjogVHlwZVxuICAgIGluZGV4LCAgICAgICAgICAvLyA6OiBJbnRlZ2VyXG4gICAgcHJvcFBhdGgsICAgICAgIC8vIDo6IFByb3BQYXRoXG4gICAgdmFsdWVzICAgICAgICAgIC8vIDo6IEFycmF5IEFueVxuICApIHtcbiAgICB2YXIgcmVjdXIgPSBzYXRpc2ZhY3RvcnlUeXBlcztcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHZhbHVlcy5sZW5ndGg7IGlkeCArPSAxKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZXhwVHlwZS52YWxpZGF0ZSh2YWx1ZXNbaWR4XSk7XG4gICAgICBpZiAocmVzdWx0LmlzTGVmdCkge1xuICAgICAgICByZXR1cm4gTGVmdChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gaW52YWxpZFZhbHVlKGVudixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUucHJvcFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKGV4cFR5cGUudHlwZSkge1xuXG4gICAgICBjYXNlIFZBUklBQkxFOlxuICAgICAgICB2YXIgdHlwZVZhck5hbWUgPSBleHBUeXBlLm5hbWU7XG4gICAgICAgIHZhciBjb25zdHJhaW50cyA9IHR5cGVJbmZvLmNvbnN0cmFpbnRzO1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25zdHJhaW50cywgdHlwZVZhck5hbWUpKSB7XG4gICAgICAgICAgdmFyIHR5cGVDbGFzc2VzID0gY29uc3RyYWludHNbdHlwZVZhck5hbWVdO1xuICAgICAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgdmFsdWVzLmxlbmd0aDsgaWR4ICs9IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlkeDIgPSAwOyBpZHgyIDwgdHlwZUNsYXNzZXMubGVuZ3RoOyBpZHgyICs9IDEpIHtcbiAgICAgICAgICAgICAgaWYgKCF0eXBlQ2xhc3Nlc1tpZHgyXS50ZXN0KHZhbHVlc1tpZHhdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBMZWZ0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVDbGFzc0NvbnN0cmFpbnRWaW9sYXRpb24oXG4gICAgICAgICAgICAgICAgICAgIGVudixcbiAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIHR5cGVDbGFzc2VzW2lkeDJdLFxuICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcFBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1tpZHhdLFxuICAgICAgICAgICAgICAgICAgICB0eXBlVmFyTWFwXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHR5cGVWYXJNYXAkID0gdXBkYXRlVHlwZVZhck1hcChlbnYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVZhck1hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyk7XG5cbiAgICAgICAgdmFyIG9rVHlwZXMgPSB0eXBlVmFyTWFwJFt0eXBlVmFyTmFtZV0udHlwZXM7XG4gICAgICAgIHJldHVybiBpc0VtcHR5KG9rVHlwZXMpICYmICFpc0VtcHR5KHZhbHVlcykgP1xuICAgICAgICAgIExlZnQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZVZhckNvbnN0cmFpbnRWaW9sYXRpb24oXG4gICAgICAgICAgICAgIGVudixcbiAgICAgICAgICAgICAgdHlwZUluZm8sXG4gICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICBwcm9wUGF0aCxcbiAgICAgICAgICAgICAgdHlwZVZhck1hcCRbdHlwZVZhck5hbWVdLnZhbHVlc0J5UGF0aFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KSA6XG4gICAgICAgICAgWi5yZWR1Y2UoZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRW1wdHkoZXhwVHlwZS5rZXlzKSB8fCBpc0VtcHR5KHQua2V5cykgP1xuICAgICAgICAgICAgICBlIDpcbiAgICAgICAgICAgICAgWi5jaGFpbihmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICAgICAgLy8gIFRoZSBgYWAgaW4gYEZ1bmN0b3IgZiA9PiBmIGFgIGNvcnJlc3BvbmRzIHRvIHRoZSBgYWBcbiAgICAgICAgICAgICAgICAvLyAgaW4gYE1heWJlIGFgIGJ1dCB0byB0aGUgYGJgIGluIGBFaXRoZXIgYSBiYC4gQSB0eXBlXG4gICAgICAgICAgICAgICAgLy8gIHZhcmlhYmxlJ3MgJDEgd2lsbCBjb3JyZXNwb25kIHRvIGVpdGhlciAkMSBvciAkMiBvZlxuICAgICAgICAgICAgICAgIC8vICB0aGUgYWN0dWFsIHR5cGUgZGVwZW5kaW5nIG9uIHRoZSBhY3R1YWwgdHlwZSdzIGFyaXR5LlxuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0LmtleXMubGVuZ3RoIC0gZXhwVHlwZS5rZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwVHlwZS5rZXlzLnJlZHVjZShmdW5jdGlvbihlLCBrLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBleHRyYWN0b3IgPSB0LnR5cGVzW3Qua2V5c1tvZmZzZXQgKyBpZHhdXS5leHRyYWN0b3I7XG4gICAgICAgICAgICAgICAgICB2YXIgaW5uZXJWYWx1ZXMgPSBaLmNoYWluKGV4dHJhY3RvciwgdmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBaLmNoYWluKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY3VyKGVudixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIudHlwZVZhck1hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwVHlwZS50eXBlc1trXS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWi5jb25jYXQocHJvcFBhdGgsIFtrXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyVmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgWi5yZWR1Y2UoZnVuY3Rpb24oZSwgeCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB0ID0gZXhwVHlwZS50eXBlc1trXS50eXBlO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBaLmNoYWluKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXN0KGVudiwgdCwgeCkgPyBSaWdodChyKSA6IExlZnQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wUGF0aCQgPSBaLmNvbmNhdChwcm9wUGF0aCwgW2tdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQudHlwZSA9PT0gVkFSSUFCTEUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVWYXJDb25zdHJhaW50VmlvbGF0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW52LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BQYXRoJCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpbmdsZXRvbihKU09OLnN0cmluZ2lmeShaLmNvbmNhdChbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BQYXRoJCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt4XSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkVmFsdWUoZW52LCB0eXBlSW5mbywgaW5kZXgsIHByb3BQYXRoJCwgeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9LCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZSwgaW5uZXJWYWx1ZXMpXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0sIFJpZ2h0KHIpKTtcbiAgICAgICAgICAgICAgfSwgZSk7XG4gICAgICAgICAgfSwgUmlnaHQoe3R5cGVWYXJNYXA6IHR5cGVWYXJNYXAkLCB0eXBlczogb2tUeXBlc30pLCBva1R5cGVzKTtcblxuICAgICAgY2FzZSBVTkFSWTpcbiAgICAgICAgcmV0dXJuIFoubWFwKFxuICAgICAgICAgIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZVZhck1hcDogcmVzdWx0LnR5cGVWYXJNYXAsXG4gICAgICAgICAgICAgIHR5cGVzOiBaLm1hcChmcm9tVW5hcnlUeXBlKGV4cFR5cGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IocmVzdWx0LnR5cGVzLCBbZXhwVHlwZS50eXBlcy4kMS50eXBlXSkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVjdXIoZW52LFxuICAgICAgICAgICAgICAgIHR5cGVJbmZvLFxuICAgICAgICAgICAgICAgIHR5cGVWYXJNYXAsXG4gICAgICAgICAgICAgICAgZXhwVHlwZS50eXBlcy4kMS50eXBlLFxuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIFouY29uY2F0KHByb3BQYXRoLCBbJyQxJ10pLFxuICAgICAgICAgICAgICAgIFouY2hhaW4oZXhwVHlwZS50eXBlcy4kMS5leHRyYWN0b3IsIHZhbHVlcykpXG4gICAgICAgICk7XG5cbiAgICAgIGNhc2UgQklOQVJZOlxuICAgICAgICByZXR1cm4gWi5jaGFpbihcbiAgICAgICAgICBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciAkMXMgPSByZXN1bHQudHlwZXM7XG4gICAgICAgICAgICByZXR1cm4gWi5tYXAoXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhciAkMnMgPSByZXN1bHQudHlwZXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHR5cGVWYXJNYXA6IHJlc3VsdC50eXBlVmFyTWFwLFxuICAgICAgICAgICAgICAgICAgdHlwZXM6IHhwcm9kKGV4cFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IoJDFzLCBbZXhwVHlwZS50eXBlcy4kMS50eXBlXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IoJDJzLCBbZXhwVHlwZS50eXBlcy4kMi50eXBlXSkpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVjdXIoZW52LFxuICAgICAgICAgICAgICAgICAgICB0eXBlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnR5cGVWYXJNYXAsXG4gICAgICAgICAgICAgICAgICAgIGV4cFR5cGUudHlwZXMuJDIudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIFouY29uY2F0KHByb3BQYXRoLCBbJyQyJ10pLFxuICAgICAgICAgICAgICAgICAgICBaLmNoYWluKGV4cFR5cGUudHlwZXMuJDIuZXh0cmFjdG9yLCB2YWx1ZXMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlY3VyKGVudixcbiAgICAgICAgICAgICAgICB0eXBlSW5mbyxcbiAgICAgICAgICAgICAgICB0eXBlVmFyTWFwLFxuICAgICAgICAgICAgICAgIGV4cFR5cGUudHlwZXMuJDEudHlwZSxcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICBaLmNvbmNhdChwcm9wUGF0aCwgWyckMSddKSxcbiAgICAgICAgICAgICAgICBaLmNoYWluKGV4cFR5cGUudHlwZXMuJDEuZXh0cmFjdG9yLCB2YWx1ZXMpKVxuICAgICAgICApO1xuXG4gICAgICBjYXNlIFJFQ09SRDpcbiAgICAgICAgcmV0dXJuIFoucmVkdWNlKGZ1bmN0aW9uKGUsIGspIHtcbiAgICAgICAgICByZXR1cm4gWi5jaGFpbihmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdXIoZW52LFxuICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHIudHlwZVZhck1hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBleHBUeXBlLnR5cGVzW2tdLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgWi5jb25jYXQocHJvcFBhdGgsIFtrXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgWi5jaGFpbihleHBUeXBlLnR5cGVzW2tdLmV4dHJhY3RvciwgdmFsdWVzKSk7XG4gICAgICAgICAgfSwgZSk7XG4gICAgICAgIH0sIFJpZ2h0KHt0eXBlVmFyTWFwOiB0eXBlVmFyTWFwLCB0eXBlczogW2V4cFR5cGVdfSksIGV4cFR5cGUua2V5cyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBSaWdodCh7dHlwZVZhck1hcDogdHlwZVZhck1hcCwgdHlwZXM6IFtleHBUeXBlXX0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIyB0ZXN0IDo6IEFycmF5IFR5cGUgLT4gVHlwZSAtPiBhIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBUYWtlcyBhbiBlbnZpcm9ubWVudCwgYSB0eXBlLCBhbmQgYW55IHZhbHVlLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVcbiAgLy8uIGlzIGEgbWVtYmVyIG9mIHRoZSB0eXBlOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBUaGUgZW52aXJvbm1lbnQgaXMgb25seSBzaWduaWZpY2FudCBpZiB0aGUgdHlwZSBjb250YWluc1xuICAvLy4gW3R5cGUgdmFyaWFibGVzXVtdLlxuICAvLy5cbiAgLy8uIE9uZSBtYXkgZGVmaW5lIGEgbW9yZSByZXN0cmljdGl2ZSB0eXBlIGluIHRlcm1zIG9mIGEgbW9yZSBnZW5lcmFsIG9uZTpcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiAvLyAgICBOb25OZWdhdGl2ZUludGVnZXIgOjogVHlwZVxuICAvLy4gY29uc3QgTm9uTmVnYXRpdmVJbnRlZ2VyID0gJC5OdWxsYXJ5VHlwZShcbiAgLy8uICAgJ215LXBhY2thZ2UvTm9uTmVnYXRpdmVJbnRlZ2VyJyxcbiAgLy8uICAgJ2h0dHA6Ly9leGFtcGxlLmNvbS9teS1wYWNrYWdlI05vbk5lZ2F0aXZlSW50ZWdlcicsXG4gIC8vLiAgIHggPT4gJC50ZXN0KFtdLCAkLkludGVnZXIsIHgpICYmIHggPj0gMFxuICAvLy4gKTtcbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uIFVzaW5nIHR5cGVzIGFzIHByZWRpY2F0ZXMgaXMgdXNlZnVsIGluIG90aGVyIGNvbnRleHRzIHRvby4gT25lIGNvdWxkLFxuICAvLy4gZm9yIGV4YW1wbGUsIGRlZmluZSBhIFtyZWNvcmQgdHlwZV1bXSBmb3IgZWFjaCBlbmRwb2ludCBvZiBhIFJFU1QgQVBJXG4gIC8vLiBhbmQgdmFsaWRhdGUgdGhlIGJvZGllcyBvZiBpbmNvbWluZyBQT1NUIHJlcXVlc3RzIGFnYWluc3QgdGhlc2UgdHlwZXMuXG4gIGZ1bmN0aW9uIHRlc3QoZW52LCB0LCB4KSB7XG4gICAgdmFyIHR5cGVJbmZvID0ge25hbWU6ICduYW1lJywgY29uc3RyYWludHM6IHt9LCB0eXBlczogW3RdfTtcbiAgICByZXR1cm4gc2F0aXNmYWN0b3J5VHlwZXMoZW52LCB0eXBlSW5mbywge30sIHQsIDAsIFtdLCBbeF0pLmlzUmlnaHQ7XG4gIH1cblxuICAvLy4gIyMjIFR5cGUgY29uc3RydWN0b3JzXG4gIC8vLlxuICAvLy4gc2FuY3R1YXJ5LWRlZiBwcm92aWRlcyBzZXZlcmFsIGZ1bmN0aW9ucyBmb3IgZGVmaW5pbmcgdHlwZXMuXG5cbiAgLy8jIE51bGxhcnlUeXBlIDo6IFN0cmluZyAtPiBTdHJpbmcgLT4gKEFueSAtPiBCb29sZWFuKSAtPiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb25zdHJ1Y3RvciBmb3IgdHlwZXMgd2l0aCBubyB0eXBlIHZhcmlhYmxlcyAoc3VjaCBhcyBbYE51bWJlcmBdW10pLlxuICAvLy5cbiAgLy8uIFRvIGRlZmluZSBhIG51bGxhcnkgdHlwZSBgdGAgb25lIG11c3QgcHJvdmlkZTpcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIG5hbWUgb2YgYHRgIChleHBvc2VkIGFzIGB0Lm5hbWVgKTtcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIGRvY3VtZW50YXRpb24gVVJMIG9mIGB0YCAoZXhwb3NlZCBhcyBgdC51cmxgKTsgYW5kXG4gIC8vLlxuICAvLy4gICAtIGEgcHJlZGljYXRlIHdoaWNoIGFjY2VwdHMgYW55IEphdmFTY3JpcHQgdmFsdWUgYW5kIHJldHVybnMgYHRydWVgIGlmXG4gIC8vLiAgICAgKGFuZCBvbmx5IGlmKSB0aGUgdmFsdWUgaXMgYSBtZW1iZXIgb2YgYHRgLlxuICAvLy5cbiAgLy8uIEZvciBleGFtcGxlOlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uIC8vICAgIEludGVnZXIgOjogVHlwZVxuICAvLy4gY29uc3QgSW50ZWdlciA9ICQuTnVsbGFyeVR5cGUoXG4gIC8vLiAgICdteS1wYWNrYWdlL0ludGVnZXInLFxuICAvLy4gICAnaHR0cDovL2V4YW1wbGUuY29tL215LXBhY2thZ2UjSW50ZWdlcicsXG4gIC8vLiAgIHggPT4gdHlwZW9mIHggPT09ICdudW1iZXInICYmXG4gIC8vLiAgICAgICAgTWF0aC5mbG9vcih4KSA9PT0geCAmJlxuICAvLy4gICAgICAgIHggPj0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgJiZcbiAgLy8uICAgICAgICB4IDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gIC8vLiApO1xuICAvLy5cbiAgLy8uIC8vICAgIE5vblplcm9JbnRlZ2VyIDo6IFR5cGVcbiAgLy8uIGNvbnN0IE5vblplcm9JbnRlZ2VyID0gJC5OdWxsYXJ5VHlwZShcbiAgLy8uICAgJ215LXBhY2thZ2UvTm9uWmVyb0ludGVnZXInLFxuICAvLy4gICAnaHR0cDovL2V4YW1wbGUuY29tL215LXBhY2thZ2UjTm9uWmVyb0ludGVnZXInLFxuICAvLy4gICB4ID0+ICQudGVzdChbXSwgSW50ZWdlciwgeCkgJiYgeCAhPT0gMFxuICAvLy4gKTtcbiAgLy8uXG4gIC8vLiAvLyAgICByZW0gOjogSW50ZWdlciAtPiBOb25aZXJvSW50ZWdlciAtPiBJbnRlZ2VyXG4gIC8vLiBjb25zdCByZW0gPVxuICAvLy4gZGVmKCdyZW0nLCB7fSwgW0ludGVnZXIsIE5vblplcm9JbnRlZ2VyLCBJbnRlZ2VyXSwgKHgsIHkpID0+IHggJSB5KTtcbiAgLy8uXG4gIC8vLiByZW0oNDIsIDUpO1xuICAvLy4gLy8gPT4gMlxuICAvLy5cbiAgLy8uIHJlbSgwLjUpO1xuICAvLy4gLy8gISBUeXBlRXJyb3I6IEludmFsaWQgdmFsdWVcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIHJlbSA6OiBJbnRlZ2VyIC0+IE5vblplcm9JbnRlZ2VyIC0+IEludGVnZXJcbiAgLy8uIC8vICAgICAgICAgIF5eXl5eXl5cbiAgLy8uIC8vICAgICAgICAgICAgIDFcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIDEpICAwLjUgOjogTnVtYmVyXG4gIC8vLiAvL1xuICAvLy4gLy8gICBUaGUgdmFsdWUgYXQgcG9zaXRpb24gMSBpcyBub3QgYSBtZW1iZXIgb2Yg4oCYSW50ZWdlcuKAmS5cbiAgLy8uXG4gIC8vLiByZW0oNDIsIDApO1xuICAvLy4gLy8gISBUeXBlRXJyb3I6IEludmFsaWQgdmFsdWVcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIHJlbSA6OiBJbnRlZ2VyIC0+IE5vblplcm9JbnRlZ2VyIC0+IEludGVnZXJcbiAgLy8uIC8vICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5eXl5eXl5cbiAgLy8uIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAvLy4gLy9cbiAgLy8uIC8vICAgMSkgIDAgOjogTnVtYmVyXG4gIC8vLiAvL1xuICAvLy4gLy8gICBUaGUgdmFsdWUgYXQgcG9zaXRpb24gMSBpcyBub3QgYSBtZW1iZXIgb2Yg4oCYTm9uWmVyb0ludGVnZXLigJkuXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTnVsbGFyeVR5cGUobmFtZSwgdXJsLCB0ZXN0KSB7XG4gICAgZnVuY3Rpb24gZm9ybWF0KG91dGVyLCBpbm5lcikge1xuICAgICAgcmV0dXJuIG91dGVyKHN0cmlwTmFtZXNwYWNlKG5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfVHlwZShOVUxMQVJZLCBuYW1lLCB1cmwsIGZvcm1hdCwgdGVzdCwgW10sIHt9KTtcbiAgfVxuXG4gIHZhciBDaGVja2VkTnVsbGFyeVR5cGUgPVxuICBkZWYoJ051bGxhcnlUeXBlJyxcbiAgICAgIHt9LFxuICAgICAgW1N0cmluZ18sIFN0cmluZ18sIEZ1bmN0aW9uXyhbQW55LCBCb29sZWFuX10pLCBUeXBlXSxcbiAgICAgIE51bGxhcnlUeXBlKTtcblxuICAvLyMgVW5hcnlUeXBlIDo6IFN0cmluZyAtPiBTdHJpbmcgLT4gKEFueSAtPiBCb29sZWFuKSAtPiAodCBhIC0+IEFycmF5IGEpIC0+IChUeXBlIC0+IFR5cGUpXG4gIC8vLlxuICAvLy4gVHlwZSBjb25zdHJ1Y3RvciBmb3IgdHlwZXMgd2l0aCBvbmUgdHlwZSB2YXJpYWJsZSAoc3VjaCBhcyBbYEFycmF5YF1bXSkuXG4gIC8vLlxuICAvLy4gVG8gZGVmaW5lIGEgdW5hcnkgdHlwZSBgdCBhYCBvbmUgbXVzdCBwcm92aWRlOlxuICAvLy5cbiAgLy8uICAgLSB0aGUgbmFtZSBvZiBgdGAgKGV4cG9zZWQgYXMgYHQubmFtZWApO1xuICAvLy5cbiAgLy8uICAgLSB0aGUgZG9jdW1lbnRhdGlvbiBVUkwgb2YgYHRgIChleHBvc2VkIGFzIGB0LnVybGApO1xuICAvLy5cbiAgLy8uICAgLSBhIHByZWRpY2F0ZSB3aGljaCBhY2NlcHRzIGFueSBKYXZhU2NyaXB0IHZhbHVlIGFuZCByZXR1cm5zIGB0cnVlYFxuICAvLy4gICAgIGlmIChhbmQgb25seSBpZikgdGhlIHZhbHVlIGlzIGEgbWVtYmVyIG9mIGB0IHhgIGZvciBzb21lIHR5cGUgYHhgO1xuICAvLy5cbiAgLy8uICAgLSBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzIGFueSB2YWx1ZSBvZiB0eXBlIGB0IGFgIGFuZCByZXR1cm5zIGFuIGFycmF5XG4gIC8vLiAgICAgb2YgdGhlIHZhbHVlcyBvZiB0eXBlIGBhYCBjb250YWluZWQgaW4gdGhlIGB0YCAoZXhwb3NlZCBhc1xuICAvLy4gICAgIGB0LnR5cGVzLiQxLmV4dHJhY3RvcmApOyBhbmRcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIHR5cGUgb2YgYGFgIChleHBvc2VkIGFzIGB0LnR5cGVzLiQxLnR5cGVgKS5cbiAgLy8uXG4gIC8vLiBGb3IgZXhhbXBsZTpcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiBjb25zdCB0eXBlID0gcmVxdWlyZSgnc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMnKTtcbiAgLy8uXG4gIC8vLiAvLyAgICBtYXliZVR5cGVJZGVudCA6OiBTdHJpbmdcbiAgLy8uIGNvbnN0IG1heWJlVHlwZUlkZW50ID0gJ215LXBhY2thZ2UvTWF5YmUnO1xuICAvLy5cbiAgLy8uIC8vICAgIE1heWJlIDo6IFR5cGUgLT4gVHlwZVxuICAvLy4gY29uc3QgTWF5YmUgPSAkLlVuYXJ5VHlwZShcbiAgLy8uICAgbWF5YmVUeXBlSWRlbnQsXG4gIC8vLiAgICdodHRwOi8vZXhhbXBsZS5jb20vbXktcGFja2FnZSNNYXliZScsXG4gIC8vLiAgIHggPT4gdHlwZSh4KSA9PT0gbWF5YmVUeXBlSWRlbnQsXG4gIC8vLiAgIG1heWJlID0+IG1heWJlLmlzSnVzdCA/IFttYXliZS52YWx1ZV0gOiBbXVxuICAvLy4gKTtcbiAgLy8uXG4gIC8vLiAvLyAgICBNYXliZVR5cGVSZXAgOjogVHlwZVJlcCBNYXliZVxuICAvLy4gY29uc3QgTWF5YmVUeXBlUmVwID0geydAQHR5cGUnOiBtYXliZVR5cGVJZGVudH07XG4gIC8vLlxuICAvLy4gLy8gICAgTm90aGluZyA6OiBNYXliZSBhXG4gIC8vLiBjb25zdCBOb3RoaW5nID0ge1xuICAvLy4gICBjb25zdHJ1Y3RvcjogTWF5YmVUeXBlUmVwLFxuICAvLy4gICBpc0p1c3Q6IGZhbHNlLFxuICAvLy4gICBpc05vdGhpbmc6IHRydWUsXG4gIC8vLiAgIHRvU3RyaW5nOiAoKSA9PiAnTm90aGluZycsXG4gIC8vLiB9O1xuICAvLy5cbiAgLy8uIC8vICAgIEp1c3QgOjogYSAtPiBNYXliZSBhXG4gIC8vLiBjb25zdCBKdXN0ID0geCA9PiAoe1xuICAvLy4gICBjb25zdHJ1Y3RvcjogTWF5YmVUeXBlUmVwLFxuICAvLy4gICBpc0p1c3Q6IHRydWUsXG4gIC8vLiAgIGlzTm90aGluZzogZmFsc2UsXG4gIC8vLiAgIHRvU3RyaW5nOiAoKSA9PiAnSnVzdCgnICsgWi50b1N0cmluZyh4KSArICcpJyxcbiAgLy8uICAgdmFsdWU6IHgsXG4gIC8vLiB9KTtcbiAgLy8uXG4gIC8vLiAvLyAgICBmcm9tTWF5YmUgOjogYSAtPiBNYXliZSBhIC0+IGFcbiAgLy8uIGNvbnN0IGZyb21NYXliZSA9XG4gIC8vLiBkZWYoJ2Zyb21NYXliZScsIHt9LCBbYSwgTWF5YmUoYSksIGFdLCAoeCwgbSkgPT4gbS5pc0p1c3QgPyBtLnZhbHVlIDogeCk7XG4gIC8vLlxuICAvLy4gZnJvbU1heWJlKDAsIEp1c3QoNDIpKTtcbiAgLy8uIC8vID0+IDQyXG4gIC8vLlxuICAvLy4gZnJvbU1heWJlKDAsIE5vdGhpbmcpO1xuICAvLy4gLy8gPT4gMFxuICAvLy5cbiAgLy8uIGZyb21NYXliZSgwLCBKdXN0KCdYWFgnKSk7XG4gIC8vLiAvLyAhIFR5cGVFcnJvcjogVHlwZS12YXJpYWJsZSBjb25zdHJhaW50IHZpb2xhdGlvblxuICAvLy4gLy9cbiAgLy8uIC8vICAgZnJvbU1heWJlIDo6IGEgLT4gTWF5YmUgYSAtPiBhXG4gIC8vLiAvLyAgICAgICAgICAgICAgICBeICAgICAgICAgIF5cbiAgLy8uIC8vICAgICAgICAgICAgICAgIDEgICAgICAgICAgMlxuICAvLy4gLy9cbiAgLy8uIC8vICAgMSkgIDAgOjogTnVtYmVyXG4gIC8vLiAvL1xuICAvLy4gLy8gICAyKSAgXCJYWFhcIiA6OiBTdHJpbmdcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIFNpbmNlIHRoZXJlIGlzIG5vIHR5cGUgb2Ygd2hpY2ggYWxsIHRoZSBhYm92ZSB2YWx1ZXMgYXJlIG1lbWJlcnMsIHRoZSB0eXBlLXZhcmlhYmxlIGNvbnN0cmFpbnQgaGFzIGJlZW4gdmlvbGF0ZWQuXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gVW5hcnlUeXBlKG5hbWUsIHVybCwgdGVzdCwgXzEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oJDEpIHtcbiAgICAgIGZ1bmN0aW9uIGZvcm1hdChvdXRlciwgaW5uZXIpIHtcbiAgICAgICAgcmV0dXJuIG91dGVyKCcoJyArIHN0cmlwTmFtZXNwYWNlKG5hbWUpICsgJyAnKSArXG4gICAgICAgICAgICAgICBpbm5lcignJDEnKShTdHJpbmcoJDEpKSArIG91dGVyKCcpJyk7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZXMgPSB7JDE6IHtleHRyYWN0b3I6IF8xLCB0eXBlOiAkMX19O1xuICAgICAgcmV0dXJuIG5ldyBfVHlwZShVTkFSWSwgbmFtZSwgdXJsLCBmb3JtYXQsIHRlc3QsIFsnJDEnXSwgdHlwZXMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgQ2hlY2tlZFVuYXJ5VHlwZSA9XG4gIGRlZignVW5hcnlUeXBlJyxcbiAgICAgIHt9LFxuICAgICAgW1N0cmluZ18sXG4gICAgICAgU3RyaW5nXyxcbiAgICAgICBGdW5jdGlvbl8oW0FueSwgQm9vbGVhbl9dKSxcbiAgICAgICBGdW5jdGlvbl8oW1VuY2hlY2tlZCgndCBhJyksIEFycmF5XyhVbmNoZWNrZWQoJ2EnKSldKSxcbiAgICAgICBBbnlGdW5jdGlvbl0sXG4gICAgICBmdW5jdGlvbihuYW1lLCB1cmwsIHRlc3QsIF8xKSB7XG4gICAgICAgIHJldHVybiBkZWYoc3RyaXBOYW1lc3BhY2UobmFtZSksXG4gICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgW1R5cGUsIFR5cGVdLFxuICAgICAgICAgICAgICAgICAgIFVuYXJ5VHlwZShuYW1lLCB1cmwsIHRlc3QsIF8xKSk7XG4gICAgICB9KTtcblxuICAvLyAgZnJvbVVuYXJ5VHlwZSA6OiBUeXBlIC0+IChUeXBlIC0+IFR5cGUpXG4gIGZ1bmN0aW9uIGZyb21VbmFyeVR5cGUodCkge1xuICAgIHJldHVybiBVbmFyeVR5cGUodC5uYW1lLCB0LnVybCwgdC5fdGVzdCwgdC50eXBlcy4kMS5leHRyYWN0b3IpO1xuICB9XG5cbiAgLy8jIEJpbmFyeVR5cGUgOjogU3RyaW5nIC0+IFN0cmluZyAtPiAoQW55IC0+IEJvb2xlYW4pIC0+ICh0IGEgYiAtPiBBcnJheSBhKSAtPiAodCBhIGIgLT4gQXJyYXkgYikgLT4gKFR5cGUgLT4gVHlwZSAtPiBUeXBlKVxuICAvLy5cbiAgLy8uIFR5cGUgY29uc3RydWN0b3IgZm9yIHR5cGVzIHdpdGggdHdvIHR5cGUgdmFyaWFibGVzIChzdWNoIGFzIFtgUGFpcmBdW10pLlxuICAvLy5cbiAgLy8uIFRvIGRlZmluZSBhIGJpbmFyeSB0eXBlIGB0IGEgYmAgb25lIG11c3QgcHJvdmlkZTpcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIG5hbWUgb2YgYHRgIChleHBvc2VkIGFzIGB0Lm5hbWVgKTtcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIGRvY3VtZW50YXRpb24gVVJMIG9mIGB0YCAoZXhwb3NlZCBhcyBgdC51cmxgKTtcbiAgLy8uXG4gIC8vLiAgIC0gYSBwcmVkaWNhdGUgd2hpY2ggYWNjZXB0cyBhbnkgSmF2YVNjcmlwdCB2YWx1ZSBhbmQgcmV0dXJucyBgdHJ1ZWBcbiAgLy8uICAgICBpZiAoYW5kIG9ubHkgaWYpIHRoZSB2YWx1ZSBpcyBhIG1lbWJlciBvZiBgdCB4IHlgIGZvciBzb21lIHR5cGVzXG4gIC8vLiAgICAgYHhgIGFuZCBgeWA7XG4gIC8vLlxuICAvLy4gICAtIGEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYW55IHZhbHVlIG9mIHR5cGUgYHQgYSBiYCBhbmQgcmV0dXJucyBhbiBhcnJheVxuICAvLy4gICAgIG9mIHRoZSB2YWx1ZXMgb2YgdHlwZSBgYWAgY29udGFpbmVkIGluIHRoZSBgdGAgKGV4cG9zZWQgYXNcbiAgLy8uICAgICBgdC50eXBlcy4kMS5leHRyYWN0b3JgKTtcbiAgLy8uXG4gIC8vLiAgIC0gYSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhbnkgdmFsdWUgb2YgdHlwZSBgdCBhIGJgIGFuZCByZXR1cm5zIGFuIGFycmF5XG4gIC8vLiAgICAgb2YgdGhlIHZhbHVlcyBvZiB0eXBlIGBiYCBjb250YWluZWQgaW4gdGhlIGB0YCAoZXhwb3NlZCBhc1xuICAvLy4gICAgIGB0LnR5cGVzLiQyLmV4dHJhY3RvcmApO1xuICAvLy5cbiAgLy8uICAgLSB0aGUgdHlwZSBvZiBgYWAgKGV4cG9zZWQgYXMgYHQudHlwZXMuJDEudHlwZWApOyBhbmRcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIHR5cGUgb2YgYGJgIChleHBvc2VkIGFzIGB0LnR5cGVzLiQyLnR5cGVgKS5cbiAgLy8uXG4gIC8vLiBGb3IgZXhhbXBsZTpcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiBjb25zdCB0eXBlID0gcmVxdWlyZSgnc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMnKTtcbiAgLy8uXG4gIC8vLiAvLyAgICBwYWlyVHlwZUlkZW50IDo6IFN0cmluZ1xuICAvLy4gY29uc3QgcGFpclR5cGVJZGVudCA9ICdteS1wYWNrYWdlL1BhaXInO1xuICAvLy5cbiAgLy8uIC8vICAgICRQYWlyIDo6IFR5cGUgLT4gVHlwZSAtPiBUeXBlXG4gIC8vLiBjb25zdCAkUGFpciA9ICQuQmluYXJ5VHlwZShcbiAgLy8uICAgcGFpclR5cGVJZGVudCxcbiAgLy8uICAgJ2h0dHA6Ly9leGFtcGxlLmNvbS9teS1wYWNrYWdlI1BhaXInLFxuICAvLy4gICB4ID0+IHR5cGUoeCkgPT09IHBhaXJUeXBlSWRlbnQsXG4gIC8vLiAgIHBhaXIgPT4gW3BhaXJbMF1dLFxuICAvLy4gICBwYWlyID0+IFtwYWlyWzFdXVxuICAvLy4gKTtcbiAgLy8uXG4gIC8vLiAvLyAgICBQYWlyVHlwZVJlcCA6OiBUeXBlUmVwIFBhaXJcbiAgLy8uIGNvbnN0IFBhaXJUeXBlUmVwID0geydAQHR5cGUnOiBwYWlyVHlwZUlkZW50fTtcbiAgLy8uXG4gIC8vLiAvLyAgICBQYWlyIDo6IGEgLT4gYiAtPiBQYWlyIGEgYlxuICAvLy4gY29uc3QgUGFpciA9IGRlZignUGFpcicsIHt9LCBbYSwgYiwgJFBhaXIoYSwgYildLCAoeCwgeSkgPT4gKHtcbiAgLy8uICAgJzAnOiB4LFxuICAvLy4gICAnMSc6IHksXG4gIC8vLiAgIGNvbnN0cnVjdG9yOiBQYWlyVHlwZVJlcCxcbiAgLy8uICAgbGVuZ3RoOiAyLFxuICAvLy4gICB0b1N0cmluZzogKCkgPT4gJ1BhaXIoJyArIFoudG9TdHJpbmcoeCkgKyAnLCAnICsgWi50b1N0cmluZyh5KSArICcpJyxcbiAgLy8uIH0pKTtcbiAgLy8uXG4gIC8vLiAvLyAgICBSYW5rIDo6IFR5cGVcbiAgLy8uIGNvbnN0IFJhbmsgPSAkLk51bGxhcnlUeXBlKFxuICAvLy4gICAnbXktcGFja2FnZS9SYW5rJyxcbiAgLy8uICAgJ2h0dHA6Ly9leGFtcGxlLmNvbS9teS1wYWNrYWdlI1JhbmsnLFxuICAvLy4gICB4ID0+IHR5cGVvZiB4ID09PSAnc3RyaW5nJyAmJiAvXihbQTIzNDU2Nzg5SlFLXXwxMCkkLy50ZXN0KHgpXG4gIC8vLiApO1xuICAvLy5cbiAgLy8uIC8vICAgIFN1aXQgOjogVHlwZVxuICAvLy4gY29uc3QgU3VpdCA9ICQuTnVsbGFyeVR5cGUoXG4gIC8vLiAgICdteS1wYWNrYWdlL1N1aXQnLFxuICAvLy4gICAnaHR0cDovL2V4YW1wbGUuY29tL215LXBhY2thZ2UjU3VpdCcsXG4gIC8vLiAgIHggPT4gdHlwZW9mIHggPT09ICdzdHJpbmcnICYmIC9eW1xcdTI2NjBcXHUyNjYzXFx1MjY2NVxcdTI2NjZdJC8udGVzdCh4KVxuICAvLy4gKTtcbiAgLy8uXG4gIC8vLiAvLyAgICBDYXJkIDo6IFR5cGVcbiAgLy8uIGNvbnN0IENhcmQgPSAkUGFpcihSYW5rLCBTdWl0KTtcbiAgLy8uXG4gIC8vLiAvLyAgICBzaG93Q2FyZCA6OiBDYXJkIC0+IFN0cmluZ1xuICAvLy4gY29uc3Qgc2hvd0NhcmQgPVxuICAvLy4gZGVmKCdzaG93Q2FyZCcsIHt9LCBbQ2FyZCwgJC5TdHJpbmddLCBjYXJkID0+IGNhcmRbMF0gKyBjYXJkWzFdKTtcbiAgLy8uXG4gIC8vLiBzaG93Q2FyZChQYWlyKCdBJywgJ+KZoCcpKTtcbiAgLy8uIC8vID0+ICdB4pmgJ1xuICAvLy5cbiAgLy8uIHNob3dDYXJkKFBhaXIoJ1gnLCAn4pmgJykpO1xuICAvLy4gLy8gISBUeXBlRXJyb3I6IEludmFsaWQgdmFsdWVcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIHNob3dDYXJkIDo6IFBhaXIgUmFuayBTdWl0IC0+IFN0cmluZ1xuICAvLy4gLy8gICAgICAgICAgICAgICAgICAgIF5eXl5cbiAgLy8uIC8vICAgICAgICAgICAgICAgICAgICAgMVxuICAvLy4gLy9cbiAgLy8uIC8vICAgMSkgIFwiWFwiIDo6IFN0cmluZ1xuICAvLy4gLy9cbiAgLy8uIC8vICAgVGhlIHZhbHVlIGF0IHBvc2l0aW9uIDEgaXMgbm90IGEgbWVtYmVyIG9mIOKAmFJhbmvigJkuXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gQmluYXJ5VHlwZShuYW1lLCB1cmwsIHRlc3QsIF8xLCBfMikge1xuICAgIHJldHVybiBmdW5jdGlvbigkMSwgJDIpIHtcbiAgICAgIGZ1bmN0aW9uIGZvcm1hdChvdXRlciwgaW5uZXIpIHtcbiAgICAgICAgcmV0dXJuIG91dGVyKCcoJyArIHN0cmlwTmFtZXNwYWNlKG5hbWUpICsgJyAnKSArXG4gICAgICAgICAgICAgICBpbm5lcignJDEnKShTdHJpbmcoJDEpKSArIG91dGVyKCcgJykgK1xuICAgICAgICAgICAgICAgaW5uZXIoJyQyJykoU3RyaW5nKCQyKSkgKyBvdXRlcignKScpO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGVzID0geyQxOiB7ZXh0cmFjdG9yOiBfMSwgdHlwZTogJDF9LFxuICAgICAgICAgICAgICAgICAgICQyOiB7ZXh0cmFjdG9yOiBfMiwgdHlwZTogJDJ9fTtcbiAgICAgIHJldHVybiBuZXcgX1R5cGUoQklOQVJZLCBuYW1lLCB1cmwsIGZvcm1hdCwgdGVzdCwgWyckMScsICckMiddLCB0eXBlcyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBDaGVja2VkQmluYXJ5VHlwZSA9XG4gIGRlZignQmluYXJ5VHlwZScsXG4gICAgICB7fSxcbiAgICAgIFtTdHJpbmdfLFxuICAgICAgIFN0cmluZ18sXG4gICAgICAgRnVuY3Rpb25fKFtBbnksIEJvb2xlYW5fXSksXG4gICAgICAgRnVuY3Rpb25fKFtVbmNoZWNrZWQoJ3QgYSBiJyksIEFycmF5XyhVbmNoZWNrZWQoJ2EnKSldKSxcbiAgICAgICBGdW5jdGlvbl8oW1VuY2hlY2tlZCgndCBhIGInKSwgQXJyYXlfKFVuY2hlY2tlZCgnYicpKV0pLFxuICAgICAgIEFueUZ1bmN0aW9uXSxcbiAgICAgIGZ1bmN0aW9uKG5hbWUsIHVybCwgdGVzdCwgXzEsIF8yKSB7XG4gICAgICAgIHJldHVybiBkZWYoc3RyaXBOYW1lc3BhY2UobmFtZSksXG4gICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgW1R5cGUsIFR5cGUsIFR5cGVdLFxuICAgICAgICAgICAgICAgICAgIEJpbmFyeVR5cGUobmFtZSwgdXJsLCB0ZXN0LCBfMSwgXzIpKTtcbiAgICAgIH0pO1xuXG4gIC8vICB4cHJvZCA6OiAoVHlwZSwgQXJyYXkgVHlwZSwgQXJyYXkgVHlwZSkgLT4gQXJyYXkgVHlwZVxuICBmdW5jdGlvbiB4cHJvZCh0LCAkMXMsICQycykge1xuICAgIHZhciBzcGVjaWFsaXplID0gQmluYXJ5VHlwZSh0Lm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Ll90ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LnR5cGVzLiQxLmV4dHJhY3RvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdC50eXBlcy4kMi5leHRyYWN0b3IpO1xuICAgIHZhciAkdHlwZXMgPSBbXTtcbiAgICAkMXMuZm9yRWFjaChmdW5jdGlvbigkMSkge1xuICAgICAgJDJzLmZvckVhY2goZnVuY3Rpb24oJDIpIHtcbiAgICAgICAgJHR5cGVzLnB1c2goc3BlY2lhbGl6ZSgkMSwgJDIpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiAkdHlwZXM7XG4gIH1cblxuICAvLyMgRW51bVR5cGUgOjogU3RyaW5nIC0+IFN0cmluZyAtPiBBcnJheSBBbnkgLT4gVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29uc3RydWN0b3IgZm9yIFtlbnVtZXJhdGVkIHR5cGVzXVtdIChzdWNoIGFzIFtgUmVnZXhGbGFnc2BdW10pLlxuICAvLy5cbiAgLy8uIFRvIGRlZmluZSBhbiBlbnVtZXJhdGVkIHR5cGUgYHRgIG9uZSBtdXN0IHByb3ZpZGU6XG4gIC8vLlxuICAvLy4gICAtIHRoZSBuYW1lIG9mIGB0YCAoZXhwb3NlZCBhcyBgdC5uYW1lYCk7XG4gIC8vLlxuICAvLy4gICAtIHRoZSBkb2N1bWVudGF0aW9uIFVSTCBvZiBgdGAgKGV4cG9zZWQgYXMgYHQudXJsYCk7IGFuZFxuICAvLy5cbiAgLy8uICAgLSBhbiBhcnJheSBvZiBkaXN0aW5jdCB2YWx1ZXMuXG4gIC8vLlxuICAvLy4gRm9yIGV4YW1wbGU6XG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gLy8gICAgRGVub21pbmF0aW9uIDo6IFR5cGVcbiAgLy8uIGNvbnN0IERlbm9taW5hdGlvbiA9ICQuRW51bVR5cGUoXG4gIC8vLiAgICdteS1wYWNrYWdlL0Rlbm9taW5hdGlvbicsXG4gIC8vLiAgICdodHRwOi8vZXhhbXBsZS5jb20vbXktcGFja2FnZSNEZW5vbWluYXRpb24nLFxuICAvLy4gICBbMTAsIDIwLCA1MCwgMTAwLCAyMDBdXG4gIC8vLiApO1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIEVudW1UeXBlKG5hbWUsIHVybCwgbWVtYmVycykge1xuICAgIHJldHVybiBOdWxsYXJ5VHlwZShuYW1lLCB1cmwsIG1lbWJlck9mKG1lbWJlcnMpKTtcbiAgfVxuXG4gIHZhciBDaGVja2VkRW51bVR5cGUgPVxuICBkZWYoJ0VudW1UeXBlJywge30sIFtTdHJpbmdfLCBTdHJpbmdfLCBBcnJheV8oQW55KSwgVHlwZV0sIEVudW1UeXBlKTtcblxuICAvLyMgUmVjb3JkVHlwZSA6OiBTdHJNYXAgVHlwZSAtPiBUeXBlXG4gIC8vLlxuICAvLy4gYFJlY29yZFR5cGVgIGlzIHVzZWQgdG8gY29uc3RydWN0IHJlY29yZCB0eXBlcy4gVGhlIHR5cGUgZGVmaW5pdGlvblxuICAvLy4gc3BlY2lmaWVzIHRoZSBuYW1lIGFuZCB0eXBlIG9mIGVhY2ggcmVxdWlyZWQgZmllbGQuXG4gIC8vLlxuICAvLy4gVG8gZGVmaW5lIGEgcmVjb3JkIHR5cGUgb25lIG11c3QgcHJvdmlkZTpcbiAgLy8uXG4gIC8vLiAgIC0gYW4gb2JqZWN0IG1hcHBpbmcgZmllbGQgbmFtZSB0byB0eXBlLlxuICAvLy5cbiAgLy8uIEZvciBleGFtcGxlOlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uIC8vICAgIFBvaW50IDo6IFR5cGVcbiAgLy8uIGNvbnN0IFBvaW50ID0gJC5SZWNvcmRUeXBlKHt4OiAkLkZpbml0ZU51bWJlciwgeTogJC5GaW5pdGVOdW1iZXJ9KTtcbiAgLy8uXG4gIC8vLiAvLyAgICBkaXN0IDo6IFBvaW50IC0+IFBvaW50IC0+IEZpbml0ZU51bWJlclxuICAvLy4gY29uc3QgZGlzdCA9XG4gIC8vLiBkZWYoJ2Rpc3QnLCB7fSwgW1BvaW50LCBQb2ludCwgJC5GaW5pdGVOdW1iZXJdLFxuICAvLy4gICAgIChwLCBxKSA9PiBNYXRoLnNxcnQoTWF0aC5wb3cocC54IC0gcS54LCAyKSArXG4gIC8vLiAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyhwLnkgLSBxLnksIDIpKSk7XG4gIC8vLlxuICAvLy4gZGlzdCh7eDogMCwgeTogMH0sIHt4OiAzLCB5OiA0fSk7XG4gIC8vLiAvLyA9PiA1XG4gIC8vLlxuICAvLy4gZGlzdCh7eDogMCwgeTogMH0sIHt4OiAzLCB5OiA0LCBjb2xvcjogJ3JlZCd9KTtcbiAgLy8uIC8vID0+IDVcbiAgLy8uXG4gIC8vLiBkaXN0KHt4OiAwLCB5OiAwfSwge3g6IE5hTiwgeTogTmFOfSk7XG4gIC8vLiAvLyAhIFR5cGVFcnJvcjogSW52YWxpZCB2YWx1ZVxuICAvLy4gLy9cbiAgLy8uIC8vICAgZGlzdCA6OiB7IHggOjogRmluaXRlTnVtYmVyLCB5IDo6IEZpbml0ZU51bWJlciB9IC0+IHsgeCA6OiBGaW5pdGVOdW1iZXIsIHkgOjogRmluaXRlTnVtYmVyIH0gLT4gRmluaXRlTnVtYmVyXG4gIC8vLiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5eXl5eXG4gIC8vLiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxXG4gIC8vLiAvL1xuICAvLy4gLy8gICAxKSAgTmFOIDo6IE51bWJlclxuICAvLy4gLy9cbiAgLy8uIC8vICAgVGhlIHZhbHVlIGF0IHBvc2l0aW9uIDEgaXMgbm90IGEgbWVtYmVyIG9mIOKAmEZpbml0ZU51bWJlcuKAmS5cbiAgLy8uXG4gIC8vLiBkaXN0KDApO1xuICAvLy4gLy8gISBUeXBlRXJyb3I6IEludmFsaWQgdmFsdWVcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIGRpc3QgOjogeyB4IDo6IEZpbml0ZU51bWJlciwgeSA6OiBGaW5pdGVOdW1iZXIgfSAtPiB7IHggOjogRmluaXRlTnVtYmVyLCB5IDo6IEZpbml0ZU51bWJlciB9IC0+IEZpbml0ZU51bWJlclxuICAvLy4gLy8gICAgICAgICAgIF5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgLy8uIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAvLy4gLy9cbiAgLy8uIC8vICAgMSkgIDAgOjogTnVtYmVyXG4gIC8vLiAvL1xuICAvLy4gLy8gICBUaGUgdmFsdWUgYXQgcG9zaXRpb24gMSBpcyBub3QgYSBtZW1iZXIgb2Yg4oCYeyB4IDo6IEZpbml0ZU51bWJlciwgeSA6OiBGaW5pdGVOdW1iZXIgfeKAmS5cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBSZWNvcmRUeXBlKGZpZWxkcykge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZmllbGRzKS5zb3J0KCk7XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQob3V0ZXIsIGlubmVyKSB7XG4gICAgICByZXR1cm4gd3JhcChvdXRlcigneycpKShvdXRlcignIH0nKSkoWi5tYXAoZnVuY3Rpb24oaykge1xuICAgICAgICB2YXIgdCA9IGZpZWxkc1trXTtcbiAgICAgICAgcmV0dXJuIG91dGVyKCcgJyArIGsgKyAnIDo6ICcpICtcbiAgICAgICAgICAgICAgIHVubGVzcyh0LnR5cGUgPT09IFJFQ09SRCB8fCBpc0VtcHR5KHQua2V5cyksXG4gICAgICAgICAgICAgICAgICAgICAgc3RyaXBPdXRlcm1vc3RQYXJlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgaW5uZXIoaykoU3RyaW5nKHQpKSk7XG4gICAgICB9LCBrZXlzKS5qb2luKG91dGVyKCcsJykpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0KHgpIHtcbiAgICAgIHJldHVybiB4ICE9IG51bGwgJiZcbiAgICAgICAgICAgICBrZXlzLmV2ZXJ5KGZ1bmN0aW9uKGspIHsgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoeCwgayk7IH0pO1xuICAgIH1cblxuICAgIHZhciAkdHlwZXMgPSB7fTtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgJHR5cGVzW2tdID0ge2V4dHJhY3RvcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gW3hba11dOyB9LCB0eXBlOiBmaWVsZHNba119O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBfVHlwZShSRUNPUkQsICcnLCAnJywgZm9ybWF0LCB0ZXN0LCBrZXlzLCAkdHlwZXMpO1xuICB9XG5cbiAgdmFyIENoZWNrZWRSZWNvcmRUeXBlID1cbiAgZGVmKCdSZWNvcmRUeXBlJywge30sIFtTdHJNYXAoVHlwZSksIFR5cGVdLCBSZWNvcmRUeXBlKTtcblxuICAvLyMgVHlwZVZhcmlhYmxlIDo6IFN0cmluZyAtPiBUeXBlXG4gIC8vLlxuICAvLy4gUG9seW1vcnBoaXNtIGlzIHBvd2VyZnVsLiBOb3QgYmVpbmcgYWJsZSB0byBkZWZpbmUgYSBmdW5jdGlvbiBmb3JcbiAgLy8uIGFsbCB0eXBlcyB3b3VsZCBiZSB2ZXJ5IGxpbWl0aW5nIGluZGVlZDogb25lIGNvdWxkbid0IGV2ZW4gZGVmaW5lIHRoZVxuICAvLy4gaWRlbnRpdHkgZnVuY3Rpb24hXG4gIC8vLlxuICAvLy4gQmVmb3JlIGRlZmluaW5nIGEgcG9seW1vcnBoaWMgZnVuY3Rpb24gb25lIG11c3QgZGVmaW5lIG9uZSBvciBtb3JlIHR5cGVcbiAgLy8uIHZhcmlhYmxlczpcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiBjb25zdCBhID0gJC5UeXBlVmFyaWFibGUoJ2EnKTtcbiAgLy8uIGNvbnN0IGIgPSAkLlR5cGVWYXJpYWJsZSgnYicpO1xuICAvLy5cbiAgLy8uIC8vICAgIGlkIDo6IGEgLT4gYVxuICAvLy4gY29uc3QgaWQgPSBkZWYoJ2lkJywge30sIFthLCBhXSwgeCA9PiB4KTtcbiAgLy8uXG4gIC8vLiBpZCg0Mik7XG4gIC8vLiAvLyA9PiA0MlxuICAvLy5cbiAgLy8uIGlkKG51bGwpO1xuICAvLy4gLy8gPT4gbnVsbFxuICAvLy4gYGBgXG4gIC8vLlxuICAvLy4gVGhlIHNhbWUgdHlwZSB2YXJpYWJsZSBtYXkgYmUgdXNlZCBpbiBtdWx0aXBsZSBwb3NpdGlvbnMsIGNyZWF0aW5nIGFcbiAgLy8uIGNvbnN0cmFpbnQ6XG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gLy8gICAgY21wIDo6IGEgLT4gYSAtPiBOdW1iZXJcbiAgLy8uIGNvbnN0IGNtcCA9XG4gIC8vLiBkZWYoJ2NtcCcsIHt9LCBbYSwgYSwgJC5OdW1iZXJdLCAoeCwgeSkgPT4geCA8IHkgPyAtMSA6IHggPiB5ID8gMSA6IDApO1xuICAvLy5cbiAgLy8uIGNtcCg0MiwgNDIpO1xuICAvLy4gLy8gPT4gMFxuICAvLy5cbiAgLy8uIGNtcCgnYScsICd6Jyk7XG4gIC8vLiAvLyA9PiAtMVxuICAvLy5cbiAgLy8uIGNtcCgneicsICdhJyk7XG4gIC8vLiAvLyA9PiAxXG4gIC8vLlxuICAvLy4gY21wKDAsICcxJyk7XG4gIC8vLiAvLyAhIFR5cGVFcnJvcjogVHlwZS12YXJpYWJsZSBjb25zdHJhaW50IHZpb2xhdGlvblxuICAvLy4gLy9cbiAgLy8uIC8vICAgY21wIDo6IGEgLT4gYSAtPiBOdW1iZXJcbiAgLy8uIC8vICAgICAgICAgIF4gICAgXlxuICAvLy4gLy8gICAgICAgICAgMSAgICAyXG4gIC8vLiAvL1xuICAvLy4gLy8gICAxKSAgMCA6OiBOdW1iZXJcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIDIpICBcIjFcIiA6OiBTdHJpbmdcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIFNpbmNlIHRoZXJlIGlzIG5vIHR5cGUgb2Ygd2hpY2ggYWxsIHRoZSBhYm92ZSB2YWx1ZXMgYXJlIG1lbWJlcnMsIHRoZSB0eXBlLXZhcmlhYmxlIGNvbnN0cmFpbnQgaGFzIGJlZW4gdmlvbGF0ZWQuXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gVHlwZVZhcmlhYmxlKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9UeXBlKFZBUklBQkxFLCBuYW1lLCAnJywgYWx3YXlzMihuYW1lKSwgSyh0cnVlKSwgW10sIHt9KTtcbiAgfVxuXG4gIHZhciBDaGVja2VkVHlwZVZhcmlhYmxlID1cbiAgZGVmKCdUeXBlVmFyaWFibGUnLCB7fSwgW1N0cmluZ18sIFR5cGVdLCBUeXBlVmFyaWFibGUpO1xuXG4gIC8vIyBVbmFyeVR5cGVWYXJpYWJsZSA6OiBTdHJpbmcgLT4gKFR5cGUgLT4gVHlwZSlcbiAgLy8uXG4gIC8vLiBDb21iaW5lcyBbYFVuYXJ5VHlwZWBdW10gYW5kIFtgVHlwZVZhcmlhYmxlYF1bXS5cbiAgLy8uXG4gIC8vLiBUbyBkZWZpbmUgYSB1bmFyeSB0eXBlIHZhcmlhYmxlIGB0IGFgIG9uZSBtdXN0IHByb3ZpZGU6XG4gIC8vLlxuICAvLy4gICAtIGEgbmFtZSAoY29udmVudGlvbmFsbHkgbWF0Y2hpbmcgYF5bYS16XSRgKTsgYW5kXG4gIC8vLlxuICAvLy4gICAtIHRoZSB0eXBlIG9mIGBhYCAoZXhwb3NlZCBhcyBgdC50eXBlcy4kMS50eXBlYCkuXG4gIC8vLlxuICAvLy4gQ29uc2lkZXIgdGhlIHR5cGUgb2YgYSBnZW5lcmFsaXplZCBgbWFwYDpcbiAgLy8uXG4gIC8vLiBgYGBoYXNrZWxsXG4gIC8vLiBtYXAgOjogRnVuY3RvciBmID0+IChhIC0+IGIpIC0+IGYgYSAtPiBmIGJcbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uIGBmYCBpcyBhIHVuYXJ5IHR5cGUgdmFyaWFibGUuIFdpdGggdHdvIChudWxsYXJ5KSB0eXBlIHZhcmlhYmxlcywgb25lXG4gIC8vLiB1bmFyeSB0eXBlIHZhcmlhYmxlLCBhbmQgb25lIFt0eXBlIGNsYXNzXVtdIGl0J3MgcG9zc2libGUgdG8gZGVmaW5lIGFcbiAgLy8uIGZ1bGx5IHBvbHltb3JwaGljIGBtYXBgIGZ1bmN0aW9uOlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uIGNvbnN0ICQgPSByZXF1aXJlKCdzYW5jdHVhcnktZGVmJyk7XG4gIC8vLiBjb25zdCBaID0gcmVxdWlyZSgnc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcycpO1xuICAvLy5cbiAgLy8uIGNvbnN0IGEgPSAkLlR5cGVWYXJpYWJsZSgnYScpO1xuICAvLy4gY29uc3QgYiA9ICQuVHlwZVZhcmlhYmxlKCdiJyk7XG4gIC8vLiBjb25zdCBmID0gJC5VbmFyeVR5cGVWYXJpYWJsZSgnZicpO1xuICAvLy5cbiAgLy8uIC8vICAgIG1hcCA6OiBGdW5jdG9yIGYgPT4gKGEgLT4gYikgLT4gZiBhIC0+IGYgYlxuICAvLy4gY29uc3QgbWFwID1cbiAgLy8uIGRlZignbWFwJyxcbiAgLy8uICAgICB7ZjogW1ouRnVuY3Rvcl19LFxuICAvLy4gICAgIFskLkZ1bmN0aW9uKFthLCBiXSksIGYoYSksIGYoYildLFxuICAvLy4gICAgIFoubWFwKTtcbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uIFdoZXJlYXMgYSByZWd1bGFyIHR5cGUgdmFyaWFibGUgaXMgZnVsbHkgcmVzb2x2ZWQgKGBhYCBtaWdodCBiZWNvbWVcbiAgLy8uIGBBcnJheSAoQXJyYXkgU3RyaW5nKWAsIGZvciBleGFtcGxlKSwgYSB1bmFyeSB0eXBlIHZhcmlhYmxlIGRlZmVycyB0b1xuICAvLy4gaXRzIHR5cGUgYXJndW1lbnQsIHdoaWNoIG1heSBpdHNlbGYgYmUgYSB0eXBlIHZhcmlhYmxlLiBUaGUgdHlwZSBhcmd1bWVudFxuICAvLy4gY29ycmVzcG9uZHMgdG8gdGhlIHR5cGUgYXJndW1lbnQgb2YgYSB1bmFyeSB0eXBlIG9yIHRoZSAqc2Vjb25kKiB0eXBlXG4gIC8vLiBhcmd1bWVudCBvZiBhIGJpbmFyeSB0eXBlLiBUaGUgc2Vjb25kIHR5cGUgYXJndW1lbnQgb2YgYE1hcCBrIHZgLCBmb3JcbiAgLy8uIGV4YW1wbGUsIGlzIGB2YC4gT25lIGNvdWxkIHJlcGxhY2UgYEZ1bmN0b3IgPT4gZmAgd2l0aCBgTWFwIGtgIG9yIHdpdGhcbiAgLy8uIGBNYXAgSW50ZWdlcmAsIGJ1dCBub3Qgd2l0aCBgTWFwYC5cbiAgLy8uXG4gIC8vLiBUaGlzIHNoYWxsb3cgaW5zcGVjdGlvbiBtYWtlcyBpdCBwb3NzaWJsZSB0byBjb25zdHJhaW4gYSB2YWx1ZSdzIFwib3V0ZXJcIlxuICAvLy4gYW5kIFwiaW5uZXJcIiB0eXBlcyBpbmRlcGVuZGVudGx5LlxuICBmdW5jdGlvbiBVbmFyeVR5cGVWYXJpYWJsZShuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCQxKSB7XG4gICAgICBmdW5jdGlvbiBmb3JtYXQob3V0ZXIsIGlubmVyKSB7XG4gICAgICAgIHJldHVybiBvdXRlcignKCcgKyBuYW1lICsgJyAnKSArIGlubmVyKCckMScpKFN0cmluZygkMSkpICsgb3V0ZXIoJyknKTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlcyA9IHskMToge2V4dHJhY3RvcjogSyhbXSksIHR5cGU6ICQxfX07XG4gICAgICByZXR1cm4gbmV3IF9UeXBlKFZBUklBQkxFLCBuYW1lLCAnJywgZm9ybWF0LCBLKHRydWUpLCBbJyQxJ10sIHR5cGVzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIENoZWNrZWRVbmFyeVR5cGVWYXJpYWJsZSA9XG4gIGRlZignVW5hcnlUeXBlVmFyaWFibGUnLFxuICAgICAge30sXG4gICAgICBbU3RyaW5nXywgQW55RnVuY3Rpb25dLFxuICAgICAgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gZGVmKG5hbWUsIHt9LCBbVHlwZSwgVHlwZV0sIFVuYXJ5VHlwZVZhcmlhYmxlKG5hbWUpKTtcbiAgICAgIH0pO1xuXG4gIC8vIyBCaW5hcnlUeXBlVmFyaWFibGUgOjogU3RyaW5nIC0+IChUeXBlIC0+IFR5cGUgLT4gVHlwZSlcbiAgLy8uXG4gIC8vLiBDb21iaW5lcyBbYEJpbmFyeVR5cGVgXVtdIGFuZCBbYFR5cGVWYXJpYWJsZWBdW10uXG4gIC8vLlxuICAvLy4gVG8gZGVmaW5lIGEgYmluYXJ5IHR5cGUgdmFyaWFibGUgYHQgYSBiYCBvbmUgbXVzdCBwcm92aWRlOlxuICAvLy5cbiAgLy8uICAgLSBhIG5hbWUgKGNvbnZlbnRpb25hbGx5IG1hdGNoaW5nIGBeW2Etel0kYCk7XG4gIC8vLlxuICAvLy4gICAtIHRoZSB0eXBlIG9mIGBhYCAoZXhwb3NlZCBhcyBgdC50eXBlcy4kMS50eXBlYCk7IGFuZFxuICAvLy5cbiAgLy8uICAgLSB0aGUgdHlwZSBvZiBgYmAgKGV4cG9zZWQgYXMgYHQudHlwZXMuJDIudHlwZWApLlxuICAvLy5cbiAgLy8uIFRoZSBtb3JlIGRldGFpbGVkIGV4cGxhbmF0aW9uIG9mIFtgVW5hcnlUeXBlVmFyaWFibGVgXVtdIGFsc28gYXBwbGllcyB0b1xuICAvLy4gYEJpbmFyeVR5cGVWYXJpYWJsZWAuXG4gIGZ1bmN0aW9uIEJpbmFyeVR5cGVWYXJpYWJsZShuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCQxLCAkMikge1xuICAgICAgZnVuY3Rpb24gZm9ybWF0KG91dGVyLCBpbm5lcikge1xuICAgICAgICByZXR1cm4gb3V0ZXIoJygnICsgbmFtZSArICcgJykgKyBpbm5lcignJDEnKShTdHJpbmcoJDEpKSArIG91dGVyKCcgJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lcignJDInKShTdHJpbmcoJDIpKSArIG91dGVyKCcpJyk7XG4gICAgICB9XG4gICAgICB2YXIga2V5cyA9IFsnJDEnLCAnJDInXTtcbiAgICAgIHZhciB0eXBlcyA9IHskMToge2V4dHJhY3RvcjogSyhbXSksIHR5cGU6ICQxfSxcbiAgICAgICAgICAgICAgICAgICAkMjoge2V4dHJhY3RvcjogSyhbXSksIHR5cGU6ICQyfX07XG4gICAgICByZXR1cm4gbmV3IF9UeXBlKFZBUklBQkxFLCBuYW1lLCAnJywgZm9ybWF0LCBLKHRydWUpLCBrZXlzLCB0eXBlcyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBDaGVja2VkQmluYXJ5VHlwZVZhcmlhYmxlID1cbiAgZGVmKCdCaW5hcnlUeXBlVmFyaWFibGUnLFxuICAgICAge30sXG4gICAgICBbU3RyaW5nXywgQW55RnVuY3Rpb25dLFxuICAgICAgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gZGVmKG5hbWUsIHt9LCBbVHlwZSwgVHlwZSwgVHlwZV0sIEJpbmFyeVR5cGVWYXJpYWJsZShuYW1lKSk7XG4gICAgICB9KTtcblxuICAvLyMgVGh1bmsgOjogVHlwZSAtPiBUeXBlXG4gIC8vLlxuICAvLy4gYCQuVGh1bmsoVClgIGlzIHNob3J0aGFuZCBmb3IgYCQuRnVuY3Rpb24oW1RdKWAsIHRoZSB0eXBlIGNvbXByaXNpbmdcbiAgLy8uIGV2ZXJ5IG51bGxhcnkgZnVuY3Rpb24gKHRodW5rKSB3aGljaCByZXR1cm5zIGEgdmFsdWUgb2YgdHlwZSBgVGAuXG4gIHZhciBUaHVuayA9XG4gIGRlZignVGh1bmsnLFxuICAgICAge30sXG4gICAgICBbVHlwZSwgVHlwZV0sXG4gICAgICBmdW5jdGlvbih0KSB7IHJldHVybiBGdW5jdGlvbl8oW3RdKTsgfSk7XG5cbiAgLy8jIFByZWRpY2F0ZSA6OiBUeXBlIC0+IFR5cGVcbiAgLy8uXG4gIC8vLiBgJC5QcmVkaWNhdGUoVClgIGlzIHNob3J0aGFuZCBmb3IgYCQuRnVuY3Rpb24oW1QsICQuQm9vbGVhbl0pYCwgdGhlIHR5cGVcbiAgLy8uIGNvbXByaXNpbmcgZXZlcnkgcHJlZGljYXRlIGZ1bmN0aW9uIHdoaWNoIHRha2VzIGEgdmFsdWUgb2YgdHlwZSBgVGAuXG4gIHZhciBQcmVkaWNhdGUgPVxuICBkZWYoJ1ByZWRpY2F0ZScsXG4gICAgICB7fSxcbiAgICAgIFtUeXBlLCBUeXBlXSxcbiAgICAgIGZ1bmN0aW9uKHQpIHsgcmV0dXJuIEZ1bmN0aW9uXyhbdCwgQm9vbGVhbl9dKTsgfSk7XG5cbiAgLy8uICMjIyBUeXBlIGNsYXNzZXNcbiAgLy8uXG4gIC8vLiBgY29uY2F0U2AsIGRlZmluZWQgZWFybGllciwgaXMgYSBmdW5jdGlvbiB3aGljaCBjb25jYXRlbmF0ZXMgdHdvIHN0cmluZ3MuXG4gIC8vLiBUaGlzIGlzIG92ZXJseSByZXN0cmljdGl2ZSwgc2luY2Ugb3RoZXIgdHlwZXMgc3VwcG9ydCBjb25jYXRlbmF0aW9uXG4gIC8vLiAoQXJyYXksIGZvciBleGFtcGxlKS5cbiAgLy8uXG4gIC8vLiBPbmUgY291bGQgdXNlIGEgdHlwZSB2YXJpYWJsZSB0byBkZWZpbmUgYSBwb2x5bW9ycGhpYyBcImNvbmNhdFwiIGZ1bmN0aW9uOlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uIC8vICAgIF9jb25jYXQgOjogYSAtPiBhIC0+IGFcbiAgLy8uIGNvbnN0IF9jb25jYXQgPVxuICAvLy4gZGVmKCdfY29uY2F0Jywge30sIFthLCBhLCBhXSwgKHgsIHkpID0+IHguY29uY2F0KHkpKTtcbiAgLy8uXG4gIC8vLiBfY29uY2F0KCdmaXp6JywgJ2J1enonKTtcbiAgLy8uIC8vID0+ICdmaXp6YnV6eidcbiAgLy8uXG4gIC8vLiBfY29uY2F0KFsxLCAyXSwgWzMsIDRdKTtcbiAgLy8uIC8vID0+IFsxLCAyLCAzLCA0XVxuICAvLy5cbiAgLy8uIF9jb25jYXQoWzEsIDJdLCAnYnV6eicpO1xuICAvLy4gLy8gISBUeXBlRXJyb3I6IFR5cGUtdmFyaWFibGUgY29uc3RyYWludCB2aW9sYXRpb25cbiAgLy8uIC8vXG4gIC8vLiAvLyAgIF9jb25jYXQgOjogYSAtPiBhIC0+IGFcbiAgLy8uIC8vICAgICAgICAgICAgICBeICAgIF5cbiAgLy8uIC8vICAgICAgICAgICAgICAxICAgIDJcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIDEpICBbMSwgMl0gOjogQXJyYXkgTnVtYmVyXG4gIC8vLiAvL1xuICAvLy4gLy8gICAyKSAgXCJidXp6XCIgOjogU3RyaW5nXG4gIC8vLiAvL1xuICAvLy4gLy8gICBTaW5jZSB0aGVyZSBpcyBubyB0eXBlIG9mIHdoaWNoIGFsbCB0aGUgYWJvdmUgdmFsdWVzIGFyZSBtZW1iZXJzLCB0aGUgdHlwZS12YXJpYWJsZSBjb25zdHJhaW50IGhhcyBiZWVuIHZpb2xhdGVkLlxuICAvLy4gYGBgXG4gIC8vLlxuICAvLy4gVGhlIHR5cGUgb2YgYF9jb25jYXRgIGlzIG1pc2xlYWRpbmc6IGl0IHN1Z2dlc3RzIHRoYXQgaXQgY2FuIG9wZXJhdGUgb25cbiAgLy8uIGFueSB0d28gdmFsdWVzIG9mICphbnkqIG9uZSB0eXBlLiBJbiBmYWN0IHRoZXJlJ3MgYW4gaW1wbGljaXQgY29uc3RyYWludCxcbiAgLy8uIHNpbmNlIHRoZSB0eXBlIG11c3Qgc3VwcG9ydCBjb25jYXRlbmF0aW9uIChpbiBbbWF0aGVtYXRpY2FsXVtzZW1pZ3JvdXBdXG4gIC8vLiB0ZXJtcywgdGhlIHR5cGUgbXVzdCBoYXZlIGEgW3NlbWlncm91cF1bRkw6U2VtaWdyb3VwXSkuIFRoZSBydW4tdGltZSB0eXBlXG4gIC8vLiBlcnJvcnMgdGhhdCByZXN1bHQgd2hlbiB0aGlzIGNvbnN0cmFpbnQgaXMgdmlvbGF0ZWQgYXJlIG5vdCBwYXJ0aWN1bGFybHlcbiAgLy8uIGRlc2NyaXB0aXZlOlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uIF9jb25jYXQoe30sIHt9KTtcbiAgLy8uIC8vICEgVHlwZUVycm9yOiB1bmRlZmluZWQgaXMgbm90IGEgZnVuY3Rpb25cbiAgLy8uXG4gIC8vLiBfY29uY2F0KG51bGwsIG51bGwpO1xuICAvLy4gLy8gISBUeXBlRXJyb3I6IENhbm5vdCByZWFkIHByb3BlcnR5ICdjb25jYXQnIG9mIG51bGxcbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uIFRoZSBzb2x1dGlvbiBpcyB0byBjb25zdHJhaW4gYGFgIGJ5IGZpcnN0IGRlZmluaW5nIGEgW2BUeXBlQ2xhc3NgXVtdXG4gIC8vLiB2YWx1ZSwgdGhlbiBzcGVjaWZ5aW5nIHRoZSBjb25zdHJhaW50IGluIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBcImNvbmNhdFwiXG4gIC8vLiBmdW5jdGlvbjpcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiBjb25zdCBaID0gcmVxdWlyZSgnc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcycpO1xuICAvLy5cbiAgLy8uIC8vICAgIFNlbWlncm91cCA6OiBUeXBlQ2xhc3NcbiAgLy8uIGNvbnN0IFNlbWlncm91cCA9IFouVHlwZUNsYXNzKFxuICAvLy4gICAnbXktcGFja2FnZS9TZW1pZ3JvdXAnLFxuICAvLy4gICAnaHR0cDovL2V4YW1wbGUuY29tL215LXBhY2thZ2UjU2VtaWdyb3VwJyxcbiAgLy8uICAgW10sXG4gIC8vLiAgIHggPT4geCAhPSBudWxsICYmIHR5cGVvZiB4LmNvbmNhdCA9PT0gJ2Z1bmN0aW9uJ1xuICAvLy4gKTtcbiAgLy8uXG4gIC8vLiAvLyAgICBjb25jYXQgOjogU2VtaWdyb3VwIGEgPT4gYSAtPiBhIC0+IGFcbiAgLy8uIGNvbnN0IGNvbmNhdCA9XG4gIC8vLiBkZWYoJ2NvbmNhdCcsIHthOiBbU2VtaWdyb3VwXX0sIFthLCBhLCBhXSwgKHgsIHkpID0+IHguY29uY2F0KHkpKTtcbiAgLy8uXG4gIC8vLiBjb25jYXQoWzEsIDJdLCBbMywgNF0pO1xuICAvLy4gLy8gPT4gWzEsIDIsIDMsIDRdXG4gIC8vLlxuICAvLy4gY29uY2F0KHt9LCB7fSk7XG4gIC8vLiAvLyAhIFR5cGVFcnJvcjogVHlwZS1jbGFzcyBjb25zdHJhaW50IHZpb2xhdGlvblxuICAvLy4gLy9cbiAgLy8uIC8vICAgY29uY2F0IDo6IFNlbWlncm91cCBhID0+IGEgLT4gYSAtPiBhXG4gIC8vLiAvLyAgICAgICAgICAgICBeXl5eXl5eXl5eXiAgICBeXG4gIC8vLiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAxXG4gIC8vLiAvL1xuICAvLy4gLy8gICAxKSAge30gOjogT2JqZWN0LCBTdHJNYXAgPz8/XG4gIC8vLiAvL1xuICAvLy4gLy8gICDigJhjb25jYXTigJkgcmVxdWlyZXMg4oCYYeKAmSB0byBzYXRpc2Z5IHRoZSBTZW1pZ3JvdXAgdHlwZS1jbGFzcyBjb25zdHJhaW50OyB0aGUgdmFsdWUgYXQgcG9zaXRpb24gMSBkb2VzIG5vdC5cbiAgLy8uIC8vXG4gIC8vLiAvLyAgIFNlZSBodHRwOi8vZXhhbXBsZS5jb20vbXktcGFja2FnZSNTZW1pZ3JvdXAgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBteS1wYWNrYWdlL1NlbWlncm91cCB0eXBlIGNsYXNzLlxuICAvLy5cbiAgLy8uIGNvbmNhdChudWxsLCBudWxsKTtcbiAgLy8uIC8vICEgVHlwZUVycm9yOiBUeXBlLWNsYXNzIGNvbnN0cmFpbnQgdmlvbGF0aW9uXG4gIC8vLiAvL1xuICAvLy4gLy8gICBjb25jYXQgOjogU2VtaWdyb3VwIGEgPT4gYSAtPiBhIC0+IGFcbiAgLy8uIC8vICAgICAgICAgICAgIF5eXl5eXl5eXl5eICAgIF5cbiAgLy8uIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIDEpICBudWxsIDo6IE51bGxcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIOKAmGNvbmNhdOKAmSByZXF1aXJlcyDigJhh4oCZIHRvIHNhdGlzZnkgdGhlIFNlbWlncm91cCB0eXBlLWNsYXNzIGNvbnN0cmFpbnQ7IHRoZSB2YWx1ZSBhdCBwb3NpdGlvbiAxIGRvZXMgbm90LlxuICAvLy4gLy9cbiAgLy8uIC8vICAgU2VlIGh0dHA6Ly9leGFtcGxlLmNvbS9teS1wYWNrYWdlI1NlbWlncm91cCBmb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG15LXBhY2thZ2UvU2VtaWdyb3VwIHR5cGUgY2xhc3MuXG4gIC8vLiBgYGBcbiAgLy8uXG4gIC8vLiBNdWx0aXBsZSBjb25zdHJhaW50cyBtYXkgYmUgcGxhY2VkIG9uIGEgdHlwZSB2YXJpYWJsZSBieSBpbmNsdWRpbmdcbiAgLy8uIG11bHRpcGxlIGBUeXBlQ2xhc3NgIHZhbHVlcyBpbiB0aGUgYXJyYXkgKGUuZy4gYHthOiBbRm9vLCBCYXIsIEJhel19YCkuXG5cbiAgLy8gIGNoZWNrVmFsdWUgOjogLi4uIC0+IFVuZGVmaW5lZFxuICBmdW5jdGlvbiBjaGVja1ZhbHVlKFxuICAgIGVudiwgICAgICAgICAgICAgICAgLy8gOjogQXJyYXkgVHlwZVxuICAgIHR5cGVJbmZvLCAgICAgICAgICAgLy8gOjogVHlwZUluZm9cbiAgICAkdHlwZVZhck1hcEJveCwgICAgIC8vIDo6IEJveCBUeXBlVmFyTWFwXG4gICAgaW5kZXgsICAgICAgICAgICAgICAvLyA6OiBJbnRlZ2VyXG4gICAgcHJvcFBhdGgsICAgICAgICAgICAvLyA6OiBQcm9wUGF0aFxuICAgIHQsICAgICAgICAgICAgICAgICAgLy8gOjogVHlwZVxuICAgIHZhbHVlICAgICAgICAgICAgICAgLy8gOjogQW55XG4gICkge1xuICAgIGlmICh0LnR5cGUgPT09IFZBUklBQkxFKSB7XG4gICAgICAkdHlwZVZhck1hcEJveFswXSA9XG4gICAgICAgIHVwZGF0ZVR5cGVWYXJNYXAoZW52LCAkdHlwZVZhck1hcEJveFswXSwgdCwgaW5kZXgsIHByb3BQYXRoLCBbdmFsdWVdKTtcbiAgICAgIGlmIChpc0VtcHR5KCR0eXBlVmFyTWFwQm94WzBdW3QubmFtZV0udHlwZXMpKSB7XG4gICAgICAgIHRocm93IHR5cGVWYXJDb25zdHJhaW50VmlvbGF0aW9uKFxuICAgICAgICAgIGVudixcbiAgICAgICAgICB0eXBlSW5mbyxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBwcm9wUGF0aCxcbiAgICAgICAgICAkdHlwZVZhck1hcEJveFswXVt0Lm5hbWVdLnZhbHVlc0J5UGF0aFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXRlc3QoZW52LCB0LCB2YWx1ZSkpIHtcbiAgICAgIHRocm93IGludmFsaWRWYWx1ZShlbnYsIHR5cGVJbmZvLCBpbmRleCwgcHJvcFBhdGgsIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvLyAgd3JhcEZ1bmN0aW9uIDo6IC4uLiAtPiBGdW5jdGlvblxuICBmdW5jdGlvbiB3cmFwRnVuY3Rpb24oXG4gICAgZW52LCAgICAgICAgICAgICAgICAvLyA6OiBBcnJheSBUeXBlXG4gICAgdHlwZUluZm8sICAgICAgICAgICAvLyA6OiBUeXBlSW5mb1xuICAgICR0eXBlVmFyTWFwQm94LCAgICAgLy8gOjogQm94IFR5cGVWYXJNYXBcbiAgICBpbmRleCwgICAgICAgICAgICAgIC8vIDo6IEludGVnZXJcbiAgICBmICAgICAgICAgICAgICAgICAgIC8vIDo6IEZ1bmN0aW9uXG4gICkge1xuICAgIHZhciBleHBUeXBlID0gdHlwZUluZm8udHlwZXNbaW5kZXhdO1xuICAgIHZhciBudW1BcmdzRXhwZWN0ZWQgPSBleHBUeXBlLmtleXMubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gYXJpdHkobnVtQXJnc0V4cGVjdGVkLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSBudW1BcmdzRXhwZWN0ZWQpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZEFyZ3VtZW50c0xlbmd0aCh0eXBlSW5mbywgaW5kZXgsIG51bUFyZ3NFeHBlY3RlZCwgYXJncyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjaGVja1ZhbHVlJChwcm9wUGF0aCwgdCwgeCkge1xuICAgICAgICBjaGVja1ZhbHVlKGVudiwgdHlwZUluZm8sICR0eXBlVmFyTWFwQm94LCBpbmRleCwgcHJvcFBhdGgsIHQsIHgpO1xuICAgICAgfVxuICAgICAgaW5pdChleHBUeXBlLmtleXMpLmZvckVhY2goZnVuY3Rpb24oaywgaWR4KSB7XG4gICAgICAgIGNoZWNrVmFsdWUkKFtrXSwgZXhwVHlwZS50eXBlc1trXS50eXBlLCBhcmdzW2lkeF0pO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBvdXRwdXQgPSBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB2YXIgayA9IGxhc3QoZXhwVHlwZS5rZXlzKTtcbiAgICAgIGNoZWNrVmFsdWUkKFtrXSwgZXhwVHlwZS50eXBlc1trXS50eXBlLCBvdXRwdXQpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KTtcbiAgfVxuXG4gIC8vICB3cmFwRnVuY3Rpb25Db25kIDo6XG4gIC8vICAgIEFycmF5IFR5cGUgLT4gVHlwZUluZm8gLT4gQm94IFR5cGVWYXJNYXAgLT4gSW50ZWdlciAtPiBhIC0+IGFcbiAgZnVuY3Rpb24gd3JhcEZ1bmN0aW9uQ29uZChlbnYsIHR5cGVJbmZvLCAkdHlwZVZhck1hcEJveCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVJbmZvLnR5cGVzW2luZGV4XS50eXBlID09PSBGVU5DVElPTiA/XG4gICAgICB3cmFwRnVuY3Rpb24oZW52LCB0eXBlSW5mbywgJHR5cGVWYXJNYXBCb3gsIGluZGV4LCB2YWx1ZSkgOlxuICAgICAgdmFsdWU7XG4gIH1cblxuICAvLyAgd3JhcEZ1bmN0aW9ucyA6OiAuLi4gLT4gQXJyYXkgQW55XG4gIGZ1bmN0aW9uIHdyYXBGdW5jdGlvbnMoXG4gICAgZW52LCAgICAgICAgICAgICAgICAvLyA6OiBBcnJheSBUeXBlXG4gICAgdHlwZUluZm8sICAgICAgICAgICAvLyA6OiBUeXBlSW5mb1xuICAgICR0eXBlVmFyTWFwQm94LCAgICAgLy8gOjogQm94IFR5cGVWYXJNYXBcbiAgICB2YWx1ZXMgICAgICAgICAgICAgIC8vIDo6IEFycmF5IEFueVxuICApIHtcbiAgICByZXR1cm4gdmFsdWVzLm1hcChmdW5jdGlvbih2YWx1ZSwgaWR4KSB7XG4gICAgICByZXR1cm4gd3JhcEZ1bmN0aW9uQ29uZChlbnYsIHR5cGVJbmZvLCAkdHlwZVZhck1hcEJveCwgaWR4LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyAgdG9vTWFueUFyZ3VtZW50cyA6OiAoVHlwZUluZm8sIEludGVnZXIpIC0+IEVycm9yXG4gIC8vXG4gIC8vICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW4gYGN1cnJ5YCB3aGVuIGEgZnVuY3Rpb24gZGVmaW5lZCB2aWEgYGRlZmBcbiAgLy8gIGlzIGFwcGxpZWQgdG8gdG9vIG1hbnkgYXJndW1lbnRzLlxuICBmdW5jdGlvbiB0b29NYW55QXJndW1lbnRzKHR5cGVJbmZvLCBudW1BcmdzUmVjZWl2ZWQpIHtcbiAgICB2YXIgbnVtQXJnc0V4cGVjdGVkID0gdHlwZUluZm8udHlwZXMubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvcih0cmltVHJhaWxpbmdTcGFjZXMoXG4gICAgICAnRnVuY3Rpb24gYXBwbGllZCB0byB0b28gbWFueSBhcmd1bWVudHNcXG5cXG4nICtcbiAgICAgIHR5cGVTaWduYXR1cmUodHlwZUluZm8pICsgJ1xcblxcbicgK1xuICAgICAgcSh0eXBlSW5mby5uYW1lKSArICcgZXhwZWN0ZWQnICtcbiAgICAgIChudW1BcmdzRXhwZWN0ZWQgPiAwID8gJyBhdCBtb3N0ICcgOiAnICcpICsgbnVtQXJncyhudW1BcmdzRXhwZWN0ZWQpICtcbiAgICAgICcgYnV0IHJlY2VpdmVkICcgKyBudW1BcmdzKG51bUFyZ3NSZWNlaXZlZCkgKyAnLlxcbidcbiAgICApKTtcbiAgfVxuXG4gIC8vICBjb25zdHJhaW50c1JlcHIgOjogLi4uIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBjb25zdHJhaW50c1JlcHIoXG4gICAgY29uc3RyYWludHMsICAgIC8vIDo6IFN0ck1hcCAoQXJyYXkgVHlwZUNsYXNzKVxuICAgIG91dGVyLCAgICAgICAgICAvLyA6OiBTdHJpbmcgLT4gU3RyaW5nXG4gICAgaW5uZXIgICAgICAgICAgIC8vIDo6IFN0cmluZyAtPiBUeXBlQ2xhc3MgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICApIHtcbiAgICB2YXIgJHJlcHJzID0gW107XG4gICAgT2JqZWN0LmtleXMoY29uc3RyYWludHMpLnNvcnQoKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBmID0gaW5uZXIoayk7XG4gICAgICBjb25zdHJhaW50c1trXS5mb3JFYWNoKGZ1bmN0aW9uKHR5cGVDbGFzcykge1xuICAgICAgICAkcmVwcnMucHVzaChmKHR5cGVDbGFzcykoc3RyaXBOYW1lc3BhY2UodHlwZUNsYXNzLm5hbWUpICsgJyAnICsgaykpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHdoZW4oJHJlcHJzLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24ocykgeyByZXR1cm4gcyArIG91dGVyKCcgPT4gJyk7IH0sXG4gICAgICAgICAgICAgICAgd2hlbigkcmVwcnMubGVuZ3RoID4gMSxcbiAgICAgICAgICAgICAgICAgICAgIHdyYXAob3V0ZXIoJygnKSkob3V0ZXIoJyknKSksXG4gICAgICAgICAgICAgICAgICAgICAkcmVwcnMuam9pbihvdXRlcignLCAnKSkpKTtcbiAgfVxuXG4gIC8vICBsYWJlbCA6OiBTdHJpbmcgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBsYWJlbChsYWJlbCkge1xuICAgIHJldHVybiBmdW5jdGlvbihzKSB7XG4gICAgICB2YXIgZGVsdGEgPSBzLmxlbmd0aCAtIGxhYmVsLmxlbmd0aDtcbiAgICAgIHJldHVybiBzdHJSZXBlYXQoJyAnLCBNYXRoLmZsb29yKGRlbHRhIC8gMikpICsgbGFiZWwgK1xuICAgICAgICAgICAgIHN0clJlcGVhdCgnICcsIE1hdGguY2VpbChkZWx0YSAvIDIpKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gIHR5cGVWYXJOYW1lcyA6OiBUeXBlIC0+IEFycmF5IFN0cmluZ1xuICBmdW5jdGlvbiB0eXBlVmFyTmFtZXModCkge1xuICAgIHJldHVybiBaLmNvbmNhdChcbiAgICAgIHQudHlwZSA9PT0gVkFSSUFCTEUgPyBbdC5uYW1lXSA6IFtdLFxuICAgICAgWi5jaGFpbihmdW5jdGlvbihrKSB7IHJldHVybiB0eXBlVmFyTmFtZXModC50eXBlc1trXS50eXBlKTsgfSwgdC5rZXlzKVxuICAgICk7XG4gIH1cblxuICAvLyAgc2hvd1R5cGVXaXRoIDo6IFR5cGVJbmZvIC0+IFR5cGUgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIHNob3dUeXBlV2l0aCh0eXBlSW5mbykge1xuICAgIHZhciBuYW1lcyA9IFouY2hhaW4odHlwZVZhck5hbWVzLCB0eXBlSW5mby50eXBlcyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBjb2RlID0gJ2EnLmNoYXJDb2RlQXQoMCk7XG4gICAgICByZXR1cm4gdW5sZXNzKFxuICAgICAgICB0LnR5cGUgPT09IEZVTkNUSU9OIHx8IHQudHlwZSA9PT0gUkVDT1JEIHx8IGlzRW1wdHkodC5rZXlzKSxcbiAgICAgICAgc3RyaXBPdXRlcm1vc3RQYXJlbnMsXG4gICAgICAgIFN0cmluZyh0KS5yZXBsYWNlKC9cXGJVbmtub3duXFxiL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wbHVzcGx1c1xuICAgICAgICAgIGRvIHZhciBuYW1lID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKyspO1xuICAgICAgICAgIHdoaWxlIChuYW1lcy5pbmRleE9mKG5hbWUpID49IDApO1xuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gIHNob3dUeXBlUXVvdGVkIDo6IFR5cGUgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIHNob3dUeXBlUXVvdGVkKHQpIHtcbiAgICByZXR1cm4gcSh1bmxlc3ModC50eXBlID09PSBSRUNPUkQgfHwgaXNFbXB0eSh0LmtleXMpLFxuICAgICAgICAgICAgICAgICAgICBzdHJpcE91dGVybW9zdFBhcmVucyxcbiAgICAgICAgICAgICAgICAgICAgU3RyaW5nKHQpKSk7XG4gIH1cblxuICAvLyAgc2hvd1ZhbHVlc0FuZFR5cGVzIDo6IC4uLiAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gc2hvd1ZhbHVlc0FuZFR5cGVzKFxuICAgIGVudiwgICAgICAgICAgICAvLyA6OiBBcnJheSBUeXBlXG4gICAgdHlwZUluZm8sICAgICAgIC8vIDo6IFR5cGVJbmZvXG4gICAgdmFsdWVzLCAgICAgICAgIC8vIDo6IEFycmF5IEFueVxuICAgIHBvcyAgICAgICAgICAgICAvLyA6OiBJbnRlZ2VyXG4gICkge1xuICAgIHZhciBzaG93VHlwZSA9IHNob3dUeXBlV2l0aCh0eXBlSW5mbyk7XG4gICAgcmV0dXJuIFN0cmluZyhwb3MpICsgJykgICcgKyBaLm1hcChmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgdHlwZXMgPSBkZXRlcm1pbmVBY3R1YWxUeXBlc0xvb3NlKGVudiwgW3hdKTtcbiAgICAgIHJldHVybiBaLnRvU3RyaW5nKHgpICsgJyA6OiAnICsgWi5tYXAoc2hvd1R5cGUsIHR5cGVzKS5qb2luKCcsICcpO1xuICAgIH0sIHZhbHVlcykuam9pbignXFxuICAgICcpO1xuICB9XG5cbiAgLy8gIHR5cGVTaWduYXR1cmUgOjogVHlwZUluZm8gLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIHR5cGVTaWduYXR1cmUodHlwZUluZm8pIHtcbiAgICB2YXIgcmVwcnMgPSBaLm1hcChzaG93VHlwZVdpdGgodHlwZUluZm8pLCB0eXBlSW5mby50eXBlcyk7XG4gICAgdmFyIGFyaXR5ID0gcmVwcnMubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gdHlwZUluZm8ubmFtZSArICcgOjogJyArXG4gICAgICAgICAgICAgY29uc3RyYWludHNSZXByKHR5cGVJbmZvLmNvbnN0cmFpbnRzLCBpZCwgSyhLKGlkKSkpICtcbiAgICAgICAgICAgICB3aGVuKGFyaXR5ID09PSAwLCBwYXJlbnRoZXNpemUsIGluaXQocmVwcnMpLmpvaW4oJyAtPiAnKSkgK1xuICAgICAgICAgICAgICcgLT4gJyArIGxhc3QocmVwcnMpO1xuICB9XG5cbiAgLy8gIF91bmRlcmxpbmUgOjogLi4uIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBfdW5kZXJsaW5lKFxuICAgIHQsICAgICAgICAgICAgICAvLyA6OiBUeXBlXG4gICAgcHJvcFBhdGgsICAgICAgIC8vIDo6IFByb3BQYXRoXG4gICAgZm9ybWF0VHlwZTMgICAgIC8vIDo6IFR5cGUgLT4gQXJyYXkgU3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgKSB7XG4gICAgcmV0dXJuIHVubGVzcyh0LnR5cGUgPT09IFJFQ09SRCB8fFxuICAgICAgICAgICAgICAgICAgICBpc0VtcHR5KHQua2V5cykgfHxcbiAgICAgICAgICAgICAgICAgICAgdC50eXBlID09PSBGVU5DVElPTiAmJiBpc0VtcHR5KHByb3BQYXRoKSB8fFxuICAgICAgICAgICAgICAgICAgICAhaXNFbXB0eShwcm9wUGF0aCksXG4gICAgICAgICAgICAgICAgICBzdHJpcE91dGVybW9zdFBhcmVucyxcbiAgICAgICAgICAgICAgICAgIGZvcm1hdFR5cGUzKHQpKHByb3BQYXRoKSh0LmZvcm1hdChfLCBmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBLKF91bmRlcmxpbmUodC50eXBlc1trXS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFouY29uY2F0KHByb3BQYXRoLCBba10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdFR5cGUzKSk7XG4gICAgICAgICAgICAgICAgICB9KSkpO1xuICB9XG5cbiAgLy8gIHVuZGVybGluZSA6OiAuLi4gLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIHVuZGVybGluZShcbiAgICB0eXBlSW5mbywgICAgICAgICAgICAgICAvLyA6OiBUeXBlSW5mb1xuICAgIHVuZGVybGluZUNvbnN0cmFpbnQsICAgIC8vIDo6IFN0cmluZyAtPiBUeXBlQ2xhc3MgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICAgIGZvcm1hdFR5cGU1XG4gICAgLy8gOjogSW50ZWdlciAtPiAoU3RyaW5nIC0+IFN0cmluZykgLT4gVHlwZSAtPiBQcm9wUGF0aCAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gICkge1xuICAgIHZhciBzdCA9IHR5cGVJbmZvLnR5cGVzLnJlZHVjZShmdW5jdGlvbihzdCwgdCwgaW5kZXgpIHtcbiAgICAgIHZhciBmb3JtYXRUeXBlNCA9IGZvcm1hdFR5cGU1KGluZGV4KTtcbiAgICAgIHZhciBjb3VudGVyID0gc3QuY291bnRlcjtcbiAgICAgIGZ1bmN0aW9uIHJlcGxhY2UocykgeyByZXR1cm4gbGFiZWwoU3RyaW5nKGNvdW50ZXIgKz0gMSkpKHMpOyB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYXJldHM6IFouY29uY2F0KHN0LmNhcmV0cywgW191bmRlcmxpbmUodCwgW10sIGZvcm1hdFR5cGU0KHIoJ14nKSkpXSksXG4gICAgICAgIG51bWJlcnM6IFouY29uY2F0KHN0Lm51bWJlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtfdW5kZXJsaW5lKHQsIFtdLCBmb3JtYXRUeXBlNChyZXBsYWNlKSldKSxcbiAgICAgICAgY291bnRlcjogY291bnRlclxuICAgICAgfTtcbiAgICB9LCB7Y2FyZXRzOiBbXSwgbnVtYmVyczogW10sIGNvdW50ZXI6IDB9KTtcblxuICAgIHJldHVybiB0eXBlU2lnbmF0dXJlKHR5cGVJbmZvKSArICdcXG4nICtcbiAgICAgICAgICAgXyh0eXBlSW5mby5uYW1lICsgJyA6OiAnKSArXG4gICAgICAgICAgICAgY29uc3RyYWludHNSZXByKHR5cGVJbmZvLmNvbnN0cmFpbnRzLCBfLCB1bmRlcmxpbmVDb25zdHJhaW50KSArXG4gICAgICAgICAgICAgc3QuY2FyZXRzLmpvaW4oXygnIC0+ICcpKSArICdcXG4nICtcbiAgICAgICAgICAgXyh0eXBlSW5mby5uYW1lICsgJyA6OiAnKSArXG4gICAgICAgICAgICAgY29uc3RyYWludHNSZXByKHR5cGVJbmZvLmNvbnN0cmFpbnRzLCBfLCBLKEsoXykpKSArXG4gICAgICAgICAgICAgc3QubnVtYmVycy5qb2luKF8oJyAtPiAnKSkgKyAnXFxuJztcbiAgfVxuXG4gIC8vICByZXNvbHZlUHJvcFBhdGggOjogKFR5cGUsIEFycmF5IFN0cmluZykgLT4gVHlwZVxuICBmdW5jdGlvbiByZXNvbHZlUHJvcFBhdGgodCwgcHJvcFBhdGgpIHtcbiAgICByZXR1cm4gWi5yZWR1Y2UoZnVuY3Rpb24odCwgcHJvcCkgeyByZXR1cm4gdC50eXBlc1twcm9wXS50eXBlOyB9LFxuICAgICAgICAgICAgICAgICAgICB0LFxuICAgICAgICAgICAgICAgICAgICBwcm9wUGF0aCk7XG4gIH1cblxuICAvLyAgZm9ybWF0VHlwZTYgOjpcbiAgLy8gICAgUHJvcFBhdGggLT4gSW50ZWdlciAtPiAoU3RyaW5nIC0+IFN0cmluZykgLT5cbiAgLy8gICAgICBUeXBlIC0+IFByb3BQYXRoIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gZm9ybWF0VHlwZTYoaW5kZXhlZFByb3BQYXRoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGluZGV4Xykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ocHJvcFBhdGhfKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXhlZFByb3BQYXRoXyA9IFouY29uY2F0KFtpbmRleF9dLCBwcm9wUGF0aF8pO1xuICAgICAgICAgICAgdmFyIHAgPSBpc1ByZWZpeChpbmRleGVkUHJvcFBhdGhfKShpbmRleGVkUHJvcFBhdGgpO1xuICAgICAgICAgICAgdmFyIHEgPSBpc1ByZWZpeChpbmRleGVkUHJvcFBhdGgpKGluZGV4ZWRQcm9wUGF0aF8pO1xuICAgICAgICAgICAgcmV0dXJuIHAgJiYgcSA/IGYgOiBwID8gaWQgOiBfO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICAvLyAgc2VlIDo6IChTdHJpbmcsIHsgbmFtZSA6OiBTdHJpbmcsIHVybCA6OiBTdHJpbmc/IH0pIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBzZWUobGFiZWwsIHJlY29yZCkge1xuICAgIHJldHVybiByZWNvcmQudXJsID09IG51bGwgfHwgcmVjb3JkLnVybCA9PT0gJycgP1xuICAgICAgICAgICAnJyA6XG4gICAgICAgICAgICdcXG5TZWUgJyArIHJlY29yZC51cmwgK1xuICAgICAgICAgICAnIGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgJyArIHJlY29yZC5uYW1lICsgJyAnICsgbGFiZWwgKyAnLlxcbic7XG4gIH1cblxuICAvLyAgdHlwZUNsYXNzQ29uc3RyYWludFZpb2xhdGlvbiA6OiAuLi4gLT4gRXJyb3JcbiAgZnVuY3Rpb24gdHlwZUNsYXNzQ29uc3RyYWludFZpb2xhdGlvbihcbiAgICBlbnYsICAgICAgICAgICAgLy8gOjogQXJyYXkgVHlwZVxuICAgIHR5cGVJbmZvLCAgICAgICAvLyA6OiBUeXBlSW5mb1xuICAgIHR5cGVDbGFzcywgICAgICAvLyA6OiBUeXBlQ2xhc3NcbiAgICBpbmRleCwgICAgICAgICAgLy8gOjogSW50ZWdlclxuICAgIHByb3BQYXRoLCAgICAgICAvLyA6OiBQcm9wUGF0aFxuICAgIHZhbHVlLCAgICAgICAgICAvLyA6OiBBbnlcbiAgICB0eXBlVmFyTWFwICAgICAgLy8gOjogVHlwZVZhck1hcFxuICApIHtcbiAgICB2YXIgZXhwVHlwZSA9IHJlc29sdmVQcm9wUGF0aCh0eXBlSW5mby50eXBlc1tpbmRleF0sIHByb3BQYXRoKTtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvcih0cmltVHJhaWxpbmdTcGFjZXMoXG4gICAgICAnVHlwZS1jbGFzcyBjb25zdHJhaW50IHZpb2xhdGlvblxcblxcbicgK1xuICAgICAgdW5kZXJsaW5lKHR5cGVJbmZvLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHR2bikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRjKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0dm4gPT09IGV4cFR5cGUubmFtZSAmJiB0Yy5uYW1lID09PSB0eXBlQ2xhc3MubmFtZSA/XG4gICAgICAgICAgICAgICAgICAgICAgcignXicpIDpcbiAgICAgICAgICAgICAgICAgICAgICBfO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZvcm1hdFR5cGU2KFouY29uY2F0KFtpbmRleF0sIHByb3BQYXRoKSkpICtcbiAgICAgICdcXG4nICtcbiAgICAgIHNob3dWYWx1ZXNBbmRUeXBlcyhlbnYsIHR5cGVJbmZvLCBbdmFsdWVdLCAxKSArICdcXG5cXG4nICtcbiAgICAgIHEodHlwZUluZm8ubmFtZSkgKyAnIHJlcXVpcmVzICcgKyBxKGV4cFR5cGUubmFtZSkgKyAnIHRvIHNhdGlzZnkgdGhlICcgK1xuICAgICAgc3RyaXBOYW1lc3BhY2UodHlwZUNsYXNzLm5hbWUpICsgJyB0eXBlLWNsYXNzIGNvbnN0cmFpbnQ7ICcgK1xuICAgICAgJ3RoZSB2YWx1ZSBhdCBwb3NpdGlvbiAxIGRvZXMgbm90LlxcbicgK1xuICAgICAgc2VlKCd0eXBlIGNsYXNzJywgdHlwZUNsYXNzKVxuICAgICkpO1xuICB9XG5cbiAgLy8gIHR5cGVWYXJDb25zdHJhaW50VmlvbGF0aW9uIDo6IC4uLiAtPiBFcnJvclxuICBmdW5jdGlvbiB0eXBlVmFyQ29uc3RyYWludFZpb2xhdGlvbihcbiAgICBlbnYsICAgICAgICAgICAgLy8gOjogQXJyYXkgVHlwZVxuICAgIHR5cGVJbmZvLCAgICAgICAvLyA6OiBUeXBlSW5mb1xuICAgIGluZGV4LCAgICAgICAgICAvLyA6OiBJbnRlZ2VyXG4gICAgcHJvcFBhdGgsICAgICAgIC8vIDo6IFByb3BQYXRoXG4gICAgdmFsdWVzQnlQYXRoICAgIC8vIDo6IFN0ck1hcCAoQXJyYXkgQW55KVxuICApIHtcbiAgICAvLyAgSWYgd2UgYXBwbHkgYW4g4oCYYSAtPiBhIC0+IGEgLT4gYeKAmSBmdW5jdGlvbiB0byBMZWZ0KCd4JyksIFJpZ2h0KDEpLCBhbmRcbiAgICAvLyAgUmlnaHQobnVsbCkgd2UnZCBsaWtlIHRvIGF2b2lkIHVuZGVybGluaW5nIHRoZSBmaXJzdCBhcmd1bWVudCBwb3NpdGlvbixcbiAgICAvLyAgc2luY2UgTGVmdCgneCcpIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgb3RoZXIg4oCYYeKAmSB2YWx1ZXMuXG4gICAgdmFyIGtleSA9IEpTT04uc3RyaW5naWZ5KFouY29uY2F0KFtpbmRleF0sIHByb3BQYXRoKSk7XG4gICAgdmFyIHZhbHVlcyA9IHZhbHVlc0J5UGF0aFtrZXldO1xuXG4gICAgLy8gIE5vdGU6IFNvcnRpbmcgdGhlc2Uga2V5cyBsZXhpY29ncmFwaGljYWxseSBpcyBub3QgXCJjb3JyZWN0XCIsIGJ1dCBpdFxuICAgIC8vICBkb2VzIHRoZSByaWdodCB0aGluZyBmb3IgaW5kZXhlcyBsZXNzIHRoYW4gMTAuXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZXNCeVBhdGgpLnNvcnQoKS5maWx0ZXIoZnVuY3Rpb24oaykge1xuICAgICAgdmFyIHZhbHVlc18gPSB2YWx1ZXNCeVBhdGhba107XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvLyAgS2VlcCBYLCB0aGUgcG9zaXRpb24gYXQgd2hpY2ggdGhlIHZpb2xhdGlvbiB3YXMgb2JzZXJ2ZWQuXG4gICAgICAgIGsgPT09IGtleSB8fFxuICAgICAgICAvLyAgS2VlcCBwb3NpdGlvbnMgd2hvc2UgdmFsdWVzIGFyZSBpbmNvbXBhdGlibGUgd2l0aCB0aGUgdmFsdWVzIGF0IFguXG4gICAgICAgIGlzRW1wdHkoZGV0ZXJtaW5lQWN0dWFsVHlwZXNTdHJpY3QoZW52LCBaLmNvbmNhdCh2YWx1ZXMsIHZhbHVlc18pKSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB2YXIgdW5kZXJsaW5lZFR5cGVWYXJzID1cbiAgICB1bmRlcmxpbmVUeXBlVmFycyh0eXBlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICBaLnJlZHVjZShmdW5jdGlvbigkdmFsdWVzQnlQYXRoLCBrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdmFsdWVzQnlQYXRoW2tdID0gdmFsdWVzQnlQYXRoW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR2YWx1ZXNCeVBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgfSwge30sIGtleXMpKTtcblxuICAgIHJldHVybiBuZXcgVHlwZUVycm9yKHRyaW1UcmFpbGluZ1NwYWNlcyhcbiAgICAgIHZhbHVlcy5sZW5ndGggPT09IDEgJiYgaXNFbXB0eShkZXRlcm1pbmVBY3R1YWxUeXBlc0xvb3NlKGVudiwgdmFsdWVzKSkgP1xuICAgICAgICAnVW5yZWNvZ25pemVkIHZhbHVlXFxuXFxuJyArXG4gICAgICAgIHVuZGVybGluZWRUeXBlVmFycyArICdcXG4nICtcbiAgICAgICAgJzEpICAnICsgWi50b1N0cmluZyh2YWx1ZXNbMF0pICsgJyA6OiAobm8gdHlwZXMpXFxuXFxuJyArXG4gICAgICAgIHRvTWFya2Rvd25MaXN0KFxuICAgICAgICAgICdUaGUgZW52aXJvbm1lbnQgaXMgZW1wdHkhICcgK1xuICAgICAgICAgICdQb2x5bW9ycGhpYyBmdW5jdGlvbnMgcmVxdWlyZSBhIG5vbi1lbXB0eSBlbnZpcm9ubWVudC5cXG4nLFxuICAgICAgICAgICdUaGUgdmFsdWUgYXQgcG9zaXRpb24gMSBpcyBub3QgYSBtZW1iZXIgb2YgYW55IHR5cGUgaW4gJyArXG4gICAgICAgICAgJ3RoZSBlbnZpcm9ubWVudC5cXG5cXG4nICtcbiAgICAgICAgICAnVGhlIGVudmlyb25tZW50IGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgdHlwZXM6XFxuXFxuJyxcbiAgICAgICAgICBzaG93VHlwZVdpdGgodHlwZUluZm8pLFxuICAgICAgICAgIGVudlxuICAgICAgICApIDpcbiAgICAgIC8vIGVsc2VcbiAgICAgICAgJ1R5cGUtdmFyaWFibGUgY29uc3RyYWludCB2aW9sYXRpb25cXG5cXG4nICtcbiAgICAgICAgdW5kZXJsaW5lZFR5cGVWYXJzICsgJ1xcbicgK1xuICAgICAgICBaLnJlZHVjZShmdW5jdGlvbihzdCwgaykge1xuICAgICAgICAgIHZhciB2YWx1ZXMgPSB2YWx1ZXNCeVBhdGhba107XG4gICAgICAgICAgcmV0dXJuIGlzRW1wdHkodmFsdWVzKSA/IHN0IDoge1xuICAgICAgICAgICAgaWR4OiBzdC5pZHggKyAxLFxuICAgICAgICAgICAgczogc3QucyArXG4gICAgICAgICAgICAgICBzaG93VmFsdWVzQW5kVHlwZXMoZW52LCB0eXBlSW5mbywgdmFsdWVzLCBzdC5pZHggKyAxKSArXG4gICAgICAgICAgICAgICAnXFxuXFxuJ1xuICAgICAgICAgIH07XG4gICAgICAgIH0sIHtpZHg6IDAsIHM6ICcnfSwga2V5cykucyArXG4gICAgICAgICdTaW5jZSB0aGVyZSBpcyBubyB0eXBlIG9mIHdoaWNoIGFsbCB0aGUgYWJvdmUgdmFsdWVzIGFyZSAnICtcbiAgICAgICAgJ21lbWJlcnMsIHRoZSB0eXBlLXZhcmlhYmxlIGNvbnN0cmFpbnQgaGFzIGJlZW4gdmlvbGF0ZWQuXFxuJ1xuICAgICkpO1xuICB9XG5cbiAgLy8gIGludmFsaWRWYWx1ZSA6OiAuLi4gLT4gRXJyb3JcbiAgZnVuY3Rpb24gaW52YWxpZFZhbHVlKFxuICAgIGVudiwgICAgICAgICAgICAvLyA6OiBBcnJheSBUeXBlXG4gICAgdHlwZUluZm8sICAgICAgIC8vIDo6IFR5cGVJbmZvXG4gICAgaW5kZXgsICAgICAgICAgIC8vIDo6IEludGVnZXJcbiAgICBwcm9wUGF0aCwgICAgICAgLy8gOjogUHJvcFBhdGhcbiAgICB2YWx1ZSAgICAgICAgICAgLy8gOjogQW55XG4gICkge1xuICAgIHZhciB0ID0gcmVzb2x2ZVByb3BQYXRoKHR5cGVJbmZvLnR5cGVzW2luZGV4XSwgcHJvcFBhdGgpO1xuICAgIHJldHVybiBuZXcgVHlwZUVycm9yKHRyaW1UcmFpbGluZ1NwYWNlcyhcbiAgICAgICdJbnZhbGlkIHZhbHVlXFxuXFxuJyArXG4gICAgICB1bmRlcmxpbmUodHlwZUluZm8sXG4gICAgICAgICAgICAgICAgSyhLKF8pKSxcbiAgICAgICAgICAgICAgICBmb3JtYXRUeXBlNihaLmNvbmNhdChbaW5kZXhdLCBwcm9wUGF0aCkpKSArXG4gICAgICAnXFxuJyArXG4gICAgICBzaG93VmFsdWVzQW5kVHlwZXMoZW52LCB0eXBlSW5mbywgW3ZhbHVlXSwgMSkgKyAnXFxuXFxuJyArXG4gICAgICAnVGhlIHZhbHVlIGF0IHBvc2l0aW9uIDEgaXMgbm90IGEgbWVtYmVyIG9mICcgKyBzaG93VHlwZVF1b3RlZCh0KSArICcuJyArXG4gICAgICAnXFxuJyArXG4gICAgICBzZWUoJ3R5cGUnLCB0KVxuICAgICkpO1xuICB9XG5cbiAgLy8gIGludmFsaWRBcmd1bWVudHNMZW5ndGggOjogLi4uIC0+IEVycm9yXG4gIC8vXG4gIC8vICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW4gYHdyYXBGdW5jdGlvbmAgdG8gZW5zdXJlIHRoYXQgaGlnaGVyLW9yZGVyXG4gIC8vICBmdW5jdGlvbnMgZGVmaW5lZCB2aWEgYGRlZmAgb25seSBldmVyIGFwcGx5IGEgZnVuY3Rpb24gYXJndW1lbnQgdG9cbiAgLy8gIHRoZSBjb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMuXG4gIGZ1bmN0aW9uIGludmFsaWRBcmd1bWVudHNMZW5ndGgoXG4gICAgdHlwZUluZm8sICAgICAgICAgICAvLyA6OiBUeXBlSW5mb1xuICAgIGluZGV4LCAgICAgICAgICAgICAgLy8gOjogSW50ZWdlclxuICAgIG51bUFyZ3NFeHBlY3RlZCwgICAgLy8gOjogSW50ZWdlclxuICAgIGFyZ3MgICAgICAgICAgICAgICAgLy8gOjogQXJyYXkgQW55XG4gICkge1xuICAgIHJldHVybiBuZXcgVHlwZUVycm9yKHRyaW1UcmFpbGluZ1NwYWNlcyhcbiAgICAgIHEodHlwZUluZm8ubmFtZSkgKyAnIGFwcGxpZWQgJyArIHNob3dUeXBlUXVvdGVkKHR5cGVJbmZvLnR5cGVzW2luZGV4XSkgK1xuICAgICAgJyB0byB0aGUgd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50c1xcblxcbicgK1xuICAgICAgdW5kZXJsaW5lKFxuICAgICAgICB0eXBlSW5mbyxcbiAgICAgICAgSyhLKF8pKSxcbiAgICAgICAgZnVuY3Rpb24oaW5kZXhfKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihwcm9wUGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhfID09PSBpbmRleCA/XG4gICAgICAgICAgICAgICAgICAgIFN0cmluZyh0KS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgIC9eWyhdKC4qKSAtPiAoLiopWyldJC8sXG4gICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24ocywgJDEsICQyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXygnKCcpICsgZigkMSkgKyBfKCcgLT4gJyArICQyICsgJyknKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICkgOlxuICAgICAgICAgICAgICAgICAgICBfKHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICkgKyAnXFxuJyArXG4gICAgICAnRXhwZWN0ZWQgJyArIG51bUFyZ3MobnVtQXJnc0V4cGVjdGVkKSArXG4gICAgICAnIGJ1dCByZWNlaXZlZCAnICsgbnVtQXJncyhhcmdzLmxlbmd0aCkgK1xuICAgICAgdG9NYXJrZG93bkxpc3QoJy5cXG4nLCAnOlxcblxcbicsIFoudG9TdHJpbmcsIGFyZ3MpXG4gICAgKSk7XG4gIH1cblxuICAvLyAgYXNzZXJ0UmlnaHQgOjogRWl0aGVyICgoKSAtPiBFcnJvcikgYSAtPiBhICFcbiAgZnVuY3Rpb24gYXNzZXJ0UmlnaHQoZWl0aGVyKSB7XG4gICAgaWYgKGVpdGhlci5pc0xlZnQpIHRocm93IGVpdGhlci52YWx1ZSgpO1xuICAgIHJldHVybiBlaXRoZXIudmFsdWU7XG4gIH1cblxuICAvLyAgY3VycnkgOjogLi4uIC0+IEZ1bmN0aW9uXG4gIGZ1bmN0aW9uIGN1cnJ5KFxuICAgIG9wdHMsICAgICAgICAgLy8gOjogT3B0aW9uc1xuICAgIHR5cGVJbmZvLCAgICAgLy8gOjogVHlwZUluZm9cbiAgICBfdHlwZVZhck1hcCwgIC8vIDo6IFR5cGVWYXJNYXBcbiAgICBfdmFsdWVzLCAgICAgIC8vIDo6IEFycmF5IEFueVxuICAgIF9pbmRleGVzLCAgICAgLy8gOjogQXJyYXkgSW50ZWdlclxuICAgIGltcGwgICAgICAgICAgLy8gOjogRnVuY3Rpb25cbiAgKSB7XG4gICAgdmFyIG4gPSB0eXBlSW5mby50eXBlcy5sZW5ndGggLSAxO1xuXG4gICAgdmFyIGN1cnJpZWQgPSBhcml0eShfaW5kZXhlcy5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKG9wdHMuY2hlY2tUeXBlcykge1xuICAgICAgICB2YXIgZGVsdGEgPSBfaW5kZXhlcy5sZW5ndGggLSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBpZiAoZGVsdGEgPCAwKSB0aHJvdyB0b29NYW55QXJndW1lbnRzKHR5cGVJbmZvLCBuIC0gZGVsdGEpO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGVWYXJNYXAgPSBfdHlwZVZhck1hcDtcbiAgICAgIHZhciB2YWx1ZXMgPSBfdmFsdWVzLnNsaWNlKCk7XG4gICAgICB2YXIgaW5kZXhlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgX2luZGV4ZXMubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgICAgICB2YXIgaW5kZXggPSBfaW5kZXhlc1tpZHhdO1xuXG4gICAgICAgIGlmIChpZHggPCBhcmd1bWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgICAhKHR5cGVvZiBhcmd1bWVudHNbaWR4XSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgYXJndW1lbnRzW2lkeF0gIT0gbnVsbCAmJlxuICAgICAgICAgICAgICBhcmd1bWVudHNbaWR4XVsnQEBmdW5jdGlvbmFsL3BsYWNlaG9sZGVyJ10gPT09IHRydWUpKSB7XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbaWR4XTtcbiAgICAgICAgICBpZiAob3B0cy5jaGVja1R5cGVzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2F0aXNmYWN0b3J5VHlwZXMob3B0cy5lbnYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVZhck1hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlSW5mby50eXBlc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlXSk7XG4gICAgICAgICAgICB0eXBlVmFyTWFwID0gYXNzZXJ0UmlnaHQocmVzdWx0KS50eXBlVmFyTWFwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRW1wdHkoaW5kZXhlcykpIHtcbiAgICAgICAgaWYgKG9wdHMuY2hlY2tUeXBlcykge1xuICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGltcGwuYXBwbHkodGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBGdW5jdGlvbnMob3B0cy5lbnYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdHlwZVZhck1hcF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcykpO1xuICAgICAgICAgIGFzc2VydFJpZ2h0KHNhdGlzZmFjdG9yeVR5cGVzKG9wdHMuZW52LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVWYXJNYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8udHlwZXNbbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcmV0dXJuVmFsdWVdKSk7XG4gICAgICAgICAgcmV0dXJuIHdyYXBGdW5jdGlvbkNvbmQoZW52LCB0eXBlSW5mbywgW3R5cGVWYXJNYXBdLCBuLCByZXR1cm5WYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGltcGwuYXBwbHkodGhpcywgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGN1cnJ5KG9wdHMsIHR5cGVJbmZvLCB0eXBlVmFyTWFwLCB2YWx1ZXMsIGluZGV4ZXMsIGltcGwpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHNob3dUeXBlID0gc2hvd1R5cGVXaXRoKHR5cGVJbmZvKTtcbiAgICBjdXJyaWVkLmluc3BlY3QgPSBjdXJyaWVkLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdlJlcHJzID0gW107XG4gICAgICB2YXIgdFJlcHJzID0gW107XG4gICAgICBmb3IgKHZhciBpZHggPSAwLCBwbGFjZWhvbGRlcnMgPSAwOyBpZHggPCBuOyBpZHggKz0gMSkge1xuICAgICAgICBpZiAoX2luZGV4ZXMuaW5kZXhPZihpZHgpID49IDApIHtcbiAgICAgICAgICBwbGFjZWhvbGRlcnMgKz0gMTtcbiAgICAgICAgICB0UmVwcnMucHVzaChzaG93VHlwZSh0eXBlSW5mby50eXBlc1tpZHhdKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hpbGUgKHBsYWNlaG9sZGVycyA+IDApIHtcbiAgICAgICAgICAgIHZSZXBycy5wdXNoKCdfXycpO1xuICAgICAgICAgICAgcGxhY2Vob2xkZXJzIC09IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZSZXBycy5wdXNoKFoudG9TdHJpbmcoX3ZhbHVlc1tpZHhdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlSW5mby5uYW1lICtcbiAgICAgICAgICAgICB3aGVuKHZSZXBycy5sZW5ndGggPiAwLCBwYXJlbnRoZXNpemUsIHZSZXBycy5qb2luKCcsICcpKSArXG4gICAgICAgICAgICAgJyA6OiAnICtcbiAgICAgICAgICAgICBjb25zdHJhaW50c1JlcHIodHlwZUluZm8uY29uc3RyYWludHMsIGlkLCBLKEsoaWQpKSkgK1xuICAgICAgICAgICAgIHdoZW4obiA9PT0gMCwgcGFyZW50aGVzaXplLCB0UmVwcnMuam9pbignIC0+ICcpKSArXG4gICAgICAgICAgICAgJyAtPiAnICsgc2hvd1R5cGUodHlwZUluZm8udHlwZXNbbl0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gY3VycmllZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGUob3B0cykge1xuICAgIGZ1bmN0aW9uIGRlZihuYW1lLCBjb25zdHJhaW50cywgZXhwVHlwZXMsIGltcGwpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkoZXhwVHlwZXMubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IocShkZWYubmFtZSkgKyAnIGNhbm5vdCBkZWZpbmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGggYXJpdHkgZ3JlYXRlciB0aGFuIG5pbmUnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyeShvcHRzLFxuICAgICAgICAgICAgICAgICAgIHtuYW1lOiBuYW1lLCBjb25zdHJhaW50czogY29uc3RyYWludHMsIHR5cGVzOiBleHBUeXBlc30sXG4gICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgICAgICAgICAgIHJhbmdlKDAsIHZhbHVlcy5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgIGltcGwpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmKGRlZi5uYW1lLFxuICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICBbU3RyaW5nXyxcbiAgICAgICAgICAgICAgICBTdHJNYXAoQXJyYXlfKFR5cGVDbGFzcykpLFxuICAgICAgICAgICAgICAgIE5vbkVtcHR5KEFycmF5XyhUeXBlKSksXG4gICAgICAgICAgICAgICAgQW55RnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgQW55RnVuY3Rpb25dLFxuICAgICAgICAgICAgICAgZGVmKTtcbiAgfVxuXG4gIHZhciBjcmVhdGUgPVxuICBkZWYoJ2NyZWF0ZScsXG4gICAgICB7fSxcbiAgICAgIFtSZWNvcmRUeXBlKHtjaGVja1R5cGVzOiBCb29sZWFuXywgZW52OiBBcnJheV8oQW55KX0pLCBBbnlGdW5jdGlvbl0sXG4gICAgICBfY3JlYXRlKTtcblxuICAvLyAgZnJvbVVuY2hlY2tlZFVuYXJ5VHlwZSA6OiAoVHlwZSAtPiBUeXBlKSAtPiAoVHlwZSAtPiBUeXBlKVxuICBmdW5jdGlvbiBmcm9tVW5jaGVja2VkVW5hcnlUeXBlKHR5cGVDb25zdHJ1Y3Rvcikge1xuICAgIHZhciB0ID0gdHlwZUNvbnN0cnVjdG9yKFVua25vd24pO1xuICAgIHZhciBfMSA9IHQudHlwZXMuJDEuZXh0cmFjdG9yO1xuICAgIHJldHVybiBDaGVja2VkVW5hcnlUeXBlKHQubmFtZSwgdC51cmwsIHQuX3Rlc3QsIF8xKTtcbiAgfVxuXG4gIC8vICBmcm9tVW5jaGVja2VkQmluYXJ5VHlwZSA6OiAoKFR5cGUsIFR5cGUpIC0+IFR5cGUpIC0+XG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoVHlwZSAtPiBUeXBlIC0+IFR5cGUpXG4gIGZ1bmN0aW9uIGZyb21VbmNoZWNrZWRCaW5hcnlUeXBlKHR5cGVDb25zdHJ1Y3Rvcikge1xuICAgIHZhciB0ID0gdHlwZUNvbnN0cnVjdG9yKFVua25vd24sIFVua25vd24pO1xuICAgIHZhciBfMSA9IHQudHlwZXMuJDEuZXh0cmFjdG9yO1xuICAgIHZhciBfMiA9IHQudHlwZXMuJDIuZXh0cmFjdG9yO1xuICAgIHJldHVybiBDaGVja2VkQmluYXJ5VHlwZSh0Lm5hbWUsIHQudXJsLCB0Ll90ZXN0LCBfMSwgXzIpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBfXzogX18sXG4gICAgQW55OiBBbnksXG4gICAgQW55RnVuY3Rpb246IEFueUZ1bmN0aW9uLFxuICAgIEFyZ3VtZW50czogQXJndW1lbnRzLFxuICAgIEFycmF5OiBmcm9tVW5jaGVja2VkVW5hcnlUeXBlKEFycmF5XyksXG4gICAgQm9vbGVhbjogQm9vbGVhbl8sXG4gICAgRGF0ZTogRGF0ZV8sXG4gICAgRXJyb3I6IEVycm9yXyxcbiAgICBGaW5pdGVOdW1iZXI6IEZpbml0ZU51bWJlcixcbiAgICBGdW5jdGlvbjogZGVmKCdGdW5jdGlvbicsIHt9LCBbQXJyYXlfKFR5cGUpLCBUeXBlXSwgRnVuY3Rpb25fKSxcbiAgICBHbG9iYWxSZWdFeHA6IEdsb2JhbFJlZ0V4cCxcbiAgICBJbnRlZ2VyOiBJbnRlZ2VyLFxuICAgIE5lZ2F0aXZlRmluaXRlTnVtYmVyOiBOZWdhdGl2ZUZpbml0ZU51bWJlcixcbiAgICBOZWdhdGl2ZUludGVnZXI6IE5lZ2F0aXZlSW50ZWdlcixcbiAgICBOZWdhdGl2ZU51bWJlcjogTmVnYXRpdmVOdW1iZXIsXG4gICAgTm9uRW1wdHk6IE5vbkVtcHR5LFxuICAgIE5vbkdsb2JhbFJlZ0V4cDogTm9uR2xvYmFsUmVnRXhwLFxuICAgIE5vbk5lZ2F0aXZlSW50ZWdlcjogTm9uTmVnYXRpdmVJbnRlZ2VyLFxuICAgIE5vblplcm9GaW5pdGVOdW1iZXI6IE5vblplcm9GaW5pdGVOdW1iZXIsXG4gICAgTm9uWmVyb0ludGVnZXI6IE5vblplcm9JbnRlZ2VyLFxuICAgIE5vblplcm9WYWxpZE51bWJlcjogTm9uWmVyb1ZhbGlkTnVtYmVyLFxuICAgIE51bGw6IE51bGwsXG4gICAgTnVsbGFibGU6IGZyb21VbmNoZWNrZWRVbmFyeVR5cGUoTnVsbGFibGUpLFxuICAgIE51bWJlcjogTnVtYmVyXyxcbiAgICBPYmplY3Q6IE9iamVjdF8sXG4gICAgUGFpcjogZnJvbVVuY2hlY2tlZEJpbmFyeVR5cGUoUGFpciksXG4gICAgUG9zaXRpdmVGaW5pdGVOdW1iZXI6IFBvc2l0aXZlRmluaXRlTnVtYmVyLFxuICAgIFBvc2l0aXZlSW50ZWdlcjogUG9zaXRpdmVJbnRlZ2VyLFxuICAgIFBvc2l0aXZlTnVtYmVyOiBQb3NpdGl2ZU51bWJlcixcbiAgICBSZWdFeHA6IFJlZ0V4cF8sXG4gICAgUmVnZXhGbGFnczogUmVnZXhGbGFncyxcbiAgICBTdHJNYXA6IGZyb21VbmNoZWNrZWRVbmFyeVR5cGUoU3RyTWFwKSxcbiAgICBTdHJpbmc6IFN0cmluZ18sXG4gICAgU3ltYm9sOiBTeW1ib2xfLFxuICAgIFR5cGU6IFR5cGUsXG4gICAgVHlwZUNsYXNzOiBUeXBlQ2xhc3MsXG4gICAgVW5kZWZpbmVkOiBVbmRlZmluZWQsXG4gICAgVW5rbm93bjogVW5rbm93bixcbiAgICBWYWxpZERhdGU6IFZhbGlkRGF0ZSxcbiAgICBWYWxpZE51bWJlcjogVmFsaWROdW1iZXIsXG4gICAgZW52OiBlbnYsXG4gICAgY3JlYXRlOiBjcmVhdGUsXG4gICAgdGVzdDogZGVmKCd0ZXN0Jywge30sIFtBcnJheV8oVHlwZSksIFR5cGUsIEFueSwgQm9vbGVhbl9dLCB0ZXN0KSxcbiAgICBOdWxsYXJ5VHlwZTogQ2hlY2tlZE51bGxhcnlUeXBlLFxuICAgIFVuYXJ5VHlwZTogQ2hlY2tlZFVuYXJ5VHlwZSxcbiAgICBCaW5hcnlUeXBlOiBDaGVja2VkQmluYXJ5VHlwZSxcbiAgICBFbnVtVHlwZTogQ2hlY2tlZEVudW1UeXBlLFxuICAgIFJlY29yZFR5cGU6IENoZWNrZWRSZWNvcmRUeXBlLFxuICAgIFR5cGVWYXJpYWJsZTogQ2hlY2tlZFR5cGVWYXJpYWJsZSxcbiAgICBVbmFyeVR5cGVWYXJpYWJsZTogQ2hlY2tlZFVuYXJ5VHlwZVZhcmlhYmxlLFxuICAgIEJpbmFyeVR5cGVWYXJpYWJsZTogQ2hlY2tlZEJpbmFyeVR5cGVWYXJpYWJsZSxcbiAgICBUaHVuazogVGh1bmssXG4gICAgUHJlZGljYXRlOiBQcmVkaWNhdGVcbiAgfTtcblxufSkpO1xuXG4vLy4gW0ZMOlNlbWlncm91cF06ICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNzZW1pZ3JvdXBcbi8vLiBbTW9ub2lkXTogICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI21vbm9pZFxuLy8uIFtTZXRvaWRdOiAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjc2V0b2lkXG4vLy4gW2BBcnJheWBdOiAgICAgICAgICAgICAgI0FycmF5XG4vLy4gW2BCaW5hcnlUeXBlYF06ICAgICAgICAgI0JpbmFyeVR5cGVcbi8vLiBbYERhdGVgXTogICAgICAgICAgICAgICAjRGF0ZVxuLy8uIFtgRmluaXRlTnVtYmVyYF06ICAgICAgICNGaW5pdGVOdW1iZXJcbi8vLiBbYEdsb2JhbFJlZ0V4cGBdOiAgICAgICAjR2xvYmFsUmVnRXhwXG4vLy4gW2BJbnRlZ2VyYF06ICAgICAgICAgICAgI0ludGVnZXJcbi8vLiBbYE5vbkdsb2JhbFJlZ0V4cGBdOiAgICAjTm9uR2xvYmFsUmVnRXhwXG4vLy4gW2BOdW1iZXJgXTogICAgICAgICAgICAgI051bWJlclxuLy8uIFtgT2JqZWN0LmNyZWF0ZWBdOiAgICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9jcmVhdGVcbi8vLiBbYFBhaXJgXTogICAgICAgICAgICAgICAjUGFpclxuLy8uIFtgUmVnRXhwYF06ICAgICAgICAgICAgICNSZWdFeHBcbi8vLiBbYFJlZ2V4RmxhZ3NgXTogICAgICAgICAjUmVnZXhGbGFnc1xuLy8uIFtgU3RyaW5nYF06ICAgICAgICAgICAgICNTdHJpbmdcbi8vLiBbYFN5bnRheEVycm9yYF06ICAgICAgICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TeW50YXhFcnJvclxuLy8uIFtgVHlwZUNsYXNzYF06ICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNUeXBlQ2xhc3Ncbi8vLiBbYFR5cGVFcnJvcmBdOiAgICAgICAgICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9UeXBlRXJyb3Jcbi8vLiBbYFR5cGVWYXJpYWJsZWBdOiAgICAgICAjVHlwZVZhcmlhYmxlXG4vLy4gW2BVbmFyeVR5cGVgXTogICAgICAgICAgI1VuYXJ5VHlwZVxuLy8uIFtgVW5hcnlUeXBlVmFyaWFibGVgXTogICNVbmFyeVR5cGVWYXJpYWJsZVxuLy8uIFtgVW5rbm93bmBdOiAgICAgICAgICAgICNVbmtub3duXG4vLy4gW2BWYWxpZE51bWJlcmBdOiAgICAgICAgI1ZhbGlkTnVtYmVyXG4vLy4gW2BlbnZgXTogICAgICAgICAgICAgICAgI2VudlxuLy8uIFthcmd1bWVudHNdOiAgICAgICAgICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Z1bmN0aW9ucy9hcmd1bWVudHNcbi8vLiBbZW51bWVyYXRlZCB0eXBlc106ICAgICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbnVtZXJhdGVkX3R5cGVcbi8vLiBbbWF4XTogICAgICAgICAgICAgICAgICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvTUFYX1NBRkVfSU5URUdFUlxuLy8uIFttaW5dOiAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9NSU5fU0FGRV9JTlRFR0VSXG4vLy4gW3JlY29yZCB0eXBlXTogICAgICAgICAgI1JlY29yZFR5cGVcbi8vLiBbc2VtaWdyb3VwXTogICAgICAgICAgICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TZW1pZ3JvdXBcbi8vLiBbdHlwZSBjbGFzc106ICAgICAgICAgICAjdHlwZS1jbGFzc2VzXG4vLy4gW3R5cGUgdmFyaWFibGVzXTogICAgICAgI1R5cGVWYXJpYWJsZVxuLy8uIFt0eXBlc106ICAgICAgICAgICAgICAgICN0eXBlc1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5LWRlZi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.store = undefined;\n\nvar _preact = __webpack_require__(2);\n\nvar _App = __webpack_require__(24);\n\nvar _App2 = _interopRequireDefault(_App);\n\nvar _store = __webpack_require__(6);\n\nvar _store2 = _interopRequireDefault(_store);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// debug\nif (false) {\n  require(\"preact/devtools\");\n}\n\nvar initialState = {\n  imagesIndex: null,\n  breeds: [],\n  letters: [],\n  images: [],\n  loading: false\n};\n\nvar store = exports.store = (0, _store2.default)(initialState);\n\n(0, _preact.render)((0, _preact.h)(\n  _store.Provider,\n  { store: store },\n  (0, _preact.h)(_App2.default, null)\n), document.getElementById(\"root\"));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvaW5kZXguanM/MWZkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBkZWJ1Z1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcImRldmVsb3BtZW50XCIpIHtcbiAgcmVxdWlyZShcInByZWFjdC9kZXZ0b29sc1wiKTtcbn1cblxuaW1wb3J0IHsgaCwgcmVuZGVyIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IEFwcCBmcm9tIFwiLi9BcHBcIjtcbmltcG9ydCBjcmVhdGVTdG9yZSBmcm9tIFwiLi9zdG9yZVwiO1xuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tIFwiLi9zdG9yZVwiO1xuXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XG4gIGltYWdlc0luZGV4OiBudWxsLFxuICBicmVlZHM6IFtdLFxuICBsZXR0ZXJzOiBbXSxcbiAgaW1hZ2VzOiBbXSxcbiAgbG9hZGluZzogZmFsc2Vcbn07XG5cbmV4cG9ydCBjb25zdCBzdG9yZSA9IGNyZWF0ZVN0b3JlKGluaXRpYWxTdGF0ZSk7XG5cbnJlbmRlcihcbiAgPFByb3ZpZGVyIHN0b3JlPXtzdG9yZX0+XG4gICAgPEFwcCAvPlxuICA8L1Byb3ZpZGVyPixcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyb290XCIpXG4pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9pbmRleC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUtBO0FBQ0E7QUFBQTtBQUNBOzs7QUFBQTtBQUNBOzs7OztBQVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanM/YzNjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.connect = connect;\nexports.Provider = Provider;\nexports.default = createStore;\n\nvar _preact = __webpack_require__(2);\n\nfunction connect(mapStateToProps, actions) {\n\tif (typeof mapStateToProps !== 'function') {\n\t\tmapStateToProps = select(mapStateToProps || []);\n\t}\n\treturn function (Child) {\n\t\tfunction Wrapper(props, _ref) {\n\t\t\tvar _this = this;\n\n\t\t\tvar store = _ref.store;\n\n\t\t\tvar state = mapStateToProps(store ? store.getState() : {}, props);\n\t\t\tvar boundActions = actions ? mapActions(actions, store) : { store: store };\n\t\t\tvar update = function update() {\n\t\t\t\tvar mapped = mapStateToProps(store ? store.getState() : {}, _this.props);\n\t\t\t\tfor (var i in mapped) {\n\t\t\t\t\tif (mapped[i] !== state[i]) {\n\t\t\t\t\t\tstate = mapped;\n\t\t\t\t\t\treturn _this.setState(null);\n\t\t\t\t\t}\n\t\t\t\t}for (var _i in state) {\n\t\t\t\t\tif (!(_i in mapped)) {\n\t\t\t\t\t\tstate = mapped;\n\t\t\t\t\t\treturn _this.setState(null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.componentDidMount = function () {\n\t\t\t\tupdate();\n\t\t\t\tstore.subscribe(update);\n\t\t\t};\n\t\t\tthis.componentWillUnmount = function () {\n\t\t\t\tstore.unsubscribe(update);\n\t\t\t};\n\t\t\tthis.render = function (props) {\n\t\t\t\treturn (0, _preact.h)(Child, assign(assign(assign({}, boundActions), props), state));\n\t\t\t};\n\t\t}\n\t\treturn (Wrapper.prototype = new _preact.Component()).constructor = Wrapper;\n\t};\n}\n\nfunction Provider(props) {\n\tthis.getChildContext = function () {\n\t\treturn { store: props.store };\n\t};\n}\n\nProvider.prototype.render = function (props) {\n\treturn props.children[0];\n};\n\nfunction createStore(state) {\n\tvar listeners = [];\n\tstate = state || {};\n\n\tfunction unsubscribe(listener) {\n\t\tvar out = [];\n\t\tfor (var i = 0; i < listeners.length; i++) {\n\t\t\tif (listeners[i] === listener) {\n\t\t\t\tlistener = null;\n\t\t\t} else {\n\t\t\t\tout.push(listeners[i]);\n\t\t\t}\n\t\t}\n\t\tlisteners = out;\n\t}\n\n\tfunction setState(update, overwrite, action) {\n\t\tstate = overwrite ? update : assign(assign({}, state), update);\n\t\tvar currentListeners = listeners;\n\t\tfor (var i = 0; i < currentListeners.length; i++) {\n\t\t\tcurrentListeners[i](state, action);\n\t\t}\n\t}\n\n\treturn {\n\t\taction: function action(_action) {\n\t\t\tfunction apply(result) {\n\t\t\t\tsetState(result, false, _action);\n\t\t\t}\n\t\t\treturn function () {\n\t\t\t\tvar args = [state];\n\t\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\t\targs.push(arguments[i]);\n\t\t\t\t}var ret = _action.apply(this, args);\n\t\t\t\tif (ret != null) {\n\t\t\t\t\tif (ret.then) ret.then(apply);else apply(ret);\n\t\t\t\t}\n\t\t\t};\n\t\t},\n\n\n\t\tsetState: setState,\n\t\tsubscribe: function subscribe(listener) {\n\t\t\tlisteners.push(listener);\n\t\t\treturn function () {\n\t\t\t\tunsubscribe(listener);\n\t\t\t};\n\t\t},\n\n\t\tunsubscribe: unsubscribe,\n\t\tgetState: function getState() {\n\t\t\treturn state;\n\t\t}\n\t};\n}\n\n// Bind an object/factory of actions to the store and wrap them.\nfunction mapActions(actions, store) {\n\tif (typeof actions === 'function') actions = actions(store);\n\tvar mapped = {};\n\tfor (var i in actions) {\n\t\tmapped[i] = store.action(actions[i]);\n\t}\n\treturn mapped;\n}\n\n// select('foo,bar') creates a function of the form: ({ foo, bar }) => ({ foo, bar })\nfunction select(properties) {\n\tif (typeof properties === 'string') properties = properties.split(/\\s*,\\s*/);\n\treturn function (state) {\n\t\tvar selected = {};\n\t\tfor (var i = 0; i < properties.length; i++) {\n\t\t\tselected[properties[i]] = state[properties[i]];\n\t\t}\n\t\treturn selected;\n\t};\n}\n\nfunction assign(obj, props) {\n\tfor (var i in props) {\n\t\tobj[i] = props[i];\n\t}return obj;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvc3RvcmUuanM/M2JmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoLCBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIGFjdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBtYXBTdGF0ZVRvUHJvcHMhPT0nZnVuY3Rpb24nKSB7XG5cdFx0bWFwU3RhdGVUb1Byb3BzID0gc2VsZWN0KG1hcFN0YXRlVG9Qcm9wcyB8fCBbXSk7XG5cdH1cblx0cmV0dXJuIENoaWxkID0+IHtcblx0XHRmdW5jdGlvbiBXcmFwcGVyKHByb3BzLCB7IHN0b3JlIH0pIHtcblx0XHRcdGxldCBzdGF0ZSA9IG1hcFN0YXRlVG9Qcm9wcyhzdG9yZSA/IHN0b3JlLmdldFN0YXRlKCkgOiB7fSwgcHJvcHMpO1xuXHRcdFx0bGV0IGJvdW5kQWN0aW9ucyA9IGFjdGlvbnMgPyBtYXBBY3Rpb25zKGFjdGlvbnMsIHN0b3JlKSA6IHsgc3RvcmUgfTtcblx0XHRcdGxldCB1cGRhdGUgPSAoKSA9PiB7XG5cdFx0XHRcdGxldCBtYXBwZWQgPSBtYXBTdGF0ZVRvUHJvcHMoc3RvcmUgPyBzdG9yZS5nZXRTdGF0ZSgpIDoge30sIHRoaXMucHJvcHMpO1xuXHRcdFx0XHRmb3IgKGxldCBpIGluIG1hcHBlZCkgaWYgKG1hcHBlZFtpXSE9PXN0YXRlW2ldKSB7XG5cdFx0XHRcdFx0c3RhdGUgPSBtYXBwZWQ7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0U3RhdGUobnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChsZXQgaSBpbiBzdGF0ZSkgaWYgKCEoaSBpbiBtYXBwZWQpKSB7XG5cdFx0XHRcdFx0c3RhdGUgPSBtYXBwZWQ7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0U3RhdGUobnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHR0aGlzLmNvbXBvbmVudERpZE1vdW50ID0gKCkgPT4ge1xuXHRcdFx0XHR1cGRhdGUoKTtcblx0XHRcdFx0c3RvcmUuc3Vic2NyaWJlKHVwZGF0ZSk7XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCA9ICgpID0+IHtcblx0XHRcdFx0c3RvcmUudW5zdWJzY3JpYmUodXBkYXRlKTtcblx0XHRcdH07XG5cdFx0XHR0aGlzLnJlbmRlciA9IHByb3BzID0+IGgoQ2hpbGQsIGFzc2lnbihhc3NpZ24oYXNzaWduKHt9LCBib3VuZEFjdGlvbnMpLCBwcm9wcyksIHN0YXRlKSk7XG5cdFx0fVxuXHRcdHJldHVybiAoV3JhcHBlci5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCkpLmNvbnN0cnVjdG9yID0gV3JhcHBlcjtcblx0fTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gUHJvdmlkZXIocHJvcHMpIHtcblx0dGhpcy5nZXRDaGlsZENvbnRleHQgPSAoKSA9PiAoeyBzdG9yZTogcHJvcHMuc3RvcmUgfSk7XG59XG5cblByb3ZpZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBwcm9wcyA9PiBwcm9wcy5jaGlsZHJlblswXTtcblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVTdG9yZShzdGF0ZSkge1xuXHRsZXQgbGlzdGVuZXJzID0gW107XG5cdHN0YXRlID0gc3RhdGUgfHwge307XG5cblx0ZnVuY3Rpb24gdW5zdWJzY3JpYmUobGlzdGVuZXIpIHtcblx0XHRsZXQgb3V0ID0gW107XG5cdFx0Zm9yIChsZXQgaT0wOyBpPGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGxpc3RlbmVyc1tpXT09PWxpc3RlbmVyKSB7XG5cdFx0XHRcdGxpc3RlbmVyID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRvdXQucHVzaChsaXN0ZW5lcnNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRsaXN0ZW5lcnMgPSBvdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRTdGF0ZSh1cGRhdGUsIG92ZXJ3cml0ZSwgYWN0aW9uKSB7XG5cdFx0c3RhdGUgPSBvdmVyd3JpdGUgPyB1cGRhdGUgOiBhc3NpZ24oYXNzaWduKHt9LCBzdGF0ZSksIHVwZGF0ZSk7XG5cdFx0bGV0IGN1cnJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG5cdFx0Zm9yIChsZXQgaT0wOyBpPGN1cnJlbnRMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIGN1cnJlbnRMaXN0ZW5lcnNbaV0oc3RhdGUsIGFjdGlvbik7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGFjdGlvbihhY3Rpb24pIHtcblx0XHRcdGZ1bmN0aW9uIGFwcGx5KHJlc3VsdCkge1xuXHRcdFx0XHRzZXRTdGF0ZShyZXN1bHQsIGZhbHNlLCBhY3Rpb24pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsZXQgYXJncyA9IFtzdGF0ZV07XG5cdFx0XHRcdGZvciAobGV0IGk9MDsgaTxhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuXHRcdFx0XHRsZXQgcmV0ID0gYWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdFx0XHRpZiAocmV0IT1udWxsKSB7XG5cdFx0XHRcdFx0aWYgKHJldC50aGVuKSByZXQudGhlbihhcHBseSk7XG5cdFx0XHRcdFx0ZWxzZSBhcHBseShyZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRzZXRTdGF0ZSxcblx0XHRzdWJzY3JpYmUobGlzdGVuZXIpIHtcblx0XHRcdGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblx0XHRcdHJldHVybiAoKSA9PiB7IHVuc3Vic2NyaWJlKGxpc3RlbmVyKTsgfTtcblx0XHR9LFxuXHRcdHVuc3Vic2NyaWJlLFxuXHRcdGdldFN0YXRlKCkge1xuXHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdH1cblx0fTtcbn1cblxuLy8gQmluZCBhbiBvYmplY3QvZmFjdG9yeSBvZiBhY3Rpb25zIHRvIHRoZSBzdG9yZSBhbmQgd3JhcCB0aGVtLlxuZnVuY3Rpb24gbWFwQWN0aW9ucyhhY3Rpb25zLCBzdG9yZSkge1xuXHRpZiAodHlwZW9mIGFjdGlvbnM9PT0nZnVuY3Rpb24nKSBhY3Rpb25zID0gYWN0aW9ucyhzdG9yZSk7XG5cdGxldCBtYXBwZWQgPSB7fTtcblx0Zm9yIChsZXQgaSBpbiBhY3Rpb25zKSB7XG5cdFx0bWFwcGVkW2ldID0gc3RvcmUuYWN0aW9uKGFjdGlvbnNbaV0pO1xuXHR9XG5cdHJldHVybiBtYXBwZWQ7XG59XG5cblxuLy8gc2VsZWN0KCdmb28sYmFyJykgY3JlYXRlcyBhIGZ1bmN0aW9uIG9mIHRoZSBmb3JtOiAoeyBmb28sIGJhciB9KSA9PiAoeyBmb28sIGJhciB9KVxuZnVuY3Rpb24gc2VsZWN0KHByb3BlcnRpZXMpIHtcblx0aWYgKHR5cGVvZiBwcm9wZXJ0aWVzPT09J3N0cmluZycpIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLnNwbGl0KC9cXHMqLFxccyovKTtcblx0cmV0dXJuIHN0YXRlID0+IHtcblx0XHRsZXQgc2VsZWN0ZWQgPSB7fTtcblx0XHRmb3IgKGxldCBpPTA7IGk8cHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c2VsZWN0ZWRbcHJvcGVydGllc1tpXV0gPSBzdGF0ZVtwcm9wZXJ0aWVzW2ldXTtcblx0XHR9XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9O1xufVxuXG5mdW5jdGlvbiBhc3NpZ24ob2JqLCBwcm9wcykge1xuXHRmb3IgKGxldCBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcblx0cmV0dXJuIG9iajtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvc3RvcmUuanMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBRUE7QUFpQ0E7QUFPQTtBQUNBO0FBM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBeEJBO0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _api = __webpack_require__(8);\n\nvar actions = function actions(store) {\n  return {\n    toggleColor: function toggleColor(state, color) {\n      return Object.assign(color, { color: color });\n    },\n    setImagesIndex: function setImagesIndex(state, imagesIndex) {\n      return Object.assign(state, { imagesIndex: imagesIndex });\n    },\n    incrementIndex: function incrementIndex(state, imagesIndex) {\n      if (state.imagesIndex < state.letters.length - 1) {\n        return Object.assign(state, { imagesIndex: state.imagesIndex + 1 });\n      }\n      return state;\n    },\n    decrementIndex: function decrementIndex(state, imagesIndex) {\n      if (state.imagesIndex > 0) {\n        return Object.assign(state, { imagesIndex: state.imagesIndex - 1 });\n      }\n      return state;\n    },\n    getBreeds: function getBreeds(state) {\n      _api.getBreeds.fork(function (err) {\n        return console.log(err);\n      }, function (data) {\n        return store.setState({ breeds: data.breeds, letters: data.letters });\n      });\n    },\n    setImages: function setImages(state, images) {\n      return Object.assign(state, { images: images });\n    },\n    setLoading: function setLoading(state, isLoading) {\n      return Object.assign(state, { loading: isLoading });\n    }\n  };\n};\n\nexports.default = actions;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvYWN0aW9ucy5qcz83NzAxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Z2V0QnJlZWRzfSBmcm9tICcuL2FwaSdcblxuY29uc3QgYWN0aW9ucyA9IHN0b3JlID0+ICh7XG4gIHRvZ2dsZUNvbG9yKHN0YXRlLCBjb2xvcikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGNvbG9yLCB7IGNvbG9yIH0pO1xuICB9LFxuICBzZXRJbWFnZXNJbmRleChzdGF0ZSwgaW1hZ2VzSW5kZXgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihzdGF0ZSwgeyBpbWFnZXNJbmRleCB9KTtcbiAgfSxcbiAgaW5jcmVtZW50SW5kZXgoc3RhdGUsIGltYWdlc0luZGV4KSB7XG4gICAgaWYgKHN0YXRlLmltYWdlc0luZGV4IDwgc3RhdGUubGV0dGVycy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihzdGF0ZSwgeyBpbWFnZXNJbmRleDogc3RhdGUuaW1hZ2VzSW5kZXggKyAxIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG4gIH0sXG4gIGRlY3JlbWVudEluZGV4KHN0YXRlLCBpbWFnZXNJbmRleCkge1xuICAgIGlmIChzdGF0ZS5pbWFnZXNJbmRleCA+IDApIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHN0YXRlLCB7IGltYWdlc0luZGV4OiBzdGF0ZS5pbWFnZXNJbmRleCAtIDEgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbiAgfSxcbiAgZ2V0QnJlZWRzKHN0YXRlKSB7XG4gICAgZ2V0QnJlZWRzLmZvcmsoXG4gICAgICBlcnIgPT4gY29uc29sZS5sb2coZXJyKSxcbiAgICAgIGRhdGEgPT4gc3RvcmUuc2V0U3RhdGUoeyBicmVlZHM6IGRhdGEuYnJlZWRzLCBsZXR0ZXJzOiBkYXRhLmxldHRlcnMgfSlcbiAgICApO1xuICB9LFxuICBzZXRJbWFnZXMoc3RhdGUsIGltYWdlcykge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHN0YXRlLCB7IGltYWdlcyB9KTtcbiAgfSxcbiAgc2V0TG9hZGluZyhzdGF0ZSwgaXNMb2FkaW5nKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc3RhdGUsIHtsb2FkaW5nOiBpc0xvYWRpbmd9KVxuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYWN0aW9ucztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2FjdGlvbnMuanMiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE5QkE7QUFBQTtBQUNBO0FBZ0NBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getImagesConcurrently = exports.getImages = exports.getBreeds = exports.S = undefined;\n\nvar _fluture = __webpack_require__(9);\n\nvar F = _interopRequireWildcard(_fluture);\n\nvar _sanctuary = __webpack_require__(29);\n\nvar Sanctuary = _interopRequireWildcard(_sanctuary);\n\nvar _2 = __webpack_require__(4);\n\nvar _actions = __webpack_require__(7);\n\nvar _actions2 = _interopRequireDefault(_actions);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar _require = __webpack_require__(30),\n    flutureEnv = _require.env;\n\nvar checkTypes = \"development\" !== \"production\";\n// Sanctuary provides awesome errors in development versus e.g. Ramda\nvar S = exports.S = Sanctuary.create({\n  checkTypes: checkTypes,\n  env: Sanctuary.env.concat(flutureEnv)\n});\n\nvar API_ROOT = \"https://dog.ceo/api\";\nvar BREED_LIST_URL = API_ROOT + \"/breeds/list\";\nvar getImagesUrlFor = function getImagesUrlFor(breed) {\n  return API_ROOT + \"/breed/\" + breed + \"/images\";\n};\n\n// wrap promise library so it returns a future\nvar fuFetch = F.encaseP2(fetch);\n\nvar headers = {\n  Accept: \"application/json\"\n};\nvar get = function get(url) {\n  return fuFetch(url, { headers: headers });\n};\n\nvar groupByFirstLetter = S.groupBy(function (x) {\n  return function (y) {\n    return S.equals(S.head(x))(S.head(y));\n  };\n});\n\n// [['alf', 'argh'],['bee', 'boo']] -> ['a', 'b']\nvar getEachFirstLetter = S.mapMaybe(S.pipe([S.mapMaybe(S.head), S.head]));\n\nvar rand = function rand(items) {\n  return items[~~(items.length * Math.random())];\n};\n\n// chain and map are like .next with a promise\n// map is to transform the data f -> Future(f(d))\n// chain allows you to, e.g. map to a new Future or another type, flattening the resulting nested Types\n\nvar getBreeds = exports.getBreeds = get(BREED_LIST_URL).chain(function (res) {\n  return F.tryP(function () {\n    return res.json();\n  });\n}).map(S.prop(\"message\"))\n//index our breeds by first letters - we trust already they come from the api alphabetized\n.map(groupByFirstLetter)\n//we need a list of the letters for our nav\n.map(function (breeds) {\n  return { breeds: breeds, letters: getEachFirstLetter(breeds) };\n});\n\nvar getImages = exports.getImages = function getImages(breed) {\n  return get(getImagesUrlFor(breed)).chain(function (res) {\n    return F.tryP(function () {\n      return res.json();\n    });\n  })\n  // we need to decide how we deal with api errors--we can short circuit into the reject branch with F.reject\n  // but in this case we prefer just to ignore unsuccessful requests and display nothing by returning an empty array\n  // use chain not map because we return a new Future -- with map we would end up with [Future(message), Future(message)]\n  .chain(function (res) {\n    return res.status !== \"success\" ? F.of({ message: [] }) : F.of(res);\n  }).map(S.prop(\"message\"));\n};\n\nvar getImagesConcurrently = exports.getImagesConcurrently = function getImagesConcurrently(breeds) {\n  return (\n    // lets debounce so the Future the requests doesn't start as the user clicks through the letters\n    F.after(500, null).chain(function (_) {\n      return (\n        //The first argument is how many of the Futures you want to be concurrent\n        F.parallel(Infinity, breeds.map(function (b) {\n          return getImages(b);\n        }))\n        //instead of loading hundreds of pics, we will just take one random example for each breed\n        .map(S.ap([rand]))\n        // rand will return undefined for empty arrays, so we need to filter these out in case we got an error up the chain in getImages\n        .map(S.filter(function (v) {\n          return !!v;\n        }))\n      );\n    })\n  );\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvYXBpLmpzP2UxZDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgRiBmcm9tIFwiZmx1dHVyZVwiO1xuaW1wb3J0ICogYXMgU2FuY3R1YXJ5IGZyb20gXCJzYW5jdHVhcnlcIjtcbmltcG9ydCB7IHN0b3JlIH0gZnJvbSBcIi5cIjtcbmltcG9ydCBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcbmNvbnN0IHsgZW52OiBmbHV0dXJlRW52IH0gPSByZXF1aXJlKFwiZmx1dHVyZS1zYW5jdHVhcnktdHlwZXNcIik7XG5jb25zdCBjaGVja1R5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiO1xuLy8gU2FuY3R1YXJ5IHByb3ZpZGVzIGF3ZXNvbWUgZXJyb3JzIGluIGRldmVsb3BtZW50IHZlcnN1cyBlLmcuIFJhbWRhXG5leHBvcnQgY29uc3QgUyA9IFNhbmN0dWFyeS5jcmVhdGUoe1xuICBjaGVja1R5cGVzLFxuICBlbnY6IFNhbmN0dWFyeS5lbnYuY29uY2F0KGZsdXR1cmVFbnYpXG59KTtcblxuY29uc3QgQVBJX1JPT1QgPSBcImh0dHBzOi8vZG9nLmNlby9hcGlcIjtcbmNvbnN0IEJSRUVEX0xJU1RfVVJMID0gYCR7QVBJX1JPT1R9L2JyZWVkcy9saXN0YDtcbmNvbnN0IGdldEltYWdlc1VybEZvciA9IGJyZWVkID0+IGAke0FQSV9ST09UfS9icmVlZC8ke2JyZWVkfS9pbWFnZXNgO1xuXG4vLyB3cmFwIHByb21pc2UgbGlicmFyeSBzbyBpdCByZXR1cm5zIGEgZnV0dXJlXG5jb25zdCBmdUZldGNoID0gRi5lbmNhc2VQMihmZXRjaCk7XG5cbmNvbnN0IGhlYWRlcnMgPSB7XG4gIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCJcbn07XG5jb25zdCBnZXQgPSB1cmwgPT4gZnVGZXRjaCh1cmwsIHsgaGVhZGVycyB9KTtcblxuY29uc3QgZ3JvdXBCeUZpcnN0TGV0dGVyID0gUy5ncm91cEJ5KHggPT4geSA9PiBTLmVxdWFscyhTLmhlYWQoeCkpKFMuaGVhZCh5KSkpO1xuXG4vLyBbWydhbGYnLCAnYXJnaCddLFsnYmVlJywgJ2JvbyddXSAtPiBbJ2EnLCAnYiddXG5jb25zdCBnZXRFYWNoRmlyc3RMZXR0ZXIgPSBTLm1hcE1heWJlKFMucGlwZShbUy5tYXBNYXliZShTLmhlYWQpLCBTLmhlYWRdKSk7XG5cbmNvbnN0IHJhbmQgPSBpdGVtcyA9PiB7XG4gIHJldHVybiBpdGVtc1t+fihpdGVtcy5sZW5ndGggKiBNYXRoLnJhbmRvbSgpKV07XG59O1xuXG4vLyBjaGFpbiBhbmQgbWFwIGFyZSBsaWtlIC5uZXh0IHdpdGggYSBwcm9taXNlXG4vLyBtYXAgaXMgdG8gdHJhbnNmb3JtIHRoZSBkYXRhIGYgLT4gRnV0dXJlKGYoZCkpXG4vLyBjaGFpbiBhbGxvd3MgeW91IHRvLCBlLmcuIG1hcCB0byBhIG5ldyBGdXR1cmUgb3IgYW5vdGhlciB0eXBlLCBmbGF0dGVuaW5nIHRoZSByZXN1bHRpbmcgbmVzdGVkIFR5cGVzXG5cbmV4cG9ydCBjb25zdCBnZXRCcmVlZHMgPSBnZXQoQlJFRURfTElTVF9VUkwpXG4gIC5jaGFpbihyZXMgPT4gRi50cnlQKCgpID0+IHJlcy5qc29uKCkpKVxuICAubWFwKFMucHJvcChcIm1lc3NhZ2VcIikpXG4gIC8vaW5kZXggb3VyIGJyZWVkcyBieSBmaXJzdCBsZXR0ZXJzIC0gd2UgdHJ1c3QgYWxyZWFkeSB0aGV5IGNvbWUgZnJvbSB0aGUgYXBpIGFscGhhYmV0aXplZFxuICAubWFwKGdyb3VwQnlGaXJzdExldHRlcilcbiAgLy93ZSBuZWVkIGEgbGlzdCBvZiB0aGUgbGV0dGVycyBmb3Igb3VyIG5hdlxuICAubWFwKGJyZWVkcyA9PiAoeyBicmVlZHMsIGxldHRlcnM6IGdldEVhY2hGaXJzdExldHRlcihicmVlZHMpIH0pKTtcblxuZXhwb3J0IGNvbnN0IGdldEltYWdlcyA9IGJyZWVkID0+XG4gIGdldChnZXRJbWFnZXNVcmxGb3IoYnJlZWQpKVxuICAgIC5jaGFpbihyZXMgPT4gRi50cnlQKCgpID0+IHJlcy5qc29uKCkpKVxuICAgIC8vIHdlIG5lZWQgdG8gZGVjaWRlIGhvdyB3ZSBkZWFsIHdpdGggYXBpIGVycm9ycy0td2UgY2FuIHNob3J0IGNpcmN1aXQgaW50byB0aGUgcmVqZWN0IGJyYW5jaCB3aXRoIEYucmVqZWN0XG4gICAgLy8gYnV0IGluIHRoaXMgY2FzZSB3ZSBwcmVmZXIganVzdCB0byBpZ25vcmUgdW5zdWNjZXNzZnVsIHJlcXVlc3RzIGFuZCBkaXNwbGF5IG5vdGhpbmcgYnkgcmV0dXJuaW5nIGFuIGVtcHR5IGFycmF5XG4gICAgLy8gdXNlIGNoYWluIG5vdCBtYXAgYmVjYXVzZSB3ZSByZXR1cm4gYSBuZXcgRnV0dXJlIC0tIHdpdGggbWFwIHdlIHdvdWxkIGVuZCB1cCB3aXRoIFtGdXR1cmUobWVzc2FnZSksIEZ1dHVyZShtZXNzYWdlKV1cbiAgICAuY2hhaW4oXG4gICAgICByZXMgPT4gKHJlcy5zdGF0dXMgIT09IFwic3VjY2Vzc1wiID8gRi5vZih7IG1lc3NhZ2U6IFtdIH0pIDogRi5vZihyZXMpKVxuICAgIClcbiAgICAubWFwKFMucHJvcChcIm1lc3NhZ2VcIikpO1xuXG5leHBvcnQgY29uc3QgZ2V0SW1hZ2VzQ29uY3VycmVudGx5ID0gYnJlZWRzID0+XG4gIC8vIGxldHMgZGVib3VuY2Ugc28gdGhlIEZ1dHVyZSB0aGUgcmVxdWVzdHMgZG9lc24ndCBzdGFydCBhcyB0aGUgdXNlciBjbGlja3MgdGhyb3VnaCB0aGUgbGV0dGVyc1xuICBGLmFmdGVyKDUwMCwgbnVsbCkuY2hhaW4oXyA9PlxuICAgIC8vVGhlIGZpcnN0IGFyZ3VtZW50IGlzIGhvdyBtYW55IG9mIHRoZSBGdXR1cmVzIHlvdSB3YW50IHRvIGJlIGNvbmN1cnJlbnRcbiAgICBGLnBhcmFsbGVsKEluZmluaXR5LCBicmVlZHMubWFwKGIgPT4gZ2V0SW1hZ2VzKGIpKSlcbiAgICAgIC8vaW5zdGVhZCBvZiBsb2FkaW5nIGh1bmRyZWRzIG9mIHBpY3MsIHdlIHdpbGwganVzdCB0YWtlIG9uZSByYW5kb20gZXhhbXBsZSBmb3IgZWFjaCBicmVlZFxuICAgICAgLm1hcChTLmFwKFtyYW5kXSkpXG4gICAgICAvLyByYW5kIHdpbGwgcmV0dXJuIHVuZGVmaW5lZCBmb3IgZW1wdHkgYXJyYXlzLCBzbyB3ZSBuZWVkIHRvIGZpbHRlciB0aGVzZSBvdXQgaW4gY2FzZSB3ZSBnb3QgYW4gZXJyb3IgdXAgdGhlIGNoYWluIGluIGdldEltYWdlc1xuICAgICAgLm1hcChTLmZpbHRlcih2ID0+ICEhdikpXG4gICk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2FwaS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBSEE7QUFLQTtBQUxBO0FBTUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUFBO0FBUEE7QUFDQTtBQVVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFHQTtBQUhBO0FBSUE7QUFBQTtBQU5BO0FBQUE7QUFGQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {(function (global, factory) {\n\t true ? module.exports = factory(__webpack_require__(11), __webpack_require__(26), __webpack_require__(1), __webpack_require__(27), __webpack_require__(28)) :\n\ttypeof define === 'function' && define.amd ? define(['sanctuary-type-classes', 'inspect-f', 'sanctuary-type-identifiers', 'concurrify', 'denque'], factory) :\n\t(global.Fluture = factory(global.sanctuaryTypeClasses,global.inspectf,global.sanctuaryTypeIdentifiers,global.concurrify,global.Denque));\n}(this, (function (Z,inspectf,type,concurrify,Denque) { 'use strict';\n\nZ = Z && Z.hasOwnProperty('default') ? Z['default'] : Z;\ninspectf = inspectf && inspectf.hasOwnProperty('default') ? inspectf['default'] : inspectf;\ntype = type && type.hasOwnProperty('default') ? type['default'] : type;\nconcurrify = concurrify && concurrify.hasOwnProperty('default') ? concurrify['default'] : concurrify;\nDenque = Denque && Denque.hasOwnProperty('default') ? Denque['default'] : Denque;\n\n/* istanbul ignore file: environment-specific */\n\n/* eslint-disable no-undef */\nconst scope = typeof self === 'object' ? self :\n                     typeof global === 'object' ? global :\n                     typeof window === 'object' ? window :\n                     {};\n/* eslint-enable no-undef */\n\nconst setImmediate = typeof scope.setImmediate === 'function' ?\n                            scope.setImmediate :\n                            function setImmediate(f, x){ return setTimeout(f, 0, x) };\n\nfunction noop(){}\nfunction moop(){ return this }\nvar show = Z.toString;\nfunction padf(sf, s){ return s.replace(/^/gm, sf).replace(sf, '') }\nfunction showf(f){ return padf('  ', inspectf(2, f)) }\n\nfunction mapArray(xs, f){\n  var l = xs.length, ys = new Array(l);\n  for(var i = 0; i < l; i++) ys[i] = f(xs[i], i, xs);\n  return ys;\n}\n\nfunction partial1(f, a){\n  return function bound1(b, c, d){\n    switch(arguments.length){\n      case 1: return f(a, b);\n      case 2: return f(a, b, c);\n      default: return f(a, b, c, d);\n    }\n  };\n}\n\nfunction partial2(f, a, b){\n  return function bound2(c, d){\n    return arguments.length === 1 ? f(a, b, c) : f(a, b, c, d);\n  };\n}\n\nfunction partial3(f, a, b, c){\n  return function bound3(d){\n    return f(a, b, c, d);\n  };\n}\n\nfunction immediately(f){\n  return function immediate(x){ return setImmediate(f, x) };\n}\n\nvar FL = {\n  map: 'fantasy-land/map',\n  bimap: 'fantasy-land/bimap',\n  chain: 'fantasy-land/chain',\n  chainRec: 'fantasy-land/chainRec',\n  ap: 'fantasy-land/ap',\n  of: 'fantasy-land/of',\n  zero: 'fantasy-land/zero'\n};\n\nvar ordinal = ['first', 'second', 'third', 'fourth', 'fifth'];\n\nvar namespace = 'fluture';\nvar name = 'Future';\nvar version = 3;\n\nvar $$type = namespace + '/' + name + '@' + version;\n\nfunction error(message){\n  throw new Error(message);\n}\n\nfunction typeError(message){\n  throw new TypeError(message);\n}\n\nfunction invalidArgument(it, at, expected, actual){\n  typeError(\n    it + ' expects its ' + ordinal[at] + ' argument to ' + expected + '\\n  Actual: ' + show(actual)\n  );\n}\n\nfunction invalidContext(it, actual){\n  typeError(\n    it + ' was invoked outside the context of a Future. You might want to use'\n  + ' a dispatcher instead\\n  Called on: ' + (show(actual))\n  );\n}\n\nfunction invalidNamespace(m, x){\n  return (\n    'The Future was not created by ' + namespace + '. '\n  + 'Make sure you transform other Futures to ' + namespace + ' Futures. '\n  + 'Got ' + (x ? ('a Future from ' + x) : 'an unscoped Future') + '.'\n  + '\\n  See: https://github.com/fluture-js/Fluture#casting-futures'\n  );\n}\n\nfunction invalidVersion(m, x){\n  return (\n    'The Future was created by ' + (x < version ? 'an older' : 'a newer')\n  + ' version of ' + namespace + '. '\n  + 'This means that one of the sources which creates Futures is outdated. '\n  + 'Update this source, or transform its created Futures to be compatible.'\n  + '\\n  See: https://github.com/fluture-js/Fluture#casting-futures'\n  );\n}\n\nfunction invalidFuture(it, at, m, s){\n  var id = type.parse(type(m));\n  var info = id.name === name ? '\\n' + (\n    id.namespace !== namespace ? invalidNamespace(m, id.namespace)\n  : id.version !== version ? invalidVersion(m, id.version)\n  : 'Nothing seems wrong. Contact the Fluture maintainers.') : '';\n  typeError(\n    it + ' expects ' + (ordinal[at] ? 'its ' + ordinal[at] + ' argument to be a valid Future' : at)\n  + '.' + info + '\\n  Actual: ' + (show(m)) + ' :: ' + (id.name) + (s || '')\n  );\n}\n\nfunction isFunction(f){\n  return typeof f === 'function';\n}\n\nfunction isThenable(m){\n  return m instanceof Promise || Boolean(m) && isFunction(m.then);\n}\n\nfunction isBoolean(f){\n  return typeof f === 'boolean';\n}\n\nfunction isNumber(f){\n  return typeof f === 'number';\n}\n\nfunction isUnsigned(n){\n  return (n === Infinity || isNumber(n) && n > 0 && n % 1 === 0);\n}\n\nfunction isObject(o){\n  return o !== null && typeof o === 'object';\n}\n\nfunction isIterator(i){\n  return isObject(i) && isFunction(i.next);\n}\n\nfunction isArray(x){\n  return Array.isArray(x);\n}\n\n/*eslint no-cond-assign:0, no-constant-condition:0 */\n\nfunction interpreter(rej, res){\n\n  //This is the primary queue of actions. All actions in here will be \"cold\",\n  //meaning they haven't had the chance yet to run concurrent computations.\n  var cold = new Denque(this._actions.size);\n\n  //This is the secondary queue of actions. All actions in here will be \"hot\",\n  //meaning they have already had a chance to run a concurrent computation.\n  var queue = new Denque(this._actions.size);\n\n  //These combined variables define our current state.\n  // future  = the future we are currently forking\n  // action  = the action to be informed when the future settles\n  // cancel  = the cancel function of the current future\n  // settled = a boolean indicating whether a new tick should start\n  // async   = a boolean indicating whether we are awaiting a result asynchronously\n  var future, action, cancel = noop, settled, async = true, it;\n\n  //This function is called with a future to use in the next tick.\n  //Here we \"flatten\" the actions of another Sequence into our own actions,\n  //this is the magic that allows for infinitely stack safe recursion because\n  //actions like ChainAction will return a new Sequence.\n  //If we settled asynchronously, we call drain() directly to run the next tick.\n  function settle(m){\n    settled = true;\n    future = m;\n\n    if(future._spawn){\n      var tail = future._actions;\n\n      while(!tail.isEmpty){\n        cold.unshift(tail.head);\n        tail = tail.tail;\n      }\n\n      future = future._spawn;\n    }\n\n    if(async) drain();\n  }\n\n  //This function serves as a rejection handler for our current future.\n  //It will tell the current action that the future rejected, and it will\n  //settle the current tick with the action's answer to that.\n  function rejected(x){\n    settle(action.rejected(x));\n  }\n\n  //This function serves as a resolution handler for our current future.\n  //It will tell the current action that the future resolved, and it will\n  //settle the current tick with the action's answer to that.\n  function resolved(x){\n    settle(action.resolved(x));\n  }\n\n  //This function is passed into actions when they are \"warmed up\".\n  //If the action decides that it has its result, without the need to await\n  //anything else, then it can call this function to force \"early termination\".\n  //When early termination occurs, all actions which were queued prior to the\n  //terminator will be skipped. If they were already hot, they will also receive\n  //a cancel signal so they can cancel their own concurrent computations, as\n  //their results are no longer needed.\n  function early(m, terminator){\n    cancel();\n    cold.clear();\n\n    if(async && action !== terminator){\n      action.cancel();\n      while((it = queue.shift()) && it !== terminator) it.cancel();\n    }\n\n    settle(m);\n  }\n\n  //This function serves to kickstart concurrent computations.\n  //Takes all actions from the cold queue *back-to-front*, and calls run() on\n  //each of them, passing them the \"early\" function. If any of them settles (by\n  //calling early()), we abort. After warming up all actions in the cold queue,\n  //we warm up the current action as well.\n  function warmupActions(){\n    while(it = cold.pop()){\n      it = it.run(early);\n      if(settled) return;\n      queue.unshift(it);\n    }\n\n    action = action.run(early);\n  }\n\n  //This function represents our main execution loop.\n  //When we refer to a \"tick\", we mean the execution of the body inside the\n  //primary while-loop of this function.\n  //Every tick follows the following algorithm:\n  // 1. We try to take an action from the cold queue, if we fail, go to step 2.\n  //      1a. We fork the future.\n  //      1b. We warmupActions() if the we haven't settled yet.\n  // 2. We try to take an action from the hot queue, if we fail, go to step 3.\n  //      2a. We fork the Future, if settles, we continue to the next tick.\n  // 3. If we couldn't take actions from either queues, we fork the Future into\n  //    the user provided continuations. This is the end of the interpretation.\n  // 4. If we did take an action from one of queues, but none of the steps\n  //    caused a settle(), it means we are asynchronously waiting for something\n  //    to settle and start the next tick, so we return from the function.\n  function drain(){\n    async = false;\n\n    while(true){\n      settled = false;\n      if(action = cold.shift()){\n        cancel = future._fork(rejected, resolved);\n        if(!settled) warmupActions();\n      }else if(action = queue.shift()){\n        cancel = future._fork(rejected, resolved);\n      }else break;\n      if(settled) continue;\n      async = true;\n      return;\n    }\n\n    cancel = future._fork(rej, res);\n  }\n\n  //Start the execution loop.\n  settle(this);\n\n  //Return a cancellation function. It will cancel the current Future, the\n  //current action, and all queued hot actions.\n  return function Sequence$cancel(){\n    cancel();\n    action && action.cancel();\n    while(it = queue.shift()) it.cancel();\n  };\n\n}\n\nvar empty = ({isEmpty: true, size: 0, head: null, tail: null});\n\nfunction cons(head, tail){\n  return {isEmpty: false, size: tail.size + 1, head: head, tail: tail};\n}\n\nfunction throwRejection(x){\n  error('Future#value was called on a rejected Future\\n  Actual: Future.reject(' + show(x) + ')');\n}\n\nfunction Future(computation){\n  if(!isFunction(computation)) invalidArgument('Future', 0, 'be a Function', computation);\n  return new Computation(computation);\n}\n\nfunction isFuture(x){\n  return x instanceof Future || type(x) === $$type;\n}\n\nFuture['@@type'] = $$type;\n\nFuture.prototype[FL.ap] = function Future$FL$ap(other){\n  return other._ap(this);\n};\n\nFuture.prototype[FL.map] = function Future$FL$map(mapper){\n  return this._map(mapper);\n};\n\nFuture.prototype[FL.bimap] = function Future$FL$bimap(lmapper, rmapper){\n  return this._bimap(lmapper, rmapper);\n};\n\nFuture.prototype[FL.chain] = function Future$FL$chain(mapper){\n  return this._chain(mapper);\n};\n\nFuture.prototype.ap = function Future$ap(other){\n  if(!isFuture(this)) invalidContext('Future#ap', this);\n  if(!isFuture(other)) invalidFuture('Future#ap', 0, other);\n  return this._ap(other);\n};\n\nFuture.prototype.map = function Future$map(mapper){\n  if(!isFuture(this)) invalidContext('Future#map', this);\n  if(!isFunction(mapper)) invalidArgument('Future#map', 0, 'to be a Function', mapper);\n  return this._map(mapper);\n};\n\nFuture.prototype.bimap = function Future$bimap(lmapper, rmapper){\n  if(!isFuture(this)) invalidContext('Future#bimap', this);\n  if(!isFunction(lmapper)) invalidArgument('Future#bimap', 0, 'to be a Function', lmapper);\n  if(!isFunction(rmapper)) invalidArgument('Future#bimap', 1, 'to be a Function', rmapper);\n  return this._bimap(lmapper, rmapper);\n};\n\nFuture.prototype.chain = function Future$chain(mapper){\n  if(!isFuture(this)) invalidContext('Future#chain', this);\n  if(!isFunction(mapper)) invalidArgument('Future#chain', 0, 'to be a Function', mapper);\n  return this._chain(mapper);\n};\n\nFuture.prototype.mapRej = function Future$mapRej(mapper){\n  if(!isFuture(this)) invalidContext('Future#mapRej', this);\n  if(!isFunction(mapper)) invalidArgument('Future#mapRej', 0, 'to be a Function', mapper);\n  return this._mapRej(mapper);\n};\n\nFuture.prototype.chainRej = function Future$chainRej(mapper){\n  if(!isFuture(this)) invalidContext('Future#chainRej', this);\n  if(!isFunction(mapper)) invalidArgument('Future#chainRej', 0, 'to be a Function', mapper);\n  return this._chainRej(mapper);\n};\n\nFuture.prototype.race = function Future$race(other){\n  if(!isFuture(this)) invalidContext('Future#race', this);\n  if(!isFuture(other)) invalidFuture('Future#race', 0, other);\n  return this._race(other);\n};\n\nFuture.prototype.both = function Future$both(other){\n  if(!isFuture(this)) invalidContext('Future#both', this);\n  if(!isFuture(other)) invalidFuture('Future#both', 0, other);\n  return this._both(other);\n};\n\nFuture.prototype.and = function Future$and(other){\n  if(!isFuture(this)) invalidContext('Future#and', this);\n  if(!isFuture(other)) invalidFuture('Future#and', 0, other);\n  return this._and(other);\n};\n\nFuture.prototype.or = function Future$or(other){\n  if(!isFuture(this)) invalidContext('Future#or', this);\n  if(!isFuture(other)) invalidFuture('Future#or', 0, other);\n  return this._or(other);\n};\n\nFuture.prototype.swap = function Future$swap(){\n  if(!isFuture(this)) invalidContext('Future#ap', this);\n  return this._swap();\n};\n\nFuture.prototype.fold = function Future$fold(lmapper, rmapper){\n  if(!isFuture(this)) invalidContext('Future#ap', this);\n  if(!isFunction(lmapper)) invalidArgument('Future#fold', 0, 'to be a Function', lmapper);\n  if(!isFunction(rmapper)) invalidArgument('Future#fold', 1, 'to be a Function', rmapper);\n  return this._fold(lmapper, rmapper);\n};\n\nFuture.prototype.finally = function Future$finally(other){\n  if(!isFuture(this)) invalidContext('Future#finally', this);\n  if(!isFuture(other)) invalidFuture('Future#finally', 0, other);\n  return this._finally(other);\n};\n\nFuture.prototype.lastly = function Future$lastly(other){\n  if(!isFuture(this)) invalidContext('Future#lastly', this);\n  if(!isFuture(other)) invalidFuture('Future#lastly', 0, other);\n  return this._finally(other);\n};\n\nFuture.prototype.fork = function Future$fork(rej, res){\n  if(!isFuture(this)) invalidContext('Future#fork', this);\n  if(!isFunction(rej)) invalidArgument('Future#fork', 0, 'to be a Function', rej);\n  if(!isFunction(res)) invalidArgument('Future#fork', 0, 'to be a Function', res);\n  return this._fork(rej, res);\n};\n\nFuture.prototype.value = function Future$value(res){\n  if(!isFuture(this)) invalidContext('Future#value', this);\n  if(!isFunction(res)) invalidArgument('Future#value', 0, 'to be a Function', res);\n  return this._fork(throwRejection, res);\n};\n\nFuture.prototype.done = function Future$done(callback){\n  if(!isFuture(this)) invalidContext('Future#done', this);\n  if(!isFunction(callback)) invalidArgument('Future#done', 0, 'to be a Function', callback);\n  return this._fork(function Future$done$rej(x){ callback(x); },\n                    function Future$done$res(x){ callback(null, x); });\n};\n\nFuture.prototype.promise = function Future$promise(){\n  var _this = this;\n  return new Promise(function Future$promise$computation(res, rej){\n    _this._fork(rej, res);\n  });\n};\n\nFuture.prototype.isRejected = function Future$isRejected(){\n  return false;\n};\n\nFuture.prototype.isResolved = function Future$isResolved(){\n  return false;\n};\n\nFuture.prototype.isSettled = function Future$isSettled(){\n  return this.isRejected() || this.isResolved();\n};\n\nFuture.prototype.extractLeft = function Future$extractLeft(){\n  return [];\n};\n\nFuture.prototype.extractRight = function Future$extractRight(){\n  return [];\n};\n\nvar Core = Object.create(Future.prototype);\n\nCore._ap = function Core$ap(other){\n  return new Sequence(this)._ap(other);\n};\n\nCore._map = function Core$map(mapper){\n  return new Sequence(this)._map(mapper);\n};\n\nCore._bimap = function Core$bimap(lmapper, rmapper){\n  return new Sequence(this)._bimap(lmapper, rmapper);\n};\n\nCore._chain = function Core$chain(mapper){\n  return new Sequence(this)._chain(mapper);\n};\n\nCore._mapRej = function Core$mapRej(mapper){\n  return new Sequence(this)._mapRej(mapper);\n};\n\nCore._chainRej = function Core$chainRej(mapper){\n  return new Sequence(this)._chainRej(mapper);\n};\n\nCore._race = function Core$race(other){\n  return new Sequence(this)._race(other);\n};\n\nCore._both = function Core$both(other){\n  return new Sequence(this)._both(other);\n};\n\nCore._and = function Core$and(other){\n  return new Sequence(this)._and(other);\n};\n\nCore._or = function Core$or(other){\n  return new Sequence(this)._or(other);\n};\n\nCore._swap = function Core$swap(){\n  return new Sequence(this)._swap();\n};\n\nCore._fold = function Core$fold(lmapper, rmapper){\n  return new Sequence(this)._fold(lmapper, rmapper);\n};\n\nCore._finally = function Core$finally(other){\n  return new Sequence(this)._finally(other);\n};\n\nfunction check$fork(f, c){\n  if(!(f === undefined || (isFunction(f) && f.length === 0))) typeError(\n    'Future expected its computation to return a nullary function or void'\n    + '\\n  Actual: ' + show(f) + '\\n  From calling: ' + showf(c)\n  );\n}\n\nfunction Computation(computation){\n  this._computation = computation;\n}\n\nComputation.prototype = Object.create(Core);\n\nComputation.prototype._fork = function Computation$_fork(rej, res){\n  var open = true;\n  var f = this._computation(function Computation$rej(x){\n    if(open){\n      open = false;\n      rej(x);\n    }\n  }, function Computation$res(x){\n    if(open){\n      open = false;\n      res(x);\n    }\n  });\n  check$fork(f, this._computation);\n\n  return function Computation$cancel(){\n    open && f && f();\n    open = false;\n  };\n};\n\nComputation.prototype.toString = function Computation$toString(){\n  return 'Future(' + showf(this._computation) + ')';\n};\n\nfunction Rejected(value){\n  this._value = value;\n}\n\nRejected.prototype = Object.create(Core);\n\nRejected.prototype._ap = moop;\nRejected.prototype._map = moop;\nRejected.prototype._chain = moop;\nRejected.prototype._race = moop;\nRejected.prototype._both = moop;\nRejected.prototype._and = moop;\n\nRejected.prototype._or = function Rejected$or(other){\n  return other;\n};\n\nRejected.prototype._finally = function Rejected$finally(other){\n  return other._and(this);\n};\n\nRejected.prototype._swap = function Rejected$swap(){\n  return new Resolved(this._value);\n};\n\nRejected.prototype._fork = function Rejected$_fork(rej){\n  rej(this._value);\n  return noop;\n};\n\nRejected.prototype.isRejected = function Rejected$isRejected(){\n  return true;\n};\n\nRejected.prototype.extractLeft = function Rejected$extractLeft(){\n  return [this._value];\n};\n\nRejected.prototype.toString = function Rejected$toString(){\n  return 'Future.reject(' + show(this._value) + ')';\n};\n\nfunction reject(x){\n  return new Rejected(x);\n}\n\nfunction Resolved(value){\n  this._value = value;\n}\n\nResolved.prototype = Object.create(Core);\n\nResolved.prototype._race = moop;\nResolved.prototype._mapRej = moop;\nResolved.prototype._or = moop;\n\nResolved.prototype._and = function Resolved$and(other){\n  return other;\n};\n\nResolved.prototype._both = function Resolved$both(other){\n  var left = this._value;\n  return other._map(function Resolved$both$mapper(right){\n    return [left, right];\n  });\n};\n\nResolved.prototype._swap = function Resolved$swap(){\n  return new Rejected(this._value);\n};\n\nResolved.prototype._finally = function Resolved$finally(other){\n  var value = this._value;\n  return other._map(function Resolved$finally$mapper(){\n    return value;\n  });\n};\n\nResolved.prototype._fork = function _fork(rej, res){\n  res(this._value);\n  return noop;\n};\n\nResolved.prototype.isResolved = function Resolved$isResolved(){\n  return true;\n};\n\nResolved.prototype.extractRight = function Resolved$extractRight(){\n  return [this._value];\n};\n\nResolved.prototype.toString = function Resolved$toString(){\n  return 'Future.of(' + show(this._value) + ')';\n};\n\nfunction of(x){\n  return new Resolved(x);\n}\n\nfunction Never(){\n  this._isNever = true;\n}\n\nNever.prototype = Object.create(Future.prototype);\n\nNever.prototype._ap = moop;\nNever.prototype._map = moop;\nNever.prototype._bimap = moop;\nNever.prototype._chain = moop;\nNever.prototype._mapRej = moop;\nNever.prototype._chainRej = moop;\nNever.prototype._both = moop;\nNever.prototype._or = moop;\nNever.prototype._swap = moop;\nNever.prototype._fold = moop;\nNever.prototype._finally = moop;\n\nNever.prototype._race = function Never$race(other){\n  return other;\n};\n\nNever.prototype._fork = function Never$_fork(){\n  return noop;\n};\n\nNever.prototype.toString = function Never$toString(){\n  return 'Future.never';\n};\n\nvar never = new Never();\n\nfunction isNever(x){\n  return isFuture(x) && x._isNever === true;\n}\n\nfunction Eager(future){\n  var _this = this;\n  _this.rej = noop;\n  _this.res = noop;\n  _this.rejected = false;\n  _this.resolved = false;\n  _this.value = null;\n  _this.cancel = future._fork(function Eager$reject(x){\n    _this.value = x;\n    _this.rejected = true;\n    _this.cancel = noop;\n    _this.rej(x);\n  }, function Eager$resolve(x){\n    _this.value = x;\n    _this.resolved = true;\n    _this.cancel = noop;\n    _this.res(x);\n  });\n}\n\nEager.prototype = Object.create(Core);\n\nEager.prototype._fork = function Eager$_fork(rej, res){\n  if(this.rejected) rej(this.value);\n  else if(this.resolved) res(this.value);\n  else{\n    this.rej = rej;\n    this.res = res;\n  }\n  return this.cancel;\n};\n\nfunction check$ap(f){\n  return isFunction(f) ? f : typeError(\n    'Future#ap expects its first argument to be a Future of a Function'\n    + '\\n  Actual: Future.of(' + show(f) + ')'\n  );\n}\n\nfunction check$chain(m, f, x){\n  return isFuture(m) ? m : invalidFuture(\n    'Future#chain',\n    'the function it\\'s given to return a Future',\n    m,\n    '\\n  From calling: ' + showf(f) + '\\n  With: ' + show(x)\n  );\n}\n\nfunction check$chainRej(m, f, x){\n  return isFuture(m) ? m : invalidFuture(\n    'Future#chainRej',\n    'the function it\\'s given to return a Future',\n    m,\n    '\\n  From calling: ' + showf(f) + '\\n  With: ' + show(x)\n  );\n}\n\nvar Action = {\n  rejected: function Action$rejected(x){ this.cancel(); return new Rejected(x) },\n  resolved: function Action$resolved(x){ this.cancel(); return new Resolved(x) },\n  run: function Action$run(){ return this },\n  cancel: function Action$cancel(){}\n};\n\nfunction ApAction(other){ this.other = other; }\nApAction.prototype = Object.create(Action);\n\nApAction.prototype.resolved = function ApAction$resolved(f){\n  check$ap(f);\n  return this.other._map(function ApAction$resolved$mapper(x){ return f(x) });\n};\n\nApAction.prototype.toString = function ApAction$toString(){\n  return 'ap(' + this.other.toString() + ')';\n};\n\nfunction MapAction(mapper){ this.mapper = mapper; }\nMapAction.prototype = Object.create(Action);\n\nMapAction.prototype.resolved = function MapAction$resolved(x){\n  return new Resolved(this.mapper(x));\n};\n\nMapAction.prototype.toString = function MapAction$toString(){\n  return 'map(' + showf(this.mapper) + ')';\n};\n\nfunction BimapAction(lmapper, rmapper){ this.lmapper = lmapper; this.rmapper = rmapper; }\nBimapAction.prototype = Object.create(Action);\n\nBimapAction.prototype.rejected = function BimapAction$rejected(x){\n  return new Rejected(this.lmapper(x));\n};\n\nBimapAction.prototype.resolved = function BimapAction$resolved(x){\n  return new Resolved(this.rmapper(x));\n};\n\nBimapAction.prototype.toString = function BimapAction$toString(){\n  return 'bimap(' + showf(this.lmapper) + ', ' + showf(this.rmapper) + ')';\n};\n\nfunction ChainAction(mapper){ this.mapper = mapper; }\nChainAction.prototype = Object.create(Action);\n\nChainAction.prototype.resolved = function ChainAction$resolved(x){\n  return check$chain(this.mapper(x), this.mapper, x);\n};\n\nChainAction.prototype.toString = function ChainAction$toString(){\n  return 'chain(' + showf(this.mapper) + ')';\n};\n\nfunction MapRejAction(mapper){ this.mapper = mapper; }\nMapRejAction.prototype = Object.create(Action);\n\nMapRejAction.prototype.rejected = function MapRejAction$rejected(x){\n  return new Rejected(this.mapper(x));\n};\n\nMapRejAction.prototype.toString = function MapRejAction$toString(){\n  return 'mapRej(' + showf(this.mapper) + ')';\n};\n\nfunction ChainRejAction(mapper){ this.mapper = mapper; }\nChainRejAction.prototype = Object.create(Action);\n\nChainRejAction.prototype.rejected = function ChainRejAction$rejected(x){\n  return check$chainRej(this.mapper(x), this.mapper, x);\n};\n\nChainRejAction.prototype.toString = function ChainRejAction$toString(){\n  return 'chainRej(' + showf(this.mapper) + ')';\n};\n\nfunction SwapAction(){}\nSwapAction.prototype = Object.create(Action);\n\nSwapAction.prototype.rejected = function SwapAction$rejected(x){\n  return new Resolved(x);\n};\n\nSwapAction.prototype.resolved = function SwapAction$resolved(x){\n  return new Rejected(x);\n};\n\nSwapAction.prototype.toString = function SwapAction$toString(){\n  return 'swap()';\n};\n\nfunction FoldAction(lmapper, rmapper){ this.lmapper = lmapper; this.rmapper = rmapper; }\nFoldAction.prototype = Object.create(Action);\n\nFoldAction.prototype.rejected = function FoldAction$rejected(x){\n  return new Resolved(this.lmapper(x));\n};\n\nFoldAction.prototype.resolved = function FoldAction$resolved(x){\n  return new Resolved(this.rmapper(x));\n};\n\nFoldAction.prototype.toString = function FoldAction$toString(){\n  return 'fold(' + showf(this.lmapper) + ', ' + showf(this.rmapper) + ')';\n};\n\nfunction FinallyAction(other){ this.other = other; }\nFinallyAction.prototype = Object.create(Action);\n\nFinallyAction.prototype.rejected = function FinallyAction$rejected(x){\n  return this.other._and(new Rejected(x));\n};\n\nFinallyAction.prototype.resolved = function FinallyAction$resolved(x){\n  return this.other._map(function FoldAction$resolved$mapper(){ return x });\n};\n\nFinallyAction.prototype.cancel = function FinallyAction$cancel(){\n  this.other._fork(noop, noop)();\n};\n\nFinallyAction.prototype.toString = function FinallyAction$toString(){\n  return 'finally(' + this.other.toString() + ')';\n};\n\nfunction AndAction(other){ this.other = other; }\nAndAction.prototype = Object.create(Action);\n\nAndAction.prototype.resolved = function AndAction$resolved(){\n  return this.other;\n};\n\nAndAction.prototype.toString = function AndAction$toString(){\n  return 'and(' + this.other.toString() + ')';\n};\n\nfunction OrAction(other){ this.other = other; }\nOrAction.prototype = Object.create(Action);\n\nOrAction.prototype.rejected = function OrAction$rejected(){\n  return this.other;\n};\n\nOrAction.prototype.toString = function OrAction$toString(){\n  return 'or(' + this.other.toString() + ')';\n};\n\nfunction RaceAction(other){ this.other = other; }\nRaceAction.prototype = Object.create(Action);\n\nRaceAction.prototype.run = function RaceAction$run(early){\n  return new RaceActionState(early, new Eager(this.other));\n};\n\nRaceAction.prototype.toString = function RaceAction$toString(){\n  return 'race(' + this.other.toString() + ')';\n};\n\nfunction BothAction(other){ this.other = other; }\nBothAction.prototype = Object.create(Action);\n\nBothAction.prototype.resolved = function BothAction$resolved(x){\n  return this.other._map(function BothAction$resolved$mapper(y){ return [x, y] });\n};\n\nBothAction.prototype.run = function BothAction$run(early){\n  return new BothActionState(early, new Eager(this.other));\n};\n\nBothAction.prototype.toString = function BothAction$toString(){\n  return 'both(' + this.other.toString() + ')';\n};\n\nfunction RaceActionState(early, other){\n  var _this = this;\n  _this.other = other;\n  _this.cancel = other._fork(\n    function RaceActionState$rej(x){ early(new Rejected(x), _this); },\n    function RaceActionState$res(x){ early(new Resolved(x), _this); }\n  );\n}\n\nRaceActionState.prototype = Object.create(RaceAction.prototype);\n\nfunction BothActionState(early, other){\n  var _this = this;\n  _this.other = other;\n  _this.cancel = other._fork(\n    function BothActionState$rej(x){ early(new Rejected(x), _this); },\n    noop\n  );\n}\n\nBothActionState.prototype = Object.create(BothAction.prototype);\n\nfunction Sequence(spawn, actions){\n  this._spawn = spawn;\n  this._actions = actions || empty;\n}\n\nSequence.prototype = Object.create(Future.prototype);\n\nSequence.prototype._transform = function Sequence$_transform(action){\n  return new Sequence(this._spawn, cons(action, this._actions));\n};\n\nSequence.prototype._ap = function Sequence$ap(other){\n  return this._transform(new ApAction(other));\n};\n\nSequence.prototype._map = function Sequence$map(mapper){\n  return this._transform(new MapAction(mapper));\n};\n\nSequence.prototype._bimap = function Sequence$bimap(lmapper, rmapper){\n  return this._transform(new BimapAction(lmapper, rmapper));\n};\n\nSequence.prototype._chain = function Sequence$chain(mapper){\n  return this._transform(new ChainAction(mapper));\n};\n\nSequence.prototype._mapRej = function Sequence$mapRej(mapper){\n  return this._transform(new MapRejAction(mapper));\n};\n\nSequence.prototype._chainRej = function Sequence$chainRej(mapper){\n  return this._transform(new ChainRejAction(mapper));\n};\n\nSequence.prototype._race = function Sequence$race(other){\n  return isNever(other) ? this : this._transform(new RaceAction(other));\n};\n\nSequence.prototype._both = function Sequence$both(other){\n  return this._transform(new BothAction(other));\n};\n\nSequence.prototype._and = function Sequence$and(other){\n  return this._transform(new AndAction(other));\n};\n\nSequence.prototype._or = function Sequence$or(other){\n  return this._transform(new OrAction(other));\n};\n\nSequence.prototype._swap = function Sequence$swap(){\n  return this._transform(new SwapAction);\n};\n\nSequence.prototype._fold = function Sequence$fold(lmapper, rmapper){\n  return this._transform(new FoldAction(lmapper, rmapper));\n};\n\nSequence.prototype._finally = function Sequence$finally(other){\n  return this._transform(new FinallyAction(other));\n};\n\nSequence.prototype._fork = interpreter;\n\nSequence.prototype.toString = function Sequence$toString(){\n  var str = '', tail = this._actions;\n\n  while(!tail.isEmpty){\n    str = '.' + tail.head.toString() + str;\n    tail = tail.tail;\n  }\n\n  return this._spawn.toString() + str;\n};\n\nfunction Next(x){\n  return {done: false, value: x};\n}\n\nfunction Done(x){\n  return {done: true, value: x};\n}\n\nfunction isIteration(x){\n  return isObject(x) && isBoolean(x.done);\n}\n\nvar Undetermined = 0;\nvar Synchronous = 1;\nvar Asynchronous = 2;\n\nfunction ChainRec(step, init){\n  this._step = step;\n  this._init = init;\n}\n\nChainRec.prototype = Object.create(Core);\n\nChainRec.prototype._fork = function ChainRec$_fork(rej, res){\n\n  var _step = this._step;\n  var _init = this._init;\n  var timing = Undetermined, cancel = noop, state = Next(_init);\n\n  function resolved(it){\n    state = it;\n    timing = timing === Undetermined ? Synchronous : drain();\n  }\n\n  function drain(){\n    while(!state.done){\n      timing = Undetermined;\n      var m = _step(Next, Done, state.value);\n      cancel = m._fork(rej, resolved);\n\n      if(timing !== Synchronous){\n        timing = Asynchronous;\n        return;\n      }\n    }\n\n    res(state.value);\n  }\n\n  drain();\n\n  return function Future$chainRec$cancel(){ cancel(); };\n\n};\n\nChainRec.prototype.toString = function ChainRec$toString(){\n  return 'Future.chainRec(' + showf(this._step) + ', ' + show(this._init) + ')';\n};\n\nfunction chainRec(step, init){\n  return new ChainRec(step, init);\n}\n\nfunction ap$mval(mval, mfunc){\n  if(!Z.Apply.test(mfunc)) invalidArgument('Future.ap', 1, 'be an Apply', mfunc);\n  return Z.ap(mval, mfunc);\n}\n\nfunction ap(mval, mfunc){\n  if(!Z.Apply.test(mval)) invalidArgument('Future.ap', 0, 'be an Apply', mval);\n  if(arguments.length === 1) return partial1(ap$mval, mval);\n  return ap$mval(mval, mfunc);\n}\n\nfunction alt$left(left, right){\n  if(!Z.Alt.test(right)) invalidArgument('alt', 1, 'be an Alt', right);\n  return Z.alt(left, right);\n}\n\nfunction alt(left, right){\n  if(!Z.Alt.test(left)) invalidArgument('alt', 0, 'be an Alt', left);\n  if(arguments.length === 1) return partial1(alt$left, left);\n  return alt$left(left, right);\n}\n\nfunction map$mapper(mapper, m){\n  if(!Z.Functor.test(m)) invalidArgument('Future.map', 1, 'be a Functor', m);\n  return Z.map(mapper, m);\n}\n\nfunction map(mapper, m){\n  if(!isFunction(mapper)) invalidArgument('Future.map', 0, 'be a Function', mapper);\n  if(arguments.length === 1) return partial1(map$mapper, mapper);\n  return map$mapper(mapper, m);\n}\n\nfunction bimap$lmapper$rmapper(lmapper, rmapper, m){\n  if(!Z.Bifunctor.test(m)) invalidArgument('Future.bimap', 2, 'be a Bifunctor', m);\n  return Z.bimap(lmapper, rmapper, m);\n}\n\nfunction bimap$lmapper(lmapper, rmapper, m){\n  if(!isFunction(rmapper)) invalidArgument('Future.bimap', 1, 'be a Function', rmapper);\n  if(arguments.length === 2) return partial2(bimap$lmapper$rmapper, lmapper, rmapper);\n  return bimap$lmapper$rmapper(lmapper, rmapper, m);\n}\n\nfunction bimap(lmapper, rmapper, m){\n  if(!isFunction(lmapper)) invalidArgument('Future.bimap', 0, 'be a Function', lmapper);\n  if(arguments.length === 1) return partial1(bimap$lmapper, lmapper);\n  if(arguments.length === 2) return bimap$lmapper(lmapper, rmapper);\n  return bimap$lmapper(lmapper, rmapper, m);\n}\n\nfunction chain$chainer(chainer, m){\n  if(!Z.Chain.test(m)) invalidArgument('Future.chain', 1, 'be a Chain', m);\n  return Z.chain(chainer, m);\n}\n\nfunction chain(chainer, m){\n  if(!isFunction(chainer)) invalidArgument('Future.chain', 0, 'be a Function', chainer);\n  if(arguments.length === 1) return partial1(chain$chainer, chainer);\n  return chain$chainer(chainer, m);\n}\n\nfunction mapRej$mapper(mapper, m){\n  if(!isFuture(m)) invalidFuture('Future.mapRej', 1, m);\n  return m.mapRej(mapper);\n}\n\nfunction mapRej(mapper, m){\n  if(!isFunction(mapper)) invalidArgument('Future.mapRej', 0, 'be a Function', mapper);\n  if(arguments.length === 1) return partial1(mapRej$mapper, mapper);\n  return mapRej$mapper(mapper, m);\n}\n\nfunction chainRej$chainer(chainer, m){\n  if(!isFuture(m)) invalidFuture('Future.chainRej', 1, m);\n  return m.chainRej(chainer);\n}\n\nfunction chainRej(chainer, m){\n  if(!isFunction(chainer)) invalidArgument('Future.chainRej', 0, 'be a Function', chainer);\n  if(arguments.length === 1) return partial1(chainRej$chainer, chainer);\n  return chainRej$chainer(chainer, m);\n}\n\nfunction lastly$right(right, left){\n  if(!isFuture(left)) invalidFuture('Future.finally', 1, left);\n  return left.finally(right);\n}\n\nfunction lastly(right, left){\n  if(!isFuture(right)) invalidFuture('Future.finally', 0, right);\n  if(arguments.length === 1) return partial1(lastly$right, right);\n  return lastly$right(right, left);\n}\n\nfunction and$left(left, right){\n  if(!isFuture(right)) invalidFuture('Future.and', 1, right);\n  return left.and(right);\n}\n\nfunction and(left, right){\n  if(!isFuture(left)) invalidFuture('Future.and', 0, left);\n  if(arguments.length === 1) return partial1(and$left, left);\n  return and$left(left, right);\n}\n\nfunction both$left(left, right){\n  if(!isFuture(right)) invalidFuture('Future.both', 1, right);\n  return left.both(right);\n}\n\nfunction both(left, right){\n  if(!isFuture(left)) invalidFuture('Future.both', 0, left);\n  if(arguments.length === 1) return partial1(both$left, left);\n  return both$left(left, right);\n}\n\nfunction or$left(left, right){\n  if(!isFuture(right)) invalidFuture('Future.or', 1, right);\n  return left.or(right);\n}\n\nfunction or(left, right){\n  if(!isFuture(left)) invalidFuture('Future.or', 0, left);\n  if(arguments.length === 1) return partial1(or$left, left);\n  return or$left(left, right);\n}\n\nfunction race$right(right, left){\n  if(!isFuture(left)) invalidFuture('Future.race', 1, left);\n  return left.race(right);\n}\n\nfunction race(right, left){\n  if(!isFuture(right)) invalidFuture('Future.race', 0, right);\n  if(arguments.length === 1) return partial1(race$right, right);\n  return race$right(right, left);\n}\n\nfunction swap(m){\n  if(!isFuture(m)) invalidFuture('Future.swap', 0, m);\n  return m.swap();\n}\n\nfunction fold$f$g(f, g, m){\n  if(!isFuture(m)) invalidFuture('Future.fold', 2, m);\n  return m.fold(f, g);\n}\n\nfunction fold$f(f, g, m){\n  if(!isFunction(g)) invalidArgument('Future.fold', 1, 'be a function', g);\n  if(arguments.length === 2) return partial2(fold$f$g, f, g);\n  return fold$f$g(f, g, m);\n}\n\nfunction fold(f, g, m){\n  if(!isFunction(f)) invalidArgument('Future.fold', 0, 'be a function', f);\n  if(arguments.length === 1) return partial1(fold$f, f);\n  if(arguments.length === 2) return fold$f(f, g);\n  return fold$f(f, g, m);\n}\n\nfunction done$callback(callback, m){\n  if(!isFuture(m)) invalidFuture('Future.done', 1, m);\n  return m.done(callback);\n}\n\nfunction done(callback, m){\n  if(!isFunction(callback)) invalidArgument('Future.done', 0, 'be a Function', callback);\n  if(arguments.length === 1) return partial1(done$callback, callback);\n  return done$callback(callback, m);\n}\n\nfunction fork$f$g(f, g, m){\n  if(!isFuture(m)) invalidFuture('Future.fork', 2, m);\n  return m._fork(f, g);\n}\n\nfunction fork$f(f, g, m){\n  if(!isFunction(g)) invalidArgument('Future.fork', 1, 'be a function', g);\n  if(arguments.length === 2) return partial2(fork$f$g, f, g);\n  return fork$f$g(f, g, m);\n}\n\nfunction fork(f, g, m){\n  if(!isFunction(f)) invalidArgument('Future.fork', 0, 'be a function', f);\n  if(arguments.length === 1) return partial1(fork$f, f);\n  if(arguments.length === 2) return fork$f(f, g);\n  return fork$f(f, g, m);\n}\n\nfunction promise(m){\n  if(!isFuture(m)) invalidFuture('Future.promise', 0, m);\n  return m.promise();\n}\n\nfunction value$cont(cont, m){\n  if(!isFuture(m)) invalidFuture('Future.value', 1, m);\n  return m.value(cont);\n}\n\nfunction value(cont, m){\n  if(!isFunction(cont)) invalidArgument('Future.value', 0, 'be a Function', cont);\n  if(arguments.length === 1) return partial1(value$cont, cont);\n  return value$cont(cont, m);\n}\n\nfunction extractLeft(m){\n  if(!isFuture(m)) invalidFuture('Future.extractLeft', 0, m);\n  return m.extractLeft();\n}\n\nfunction extractRight(m){\n  if(!isFuture(m)) invalidFuture('Future.extractRight', 0, m);\n  return m.extractRight();\n}\n\nfunction check$ap$f(f){\n  if(!isFunction(f)) typeError(\n    'Future#ap expects its first argument to be a Future of a Function'\n    + '\\n  Actual: Future.of(' + show(f) + ')'\n  );\n}\n\nfunction ParallelAp(mval, mfunc){\n  this._mval = mval;\n  this._mfunc = mfunc;\n}\n\nParallelAp.prototype = Object.create(Core);\n\nParallelAp.prototype._fork = function ParallelAp$fork(rej, res){\n  var func, val, okval = false, okfunc = false, rejected = false, c1, c2;\n\n  function ParallelAp$rej(x){\n    if(!rejected){\n      rejected = true;\n      rej(x);\n    }\n  }\n\n  c1 = this._mval._fork(ParallelAp$rej, function ParallelAp$fork$resVal(x){\n    c1 = noop;\n    if(!okval) return void (okfunc = true, val = x);\n    res(func(x));\n  });\n  c2 = this._mfunc._fork(ParallelAp$rej, function ParallelAp$fork$resFunc(f){\n    c2 = noop;\n    check$ap$f(f);\n    if(!okfunc) return void (okval = true, func = f);\n    res(f(val));\n  });\n\n  return function ParallelAp$fork$cancel(){\n    c1();\n    c2();\n  };\n};\n\nParallelAp.prototype.toString = function ParallelAp$toString(){\n  return 'new ParallelAp(' + this._mval.toString() + ', ' + this._mfunc.toString() + ')';\n};\n\nfunction parallelAp(mval, mfunc){\n  return new ParallelAp(mval, mfunc);\n}\n\nfunction After$race(other){\n  return other.isSettled()\n       ? other\n       : isNever(other)\n       ? this\n       : typeof other._time === 'number'\n       ? other._time < this._time ? other : this\n       : Core._race.call(this, other);\n}\n\nfunction After(time, value){\n  this._time = time;\n  this._value = value;\n}\n\nAfter.prototype = Object.create(Core);\n\nAfter.prototype._race = After$race;\n\nAfter.prototype._swap = function After$swap(){\n  return new RejectAfter(this._time, this._value);\n};\n\nAfter.prototype._fork = function After$_fork(rej, res){\n  var id = setTimeout(res, this._time, this._value);\n  return function After$cancel(){ clearTimeout(id); };\n};\n\nAfter.prototype.extractRight = function After$extractRight(){\n  return [this._value];\n};\n\nAfter.prototype.toString = function After$toString(){\n  return 'Future.after(' + show(this._time) + ', ' + show(this._value) + ')';\n};\n\nfunction RejectAfter(time, value){\n  this._time = time;\n  this._value = value;\n}\n\nRejectAfter.prototype = Object.create(Core);\n\nRejectAfter.prototype._race = After$race;\n\nRejectAfter.prototype._swap = function RejectAfter$swap(){\n  return new After(this._time, this._value);\n};\n\nRejectAfter.prototype._fork = function RejectAfter$_fork(rej){\n  var id = setTimeout(rej, this._time, this._value);\n  return function RejectAfter$cancel(){ clearTimeout(id); };\n};\n\nRejectAfter.prototype.extractLeft = function RejectAfter$extractLeft(){\n  return [this._value];\n};\n\nRejectAfter.prototype.toString = function RejectAfter$toString(){\n  return 'Future.rejectAfter(' + show(this._time) + ', ' + show(this._value) + ')';\n};\n\nfunction after$time(time, value){\n  return time === Infinity ? never : new After(time, value);\n}\n\nfunction after(time, value){\n  if(!isUnsigned(time)) invalidArgument('Future.after', 0, 'be a positive integer', time);\n  if(arguments.length === 1) return partial1(after$time, time);\n  return after$time(time, value);\n}\n\nfunction rejectAfter$time(time, reason){\n  return time === Infinity ? never : new RejectAfter(time, reason);\n}\n\nfunction rejectAfter(time, reason){\n  if(!isUnsigned(time)) invalidArgument('Future.rejectAfter', 0, 'be a positive integer', time);\n  if(arguments.length === 1) return partial1(rejectAfter$time, time);\n  return rejectAfter$time(time, reason);\n}\n\nfunction Attempt(fn){\n  this._fn = fn;\n}\n\nAttempt.prototype = Object.create(Core);\n\nAttempt.prototype._fork = function Attempt$fork(rej, res){\n  var r;\n  try{ r = this._fn(); }catch(e){ rej(e); return noop }\n  res(r);\n  return noop;\n};\n\nAttempt.prototype.toString = function Attempt$toString(){\n  return 'Future.try(' + showf(this._fn) + ')';\n};\n\nfunction attempt(f){\n  if(!isFunction(f)) invalidArgument('Future.try', 0, 'be a function', f);\n  return new Attempt(f);\n}\n\nvar Cold = Cached.Cold = 0;\nvar Pending = Cached.Pending = 1;\nvar Rejected$1 = Cached.Rejected = 2;\nvar Resolved$1 = Cached.Resolved = 3;\n\nfunction Queued(rej, res){\n  this[Rejected$1] = rej;\n  this[Resolved$1] = res;\n}\n\nfunction Cached(pure){\n  this._pure = pure;\n  this.reset();\n}\n\nCached.prototype = Object.create(Core);\n\nCached.prototype.isRejected = function Cached$isRejected(){\n  return this._state === Rejected$1;\n};\n\nCached.prototype.isResolved = function Cached$isResolved(){\n  return this._state === Resolved$1;\n};\n\nCached.prototype.extractLeft = function Cached$extractLeft(){\n  return this.isRejected() ? [this._value] : [];\n};\n\nCached.prototype.extractRight = function Cached$extractRight(){\n  return this.isResolved() ? [this._value] : [];\n};\n\nCached.prototype._addToQueue = function Cached$addToQueue(rej, res){\n  var _this = this;\n  if(_this._state > Pending) return noop;\n  var i = _this._queue.push(new Queued(rej, res)) - 1;\n  _this._queued = _this._queued + 1;\n\n  return function Cached$removeFromQueue(){\n    if(_this._state > Pending) return;\n    _this._queue[i] = undefined;\n    _this._queued = _this._queued - 1;\n    if(_this._queued === 0) _this.reset();\n  };\n};\n\nCached.prototype._drainQueue = function Cached$drainQueue(){\n  if(this._state <= Pending) return;\n  if(this._queued === 0) return;\n  var queue = this._queue;\n  var length = queue.length;\n  var state = this._state;\n  var value = this._value;\n\n  for(var i = 0; i < length; i++){\n    queue[i] && queue[i][state](value);\n    queue[i] = undefined;\n  }\n\n  this._queue = undefined;\n  this._queued = 0;\n};\n\nCached.prototype.reject = function Cached$reject(reason){\n  if(this._state > Pending) return;\n  this._value = reason;\n  this._state = Rejected$1;\n  this._drainQueue();\n};\n\nCached.prototype.resolve = function Cached$resolve(value){\n  if(this._state > Pending) return;\n  this._value = value;\n  this._state = Resolved$1;\n  this._drainQueue();\n};\n\nCached.prototype.run = function Cached$run(){\n  var _this = this;\n  if(_this._state > Cold) return;\n  _this._state = Pending;\n  _this._cancel = _this._pure._fork(\n    function Cached$fork$rej(x){ _this.reject(x); },\n    function Cached$fork$res(x){ _this.resolve(x); }\n  );\n};\n\nCached.prototype.reset = function Cached$reset(){\n  if(this._state === Cold) return;\n  if(this._state > Pending) this._cancel();\n  this._cancel = noop;\n  this._queue = [];\n  this._queued = 0;\n  this._value = undefined;\n  this._state = Cold;\n};\n\nCached.prototype._fork = function Cached$_fork(rej, res){\n  var cancel = noop;\n\n  switch(this._state){\n    case Pending: cancel = this._addToQueue(rej, res); break;\n    case Rejected$1: rej(this._value); break;\n    case Resolved$1: res(this._value); break;\n    default: cancel = this._addToQueue(rej, res); this.run();\n  }\n\n  return cancel;\n};\n\nCached.prototype.toString = function Cached$toString(){\n  return 'Future.cache(' + this._pure.toString() + ')';\n};\n\nfunction cache(m){\n  if(!isFuture(m)) invalidFuture('Future.cache', 0, m);\n  return new Cached(m);\n}\n\nfunction Encase(fn, a){\n  this._fn = fn;\n  this._a = a;\n}\n\nEncase.prototype = Object.create(Core);\n\nEncase.prototype._fork = function Encase$fork(rej, res){\n  var r;\n  try{ r = this._fn(this._a); }catch(e){ rej(e); return noop }\n  res(r);\n  return noop;\n};\n\nEncase.prototype.toString = function Encase$toString(){\n  return 'Future.encase(' + showf(this._fn) + ', ' + show(this._a) + ')';\n};\n\nfunction encase(f, x){\n  if(!isFunction(f)) invalidArgument('Future.encase', 0, 'be a function', f);\n  if(arguments.length === 1) return partial1(encase, f);\n  return new Encase(f, x);\n}\n\nfunction Encase2(fn, a, b){\n  this._fn = fn;\n  this._a = a;\n  this._b = b;\n}\n\nEncase2.prototype = Object.create(Core);\n\nEncase2.prototype._fork = function Encase2$fork(rej, res){\n  var r;\n  try{ r = this._fn(this._a, this._b); }catch(e){ rej(e); return noop }\n  res(r);\n  return noop;\n};\n\nEncase2.prototype.toString = function Encase2$toString(){\n  return 'Future.encase2(' + showf(this._fn) + ', ' + show(this._a) + ', ' + show(this._b) + ')';\n};\n\nfunction encase2(f, x, y){\n  if(!isFunction(f)) invalidArgument('Future.encase2', 0, 'be a function', f);\n\n  switch(arguments.length){\n    case 1: return partial1(encase2, f);\n    case 2: return partial2(encase2, f, x);\n    default: return new Encase2(f, x, y);\n  }\n}\n\nfunction Encase3(fn, a, b, c){\n  this._fn = fn;\n  this._a = a;\n  this._b = b;\n  this._c = c;\n}\n\nEncase3.prototype = Object.create(Core);\n\nEncase3.prototype._fork = function Encase3$fork(rej, res){\n  var r;\n  try{ r = this._fn(this._a, this._b, this._c); }catch(e){ rej(e); return noop }\n  res(r);\n  return noop;\n};\n\nEncase3.prototype.toString = function Encase3$toString(){\n  return 'Future.encase3('\n       + showf(this._fn)\n       + ', '\n       + show(this._a)\n       + ', '\n       + show(this._b)\n       + ', '\n       + show(this._c)\n       + ')';\n};\n\nfunction encase3(f, x, y, z){\n  if(!isFunction(f)) invalidArgument('Future.encase3', 0, 'be a function', f);\n\n  switch(arguments.length){\n    case 1: return partial1(encase3, f);\n    case 2: return partial2(encase3, f, x);\n    case 3: return partial3(encase3, f, x, y);\n    default: return new Encase3(f, x, y, z);\n  }\n}\n\nfunction EncaseN(fn, a){\n  this._fn = fn;\n  this._a = a;\n}\n\nEncaseN.prototype = Object.create(Core);\n\nEncaseN.prototype._fork = function EncaseN$fork(rej, res){\n  var open = true;\n  this._fn(this._a, function EncaseN$done(err, val){\n    if(open){\n      open = false;\n      err ? rej(err) : res(val);\n    }\n  });\n  return function EncaseN$cancel(){ open = false; };\n};\n\nEncaseN.prototype.toString = function EncaseN$toString(){\n  return 'Future.encaseN(' + showf(this._fn) + ', ' + show(this._a) + ')';\n};\n\nfunction encaseN(f, x){\n  if(!isFunction(f)) invalidArgument('Future.encaseN', 0, 'be a function', f);\n  if(arguments.length === 1) return partial1(encaseN, f);\n  return new EncaseN(f, x);\n}\n\nfunction EncaseN2(fn, a, b){\n  this._fn = fn;\n  this._a = a;\n  this._b = b;\n}\n\nEncaseN2.prototype = Object.create(Core);\n\nEncaseN2.prototype._fork = function EncaseN2$fork(rej, res){\n  var open = true;\n  this._fn(this._a, this._b, function EncaseN2$done(err, val){\n    if(open){\n      open = false;\n      err ? rej(err) : res(val);\n    }\n  });\n  return function EncaseN2$cancel(){ open = false; };\n};\n\nEncaseN2.prototype.toString = function EncaseN2$toString(){\n  return 'Future.encaseN2(' + showf(this._fn) + ', ' + show(this._a) + ', ' + show(this._b) + ')';\n};\n\nfunction encaseN2(f, x, y){\n  if(!isFunction(f)) invalidArgument('Future.encaseN2', 0, 'be a function', f);\n\n  switch(arguments.length){\n    case 1: return partial1(encaseN2, f);\n    case 2: return partial2(encaseN2, f, x);\n    default: return new EncaseN2(f, x, y);\n  }\n}\n\nfunction EncaseN$1(fn, a, b, c){\n  this._fn = fn;\n  this._a = a;\n  this._b = b;\n  this._c = c;\n}\n\nEncaseN$1.prototype = Object.create(Core);\n\nEncaseN$1.prototype._fork = function EncaseN$3$fork(rej, res){\n  var open = true;\n  this._fn(this._a, this._b, this._c, function EncaseN$3$done(err, val){\n    if(open){\n      open = false;\n      err ? rej(err) : res(val);\n    }\n  });\n  return function EncaseN$3$cancel(){ open = false; };\n};\n\nEncaseN$1.prototype.toString = function EncaseN$3$toString(){\n  return 'Future.encaseN3('\n       + showf(this._fn)\n       + ', '\n       + show(this._a)\n       + ', '\n       + show(this._b)\n       + ', '\n       + show(this._c)\n       + ')';\n};\n\nfunction encaseN3(f, x, y, z){\n  if(!isFunction(f)) invalidArgument('Future.encaseN3', 0, 'be a function', f);\n\n  switch(arguments.length){\n    case 1: return partial1(encaseN3, f);\n    case 2: return partial2(encaseN3, f, x);\n    case 3: return partial3(encaseN3, f, x, y);\n    default: return new EncaseN$1(f, x, y, z);\n  }\n}\n\nfunction check$promise(p, f, a){\n  return isThenable(p) ? p : typeError(\n    'Future.encaseP expects the function it\\'s given to return a Promise/Thenable'\n    + '\\n  Actual: ' + (show(p)) + '\\n  From calling: ' + (showf(f))\n    + '\\n  With: ' + (show(a))\n  );\n}\n\nfunction EncaseP(fn, a){\n  this._fn = fn;\n  this._a = a;\n}\n\nEncaseP.prototype = Object.create(Core);\n\nEncaseP.prototype._fork = function EncaseP$fork(rej, res){\n  var _fn = this._fn;\n  var _a = this._a;\n  var open = true;\n  check$promise(_fn(_a), _fn, _a).then(immediately(function EncaseP$res(x){\n    if(open){\n      open = false;\n      res(x);\n    }\n  }), immediately(function EncaseP$rej(x){\n    if(open){\n      open = false;\n      rej(x);\n    }\n  }));\n  return function EncaseP$cancel(){ open = false; };\n};\n\nEncaseP.prototype.toString = function EncaseP$toString(){\n  return 'Future.encaseP(' + showf(this._fn) + ', ' + show(this._a) + ')';\n};\n\nfunction encaseP(f, x){\n  if(!isFunction(f)) invalidArgument('Future.encaseP', 0, 'be a function', f);\n  if(arguments.length === 1) return partial1(encaseP, f);\n  return new EncaseP(f, x);\n}\n\nfunction check$promise$1(p, f, a, b){\n  return isThenable(p) ? p : typeError(\n    'Future.encaseP2 expects the function it\\'s given to return a Promise/Thenable'\n    + '\\n  Actual: ' + (show(p)) + '\\n  From calling: ' + (showf(f))\n    + '\\n  With 1: ' + (show(a))\n    + '\\n  With 2: ' + (show(b))\n  );\n}\n\nfunction EncaseP2(fn, a, b){\n  this._fn = fn;\n  this._a = a;\n  this._b = b;\n}\n\nEncaseP2.prototype = Object.create(Core);\n\nEncaseP2.prototype._fork = function EncaseP2$fork(rej, res){\n  var _fn = this._fn;\n  var _a = this._a;\n  var _b = this._b;\n  var open = true;\n  check$promise$1(_fn(_a, _b), _fn, _a, _b).then(immediately(function EncaseP2$res(x){\n    if(open){\n      open = false;\n      res(x);\n    }\n  }), immediately(function EncaseP2$rej(x){\n    if(open){\n      open = false;\n      rej(x);\n    }\n  }));\n  return function EncaseP2$cancel(){ open = false; };\n};\n\nEncaseP2.prototype.toString = function EncaseP2$toString(){\n  return 'Future.encaseP2(' + showf(this._fn) + ', ' + show(this._a) + ', ' + show(this._b) + ')';\n};\n\nfunction encaseP2(f, x, y){\n  if(!isFunction(f)) invalidArgument('Future.encaseP2', 0, 'be a function', f);\n\n  switch(arguments.length){\n    case 1: return partial1(encaseP2, f);\n    case 2: return partial2(encaseP2, f, x);\n    default: return new EncaseP2(f, x, y);\n  }\n}\n\nfunction check$promise$2(p, f, a, b, c){\n  return isThenable(p) ? p : typeError(\n    'Future.encaseP3 expects the function it\\'s given to return a Promise/Thenable'\n    + '\\n  Actual: ' + (show(p)) + '\\n  From calling: ' + (showf(f))\n    + '\\n  With 1: ' + (show(a))\n    + '\\n  With 2: ' + (show(b))\n    + '\\n  With 3: ' + (show(c))\n  );\n}\n\nfunction EncaseP3(fn, a, b, c){\n  this._fn = fn;\n  this._a = a;\n  this._b = b;\n  this._c = c;\n}\n\nEncaseP3.prototype = Object.create(Core);\n\nEncaseP3.prototype._fork = function EncaseP3$fork(rej, res){\n  var _fn = this._fn;\n  var _a = this._a;\n  var _b = this._b;\n  var _c = this._c;\n  var open = true;\n  check$promise$2(_fn(_a, _b, _c), _fn, _a, _b, _c).then(immediately(function EncaseP3$res(x){\n    if(open){\n      open = false;\n      res(x);\n    }\n  }), immediately(function EncaseP3$rej(x){\n    if(open){\n      open = false;\n      rej(x);\n    }\n  }));\n  return function EncaseP3$cancel(){ open = false; };\n};\n\nEncaseP3.prototype.toString = function EncaseP3$toString(){\n  return 'Future.encaseP3('\n       + showf(this._fn)\n       + ', '\n       + show(this._a)\n       + ', '\n       + show(this._b)\n       + ', '\n       + show(this._c)\n       + ')';\n};\n\nfunction encaseP3(f, x, y, z){\n  if(!isFunction(f)) invalidArgument('Future.encaseP3', 0, 'be a function', f);\n\n  switch(arguments.length){\n    case 1: return partial1(encaseP3, f);\n    case 2: return partial2(encaseP3, f, x);\n    case 3: return partial3(encaseP3, f, x, y);\n    default: return new EncaseP3(f, x, y, z);\n  }\n}\n\n/*eslint consistent-return: 0*/\n\nfunction check$iterator(g){\n  return isIterator(g) ? g : invalidArgument(\n    'Future.do', 0, 'return an iterator, maybe you forgot the \"*\"', g\n  );\n}\n\nfunction check$iteration(o){\n  if(!isIteration(o)) typeError(\n    'Future.do was given an invalid generator:'\n    + ' Its iterator did not return a valid iteration from iterator.next()'\n    + '\\n  Actual: ' + show(o)\n  );\n  if(o.done || isFuture(o.value)) return o;\n  return invalidFuture(\n    'Future.do',\n    'the iterator to produce only valid Futures',\n    o.value,\n    '\\n  Tip: If you\\'re using a generator, make sure you always yield a Future'\n  );\n}\n\nfunction Go(generator){\n  this._generator = generator;\n}\n\nGo.prototype = Object.create(Core);\n\nGo.prototype._fork = function Go$_fork(rej, res){\n\n  var iterator = check$iterator(this._generator());\n\n  var timing = Undetermined, cancel = noop, state, value;\n\n  function resolved(x){\n    value = x;\n    if(timing === Asynchronous) return drain();\n    timing = Synchronous;\n    state = check$iteration(iterator.next(value));\n  }\n\n  function drain(){\n    state = check$iteration(iterator.next(value));\n\n    while(!state.done){\n      timing = Undetermined;\n      cancel = state.value._fork(rej, resolved);\n\n      if(timing !== Synchronous){\n        timing = Asynchronous;\n        return;\n      }\n    }\n\n    res(state.value);\n  }\n\n  drain();\n\n  return function Go$cancel(){ cancel(); };\n\n};\n\nGo.prototype.toString = function Go$toString(){\n  return 'Future.do(' + showf(this._generator) + ')';\n};\n\nfunction go(generator){\n  if(!isFunction(generator)) invalidArgument('Future.do', 0, 'be a Function', generator);\n  return new Go(generator);\n}\n\nfunction check$dispose(m, f, x){\n  if(!isFuture(m)) invalidFuture(\n    'Future.hook',\n    'the first function it\\'s given to return a Future',\n    m,\n    '\\n  From calling: ' + showf(f) + '\\n  With: ' + show(x)\n  );\n}\n\nfunction check$consume(m, f, x){\n  if(!isFuture(m)) invalidFuture(\n    'Future.hook',\n    'the second function it\\'s given to return a Future',\n    m,\n    '\\n  From calling: ' + showf(f) + '\\n  With: ' + show(x)\n  );\n}\n\nfunction Hook(acquire, dispose, consume){\n  this._acquire = acquire;\n  this._dispose = dispose;\n  this._consume = consume;\n}\n\nHook.prototype = Object.create(Core);\n\nHook.prototype._fork = function Hook$fork(rej, res){\n\n  var _acquire = this._acquire, _dispose = this._dispose, _consume = this._consume;\n  var cancel, cancelAcquire = noop, cancelConsume = noop, resource, value, cont = noop;\n\n  function Hook$done(){\n    cont(value);\n  }\n\n  function Hook$dispose(){\n    var disposal = _dispose(resource);\n    check$dispose(disposal, _dispose, resource);\n    cancel = disposal._fork(rej, Hook$done);\n    return cancel;\n  }\n\n  function Hook$cancelConsuption(){\n    cancelConsume();\n    Hook$dispose()();\n  }\n\n  function Hook$consumptionRejected(x){\n    cont = rej;\n    value = x;\n    Hook$dispose();\n  }\n\n  function Hook$consumptionResolved(x){\n    cont = res;\n    value = x;\n    Hook$dispose();\n  }\n\n  function Hook$acquireResolved(x){\n    resource = x;\n    var consumption = _consume(resource);\n    check$consume(consumption, _consume, resource);\n    cancel = Hook$cancelConsuption;\n    cancelConsume = consumption._fork(Hook$consumptionRejected, Hook$consumptionResolved);\n  }\n\n  cancelAcquire = _acquire._fork(rej, Hook$acquireResolved);\n\n  cancel = cancel || cancelAcquire;\n\n  return function Hook$fork$cancel(){ cancel(); };\n\n};\n\nHook.prototype.toString = function Hook$toString(){\n  return 'Future.hook('\n       + this._acquire.toString()\n       + ', '\n       + showf(this._dispose)\n       + ', '\n       + showf(this._consume)\n       + ')';\n};\n\nfunction hook$acquire$cleanup(acquire, cleanup, consume){\n  if(!isFunction(consume)) invalidArgument('Future.hook', 2, 'be a Future', consume);\n  return new Hook(acquire, cleanup, consume);\n}\n\nfunction hook$acquire(acquire, cleanup, consume){\n  if(!isFunction(cleanup)) invalidArgument('Future.hook', 1, 'be a function', cleanup);\n  if(arguments.length === 2) return partial2(hook$acquire$cleanup, acquire, cleanup);\n  return hook$acquire$cleanup(acquire, cleanup, consume);\n}\n\nfunction hook(acquire, cleanup, consume){\n  if(!isFuture(acquire)) invalidFuture('Future.hook', 0, acquire);\n  if(arguments.length === 1) return partial1(hook$acquire, acquire);\n  if(arguments.length === 2) return hook$acquire(acquire, cleanup);\n  return hook$acquire(acquire, cleanup, consume);\n}\n\nfunction Node(fn){\n  this._fn = fn;\n}\n\nNode.prototype = Object.create(Core);\n\nNode.prototype._fork = function Node$fork(rej, res){\n  var open = true;\n  this._fn(function Node$done(err, val){\n    if(open){\n      open = false;\n      err ? rej(err) : res(val);\n    }\n  });\n  return function Node$cancel(){ open = false; };\n};\n\nNode.prototype.toString = function Node$toString(){\n  return 'Future.node(' + showf(this._fn) + ')';\n};\n\nfunction node(f){\n  if(!isFunction(f)) invalidArgument('Future.node', 0, 'be a function', f);\n  return new Node(f);\n}\n\nfunction check$parallel(m, i){\n  return isFuture(m) ? m : invalidFuture(\n    'Future.parallel',\n    'its second argument to be an array of valid Futures. '\n  + 'The value at position ' + i + ' in the array is not a Future',\n    m\n  );\n}\n\nfunction Parallel(max, futures){\n  this._futures = futures;\n  this._length = futures.length;\n  this._max = Math.min(this._length, max);\n}\n\nParallel.prototype = Object.create(Core);\n\nParallel.prototype._fork = function Parallel$_fork(rej, res){\n\n  var _futures = this._futures, _length = this._length, _max = this._max;\n  var cancels = new Array(_length), out = new Array(_length);\n  var cursor = 0, running = 0, blocked = false;\n\n  function Parallel$cancel(){\n    for(var n = 0; n < _length; n++) cancels[n] && cancels[n]();\n  }\n\n  function Parallel$run(idx){\n    running++;\n    cancels[idx] = _futures[idx]._fork(function Parallel$rej(reason){\n      cancels[idx] = noop;\n      Parallel$cancel();\n      rej(reason);\n    }, function Parallel$res(value){\n      cancels[idx] = noop;\n      out[idx] = value;\n      running--;\n      if(cursor === _length && running === 0) res(out);\n      else if(blocked) Parallel$drain();\n    });\n  }\n\n  function Parallel$drain(){\n    blocked = false;\n    while(cursor < _length && running < _max) Parallel$run(cursor++);\n    blocked = true;\n  }\n\n  Parallel$drain();\n\n  return Parallel$cancel;\n\n};\n\nParallel.prototype.toString = function Parallel$toString(){\n  return 'Future.parallel(' + this._max + ', ' + show(this._futures) + ')';\n};\n\nvar emptyArray = new Resolved([]);\n\nfunction parallel$max(max, xs){\n  if(!isArray(xs)) invalidArgument('Future.parallel', 1, 'be an array', xs);\n  var futures = mapArray(xs, check$parallel);\n  return futures.length === 0 ? emptyArray : new Parallel(max, futures);\n}\n\nfunction parallel(max, xs){\n  if(!isUnsigned(max)) invalidArgument('Future.parallel', 0, 'be a positive integer', max);\n  if(arguments.length === 1) return partial1(parallel$max, max);\n  return parallel$max(max, xs);\n}\n\nfunction check$promise$3(p, f){\n  return isThenable(p) ? p : typeError(\n    'Future.tryP expects the function it\\'s given to return a Promise/Thenable'\n    + '\\n  Actual: ' + show(p) + '\\n  From calling: ' + showf(f)\n  );\n}\n\nfunction TryP(fn){\n  this._fn = fn;\n}\n\nTryP.prototype = Object.create(Core);\n\nTryP.prototype._fork = function TryP$fork(rej, res){\n  var open = true;\n  check$promise$3(this._fn(), this._fn).then(immediately(function TryP$res(x){\n    if(open){\n      open = false;\n      res(x);\n    }\n  }), immediately(function TryP$rej(x){\n    if(open){\n      open = false;\n      rej(x);\n    }\n  }));\n  return function TryP$cancel(){ open = false; };\n};\n\nTryP.prototype.toString = function TryP$toString(){\n  return 'Future.tryP(' + show(this._fn) + ')';\n};\n\nfunction tryP(f){\n  if(!isFunction(f)) invalidArgument('Future.tryP', 0, 'be a function', f);\n  return new TryP(f);\n}\n\nif(typeof Object.create !== 'function') error('Please polyfill Object.create to use Fluture');\nif(typeof Object.assign !== 'function') error('Please polyfill Object.assign to use Fluture');\nif(typeof Array.isArray !== 'function') error('Please polyfill Array.isArray to use Fluture');\n\nFuture.of = Future[FL.of] = of;\nFuture.chainRec = Future[FL.chainRec] = chainRec;\nFuture.reject = reject;\nFuture.ap = ap;\nFuture.map = map;\nFuture.bimap = bimap;\nFuture.chain = chain;\n\nvar Par = concurrify(Future, never, race, parallelAp);\nPar.of = Par[FL.of];\nPar.zero = Par[FL.zero];\nPar.map = map;\nPar.ap = ap;\nPar.alt = alt;\n\nfunction isParallel(x){\n  return x instanceof Par || type(x) === Par['@@type'];\n}\n\nfunction seq(par){\n  if(!isParallel(par)) invalidArgument('Future.seq', 0, 'to be a Par', par);\n  return par.sequential;\n}\n\n\n\n\nvar Fluture = Object.freeze({\n\tFuture: Future,\n\tdefault: Future,\n\tPar: Par,\n\tisParallel: isParallel,\n\tseq: seq,\n\tisFuture: isFuture,\n\treject: reject,\n\tof: of,\n\tnever: never,\n\tisNever: isNever,\n\tafter: after,\n\trejectAfter: rejectAfter,\n\tattempt: attempt,\n\ttry: attempt,\n\tcache: cache,\n\tencase: encase,\n\tencase2: encase2,\n\tencase3: encase3,\n\tencaseN: encaseN,\n\tencaseN2: encaseN2,\n\tencaseN3: encaseN3,\n\tencaseP: encaseP,\n\tencaseP2: encaseP2,\n\tencaseP3: encaseP3,\n\tgo: go,\n\tdo: go,\n\thook: hook,\n\tnode: node,\n\tparallel: parallel,\n\ttryP: tryP,\n\tap: ap,\n\talt: alt,\n\tmap: map,\n\tbimap: bimap,\n\tchain: chain,\n\tmapRej: mapRej,\n\tchainRej: chainRej,\n\tlastly: lastly,\n\tfinally: lastly,\n\tand: and,\n\tboth: both,\n\tor: or,\n\trace: race,\n\tswap: swap,\n\tfold: fold,\n\tdone: done,\n\tfork: fork,\n\tpromise: promise,\n\tvalue: value,\n\textractLeft: extractLeft,\n\textractRight: extractRight\n});\n\nvar index_cjs = Object.assign(Future, Fluture);\n\nreturn index_cjs;\n\n})));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mbHV0dXJlL2luZGV4LmpzPzQyNGMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ3NhbmN0dWFyeS10eXBlLWNsYXNzZXMnKSwgcmVxdWlyZSgnaW5zcGVjdC1mJyksIHJlcXVpcmUoJ3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzJyksIHJlcXVpcmUoJ2NvbmN1cnJpZnknKSwgcmVxdWlyZSgnZGVucXVlJykpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcycsICdpbnNwZWN0LWYnLCAnc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMnLCAnY29uY3VycmlmeScsICdkZW5xdWUnXSwgZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLkZsdXR1cmUgPSBmYWN0b3J5KGdsb2JhbC5zYW5jdHVhcnlUeXBlQ2xhc3NlcyxnbG9iYWwuaW5zcGVjdGYsZ2xvYmFsLnNhbmN0dWFyeVR5cGVJZGVudGlmaWVycyxnbG9iYWwuY29uY3VycmlmeSxnbG9iYWwuRGVucXVlKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoWixpbnNwZWN0Zix0eXBlLGNvbmN1cnJpZnksRGVucXVlKSB7ICd1c2Ugc3RyaWN0JztcblxuWiA9IFogJiYgWi5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpID8gWlsnZGVmYXVsdCddIDogWjtcbmluc3BlY3RmID0gaW5zcGVjdGYgJiYgaW5zcGVjdGYuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHQnKSA/IGluc3BlY3RmWydkZWZhdWx0J10gOiBpbnNwZWN0ZjtcbnR5cGUgPSB0eXBlICYmIHR5cGUuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHQnKSA/IHR5cGVbJ2RlZmF1bHQnXSA6IHR5cGU7XG5jb25jdXJyaWZ5ID0gY29uY3VycmlmeSAmJiBjb25jdXJyaWZ5Lmhhc093blByb3BlcnR5KCdkZWZhdWx0JykgPyBjb25jdXJyaWZ5WydkZWZhdWx0J10gOiBjb25jdXJyaWZ5O1xuRGVucXVlID0gRGVucXVlICYmIERlbnF1ZS5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpID8gRGVucXVlWydkZWZhdWx0J10gOiBEZW5xdWU7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlOiBlbnZpcm9ubWVudC1zcGVjaWZpYyAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZiAqL1xuY29uc3Qgc2NvcGUgPSB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgPyBzZWxmIDpcbiAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBnbG9iYWwgPT09ICdvYmplY3QnID8gZ2xvYmFsIDpcbiAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnID8gd2luZG93IDpcbiAgICAgICAgICAgICAgICAgICAgIHt9O1xuLyogZXNsaW50LWVuYWJsZSBuby11bmRlZiAqL1xuXG5jb25zdCBzZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2NvcGUuc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZS5zZXRJbW1lZGlhdGUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmLCB4KXsgcmV0dXJuIHNldFRpbWVvdXQoZiwgMCwgeCkgfTtcblxuZnVuY3Rpb24gbm9vcCgpe31cbmZ1bmN0aW9uIG1vb3AoKXsgcmV0dXJuIHRoaXMgfVxudmFyIHNob3cgPSBaLnRvU3RyaW5nO1xuZnVuY3Rpb24gcGFkZihzZiwgcyl7IHJldHVybiBzLnJlcGxhY2UoL14vZ20sIHNmKS5yZXBsYWNlKHNmLCAnJykgfVxuZnVuY3Rpb24gc2hvd2YoZil7IHJldHVybiBwYWRmKCcgICcsIGluc3BlY3RmKDIsIGYpKSB9XG5cbmZ1bmN0aW9uIG1hcEFycmF5KHhzLCBmKXtcbiAgdmFyIGwgPSB4cy5sZW5ndGgsIHlzID0gbmV3IEFycmF5KGwpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB5c1tpXSA9IGYoeHNbaV0sIGksIHhzKTtcbiAgcmV0dXJuIHlzO1xufVxuXG5mdW5jdGlvbiBwYXJ0aWFsMShmLCBhKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kMShiLCBjLCBkKXtcbiAgICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICBjYXNlIDE6IHJldHVybiBmKGEsIGIpO1xuICAgICAgY2FzZSAyOiByZXR1cm4gZihhLCBiLCBjKTtcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBmKGEsIGIsIGMsIGQpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFydGlhbDIoZiwgYSwgYil7XG4gIHJldHVybiBmdW5jdGlvbiBib3VuZDIoYywgZCl7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBmKGEsIGIsIGMpIDogZihhLCBiLCBjLCBkKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFydGlhbDMoZiwgYSwgYiwgYyl7XG4gIHJldHVybiBmdW5jdGlvbiBib3VuZDMoZCl7XG4gICAgcmV0dXJuIGYoYSwgYiwgYywgZCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGltbWVkaWF0ZWx5KGYpe1xuICByZXR1cm4gZnVuY3Rpb24gaW1tZWRpYXRlKHgpeyByZXR1cm4gc2V0SW1tZWRpYXRlKGYsIHgpIH07XG59XG5cbnZhciBGTCA9IHtcbiAgbWFwOiAnZmFudGFzeS1sYW5kL21hcCcsXG4gIGJpbWFwOiAnZmFudGFzeS1sYW5kL2JpbWFwJyxcbiAgY2hhaW46ICdmYW50YXN5LWxhbmQvY2hhaW4nLFxuICBjaGFpblJlYzogJ2ZhbnRhc3ktbGFuZC9jaGFpblJlYycsXG4gIGFwOiAnZmFudGFzeS1sYW5kL2FwJyxcbiAgb2Y6ICdmYW50YXN5LWxhbmQvb2YnLFxuICB6ZXJvOiAnZmFudGFzeS1sYW5kL3plcm8nXG59O1xuXG52YXIgb3JkaW5hbCA9IFsnZmlyc3QnLCAnc2Vjb25kJywgJ3RoaXJkJywgJ2ZvdXJ0aCcsICdmaWZ0aCddO1xuXG52YXIgbmFtZXNwYWNlID0gJ2ZsdXR1cmUnO1xudmFyIG5hbWUgPSAnRnV0dXJlJztcbnZhciB2ZXJzaW9uID0gMztcblxudmFyICQkdHlwZSA9IG5hbWVzcGFjZSArICcvJyArIG5hbWUgKyAnQCcgKyB2ZXJzaW9uO1xuXG5mdW5jdGlvbiBlcnJvcihtZXNzYWdlKXtcbiAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG5mdW5jdGlvbiB0eXBlRXJyb3IobWVzc2FnZSl7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRBcmd1bWVudChpdCwgYXQsIGV4cGVjdGVkLCBhY3R1YWwpe1xuICB0eXBlRXJyb3IoXG4gICAgaXQgKyAnIGV4cGVjdHMgaXRzICcgKyBvcmRpbmFsW2F0XSArICcgYXJndW1lbnQgdG8gJyArIGV4cGVjdGVkICsgJ1xcbiAgQWN0dWFsOiAnICsgc2hvdyhhY3R1YWwpXG4gICk7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRDb250ZXh0KGl0LCBhY3R1YWwpe1xuICB0eXBlRXJyb3IoXG4gICAgaXQgKyAnIHdhcyBpbnZva2VkIG91dHNpZGUgdGhlIGNvbnRleHQgb2YgYSBGdXR1cmUuIFlvdSBtaWdodCB3YW50IHRvIHVzZSdcbiAgKyAnIGEgZGlzcGF0Y2hlciBpbnN0ZWFkXFxuICBDYWxsZWQgb246ICcgKyAoc2hvdyhhY3R1YWwpKVxuICApO1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkTmFtZXNwYWNlKG0sIHgpe1xuICByZXR1cm4gKFxuICAgICdUaGUgRnV0dXJlIHdhcyBub3QgY3JlYXRlZCBieSAnICsgbmFtZXNwYWNlICsgJy4gJ1xuICArICdNYWtlIHN1cmUgeW91IHRyYW5zZm9ybSBvdGhlciBGdXR1cmVzIHRvICcgKyBuYW1lc3BhY2UgKyAnIEZ1dHVyZXMuICdcbiAgKyAnR290ICcgKyAoeCA/ICgnYSBGdXR1cmUgZnJvbSAnICsgeCkgOiAnYW4gdW5zY29wZWQgRnV0dXJlJykgKyAnLidcbiAgKyAnXFxuICBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mbHV0dXJlLWpzL0ZsdXR1cmUjY2FzdGluZy1mdXR1cmVzJ1xuICApO1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkVmVyc2lvbihtLCB4KXtcbiAgcmV0dXJuIChcbiAgICAnVGhlIEZ1dHVyZSB3YXMgY3JlYXRlZCBieSAnICsgKHggPCB2ZXJzaW9uID8gJ2FuIG9sZGVyJyA6ICdhIG5ld2VyJylcbiAgKyAnIHZlcnNpb24gb2YgJyArIG5hbWVzcGFjZSArICcuICdcbiAgKyAnVGhpcyBtZWFucyB0aGF0IG9uZSBvZiB0aGUgc291cmNlcyB3aGljaCBjcmVhdGVzIEZ1dHVyZXMgaXMgb3V0ZGF0ZWQuICdcbiAgKyAnVXBkYXRlIHRoaXMgc291cmNlLCBvciB0cmFuc2Zvcm0gaXRzIGNyZWF0ZWQgRnV0dXJlcyB0byBiZSBjb21wYXRpYmxlLidcbiAgKyAnXFxuICBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mbHV0dXJlLWpzL0ZsdXR1cmUjY2FzdGluZy1mdXR1cmVzJ1xuICApO1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkRnV0dXJlKGl0LCBhdCwgbSwgcyl7XG4gIHZhciBpZCA9IHR5cGUucGFyc2UodHlwZShtKSk7XG4gIHZhciBpbmZvID0gaWQubmFtZSA9PT0gbmFtZSA/ICdcXG4nICsgKFxuICAgIGlkLm5hbWVzcGFjZSAhPT0gbmFtZXNwYWNlID8gaW52YWxpZE5hbWVzcGFjZShtLCBpZC5uYW1lc3BhY2UpXG4gIDogaWQudmVyc2lvbiAhPT0gdmVyc2lvbiA/IGludmFsaWRWZXJzaW9uKG0sIGlkLnZlcnNpb24pXG4gIDogJ05vdGhpbmcgc2VlbXMgd3JvbmcuIENvbnRhY3QgdGhlIEZsdXR1cmUgbWFpbnRhaW5lcnMuJykgOiAnJztcbiAgdHlwZUVycm9yKFxuICAgIGl0ICsgJyBleHBlY3RzICcgKyAob3JkaW5hbFthdF0gPyAnaXRzICcgKyBvcmRpbmFsW2F0XSArICcgYXJndW1lbnQgdG8gYmUgYSB2YWxpZCBGdXR1cmUnIDogYXQpXG4gICsgJy4nICsgaW5mbyArICdcXG4gIEFjdHVhbDogJyArIChzaG93KG0pKSArICcgOjogJyArIChpZC5uYW1lKSArIChzIHx8ICcnKVxuICApO1xufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGYpe1xuICByZXR1cm4gdHlwZW9mIGYgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzVGhlbmFibGUobSl7XG4gIHJldHVybiBtIGluc3RhbmNlb2YgUHJvbWlzZSB8fCBCb29sZWFuKG0pICYmIGlzRnVuY3Rpb24obS50aGVuKTtcbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuKGYpe1xuICByZXR1cm4gdHlwZW9mIGYgPT09ICdib29sZWFuJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoZil7XG4gIHJldHVybiB0eXBlb2YgZiA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzVW5zaWduZWQobil7XG4gIHJldHVybiAobiA9PT0gSW5maW5pdHkgfHwgaXNOdW1iZXIobikgJiYgbiA+IDAgJiYgbiAlIDEgPT09IDApO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChvKXtcbiAgcmV0dXJuIG8gIT09IG51bGwgJiYgdHlwZW9mIG8gPT09ICdvYmplY3QnO1xufVxuXG5mdW5jdGlvbiBpc0l0ZXJhdG9yKGkpe1xuICByZXR1cm4gaXNPYmplY3QoaSkgJiYgaXNGdW5jdGlvbihpLm5leHQpO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KHgpe1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh4KTtcbn1cblxuLyplc2xpbnQgbm8tY29uZC1hc3NpZ246MCwgbm8tY29uc3RhbnQtY29uZGl0aW9uOjAgKi9cblxuZnVuY3Rpb24gaW50ZXJwcmV0ZXIocmVqLCByZXMpe1xuXG4gIC8vVGhpcyBpcyB0aGUgcHJpbWFyeSBxdWV1ZSBvZiBhY3Rpb25zLiBBbGwgYWN0aW9ucyBpbiBoZXJlIHdpbGwgYmUgXCJjb2xkXCIsXG4gIC8vbWVhbmluZyB0aGV5IGhhdmVuJ3QgaGFkIHRoZSBjaGFuY2UgeWV0IHRvIHJ1biBjb25jdXJyZW50IGNvbXB1dGF0aW9ucy5cbiAgdmFyIGNvbGQgPSBuZXcgRGVucXVlKHRoaXMuX2FjdGlvbnMuc2l6ZSk7XG5cbiAgLy9UaGlzIGlzIHRoZSBzZWNvbmRhcnkgcXVldWUgb2YgYWN0aW9ucy4gQWxsIGFjdGlvbnMgaW4gaGVyZSB3aWxsIGJlIFwiaG90XCIsXG4gIC8vbWVhbmluZyB0aGV5IGhhdmUgYWxyZWFkeSBoYWQgYSBjaGFuY2UgdG8gcnVuIGEgY29uY3VycmVudCBjb21wdXRhdGlvbi5cbiAgdmFyIHF1ZXVlID0gbmV3IERlbnF1ZSh0aGlzLl9hY3Rpb25zLnNpemUpO1xuXG4gIC8vVGhlc2UgY29tYmluZWQgdmFyaWFibGVzIGRlZmluZSBvdXIgY3VycmVudCBzdGF0ZS5cbiAgLy8gZnV0dXJlICA9IHRoZSBmdXR1cmUgd2UgYXJlIGN1cnJlbnRseSBmb3JraW5nXG4gIC8vIGFjdGlvbiAgPSB0aGUgYWN0aW9uIHRvIGJlIGluZm9ybWVkIHdoZW4gdGhlIGZ1dHVyZSBzZXR0bGVzXG4gIC8vIGNhbmNlbCAgPSB0aGUgY2FuY2VsIGZ1bmN0aW9uIG9mIHRoZSBjdXJyZW50IGZ1dHVyZVxuICAvLyBzZXR0bGVkID0gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhIG5ldyB0aWNrIHNob3VsZCBzdGFydFxuICAvLyBhc3luYyAgID0gYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB3ZSBhcmUgYXdhaXRpbmcgYSByZXN1bHQgYXN5bmNocm9ub3VzbHlcbiAgdmFyIGZ1dHVyZSwgYWN0aW9uLCBjYW5jZWwgPSBub29wLCBzZXR0bGVkLCBhc3luYyA9IHRydWUsIGl0O1xuXG4gIC8vVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhIGZ1dHVyZSB0byB1c2UgaW4gdGhlIG5leHQgdGljay5cbiAgLy9IZXJlIHdlIFwiZmxhdHRlblwiIHRoZSBhY3Rpb25zIG9mIGFub3RoZXIgU2VxdWVuY2UgaW50byBvdXIgb3duIGFjdGlvbnMsXG4gIC8vdGhpcyBpcyB0aGUgbWFnaWMgdGhhdCBhbGxvd3MgZm9yIGluZmluaXRlbHkgc3RhY2sgc2FmZSByZWN1cnNpb24gYmVjYXVzZVxuICAvL2FjdGlvbnMgbGlrZSBDaGFpbkFjdGlvbiB3aWxsIHJldHVybiBhIG5ldyBTZXF1ZW5jZS5cbiAgLy9JZiB3ZSBzZXR0bGVkIGFzeW5jaHJvbm91c2x5LCB3ZSBjYWxsIGRyYWluKCkgZGlyZWN0bHkgdG8gcnVuIHRoZSBuZXh0IHRpY2suXG4gIGZ1bmN0aW9uIHNldHRsZShtKXtcbiAgICBzZXR0bGVkID0gdHJ1ZTtcbiAgICBmdXR1cmUgPSBtO1xuXG4gICAgaWYoZnV0dXJlLl9zcGF3bil7XG4gICAgICB2YXIgdGFpbCA9IGZ1dHVyZS5fYWN0aW9ucztcblxuICAgICAgd2hpbGUoIXRhaWwuaXNFbXB0eSl7XG4gICAgICAgIGNvbGQudW5zaGlmdCh0YWlsLmhlYWQpO1xuICAgICAgICB0YWlsID0gdGFpbC50YWlsO1xuICAgICAgfVxuXG4gICAgICBmdXR1cmUgPSBmdXR1cmUuX3NwYXduO1xuICAgIH1cblxuICAgIGlmKGFzeW5jKSBkcmFpbigpO1xuICB9XG5cbiAgLy9UaGlzIGZ1bmN0aW9uIHNlcnZlcyBhcyBhIHJlamVjdGlvbiBoYW5kbGVyIGZvciBvdXIgY3VycmVudCBmdXR1cmUuXG4gIC8vSXQgd2lsbCB0ZWxsIHRoZSBjdXJyZW50IGFjdGlvbiB0aGF0IHRoZSBmdXR1cmUgcmVqZWN0ZWQsIGFuZCBpdCB3aWxsXG4gIC8vc2V0dGxlIHRoZSBjdXJyZW50IHRpY2sgd2l0aCB0aGUgYWN0aW9uJ3MgYW5zd2VyIHRvIHRoYXQuXG4gIGZ1bmN0aW9uIHJlamVjdGVkKHgpe1xuICAgIHNldHRsZShhY3Rpb24ucmVqZWN0ZWQoeCkpO1xuICB9XG5cbiAgLy9UaGlzIGZ1bmN0aW9uIHNlcnZlcyBhcyBhIHJlc29sdXRpb24gaGFuZGxlciBmb3Igb3VyIGN1cnJlbnQgZnV0dXJlLlxuICAvL0l0IHdpbGwgdGVsbCB0aGUgY3VycmVudCBhY3Rpb24gdGhhdCB0aGUgZnV0dXJlIHJlc29sdmVkLCBhbmQgaXQgd2lsbFxuICAvL3NldHRsZSB0aGUgY3VycmVudCB0aWNrIHdpdGggdGhlIGFjdGlvbidzIGFuc3dlciB0byB0aGF0LlxuICBmdW5jdGlvbiByZXNvbHZlZCh4KXtcbiAgICBzZXR0bGUoYWN0aW9uLnJlc29sdmVkKHgpKTtcbiAgfVxuXG4gIC8vVGhpcyBmdW5jdGlvbiBpcyBwYXNzZWQgaW50byBhY3Rpb25zIHdoZW4gdGhleSBhcmUgXCJ3YXJtZWQgdXBcIi5cbiAgLy9JZiB0aGUgYWN0aW9uIGRlY2lkZXMgdGhhdCBpdCBoYXMgaXRzIHJlc3VsdCwgd2l0aG91dCB0aGUgbmVlZCB0byBhd2FpdFxuICAvL2FueXRoaW5nIGVsc2UsIHRoZW4gaXQgY2FuIGNhbGwgdGhpcyBmdW5jdGlvbiB0byBmb3JjZSBcImVhcmx5IHRlcm1pbmF0aW9uXCIuXG4gIC8vV2hlbiBlYXJseSB0ZXJtaW5hdGlvbiBvY2N1cnMsIGFsbCBhY3Rpb25zIHdoaWNoIHdlcmUgcXVldWVkIHByaW9yIHRvIHRoZVxuICAvL3Rlcm1pbmF0b3Igd2lsbCBiZSBza2lwcGVkLiBJZiB0aGV5IHdlcmUgYWxyZWFkeSBob3QsIHRoZXkgd2lsbCBhbHNvIHJlY2VpdmVcbiAgLy9hIGNhbmNlbCBzaWduYWwgc28gdGhleSBjYW4gY2FuY2VsIHRoZWlyIG93biBjb25jdXJyZW50IGNvbXB1dGF0aW9ucywgYXNcbiAgLy90aGVpciByZXN1bHRzIGFyZSBubyBsb25nZXIgbmVlZGVkLlxuICBmdW5jdGlvbiBlYXJseShtLCB0ZXJtaW5hdG9yKXtcbiAgICBjYW5jZWwoKTtcbiAgICBjb2xkLmNsZWFyKCk7XG5cbiAgICBpZihhc3luYyAmJiBhY3Rpb24gIT09IHRlcm1pbmF0b3Ipe1xuICAgICAgYWN0aW9uLmNhbmNlbCgpO1xuICAgICAgd2hpbGUoKGl0ID0gcXVldWUuc2hpZnQoKSkgJiYgaXQgIT09IHRlcm1pbmF0b3IpIGl0LmNhbmNlbCgpO1xuICAgIH1cblxuICAgIHNldHRsZShtKTtcbiAgfVxuXG4gIC8vVGhpcyBmdW5jdGlvbiBzZXJ2ZXMgdG8ga2lja3N0YXJ0IGNvbmN1cnJlbnQgY29tcHV0YXRpb25zLlxuICAvL1Rha2VzIGFsbCBhY3Rpb25zIGZyb20gdGhlIGNvbGQgcXVldWUgKmJhY2stdG8tZnJvbnQqLCBhbmQgY2FsbHMgcnVuKCkgb25cbiAgLy9lYWNoIG9mIHRoZW0sIHBhc3NpbmcgdGhlbSB0aGUgXCJlYXJseVwiIGZ1bmN0aW9uLiBJZiBhbnkgb2YgdGhlbSBzZXR0bGVzIChieVxuICAvL2NhbGxpbmcgZWFybHkoKSksIHdlIGFib3J0LiBBZnRlciB3YXJtaW5nIHVwIGFsbCBhY3Rpb25zIGluIHRoZSBjb2xkIHF1ZXVlLFxuICAvL3dlIHdhcm0gdXAgdGhlIGN1cnJlbnQgYWN0aW9uIGFzIHdlbGwuXG4gIGZ1bmN0aW9uIHdhcm11cEFjdGlvbnMoKXtcbiAgICB3aGlsZShpdCA9IGNvbGQucG9wKCkpe1xuICAgICAgaXQgPSBpdC5ydW4oZWFybHkpO1xuICAgICAgaWYoc2V0dGxlZCkgcmV0dXJuO1xuICAgICAgcXVldWUudW5zaGlmdChpdCk7XG4gICAgfVxuXG4gICAgYWN0aW9uID0gYWN0aW9uLnJ1bihlYXJseSk7XG4gIH1cblxuICAvL1RoaXMgZnVuY3Rpb24gcmVwcmVzZW50cyBvdXIgbWFpbiBleGVjdXRpb24gbG9vcC5cbiAgLy9XaGVuIHdlIHJlZmVyIHRvIGEgXCJ0aWNrXCIsIHdlIG1lYW4gdGhlIGV4ZWN1dGlvbiBvZiB0aGUgYm9keSBpbnNpZGUgdGhlXG4gIC8vcHJpbWFyeSB3aGlsZS1sb29wIG9mIHRoaXMgZnVuY3Rpb24uXG4gIC8vRXZlcnkgdGljayBmb2xsb3dzIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICAvLyAxLiBXZSB0cnkgdG8gdGFrZSBhbiBhY3Rpb24gZnJvbSB0aGUgY29sZCBxdWV1ZSwgaWYgd2UgZmFpbCwgZ28gdG8gc3RlcCAyLlxuICAvLyAgICAgIDFhLiBXZSBmb3JrIHRoZSBmdXR1cmUuXG4gIC8vICAgICAgMWIuIFdlIHdhcm11cEFjdGlvbnMoKSBpZiB0aGUgd2UgaGF2ZW4ndCBzZXR0bGVkIHlldC5cbiAgLy8gMi4gV2UgdHJ5IHRvIHRha2UgYW4gYWN0aW9uIGZyb20gdGhlIGhvdCBxdWV1ZSwgaWYgd2UgZmFpbCwgZ28gdG8gc3RlcCAzLlxuICAvLyAgICAgIDJhLiBXZSBmb3JrIHRoZSBGdXR1cmUsIGlmIHNldHRsZXMsIHdlIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHRpY2suXG4gIC8vIDMuIElmIHdlIGNvdWxkbid0IHRha2UgYWN0aW9ucyBmcm9tIGVpdGhlciBxdWV1ZXMsIHdlIGZvcmsgdGhlIEZ1dHVyZSBpbnRvXG4gIC8vICAgIHRoZSB1c2VyIHByb3ZpZGVkIGNvbnRpbnVhdGlvbnMuIFRoaXMgaXMgdGhlIGVuZCBvZiB0aGUgaW50ZXJwcmV0YXRpb24uXG4gIC8vIDQuIElmIHdlIGRpZCB0YWtlIGFuIGFjdGlvbiBmcm9tIG9uZSBvZiBxdWV1ZXMsIGJ1dCBub25lIG9mIHRoZSBzdGVwc1xuICAvLyAgICBjYXVzZWQgYSBzZXR0bGUoKSwgaXQgbWVhbnMgd2UgYXJlIGFzeW5jaHJvbm91c2x5IHdhaXRpbmcgZm9yIHNvbWV0aGluZ1xuICAvLyAgICB0byBzZXR0bGUgYW5kIHN0YXJ0IHRoZSBuZXh0IHRpY2ssIHNvIHdlIHJldHVybiBmcm9tIHRoZSBmdW5jdGlvbi5cbiAgZnVuY3Rpb24gZHJhaW4oKXtcbiAgICBhc3luYyA9IGZhbHNlO1xuXG4gICAgd2hpbGUodHJ1ZSl7XG4gICAgICBzZXR0bGVkID0gZmFsc2U7XG4gICAgICBpZihhY3Rpb24gPSBjb2xkLnNoaWZ0KCkpe1xuICAgICAgICBjYW5jZWwgPSBmdXR1cmUuX2ZvcmsocmVqZWN0ZWQsIHJlc29sdmVkKTtcbiAgICAgICAgaWYoIXNldHRsZWQpIHdhcm11cEFjdGlvbnMoKTtcbiAgICAgIH1lbHNlIGlmKGFjdGlvbiA9IHF1ZXVlLnNoaWZ0KCkpe1xuICAgICAgICBjYW5jZWwgPSBmdXR1cmUuX2ZvcmsocmVqZWN0ZWQsIHJlc29sdmVkKTtcbiAgICAgIH1lbHNlIGJyZWFrO1xuICAgICAgaWYoc2V0dGxlZCkgY29udGludWU7XG4gICAgICBhc3luYyA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FuY2VsID0gZnV0dXJlLl9mb3JrKHJlaiwgcmVzKTtcbiAgfVxuXG4gIC8vU3RhcnQgdGhlIGV4ZWN1dGlvbiBsb29wLlxuICBzZXR0bGUodGhpcyk7XG5cbiAgLy9SZXR1cm4gYSBjYW5jZWxsYXRpb24gZnVuY3Rpb24uIEl0IHdpbGwgY2FuY2VsIHRoZSBjdXJyZW50IEZ1dHVyZSwgdGhlXG4gIC8vY3VycmVudCBhY3Rpb24sIGFuZCBhbGwgcXVldWVkIGhvdCBhY3Rpb25zLlxuICByZXR1cm4gZnVuY3Rpb24gU2VxdWVuY2UkY2FuY2VsKCl7XG4gICAgY2FuY2VsKCk7XG4gICAgYWN0aW9uICYmIGFjdGlvbi5jYW5jZWwoKTtcbiAgICB3aGlsZShpdCA9IHF1ZXVlLnNoaWZ0KCkpIGl0LmNhbmNlbCgpO1xuICB9O1xuXG59XG5cbnZhciBlbXB0eSA9ICh7aXNFbXB0eTogdHJ1ZSwgc2l6ZTogMCwgaGVhZDogbnVsbCwgdGFpbDogbnVsbH0pO1xuXG5mdW5jdGlvbiBjb25zKGhlYWQsIHRhaWwpe1xuICByZXR1cm4ge2lzRW1wdHk6IGZhbHNlLCBzaXplOiB0YWlsLnNpemUgKyAxLCBoZWFkOiBoZWFkLCB0YWlsOiB0YWlsfTtcbn1cblxuZnVuY3Rpb24gdGhyb3dSZWplY3Rpb24oeCl7XG4gIGVycm9yKCdGdXR1cmUjdmFsdWUgd2FzIGNhbGxlZCBvbiBhIHJlamVjdGVkIEZ1dHVyZVxcbiAgQWN0dWFsOiBGdXR1cmUucmVqZWN0KCcgKyBzaG93KHgpICsgJyknKTtcbn1cblxuZnVuY3Rpb24gRnV0dXJlKGNvbXB1dGF0aW9uKXtcbiAgaWYoIWlzRnVuY3Rpb24oY29tcHV0YXRpb24pKSBpbnZhbGlkQXJndW1lbnQoJ0Z1dHVyZScsIDAsICdiZSBhIEZ1bmN0aW9uJywgY29tcHV0YXRpb24pO1xuICByZXR1cm4gbmV3IENvbXB1dGF0aW9uKGNvbXB1dGF0aW9uKTtcbn1cblxuZnVuY3Rpb24gaXNGdXR1cmUoeCl7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgRnV0dXJlIHx8IHR5cGUoeCkgPT09ICQkdHlwZTtcbn1cblxuRnV0dXJlWydAQHR5cGUnXSA9ICQkdHlwZTtcblxuRnV0dXJlLnByb3RvdHlwZVtGTC5hcF0gPSBmdW5jdGlvbiBGdXR1cmUkRkwkYXAob3RoZXIpe1xuICByZXR1cm4gb3RoZXIuX2FwKHRoaXMpO1xufTtcblxuRnV0dXJlLnByb3RvdHlwZVtGTC5tYXBdID0gZnVuY3Rpb24gRnV0dXJlJEZMJG1hcChtYXBwZXIpe1xuICByZXR1cm4gdGhpcy5fbWFwKG1hcHBlcik7XG59O1xuXG5GdXR1cmUucHJvdG90eXBlW0ZMLmJpbWFwXSA9IGZ1bmN0aW9uIEZ1dHVyZSRGTCRiaW1hcChsbWFwcGVyLCBybWFwcGVyKXtcbiAgcmV0dXJuIHRoaXMuX2JpbWFwKGxtYXBwZXIsIHJtYXBwZXIpO1xufTtcblxuRnV0dXJlLnByb3RvdHlwZVtGTC5jaGFpbl0gPSBmdW5jdGlvbiBGdXR1cmUkRkwkY2hhaW4obWFwcGVyKXtcbiAgcmV0dXJuIHRoaXMuX2NoYWluKG1hcHBlcik7XG59O1xuXG5GdXR1cmUucHJvdG90eXBlLmFwID0gZnVuY3Rpb24gRnV0dXJlJGFwKG90aGVyKXtcbiAgaWYoIWlzRnV0dXJlKHRoaXMpKSBpbnZhbGlkQ29udGV4dCgnRnV0dXJlI2FwJywgdGhpcyk7XG4gIGlmKCFpc0Z1dHVyZShvdGhlcikpIGludmFsaWRGdXR1cmUoJ0Z1dHVyZSNhcCcsIDAsIG90aGVyKTtcbiAgcmV0dXJuIHRoaXMuX2FwKG90aGVyKTtcbn07XG5cbkZ1dHVyZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gRnV0dXJlJG1hcChtYXBwZXIpe1xuICBpZighaXNGdXR1cmUodGhpcykpIGludmFsaWRDb250ZXh0KCdGdXR1cmUjbWFwJywgdGhpcyk7XG4gIGlmKCFpc0Z1bmN0aW9uKG1hcHBlcikpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlI21hcCcsIDAsICd0byBiZSBhIEZ1bmN0aW9uJywgbWFwcGVyKTtcbiAgcmV0dXJuIHRoaXMuX21hcChtYXBwZXIpO1xufTtcblxuRnV0dXJlLnByb3RvdHlwZS5iaW1hcCA9IGZ1bmN0aW9uIEZ1dHVyZSRiaW1hcChsbWFwcGVyLCBybWFwcGVyKXtcbiAgaWYoIWlzRnV0dXJlKHRoaXMpKSBpbnZhbGlkQ29udGV4dCgnRnV0dXJlI2JpbWFwJywgdGhpcyk7XG4gIGlmKCFpc0Z1bmN0aW9uKGxtYXBwZXIpKSBpbnZhbGlkQXJndW1lbnQoJ0Z1dHVyZSNiaW1hcCcsIDAsICd0byBiZSBhIEZ1bmN0aW9uJywgbG1hcHBlcik7XG4gIGlmKCFpc0Z1bmN0aW9uKHJtYXBwZXIpKSBpbnZhbGlkQXJndW1lbnQoJ0Z1dHVyZSNiaW1hcCcsIDEsICd0byBiZSBhIEZ1bmN0aW9uJywgcm1hcHBlcik7XG4gIHJldHVybiB0aGlzLl9iaW1hcChsbWFwcGVyLCBybWFwcGVyKTtcbn07XG5cbkZ1dHVyZS5wcm90b3R5cGUuY2hhaW4gPSBmdW5jdGlvbiBGdXR1cmUkY2hhaW4obWFwcGVyKXtcbiAgaWYoIWlzRnV0dXJlKHRoaXMpKSBpbnZhbGlkQ29udGV4dCgnRnV0dXJlI2NoYWluJywgdGhpcyk7XG4gIGlmKCFpc0Z1bmN0aW9uKG1hcHBlcikpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlI2NoYWluJywgMCwgJ3RvIGJlIGEgRnVuY3Rpb24nLCBtYXBwZXIpO1xuICByZXR1cm4gdGhpcy5fY2hhaW4obWFwcGVyKTtcbn07XG5cbkZ1dHVyZS5wcm90b3R5cGUubWFwUmVqID0gZnVuY3Rpb24gRnV0dXJlJG1hcFJlaihtYXBwZXIpe1xuICBpZighaXNGdXR1cmUodGhpcykpIGludmFsaWRDb250ZXh0KCdGdXR1cmUjbWFwUmVqJywgdGhpcyk7XG4gIGlmKCFpc0Z1bmN0aW9uKG1hcHBlcikpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlI21hcFJlaicsIDAsICd0byBiZSBhIEZ1bmN0aW9uJywgbWFwcGVyKTtcbiAgcmV0dXJuIHRoaXMuX21hcFJlaihtYXBwZXIpO1xufTtcblxuRnV0dXJlLnByb3RvdHlwZS5jaGFpblJlaiA9IGZ1bmN0aW9uIEZ1dHVyZSRjaGFpblJlaihtYXBwZXIpe1xuICBpZighaXNGdXR1cmUodGhpcykpIGludmFsaWRDb250ZXh0KCdGdXR1cmUjY2hhaW5SZWonLCB0aGlzKTtcbiAgaWYoIWlzRnVuY3Rpb24obWFwcGVyKSkgaW52YWxpZEFyZ3VtZW50KCdGdXR1cmUjY2hhaW5SZWonLCAwLCAndG8gYmUgYSBGdW5jdGlvbicsIG1hcHBlcik7XG4gIHJldHVybiB0aGlzLl9jaGFpblJlaihtYXBwZXIpO1xufTtcblxuRnV0dXJlLnByb3RvdHlwZS5yYWNlID0gZnVuY3Rpb24gRnV0dXJlJHJhY2Uob3RoZXIpe1xuICBpZighaXNGdXR1cmUodGhpcykpIGludmFsaWRDb250ZXh0KCdGdXR1cmUjcmFjZScsIHRoaXMpO1xuICBpZighaXNGdXR1cmUob3RoZXIpKSBpbnZhbGlkRnV0dXJlKCdGdXR1cmUjcmFjZScsIDAsIG90aGVyKTtcbiAgcmV0dXJuIHRoaXMuX3JhY2Uob3RoZXIpO1xufTtcblxuRnV0dXJlLnByb3RvdHlwZS5ib3RoID0gZnVuY3Rpb24gRnV0dXJlJGJvdGgob3RoZXIpe1xuICBpZighaXNGdXR1cmUodGhpcykpIGludmFsaWRDb250ZXh0KCdGdXR1cmUjYm90aCcsIHRoaXMpO1xuICBpZighaXNGdXR1cmUob3RoZXIpKSBpbnZhbGlkRnV0dXJlKCdGdXR1cmUjYm90aCcsIDAsIG90aGVyKTtcbiAgcmV0dXJuIHRoaXMuX2JvdGgob3RoZXIpO1xufTtcblxuRnV0dXJlLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBGdXR1cmUkYW5kKG90aGVyKXtcbiAgaWYoIWlzRnV0dXJlKHRoaXMpKSBpbnZhbGlkQ29udGV4dCgnRnV0dXJlI2FuZCcsIHRoaXMpO1xuICBpZighaXNGdXR1cmUob3RoZXIpKSBpbnZhbGlkRnV0dXJlKCdGdXR1cmUjYW5kJywgMCwgb3RoZXIpO1xuICByZXR1cm4gdGhpcy5fYW5kKG90aGVyKTtcbn07XG5cbkZ1dHVyZS5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBGdXR1cmUkb3Iob3RoZXIpe1xuICBpZighaXNGdXR1cmUodGhpcykpIGludmFsaWRDb250ZXh0KCdGdXR1cmUjb3InLCB0aGlzKTtcbiAgaWYoIWlzRnV0dXJlKG90aGVyKSkgaW52YWxpZEZ1dHVyZSgnRnV0dXJlI29yJywgMCwgb3RoZXIpO1xuICByZXR1cm4gdGhpcy5fb3Iob3RoZXIpO1xufTtcblxuRnV0dXJlLnByb3RvdHlwZS5zd2FwID0gZnVuY3Rpb24gRnV0dXJlJHN3YXAoKXtcbiAgaWYoIWlzRnV0dXJlKHRoaXMpKSBpbnZhbGlkQ29udGV4dCgnRnV0dXJlI2FwJywgdGhpcyk7XG4gIHJldHVybiB0aGlzLl9zd2FwKCk7XG59O1xuXG5GdXR1cmUucHJvdG90eXBlLmZvbGQgPSBmdW5jdGlvbiBGdXR1cmUkZm9sZChsbWFwcGVyLCBybWFwcGVyKXtcbiAgaWYoIWlzRnV0dXJlKHRoaXMpKSBpbnZhbGlkQ29udGV4dCgnRnV0dXJlI2FwJywgdGhpcyk7XG4gIGlmKCFpc0Z1bmN0aW9uKGxtYXBwZXIpKSBpbnZhbGlkQXJndW1lbnQoJ0Z1dHVyZSNmb2xkJywgMCwgJ3RvIGJlIGEgRnVuY3Rpb24nLCBsbWFwcGVyKTtcbiAgaWYoIWlzRnVuY3Rpb24ocm1hcHBlcikpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlI2ZvbGQnLCAxLCAndG8gYmUgYSBGdW5jdGlvbicsIHJtYXBwZXIpO1xuICByZXR1cm4gdGhpcy5fZm9sZChsbWFwcGVyLCBybWFwcGVyKTtcbn07XG5cbkZ1dHVyZS5wcm90b3R5cGUuZmluYWxseSA9IGZ1bmN0aW9uIEZ1dHVyZSRmaW5hbGx5KG90aGVyKXtcbiAgaWYoIWlzRnV0dXJlKHRoaXMpKSBpbnZhbGlkQ29udGV4dCgnRnV0dXJlI2ZpbmFsbHknLCB0aGlzKTtcbiAgaWYoIWlzRnV0dXJlKG90aGVyKSkgaW52YWxpZEZ1dHVyZSgnRnV0dXJlI2ZpbmFsbHknLCAwLCBvdGhlcik7XG4gIHJldHVybiB0aGlzLl9maW5hbGx5KG90aGVyKTtcbn07XG5cbkZ1dHVyZS5wcm90b3R5cGUubGFzdGx5ID0gZnVuY3Rpb24gRnV0dXJlJGxhc3RseShvdGhlcil7XG4gIGlmKCFpc0Z1dHVyZSh0aGlzKSkgaW52YWxpZENvbnRleHQoJ0Z1dHVyZSNsYXN0bHknLCB0aGlzKTtcbiAgaWYoIWlzRnV0dXJlKG90aGVyKSkgaW52YWxpZEZ1dHVyZSgnRnV0dXJlI2xhc3RseScsIDAsIG90aGVyKTtcbiAgcmV0dXJuIHRoaXMuX2ZpbmFsbHkob3RoZXIpO1xufTtcblxuRnV0dXJlLnByb3RvdHlwZS5mb3JrID0gZnVuY3Rpb24gRnV0dXJlJGZvcmsocmVqLCByZXMpe1xuICBpZighaXNGdXR1cmUodGhpcykpIGludmFsaWRDb250ZXh0KCdGdXR1cmUjZm9yaycsIHRoaXMpO1xuICBpZighaXNGdW5jdGlvbihyZWopKSBpbnZhbGlkQXJndW1lbnQoJ0Z1dHVyZSNmb3JrJywgMCwgJ3RvIGJlIGEgRnVuY3Rpb24nLCByZWopO1xuICBpZighaXNGdW5jdGlvbihyZXMpKSBpbnZhbGlkQXJndW1lbnQoJ0Z1dHVyZSNmb3JrJywgMCwgJ3RvIGJlIGEgRnVuY3Rpb24nLCByZXMpO1xuICByZXR1cm4gdGhpcy5fZm9yayhyZWosIHJlcyk7XG59O1xuXG5GdXR1cmUucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gRnV0dXJlJHZhbHVlKHJlcyl7XG4gIGlmKCFpc0Z1dHVyZSh0aGlzKSkgaW52YWxpZENvbnRleHQoJ0Z1dHVyZSN2YWx1ZScsIHRoaXMpO1xuICBpZighaXNGdW5jdGlvbihyZXMpKSBpbnZhbGlkQXJndW1lbnQoJ0Z1dHVyZSN2YWx1ZScsIDAsICd0byBiZSBhIEZ1bmN0aW9uJywgcmVzKTtcbiAgcmV0dXJuIHRoaXMuX2ZvcmsodGhyb3dSZWplY3Rpb24sIHJlcyk7XG59O1xuXG5GdXR1cmUucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiBGdXR1cmUkZG9uZShjYWxsYmFjayl7XG4gIGlmKCFpc0Z1dHVyZSh0aGlzKSkgaW52YWxpZENvbnRleHQoJ0Z1dHVyZSNkb25lJywgdGhpcyk7XG4gIGlmKCFpc0Z1bmN0aW9uKGNhbGxiYWNrKSkgaW52YWxpZEFyZ3VtZW50KCdGdXR1cmUjZG9uZScsIDAsICd0byBiZSBhIEZ1bmN0aW9uJywgY2FsbGJhY2spO1xuICByZXR1cm4gdGhpcy5fZm9yayhmdW5jdGlvbiBGdXR1cmUkZG9uZSRyZWooeCl7IGNhbGxiYWNrKHgpOyB9LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBGdXR1cmUkZG9uZSRyZXMoeCl7IGNhbGxiYWNrKG51bGwsIHgpOyB9KTtcbn07XG5cbkZ1dHVyZS5wcm90b3R5cGUucHJvbWlzZSA9IGZ1bmN0aW9uIEZ1dHVyZSRwcm9taXNlKCl7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBGdXR1cmUkcHJvbWlzZSRjb21wdXRhdGlvbihyZXMsIHJlail7XG4gICAgX3RoaXMuX2ZvcmsocmVqLCByZXMpO1xuICB9KTtcbn07XG5cbkZ1dHVyZS5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uIEZ1dHVyZSRpc1JlamVjdGVkKCl7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbkZ1dHVyZS5wcm90b3R5cGUuaXNSZXNvbHZlZCA9IGZ1bmN0aW9uIEZ1dHVyZSRpc1Jlc29sdmVkKCl7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbkZ1dHVyZS5wcm90b3R5cGUuaXNTZXR0bGVkID0gZnVuY3Rpb24gRnV0dXJlJGlzU2V0dGxlZCgpe1xuICByZXR1cm4gdGhpcy5pc1JlamVjdGVkKCkgfHwgdGhpcy5pc1Jlc29sdmVkKCk7XG59O1xuXG5GdXR1cmUucHJvdG90eXBlLmV4dHJhY3RMZWZ0ID0gZnVuY3Rpb24gRnV0dXJlJGV4dHJhY3RMZWZ0KCl7XG4gIHJldHVybiBbXTtcbn07XG5cbkZ1dHVyZS5wcm90b3R5cGUuZXh0cmFjdFJpZ2h0ID0gZnVuY3Rpb24gRnV0dXJlJGV4dHJhY3RSaWdodCgpe1xuICByZXR1cm4gW107XG59O1xuXG52YXIgQ29yZSA9IE9iamVjdC5jcmVhdGUoRnV0dXJlLnByb3RvdHlwZSk7XG5cbkNvcmUuX2FwID0gZnVuY3Rpb24gQ29yZSRhcChvdGhlcil7XG4gIHJldHVybiBuZXcgU2VxdWVuY2UodGhpcykuX2FwKG90aGVyKTtcbn07XG5cbkNvcmUuX21hcCA9IGZ1bmN0aW9uIENvcmUkbWFwKG1hcHBlcil7XG4gIHJldHVybiBuZXcgU2VxdWVuY2UodGhpcykuX21hcChtYXBwZXIpO1xufTtcblxuQ29yZS5fYmltYXAgPSBmdW5jdGlvbiBDb3JlJGJpbWFwKGxtYXBwZXIsIHJtYXBwZXIpe1xuICByZXR1cm4gbmV3IFNlcXVlbmNlKHRoaXMpLl9iaW1hcChsbWFwcGVyLCBybWFwcGVyKTtcbn07XG5cbkNvcmUuX2NoYWluID0gZnVuY3Rpb24gQ29yZSRjaGFpbihtYXBwZXIpe1xuICByZXR1cm4gbmV3IFNlcXVlbmNlKHRoaXMpLl9jaGFpbihtYXBwZXIpO1xufTtcblxuQ29yZS5fbWFwUmVqID0gZnVuY3Rpb24gQ29yZSRtYXBSZWoobWFwcGVyKXtcbiAgcmV0dXJuIG5ldyBTZXF1ZW5jZSh0aGlzKS5fbWFwUmVqKG1hcHBlcik7XG59O1xuXG5Db3JlLl9jaGFpblJlaiA9IGZ1bmN0aW9uIENvcmUkY2hhaW5SZWoobWFwcGVyKXtcbiAgcmV0dXJuIG5ldyBTZXF1ZW5jZSh0aGlzKS5fY2hhaW5SZWoobWFwcGVyKTtcbn07XG5cbkNvcmUuX3JhY2UgPSBmdW5jdGlvbiBDb3JlJHJhY2Uob3RoZXIpe1xuICByZXR1cm4gbmV3IFNlcXVlbmNlKHRoaXMpLl9yYWNlKG90aGVyKTtcbn07XG5cbkNvcmUuX2JvdGggPSBmdW5jdGlvbiBDb3JlJGJvdGgob3RoZXIpe1xuICByZXR1cm4gbmV3IFNlcXVlbmNlKHRoaXMpLl9ib3RoKG90aGVyKTtcbn07XG5cbkNvcmUuX2FuZCA9IGZ1bmN0aW9uIENvcmUkYW5kKG90aGVyKXtcbiAgcmV0dXJuIG5ldyBTZXF1ZW5jZSh0aGlzKS5fYW5kKG90aGVyKTtcbn07XG5cbkNvcmUuX29yID0gZnVuY3Rpb24gQ29yZSRvcihvdGhlcil7XG4gIHJldHVybiBuZXcgU2VxdWVuY2UodGhpcykuX29yKG90aGVyKTtcbn07XG5cbkNvcmUuX3N3YXAgPSBmdW5jdGlvbiBDb3JlJHN3YXAoKXtcbiAgcmV0dXJuIG5ldyBTZXF1ZW5jZSh0aGlzKS5fc3dhcCgpO1xufTtcblxuQ29yZS5fZm9sZCA9IGZ1bmN0aW9uIENvcmUkZm9sZChsbWFwcGVyLCBybWFwcGVyKXtcbiAgcmV0dXJuIG5ldyBTZXF1ZW5jZSh0aGlzKS5fZm9sZChsbWFwcGVyLCBybWFwcGVyKTtcbn07XG5cbkNvcmUuX2ZpbmFsbHkgPSBmdW5jdGlvbiBDb3JlJGZpbmFsbHkob3RoZXIpe1xuICByZXR1cm4gbmV3IFNlcXVlbmNlKHRoaXMpLl9maW5hbGx5KG90aGVyKTtcbn07XG5cbmZ1bmN0aW9uIGNoZWNrJGZvcmsoZiwgYyl7XG4gIGlmKCEoZiA9PT0gdW5kZWZpbmVkIHx8IChpc0Z1bmN0aW9uKGYpICYmIGYubGVuZ3RoID09PSAwKSkpIHR5cGVFcnJvcihcbiAgICAnRnV0dXJlIGV4cGVjdGVkIGl0cyBjb21wdXRhdGlvbiB0byByZXR1cm4gYSBudWxsYXJ5IGZ1bmN0aW9uIG9yIHZvaWQnXG4gICAgKyAnXFxuICBBY3R1YWw6ICcgKyBzaG93KGYpICsgJ1xcbiAgRnJvbSBjYWxsaW5nOiAnICsgc2hvd2YoYylcbiAgKTtcbn1cblxuZnVuY3Rpb24gQ29tcHV0YXRpb24oY29tcHV0YXRpb24pe1xuICB0aGlzLl9jb21wdXRhdGlvbiA9IGNvbXB1dGF0aW9uO1xufVxuXG5Db21wdXRhdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvcmUpO1xuXG5Db21wdXRhdGlvbi5wcm90b3R5cGUuX2ZvcmsgPSBmdW5jdGlvbiBDb21wdXRhdGlvbiRfZm9yayhyZWosIHJlcyl7XG4gIHZhciBvcGVuID0gdHJ1ZTtcbiAgdmFyIGYgPSB0aGlzLl9jb21wdXRhdGlvbihmdW5jdGlvbiBDb21wdXRhdGlvbiRyZWooeCl7XG4gICAgaWYob3Blbil7XG4gICAgICBvcGVuID0gZmFsc2U7XG4gICAgICByZWooeCk7XG4gICAgfVxuICB9LCBmdW5jdGlvbiBDb21wdXRhdGlvbiRyZXMoeCl7XG4gICAgaWYob3Blbil7XG4gICAgICBvcGVuID0gZmFsc2U7XG4gICAgICByZXMoeCk7XG4gICAgfVxuICB9KTtcbiAgY2hlY2skZm9yayhmLCB0aGlzLl9jb21wdXRhdGlvbik7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIENvbXB1dGF0aW9uJGNhbmNlbCgpe1xuICAgIG9wZW4gJiYgZiAmJiBmKCk7XG4gICAgb3BlbiA9IGZhbHNlO1xuICB9O1xufTtcblxuQ29tcHV0YXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gQ29tcHV0YXRpb24kdG9TdHJpbmcoKXtcbiAgcmV0dXJuICdGdXR1cmUoJyArIHNob3dmKHRoaXMuX2NvbXB1dGF0aW9uKSArICcpJztcbn07XG5cbmZ1bmN0aW9uIFJlamVjdGVkKHZhbHVlKXtcbiAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbn1cblxuUmVqZWN0ZWQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb3JlKTtcblxuUmVqZWN0ZWQucHJvdG90eXBlLl9hcCA9IG1vb3A7XG5SZWplY3RlZC5wcm90b3R5cGUuX21hcCA9IG1vb3A7XG5SZWplY3RlZC5wcm90b3R5cGUuX2NoYWluID0gbW9vcDtcblJlamVjdGVkLnByb3RvdHlwZS5fcmFjZSA9IG1vb3A7XG5SZWplY3RlZC5wcm90b3R5cGUuX2JvdGggPSBtb29wO1xuUmVqZWN0ZWQucHJvdG90eXBlLl9hbmQgPSBtb29wO1xuXG5SZWplY3RlZC5wcm90b3R5cGUuX29yID0gZnVuY3Rpb24gUmVqZWN0ZWQkb3Iob3RoZXIpe1xuICByZXR1cm4gb3RoZXI7XG59O1xuXG5SZWplY3RlZC5wcm90b3R5cGUuX2ZpbmFsbHkgPSBmdW5jdGlvbiBSZWplY3RlZCRmaW5hbGx5KG90aGVyKXtcbiAgcmV0dXJuIG90aGVyLl9hbmQodGhpcyk7XG59O1xuXG5SZWplY3RlZC5wcm90b3R5cGUuX3N3YXAgPSBmdW5jdGlvbiBSZWplY3RlZCRzd2FwKCl7XG4gIHJldHVybiBuZXcgUmVzb2x2ZWQodGhpcy5fdmFsdWUpO1xufTtcblxuUmVqZWN0ZWQucHJvdG90eXBlLl9mb3JrID0gZnVuY3Rpb24gUmVqZWN0ZWQkX2ZvcmsocmVqKXtcbiAgcmVqKHRoaXMuX3ZhbHVlKTtcbiAgcmV0dXJuIG5vb3A7XG59O1xuXG5SZWplY3RlZC5wcm90b3R5cGUuaXNSZWplY3RlZCA9IGZ1bmN0aW9uIFJlamVjdGVkJGlzUmVqZWN0ZWQoKXtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5SZWplY3RlZC5wcm90b3R5cGUuZXh0cmFjdExlZnQgPSBmdW5jdGlvbiBSZWplY3RlZCRleHRyYWN0TGVmdCgpe1xuICByZXR1cm4gW3RoaXMuX3ZhbHVlXTtcbn07XG5cblJlamVjdGVkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIFJlamVjdGVkJHRvU3RyaW5nKCl7XG4gIHJldHVybiAnRnV0dXJlLnJlamVjdCgnICsgc2hvdyh0aGlzLl92YWx1ZSkgKyAnKSc7XG59O1xuXG5mdW5jdGlvbiByZWplY3QoeCl7XG4gIHJldHVybiBuZXcgUmVqZWN0ZWQoeCk7XG59XG5cbmZ1bmN0aW9uIFJlc29sdmVkKHZhbHVlKXtcbiAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbn1cblxuUmVzb2x2ZWQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb3JlKTtcblxuUmVzb2x2ZWQucHJvdG90eXBlLl9yYWNlID0gbW9vcDtcblJlc29sdmVkLnByb3RvdHlwZS5fbWFwUmVqID0gbW9vcDtcblJlc29sdmVkLnByb3RvdHlwZS5fb3IgPSBtb29wO1xuXG5SZXNvbHZlZC5wcm90b3R5cGUuX2FuZCA9IGZ1bmN0aW9uIFJlc29sdmVkJGFuZChvdGhlcil7XG4gIHJldHVybiBvdGhlcjtcbn07XG5cblJlc29sdmVkLnByb3RvdHlwZS5fYm90aCA9IGZ1bmN0aW9uIFJlc29sdmVkJGJvdGgob3RoZXIpe1xuICB2YXIgbGVmdCA9IHRoaXMuX3ZhbHVlO1xuICByZXR1cm4gb3RoZXIuX21hcChmdW5jdGlvbiBSZXNvbHZlZCRib3RoJG1hcHBlcihyaWdodCl7XG4gICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gIH0pO1xufTtcblxuUmVzb2x2ZWQucHJvdG90eXBlLl9zd2FwID0gZnVuY3Rpb24gUmVzb2x2ZWQkc3dhcCgpe1xuICByZXR1cm4gbmV3IFJlamVjdGVkKHRoaXMuX3ZhbHVlKTtcbn07XG5cblJlc29sdmVkLnByb3RvdHlwZS5fZmluYWxseSA9IGZ1bmN0aW9uIFJlc29sdmVkJGZpbmFsbHkob3RoZXIpe1xuICB2YXIgdmFsdWUgPSB0aGlzLl92YWx1ZTtcbiAgcmV0dXJuIG90aGVyLl9tYXAoZnVuY3Rpb24gUmVzb2x2ZWQkZmluYWxseSRtYXBwZXIoKXtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0pO1xufTtcblxuUmVzb2x2ZWQucHJvdG90eXBlLl9mb3JrID0gZnVuY3Rpb24gX2ZvcmsocmVqLCByZXMpe1xuICByZXModGhpcy5fdmFsdWUpO1xuICByZXR1cm4gbm9vcDtcbn07XG5cblJlc29sdmVkLnByb3RvdHlwZS5pc1Jlc29sdmVkID0gZnVuY3Rpb24gUmVzb2x2ZWQkaXNSZXNvbHZlZCgpe1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cblJlc29sdmVkLnByb3RvdHlwZS5leHRyYWN0UmlnaHQgPSBmdW5jdGlvbiBSZXNvbHZlZCRleHRyYWN0UmlnaHQoKXtcbiAgcmV0dXJuIFt0aGlzLl92YWx1ZV07XG59O1xuXG5SZXNvbHZlZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBSZXNvbHZlZCR0b1N0cmluZygpe1xuICByZXR1cm4gJ0Z1dHVyZS5vZignICsgc2hvdyh0aGlzLl92YWx1ZSkgKyAnKSc7XG59O1xuXG5mdW5jdGlvbiBvZih4KXtcbiAgcmV0dXJuIG5ldyBSZXNvbHZlZCh4KTtcbn1cblxuZnVuY3Rpb24gTmV2ZXIoKXtcbiAgdGhpcy5faXNOZXZlciA9IHRydWU7XG59XG5cbk5ldmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRnV0dXJlLnByb3RvdHlwZSk7XG5cbk5ldmVyLnByb3RvdHlwZS5fYXAgPSBtb29wO1xuTmV2ZXIucHJvdG90eXBlLl9tYXAgPSBtb29wO1xuTmV2ZXIucHJvdG90eXBlLl9iaW1hcCA9IG1vb3A7XG5OZXZlci5wcm90b3R5cGUuX2NoYWluID0gbW9vcDtcbk5ldmVyLnByb3RvdHlwZS5fbWFwUmVqID0gbW9vcDtcbk5ldmVyLnByb3RvdHlwZS5fY2hhaW5SZWogPSBtb29wO1xuTmV2ZXIucHJvdG90eXBlLl9ib3RoID0gbW9vcDtcbk5ldmVyLnByb3RvdHlwZS5fb3IgPSBtb29wO1xuTmV2ZXIucHJvdG90eXBlLl9zd2FwID0gbW9vcDtcbk5ldmVyLnByb3RvdHlwZS5fZm9sZCA9IG1vb3A7XG5OZXZlci5wcm90b3R5cGUuX2ZpbmFsbHkgPSBtb29wO1xuXG5OZXZlci5wcm90b3R5cGUuX3JhY2UgPSBmdW5jdGlvbiBOZXZlciRyYWNlKG90aGVyKXtcbiAgcmV0dXJuIG90aGVyO1xufTtcblxuTmV2ZXIucHJvdG90eXBlLl9mb3JrID0gZnVuY3Rpb24gTmV2ZXIkX2ZvcmsoKXtcbiAgcmV0dXJuIG5vb3A7XG59O1xuXG5OZXZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBOZXZlciR0b1N0cmluZygpe1xuICByZXR1cm4gJ0Z1dHVyZS5uZXZlcic7XG59O1xuXG52YXIgbmV2ZXIgPSBuZXcgTmV2ZXIoKTtcblxuZnVuY3Rpb24gaXNOZXZlcih4KXtcbiAgcmV0dXJuIGlzRnV0dXJlKHgpICYmIHguX2lzTmV2ZXIgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIEVhZ2VyKGZ1dHVyZSl7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIF90aGlzLnJlaiA9IG5vb3A7XG4gIF90aGlzLnJlcyA9IG5vb3A7XG4gIF90aGlzLnJlamVjdGVkID0gZmFsc2U7XG4gIF90aGlzLnJlc29sdmVkID0gZmFsc2U7XG4gIF90aGlzLnZhbHVlID0gbnVsbDtcbiAgX3RoaXMuY2FuY2VsID0gZnV0dXJlLl9mb3JrKGZ1bmN0aW9uIEVhZ2VyJHJlamVjdCh4KXtcbiAgICBfdGhpcy52YWx1ZSA9IHg7XG4gICAgX3RoaXMucmVqZWN0ZWQgPSB0cnVlO1xuICAgIF90aGlzLmNhbmNlbCA9IG5vb3A7XG4gICAgX3RoaXMucmVqKHgpO1xuICB9LCBmdW5jdGlvbiBFYWdlciRyZXNvbHZlKHgpe1xuICAgIF90aGlzLnZhbHVlID0geDtcbiAgICBfdGhpcy5yZXNvbHZlZCA9IHRydWU7XG4gICAgX3RoaXMuY2FuY2VsID0gbm9vcDtcbiAgICBfdGhpcy5yZXMoeCk7XG4gIH0pO1xufVxuXG5FYWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvcmUpO1xuXG5FYWdlci5wcm90b3R5cGUuX2ZvcmsgPSBmdW5jdGlvbiBFYWdlciRfZm9yayhyZWosIHJlcyl7XG4gIGlmKHRoaXMucmVqZWN0ZWQpIHJlaih0aGlzLnZhbHVlKTtcbiAgZWxzZSBpZih0aGlzLnJlc29sdmVkKSByZXModGhpcy52YWx1ZSk7XG4gIGVsc2V7XG4gICAgdGhpcy5yZWogPSByZWo7XG4gICAgdGhpcy5yZXMgPSByZXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY2FuY2VsO1xufTtcblxuZnVuY3Rpb24gY2hlY2skYXAoZil7XG4gIHJldHVybiBpc0Z1bmN0aW9uKGYpID8gZiA6IHR5cGVFcnJvcihcbiAgICAnRnV0dXJlI2FwIGV4cGVjdHMgaXRzIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGEgRnV0dXJlIG9mIGEgRnVuY3Rpb24nXG4gICAgKyAnXFxuICBBY3R1YWw6IEZ1dHVyZS5vZignICsgc2hvdyhmKSArICcpJ1xuICApO1xufVxuXG5mdW5jdGlvbiBjaGVjayRjaGFpbihtLCBmLCB4KXtcbiAgcmV0dXJuIGlzRnV0dXJlKG0pID8gbSA6IGludmFsaWRGdXR1cmUoXG4gICAgJ0Z1dHVyZSNjaGFpbicsXG4gICAgJ3RoZSBmdW5jdGlvbiBpdFxcJ3MgZ2l2ZW4gdG8gcmV0dXJuIGEgRnV0dXJlJyxcbiAgICBtLFxuICAgICdcXG4gIEZyb20gY2FsbGluZzogJyArIHNob3dmKGYpICsgJ1xcbiAgV2l0aDogJyArIHNob3coeClcbiAgKTtcbn1cblxuZnVuY3Rpb24gY2hlY2skY2hhaW5SZWoobSwgZiwgeCl7XG4gIHJldHVybiBpc0Z1dHVyZShtKSA/IG0gOiBpbnZhbGlkRnV0dXJlKFxuICAgICdGdXR1cmUjY2hhaW5SZWonLFxuICAgICd0aGUgZnVuY3Rpb24gaXRcXCdzIGdpdmVuIHRvIHJldHVybiBhIEZ1dHVyZScsXG4gICAgbSxcbiAgICAnXFxuICBGcm9tIGNhbGxpbmc6ICcgKyBzaG93ZihmKSArICdcXG4gIFdpdGg6ICcgKyBzaG93KHgpXG4gICk7XG59XG5cbnZhciBBY3Rpb24gPSB7XG4gIHJlamVjdGVkOiBmdW5jdGlvbiBBY3Rpb24kcmVqZWN0ZWQoeCl7IHRoaXMuY2FuY2VsKCk7IHJldHVybiBuZXcgUmVqZWN0ZWQoeCkgfSxcbiAgcmVzb2x2ZWQ6IGZ1bmN0aW9uIEFjdGlvbiRyZXNvbHZlZCh4KXsgdGhpcy5jYW5jZWwoKTsgcmV0dXJuIG5ldyBSZXNvbHZlZCh4KSB9LFxuICBydW46IGZ1bmN0aW9uIEFjdGlvbiRydW4oKXsgcmV0dXJuIHRoaXMgfSxcbiAgY2FuY2VsOiBmdW5jdGlvbiBBY3Rpb24kY2FuY2VsKCl7fVxufTtcblxuZnVuY3Rpb24gQXBBY3Rpb24ob3RoZXIpeyB0aGlzLm90aGVyID0gb3RoZXI7IH1cbkFwQWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQWN0aW9uKTtcblxuQXBBY3Rpb24ucHJvdG90eXBlLnJlc29sdmVkID0gZnVuY3Rpb24gQXBBY3Rpb24kcmVzb2x2ZWQoZil7XG4gIGNoZWNrJGFwKGYpO1xuICByZXR1cm4gdGhpcy5vdGhlci5fbWFwKGZ1bmN0aW9uIEFwQWN0aW9uJHJlc29sdmVkJG1hcHBlcih4KXsgcmV0dXJuIGYoeCkgfSk7XG59O1xuXG5BcEFjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBBcEFjdGlvbiR0b1N0cmluZygpe1xuICByZXR1cm4gJ2FwKCcgKyB0aGlzLm90aGVyLnRvU3RyaW5nKCkgKyAnKSc7XG59O1xuXG5mdW5jdGlvbiBNYXBBY3Rpb24obWFwcGVyKXsgdGhpcy5tYXBwZXIgPSBtYXBwZXI7IH1cbk1hcEFjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFjdGlvbik7XG5cbk1hcEFjdGlvbi5wcm90b3R5cGUucmVzb2x2ZWQgPSBmdW5jdGlvbiBNYXBBY3Rpb24kcmVzb2x2ZWQoeCl7XG4gIHJldHVybiBuZXcgUmVzb2x2ZWQodGhpcy5tYXBwZXIoeCkpO1xufTtcblxuTWFwQWN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIE1hcEFjdGlvbiR0b1N0cmluZygpe1xuICByZXR1cm4gJ21hcCgnICsgc2hvd2YodGhpcy5tYXBwZXIpICsgJyknO1xufTtcblxuZnVuY3Rpb24gQmltYXBBY3Rpb24obG1hcHBlciwgcm1hcHBlcil7IHRoaXMubG1hcHBlciA9IGxtYXBwZXI7IHRoaXMucm1hcHBlciA9IHJtYXBwZXI7IH1cbkJpbWFwQWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQWN0aW9uKTtcblxuQmltYXBBY3Rpb24ucHJvdG90eXBlLnJlamVjdGVkID0gZnVuY3Rpb24gQmltYXBBY3Rpb24kcmVqZWN0ZWQoeCl7XG4gIHJldHVybiBuZXcgUmVqZWN0ZWQodGhpcy5sbWFwcGVyKHgpKTtcbn07XG5cbkJpbWFwQWN0aW9uLnByb3RvdHlwZS5yZXNvbHZlZCA9IGZ1bmN0aW9uIEJpbWFwQWN0aW9uJHJlc29sdmVkKHgpe1xuICByZXR1cm4gbmV3IFJlc29sdmVkKHRoaXMucm1hcHBlcih4KSk7XG59O1xuXG5CaW1hcEFjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBCaW1hcEFjdGlvbiR0b1N0cmluZygpe1xuICByZXR1cm4gJ2JpbWFwKCcgKyBzaG93Zih0aGlzLmxtYXBwZXIpICsgJywgJyArIHNob3dmKHRoaXMucm1hcHBlcikgKyAnKSc7XG59O1xuXG5mdW5jdGlvbiBDaGFpbkFjdGlvbihtYXBwZXIpeyB0aGlzLm1hcHBlciA9IG1hcHBlcjsgfVxuQ2hhaW5BY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBY3Rpb24pO1xuXG5DaGFpbkFjdGlvbi5wcm90b3R5cGUucmVzb2x2ZWQgPSBmdW5jdGlvbiBDaGFpbkFjdGlvbiRyZXNvbHZlZCh4KXtcbiAgcmV0dXJuIGNoZWNrJGNoYWluKHRoaXMubWFwcGVyKHgpLCB0aGlzLm1hcHBlciwgeCk7XG59O1xuXG5DaGFpbkFjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBDaGFpbkFjdGlvbiR0b1N0cmluZygpe1xuICByZXR1cm4gJ2NoYWluKCcgKyBzaG93Zih0aGlzLm1hcHBlcikgKyAnKSc7XG59O1xuXG5mdW5jdGlvbiBNYXBSZWpBY3Rpb24obWFwcGVyKXsgdGhpcy5tYXBwZXIgPSBtYXBwZXI7IH1cbk1hcFJlakFjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFjdGlvbik7XG5cbk1hcFJlakFjdGlvbi5wcm90b3R5cGUucmVqZWN0ZWQgPSBmdW5jdGlvbiBNYXBSZWpBY3Rpb24kcmVqZWN0ZWQoeCl7XG4gIHJldHVybiBuZXcgUmVqZWN0ZWQodGhpcy5tYXBwZXIoeCkpO1xufTtcblxuTWFwUmVqQWN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIE1hcFJlakFjdGlvbiR0b1N0cmluZygpe1xuICByZXR1cm4gJ21hcFJlaignICsgc2hvd2YodGhpcy5tYXBwZXIpICsgJyknO1xufTtcblxuZnVuY3Rpb24gQ2hhaW5SZWpBY3Rpb24obWFwcGVyKXsgdGhpcy5tYXBwZXIgPSBtYXBwZXI7IH1cbkNoYWluUmVqQWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQWN0aW9uKTtcblxuQ2hhaW5SZWpBY3Rpb24ucHJvdG90eXBlLnJlamVjdGVkID0gZnVuY3Rpb24gQ2hhaW5SZWpBY3Rpb24kcmVqZWN0ZWQoeCl7XG4gIHJldHVybiBjaGVjayRjaGFpblJlaih0aGlzLm1hcHBlcih4KSwgdGhpcy5tYXBwZXIsIHgpO1xufTtcblxuQ2hhaW5SZWpBY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gQ2hhaW5SZWpBY3Rpb24kdG9TdHJpbmcoKXtcbiAgcmV0dXJuICdjaGFpblJlaignICsgc2hvd2YodGhpcy5tYXBwZXIpICsgJyknO1xufTtcblxuZnVuY3Rpb24gU3dhcEFjdGlvbigpe31cblN3YXBBY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBY3Rpb24pO1xuXG5Td2FwQWN0aW9uLnByb3RvdHlwZS5yZWplY3RlZCA9IGZ1bmN0aW9uIFN3YXBBY3Rpb24kcmVqZWN0ZWQoeCl7XG4gIHJldHVybiBuZXcgUmVzb2x2ZWQoeCk7XG59O1xuXG5Td2FwQWN0aW9uLnByb3RvdHlwZS5yZXNvbHZlZCA9IGZ1bmN0aW9uIFN3YXBBY3Rpb24kcmVzb2x2ZWQoeCl7XG4gIHJldHVybiBuZXcgUmVqZWN0ZWQoeCk7XG59O1xuXG5Td2FwQWN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIFN3YXBBY3Rpb24kdG9TdHJpbmcoKXtcbiAgcmV0dXJuICdzd2FwKCknO1xufTtcblxuZnVuY3Rpb24gRm9sZEFjdGlvbihsbWFwcGVyLCBybWFwcGVyKXsgdGhpcy5sbWFwcGVyID0gbG1hcHBlcjsgdGhpcy5ybWFwcGVyID0gcm1hcHBlcjsgfVxuRm9sZEFjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFjdGlvbik7XG5cbkZvbGRBY3Rpb24ucHJvdG90eXBlLnJlamVjdGVkID0gZnVuY3Rpb24gRm9sZEFjdGlvbiRyZWplY3RlZCh4KXtcbiAgcmV0dXJuIG5ldyBSZXNvbHZlZCh0aGlzLmxtYXBwZXIoeCkpO1xufTtcblxuRm9sZEFjdGlvbi5wcm90b3R5cGUucmVzb2x2ZWQgPSBmdW5jdGlvbiBGb2xkQWN0aW9uJHJlc29sdmVkKHgpe1xuICByZXR1cm4gbmV3IFJlc29sdmVkKHRoaXMucm1hcHBlcih4KSk7XG59O1xuXG5Gb2xkQWN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIEZvbGRBY3Rpb24kdG9TdHJpbmcoKXtcbiAgcmV0dXJuICdmb2xkKCcgKyBzaG93Zih0aGlzLmxtYXBwZXIpICsgJywgJyArIHNob3dmKHRoaXMucm1hcHBlcikgKyAnKSc7XG59O1xuXG5mdW5jdGlvbiBGaW5hbGx5QWN0aW9uKG90aGVyKXsgdGhpcy5vdGhlciA9IG90aGVyOyB9XG5GaW5hbGx5QWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQWN0aW9uKTtcblxuRmluYWxseUFjdGlvbi5wcm90b3R5cGUucmVqZWN0ZWQgPSBmdW5jdGlvbiBGaW5hbGx5QWN0aW9uJHJlamVjdGVkKHgpe1xuICByZXR1cm4gdGhpcy5vdGhlci5fYW5kKG5ldyBSZWplY3RlZCh4KSk7XG59O1xuXG5GaW5hbGx5QWN0aW9uLnByb3RvdHlwZS5yZXNvbHZlZCA9IGZ1bmN0aW9uIEZpbmFsbHlBY3Rpb24kcmVzb2x2ZWQoeCl7XG4gIHJldHVybiB0aGlzLm90aGVyLl9tYXAoZnVuY3Rpb24gRm9sZEFjdGlvbiRyZXNvbHZlZCRtYXBwZXIoKXsgcmV0dXJuIHggfSk7XG59O1xuXG5GaW5hbGx5QWN0aW9uLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiBGaW5hbGx5QWN0aW9uJGNhbmNlbCgpe1xuICB0aGlzLm90aGVyLl9mb3JrKG5vb3AsIG5vb3ApKCk7XG59O1xuXG5GaW5hbGx5QWN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIEZpbmFsbHlBY3Rpb24kdG9TdHJpbmcoKXtcbiAgcmV0dXJuICdmaW5hbGx5KCcgKyB0aGlzLm90aGVyLnRvU3RyaW5nKCkgKyAnKSc7XG59O1xuXG5mdW5jdGlvbiBBbmRBY3Rpb24ob3RoZXIpeyB0aGlzLm90aGVyID0gb3RoZXI7IH1cbkFuZEFjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFjdGlvbik7XG5cbkFuZEFjdGlvbi5wcm90b3R5cGUucmVzb2x2ZWQgPSBmdW5jdGlvbiBBbmRBY3Rpb24kcmVzb2x2ZWQoKXtcbiAgcmV0dXJuIHRoaXMub3RoZXI7XG59O1xuXG5BbmRBY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gQW5kQWN0aW9uJHRvU3RyaW5nKCl7XG4gIHJldHVybiAnYW5kKCcgKyB0aGlzLm90aGVyLnRvU3RyaW5nKCkgKyAnKSc7XG59O1xuXG5mdW5jdGlvbiBPckFjdGlvbihvdGhlcil7IHRoaXMub3RoZXIgPSBvdGhlcjsgfVxuT3JBY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBY3Rpb24pO1xuXG5PckFjdGlvbi5wcm90b3R5cGUucmVqZWN0ZWQgPSBmdW5jdGlvbiBPckFjdGlvbiRyZWplY3RlZCgpe1xuICByZXR1cm4gdGhpcy5vdGhlcjtcbn07XG5cbk9yQWN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIE9yQWN0aW9uJHRvU3RyaW5nKCl7XG4gIHJldHVybiAnb3IoJyArIHRoaXMub3RoZXIudG9TdHJpbmcoKSArICcpJztcbn07XG5cbmZ1bmN0aW9uIFJhY2VBY3Rpb24ob3RoZXIpeyB0aGlzLm90aGVyID0gb3RoZXI7IH1cblJhY2VBY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBY3Rpb24pO1xuXG5SYWNlQWN0aW9uLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBSYWNlQWN0aW9uJHJ1bihlYXJseSl7XG4gIHJldHVybiBuZXcgUmFjZUFjdGlvblN0YXRlKGVhcmx5LCBuZXcgRWFnZXIodGhpcy5vdGhlcikpO1xufTtcblxuUmFjZUFjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBSYWNlQWN0aW9uJHRvU3RyaW5nKCl7XG4gIHJldHVybiAncmFjZSgnICsgdGhpcy5vdGhlci50b1N0cmluZygpICsgJyknO1xufTtcblxuZnVuY3Rpb24gQm90aEFjdGlvbihvdGhlcil7IHRoaXMub3RoZXIgPSBvdGhlcjsgfVxuQm90aEFjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFjdGlvbik7XG5cbkJvdGhBY3Rpb24ucHJvdG90eXBlLnJlc29sdmVkID0gZnVuY3Rpb24gQm90aEFjdGlvbiRyZXNvbHZlZCh4KXtcbiAgcmV0dXJuIHRoaXMub3RoZXIuX21hcChmdW5jdGlvbiBCb3RoQWN0aW9uJHJlc29sdmVkJG1hcHBlcih5KXsgcmV0dXJuIFt4LCB5XSB9KTtcbn07XG5cbkJvdGhBY3Rpb24ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIEJvdGhBY3Rpb24kcnVuKGVhcmx5KXtcbiAgcmV0dXJuIG5ldyBCb3RoQWN0aW9uU3RhdGUoZWFybHksIG5ldyBFYWdlcih0aGlzLm90aGVyKSk7XG59O1xuXG5Cb3RoQWN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIEJvdGhBY3Rpb24kdG9TdHJpbmcoKXtcbiAgcmV0dXJuICdib3RoKCcgKyB0aGlzLm90aGVyLnRvU3RyaW5nKCkgKyAnKSc7XG59O1xuXG5mdW5jdGlvbiBSYWNlQWN0aW9uU3RhdGUoZWFybHksIG90aGVyKXtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgX3RoaXMub3RoZXIgPSBvdGhlcjtcbiAgX3RoaXMuY2FuY2VsID0gb3RoZXIuX2ZvcmsoXG4gICAgZnVuY3Rpb24gUmFjZUFjdGlvblN0YXRlJHJlaih4KXsgZWFybHkobmV3IFJlamVjdGVkKHgpLCBfdGhpcyk7IH0sXG4gICAgZnVuY3Rpb24gUmFjZUFjdGlvblN0YXRlJHJlcyh4KXsgZWFybHkobmV3IFJlc29sdmVkKHgpLCBfdGhpcyk7IH1cbiAgKTtcbn1cblxuUmFjZUFjdGlvblN0YXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmFjZUFjdGlvbi5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBCb3RoQWN0aW9uU3RhdGUoZWFybHksIG90aGVyKXtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgX3RoaXMub3RoZXIgPSBvdGhlcjtcbiAgX3RoaXMuY2FuY2VsID0gb3RoZXIuX2ZvcmsoXG4gICAgZnVuY3Rpb24gQm90aEFjdGlvblN0YXRlJHJlaih4KXsgZWFybHkobmV3IFJlamVjdGVkKHgpLCBfdGhpcyk7IH0sXG4gICAgbm9vcFxuICApO1xufVxuXG5Cb3RoQWN0aW9uU3RhdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCb3RoQWN0aW9uLnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIFNlcXVlbmNlKHNwYXduLCBhY3Rpb25zKXtcbiAgdGhpcy5fc3Bhd24gPSBzcGF3bjtcbiAgdGhpcy5fYWN0aW9ucyA9IGFjdGlvbnMgfHwgZW1wdHk7XG59XG5cblNlcXVlbmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRnV0dXJlLnByb3RvdHlwZSk7XG5cblNlcXVlbmNlLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gU2VxdWVuY2UkX3RyYW5zZm9ybShhY3Rpb24pe1xuICByZXR1cm4gbmV3IFNlcXVlbmNlKHRoaXMuX3NwYXduLCBjb25zKGFjdGlvbiwgdGhpcy5fYWN0aW9ucykpO1xufTtcblxuU2VxdWVuY2UucHJvdG90eXBlLl9hcCA9IGZ1bmN0aW9uIFNlcXVlbmNlJGFwKG90aGVyKXtcbiAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybShuZXcgQXBBY3Rpb24ob3RoZXIpKTtcbn07XG5cblNlcXVlbmNlLnByb3RvdHlwZS5fbWFwID0gZnVuY3Rpb24gU2VxdWVuY2UkbWFwKG1hcHBlcil7XG4gIHJldHVybiB0aGlzLl90cmFuc2Zvcm0obmV3IE1hcEFjdGlvbihtYXBwZXIpKTtcbn07XG5cblNlcXVlbmNlLnByb3RvdHlwZS5fYmltYXAgPSBmdW5jdGlvbiBTZXF1ZW5jZSRiaW1hcChsbWFwcGVyLCBybWFwcGVyKXtcbiAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybShuZXcgQmltYXBBY3Rpb24obG1hcHBlciwgcm1hcHBlcikpO1xufTtcblxuU2VxdWVuY2UucHJvdG90eXBlLl9jaGFpbiA9IGZ1bmN0aW9uIFNlcXVlbmNlJGNoYWluKG1hcHBlcil7XG4gIHJldHVybiB0aGlzLl90cmFuc2Zvcm0obmV3IENoYWluQWN0aW9uKG1hcHBlcikpO1xufTtcblxuU2VxdWVuY2UucHJvdG90eXBlLl9tYXBSZWogPSBmdW5jdGlvbiBTZXF1ZW5jZSRtYXBSZWoobWFwcGVyKXtcbiAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybShuZXcgTWFwUmVqQWN0aW9uKG1hcHBlcikpO1xufTtcblxuU2VxdWVuY2UucHJvdG90eXBlLl9jaGFpblJlaiA9IGZ1bmN0aW9uIFNlcXVlbmNlJGNoYWluUmVqKG1hcHBlcil7XG4gIHJldHVybiB0aGlzLl90cmFuc2Zvcm0obmV3IENoYWluUmVqQWN0aW9uKG1hcHBlcikpO1xufTtcblxuU2VxdWVuY2UucHJvdG90eXBlLl9yYWNlID0gZnVuY3Rpb24gU2VxdWVuY2UkcmFjZShvdGhlcil7XG4gIHJldHVybiBpc05ldmVyKG90aGVyKSA/IHRoaXMgOiB0aGlzLl90cmFuc2Zvcm0obmV3IFJhY2VBY3Rpb24ob3RoZXIpKTtcbn07XG5cblNlcXVlbmNlLnByb3RvdHlwZS5fYm90aCA9IGZ1bmN0aW9uIFNlcXVlbmNlJGJvdGgob3RoZXIpe1xuICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtKG5ldyBCb3RoQWN0aW9uKG90aGVyKSk7XG59O1xuXG5TZXF1ZW5jZS5wcm90b3R5cGUuX2FuZCA9IGZ1bmN0aW9uIFNlcXVlbmNlJGFuZChvdGhlcil7XG4gIHJldHVybiB0aGlzLl90cmFuc2Zvcm0obmV3IEFuZEFjdGlvbihvdGhlcikpO1xufTtcblxuU2VxdWVuY2UucHJvdG90eXBlLl9vciA9IGZ1bmN0aW9uIFNlcXVlbmNlJG9yKG90aGVyKXtcbiAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybShuZXcgT3JBY3Rpb24ob3RoZXIpKTtcbn07XG5cblNlcXVlbmNlLnByb3RvdHlwZS5fc3dhcCA9IGZ1bmN0aW9uIFNlcXVlbmNlJHN3YXAoKXtcbiAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybShuZXcgU3dhcEFjdGlvbik7XG59O1xuXG5TZXF1ZW5jZS5wcm90b3R5cGUuX2ZvbGQgPSBmdW5jdGlvbiBTZXF1ZW5jZSRmb2xkKGxtYXBwZXIsIHJtYXBwZXIpe1xuICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtKG5ldyBGb2xkQWN0aW9uKGxtYXBwZXIsIHJtYXBwZXIpKTtcbn07XG5cblNlcXVlbmNlLnByb3RvdHlwZS5fZmluYWxseSA9IGZ1bmN0aW9uIFNlcXVlbmNlJGZpbmFsbHkob3RoZXIpe1xuICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtKG5ldyBGaW5hbGx5QWN0aW9uKG90aGVyKSk7XG59O1xuXG5TZXF1ZW5jZS5wcm90b3R5cGUuX2ZvcmsgPSBpbnRlcnByZXRlcjtcblxuU2VxdWVuY2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gU2VxdWVuY2UkdG9TdHJpbmcoKXtcbiAgdmFyIHN0ciA9ICcnLCB0YWlsID0gdGhpcy5fYWN0aW9ucztcblxuICB3aGlsZSghdGFpbC5pc0VtcHR5KXtcbiAgICBzdHIgPSAnLicgKyB0YWlsLmhlYWQudG9TdHJpbmcoKSArIHN0cjtcbiAgICB0YWlsID0gdGFpbC50YWlsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX3NwYXduLnRvU3RyaW5nKCkgKyBzdHI7XG59O1xuXG5mdW5jdGlvbiBOZXh0KHgpe1xuICByZXR1cm4ge2RvbmU6IGZhbHNlLCB2YWx1ZTogeH07XG59XG5cbmZ1bmN0aW9uIERvbmUoeCl7XG4gIHJldHVybiB7ZG9uZTogdHJ1ZSwgdmFsdWU6IHh9O1xufVxuXG5mdW5jdGlvbiBpc0l0ZXJhdGlvbih4KXtcbiAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIGlzQm9vbGVhbih4LmRvbmUpO1xufVxuXG52YXIgVW5kZXRlcm1pbmVkID0gMDtcbnZhciBTeW5jaHJvbm91cyA9IDE7XG52YXIgQXN5bmNocm9ub3VzID0gMjtcblxuZnVuY3Rpb24gQ2hhaW5SZWMoc3RlcCwgaW5pdCl7XG4gIHRoaXMuX3N0ZXAgPSBzdGVwO1xuICB0aGlzLl9pbml0ID0gaW5pdDtcbn1cblxuQ2hhaW5SZWMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb3JlKTtcblxuQ2hhaW5SZWMucHJvdG90eXBlLl9mb3JrID0gZnVuY3Rpb24gQ2hhaW5SZWMkX2ZvcmsocmVqLCByZXMpe1xuXG4gIHZhciBfc3RlcCA9IHRoaXMuX3N0ZXA7XG4gIHZhciBfaW5pdCA9IHRoaXMuX2luaXQ7XG4gIHZhciB0aW1pbmcgPSBVbmRldGVybWluZWQsIGNhbmNlbCA9IG5vb3AsIHN0YXRlID0gTmV4dChfaW5pdCk7XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZWQoaXQpe1xuICAgIHN0YXRlID0gaXQ7XG4gICAgdGltaW5nID0gdGltaW5nID09PSBVbmRldGVybWluZWQgPyBTeW5jaHJvbm91cyA6IGRyYWluKCk7XG4gIH1cblxuICBmdW5jdGlvbiBkcmFpbigpe1xuICAgIHdoaWxlKCFzdGF0ZS5kb25lKXtcbiAgICAgIHRpbWluZyA9IFVuZGV0ZXJtaW5lZDtcbiAgICAgIHZhciBtID0gX3N0ZXAoTmV4dCwgRG9uZSwgc3RhdGUudmFsdWUpO1xuICAgICAgY2FuY2VsID0gbS5fZm9yayhyZWosIHJlc29sdmVkKTtcblxuICAgICAgaWYodGltaW5nICE9PSBTeW5jaHJvbm91cyl7XG4gICAgICAgIHRpbWluZyA9IEFzeW5jaHJvbm91cztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlcyhzdGF0ZS52YWx1ZSk7XG4gIH1cblxuICBkcmFpbigpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBGdXR1cmUkY2hhaW5SZWMkY2FuY2VsKCl7IGNhbmNlbCgpOyB9O1xuXG59O1xuXG5DaGFpblJlYy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBDaGFpblJlYyR0b1N0cmluZygpe1xuICByZXR1cm4gJ0Z1dHVyZS5jaGFpblJlYygnICsgc2hvd2YodGhpcy5fc3RlcCkgKyAnLCAnICsgc2hvdyh0aGlzLl9pbml0KSArICcpJztcbn07XG5cbmZ1bmN0aW9uIGNoYWluUmVjKHN0ZXAsIGluaXQpe1xuICByZXR1cm4gbmV3IENoYWluUmVjKHN0ZXAsIGluaXQpO1xufVxuXG5mdW5jdGlvbiBhcCRtdmFsKG12YWwsIG1mdW5jKXtcbiAgaWYoIVouQXBwbHkudGVzdChtZnVuYykpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlLmFwJywgMSwgJ2JlIGFuIEFwcGx5JywgbWZ1bmMpO1xuICByZXR1cm4gWi5hcChtdmFsLCBtZnVuYyk7XG59XG5cbmZ1bmN0aW9uIGFwKG12YWwsIG1mdW5jKXtcbiAgaWYoIVouQXBwbHkudGVzdChtdmFsKSkgaW52YWxpZEFyZ3VtZW50KCdGdXR1cmUuYXAnLCAwLCAnYmUgYW4gQXBwbHknLCBtdmFsKTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhcnRpYWwxKGFwJG12YWwsIG12YWwpO1xuICByZXR1cm4gYXAkbXZhbChtdmFsLCBtZnVuYyk7XG59XG5cbmZ1bmN0aW9uIGFsdCRsZWZ0KGxlZnQsIHJpZ2h0KXtcbiAgaWYoIVouQWx0LnRlc3QocmlnaHQpKSBpbnZhbGlkQXJndW1lbnQoJ2FsdCcsIDEsICdiZSBhbiBBbHQnLCByaWdodCk7XG4gIHJldHVybiBaLmFsdChsZWZ0LCByaWdodCk7XG59XG5cbmZ1bmN0aW9uIGFsdChsZWZ0LCByaWdodCl7XG4gIGlmKCFaLkFsdC50ZXN0KGxlZnQpKSBpbnZhbGlkQXJndW1lbnQoJ2FsdCcsIDAsICdiZSBhbiBBbHQnLCBsZWZ0KTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhcnRpYWwxKGFsdCRsZWZ0LCBsZWZ0KTtcbiAgcmV0dXJuIGFsdCRsZWZ0KGxlZnQsIHJpZ2h0KTtcbn1cblxuZnVuY3Rpb24gbWFwJG1hcHBlcihtYXBwZXIsIG0pe1xuICBpZighWi5GdW5jdG9yLnRlc3QobSkpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlLm1hcCcsIDEsICdiZSBhIEZ1bmN0b3InLCBtKTtcbiAgcmV0dXJuIFoubWFwKG1hcHBlciwgbSk7XG59XG5cbmZ1bmN0aW9uIG1hcChtYXBwZXIsIG0pe1xuICBpZighaXNGdW5jdGlvbihtYXBwZXIpKSBpbnZhbGlkQXJndW1lbnQoJ0Z1dHVyZS5tYXAnLCAwLCAnYmUgYSBGdW5jdGlvbicsIG1hcHBlcik7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiBwYXJ0aWFsMShtYXAkbWFwcGVyLCBtYXBwZXIpO1xuICByZXR1cm4gbWFwJG1hcHBlcihtYXBwZXIsIG0pO1xufVxuXG5mdW5jdGlvbiBiaW1hcCRsbWFwcGVyJHJtYXBwZXIobG1hcHBlciwgcm1hcHBlciwgbSl7XG4gIGlmKCFaLkJpZnVuY3Rvci50ZXN0KG0pKSBpbnZhbGlkQXJndW1lbnQoJ0Z1dHVyZS5iaW1hcCcsIDIsICdiZSBhIEJpZnVuY3RvcicsIG0pO1xuICByZXR1cm4gWi5iaW1hcChsbWFwcGVyLCBybWFwcGVyLCBtKTtcbn1cblxuZnVuY3Rpb24gYmltYXAkbG1hcHBlcihsbWFwcGVyLCBybWFwcGVyLCBtKXtcbiAgaWYoIWlzRnVuY3Rpb24ocm1hcHBlcikpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlLmJpbWFwJywgMSwgJ2JlIGEgRnVuY3Rpb24nLCBybWFwcGVyKTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgcmV0dXJuIHBhcnRpYWwyKGJpbWFwJGxtYXBwZXIkcm1hcHBlciwgbG1hcHBlciwgcm1hcHBlcik7XG4gIHJldHVybiBiaW1hcCRsbWFwcGVyJHJtYXBwZXIobG1hcHBlciwgcm1hcHBlciwgbSk7XG59XG5cbmZ1bmN0aW9uIGJpbWFwKGxtYXBwZXIsIHJtYXBwZXIsIG0pe1xuICBpZighaXNGdW5jdGlvbihsbWFwcGVyKSkgaW52YWxpZEFyZ3VtZW50KCdGdXR1cmUuYmltYXAnLCAwLCAnYmUgYSBGdW5jdGlvbicsIGxtYXBwZXIpO1xuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gcGFydGlhbDEoYmltYXAkbG1hcHBlciwgbG1hcHBlcik7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHJldHVybiBiaW1hcCRsbWFwcGVyKGxtYXBwZXIsIHJtYXBwZXIpO1xuICByZXR1cm4gYmltYXAkbG1hcHBlcihsbWFwcGVyLCBybWFwcGVyLCBtKTtcbn1cblxuZnVuY3Rpb24gY2hhaW4kY2hhaW5lcihjaGFpbmVyLCBtKXtcbiAgaWYoIVouQ2hhaW4udGVzdChtKSkgaW52YWxpZEFyZ3VtZW50KCdGdXR1cmUuY2hhaW4nLCAxLCAnYmUgYSBDaGFpbicsIG0pO1xuICByZXR1cm4gWi5jaGFpbihjaGFpbmVyLCBtKTtcbn1cblxuZnVuY3Rpb24gY2hhaW4oY2hhaW5lciwgbSl7XG4gIGlmKCFpc0Z1bmN0aW9uKGNoYWluZXIpKSBpbnZhbGlkQXJndW1lbnQoJ0Z1dHVyZS5jaGFpbicsIDAsICdiZSBhIEZ1bmN0aW9uJywgY2hhaW5lcik7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiBwYXJ0aWFsMShjaGFpbiRjaGFpbmVyLCBjaGFpbmVyKTtcbiAgcmV0dXJuIGNoYWluJGNoYWluZXIoY2hhaW5lciwgbSk7XG59XG5cbmZ1bmN0aW9uIG1hcFJlaiRtYXBwZXIobWFwcGVyLCBtKXtcbiAgaWYoIWlzRnV0dXJlKG0pKSBpbnZhbGlkRnV0dXJlKCdGdXR1cmUubWFwUmVqJywgMSwgbSk7XG4gIHJldHVybiBtLm1hcFJlaihtYXBwZXIpO1xufVxuXG5mdW5jdGlvbiBtYXBSZWoobWFwcGVyLCBtKXtcbiAgaWYoIWlzRnVuY3Rpb24obWFwcGVyKSkgaW52YWxpZEFyZ3VtZW50KCdGdXR1cmUubWFwUmVqJywgMCwgJ2JlIGEgRnVuY3Rpb24nLCBtYXBwZXIpO1xuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gcGFydGlhbDEobWFwUmVqJG1hcHBlciwgbWFwcGVyKTtcbiAgcmV0dXJuIG1hcFJlaiRtYXBwZXIobWFwcGVyLCBtKTtcbn1cblxuZnVuY3Rpb24gY2hhaW5SZWokY2hhaW5lcihjaGFpbmVyLCBtKXtcbiAgaWYoIWlzRnV0dXJlKG0pKSBpbnZhbGlkRnV0dXJlKCdGdXR1cmUuY2hhaW5SZWonLCAxLCBtKTtcbiAgcmV0dXJuIG0uY2hhaW5SZWooY2hhaW5lcik7XG59XG5cbmZ1bmN0aW9uIGNoYWluUmVqKGNoYWluZXIsIG0pe1xuICBpZighaXNGdW5jdGlvbihjaGFpbmVyKSkgaW52YWxpZEFyZ3VtZW50KCdGdXR1cmUuY2hhaW5SZWonLCAwLCAnYmUgYSBGdW5jdGlvbicsIGNoYWluZXIpO1xuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gcGFydGlhbDEoY2hhaW5SZWokY2hhaW5lciwgY2hhaW5lcik7XG4gIHJldHVybiBjaGFpblJlaiRjaGFpbmVyKGNoYWluZXIsIG0pO1xufVxuXG5mdW5jdGlvbiBsYXN0bHkkcmlnaHQocmlnaHQsIGxlZnQpe1xuICBpZighaXNGdXR1cmUobGVmdCkpIGludmFsaWRGdXR1cmUoJ0Z1dHVyZS5maW5hbGx5JywgMSwgbGVmdCk7XG4gIHJldHVybiBsZWZ0LmZpbmFsbHkocmlnaHQpO1xufVxuXG5mdW5jdGlvbiBsYXN0bHkocmlnaHQsIGxlZnQpe1xuICBpZighaXNGdXR1cmUocmlnaHQpKSBpbnZhbGlkRnV0dXJlKCdGdXR1cmUuZmluYWxseScsIDAsIHJpZ2h0KTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhcnRpYWwxKGxhc3RseSRyaWdodCwgcmlnaHQpO1xuICByZXR1cm4gbGFzdGx5JHJpZ2h0KHJpZ2h0LCBsZWZ0KTtcbn1cblxuZnVuY3Rpb24gYW5kJGxlZnQobGVmdCwgcmlnaHQpe1xuICBpZighaXNGdXR1cmUocmlnaHQpKSBpbnZhbGlkRnV0dXJlKCdGdXR1cmUuYW5kJywgMSwgcmlnaHQpO1xuICByZXR1cm4gbGVmdC5hbmQocmlnaHQpO1xufVxuXG5mdW5jdGlvbiBhbmQobGVmdCwgcmlnaHQpe1xuICBpZighaXNGdXR1cmUobGVmdCkpIGludmFsaWRGdXR1cmUoJ0Z1dHVyZS5hbmQnLCAwLCBsZWZ0KTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhcnRpYWwxKGFuZCRsZWZ0LCBsZWZ0KTtcbiAgcmV0dXJuIGFuZCRsZWZ0KGxlZnQsIHJpZ2h0KTtcbn1cblxuZnVuY3Rpb24gYm90aCRsZWZ0KGxlZnQsIHJpZ2h0KXtcbiAgaWYoIWlzRnV0dXJlKHJpZ2h0KSkgaW52YWxpZEZ1dHVyZSgnRnV0dXJlLmJvdGgnLCAxLCByaWdodCk7XG4gIHJldHVybiBsZWZ0LmJvdGgocmlnaHQpO1xufVxuXG5mdW5jdGlvbiBib3RoKGxlZnQsIHJpZ2h0KXtcbiAgaWYoIWlzRnV0dXJlKGxlZnQpKSBpbnZhbGlkRnV0dXJlKCdGdXR1cmUuYm90aCcsIDAsIGxlZnQpO1xuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gcGFydGlhbDEoYm90aCRsZWZ0LCBsZWZ0KTtcbiAgcmV0dXJuIGJvdGgkbGVmdChsZWZ0LCByaWdodCk7XG59XG5cbmZ1bmN0aW9uIG9yJGxlZnQobGVmdCwgcmlnaHQpe1xuICBpZighaXNGdXR1cmUocmlnaHQpKSBpbnZhbGlkRnV0dXJlKCdGdXR1cmUub3InLCAxLCByaWdodCk7XG4gIHJldHVybiBsZWZ0Lm9yKHJpZ2h0KTtcbn1cblxuZnVuY3Rpb24gb3IobGVmdCwgcmlnaHQpe1xuICBpZighaXNGdXR1cmUobGVmdCkpIGludmFsaWRGdXR1cmUoJ0Z1dHVyZS5vcicsIDAsIGxlZnQpO1xuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gcGFydGlhbDEob3IkbGVmdCwgbGVmdCk7XG4gIHJldHVybiBvciRsZWZ0KGxlZnQsIHJpZ2h0KTtcbn1cblxuZnVuY3Rpb24gcmFjZSRyaWdodChyaWdodCwgbGVmdCl7XG4gIGlmKCFpc0Z1dHVyZShsZWZ0KSkgaW52YWxpZEZ1dHVyZSgnRnV0dXJlLnJhY2UnLCAxLCBsZWZ0KTtcbiAgcmV0dXJuIGxlZnQucmFjZShyaWdodCk7XG59XG5cbmZ1bmN0aW9uIHJhY2UocmlnaHQsIGxlZnQpe1xuICBpZighaXNGdXR1cmUocmlnaHQpKSBpbnZhbGlkRnV0dXJlKCdGdXR1cmUucmFjZScsIDAsIHJpZ2h0KTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhcnRpYWwxKHJhY2UkcmlnaHQsIHJpZ2h0KTtcbiAgcmV0dXJuIHJhY2UkcmlnaHQocmlnaHQsIGxlZnQpO1xufVxuXG5mdW5jdGlvbiBzd2FwKG0pe1xuICBpZighaXNGdXR1cmUobSkpIGludmFsaWRGdXR1cmUoJ0Z1dHVyZS5zd2FwJywgMCwgbSk7XG4gIHJldHVybiBtLnN3YXAoKTtcbn1cblxuZnVuY3Rpb24gZm9sZCRmJGcoZiwgZywgbSl7XG4gIGlmKCFpc0Z1dHVyZShtKSkgaW52YWxpZEZ1dHVyZSgnRnV0dXJlLmZvbGQnLCAyLCBtKTtcbiAgcmV0dXJuIG0uZm9sZChmLCBnKTtcbn1cblxuZnVuY3Rpb24gZm9sZCRmKGYsIGcsIG0pe1xuICBpZighaXNGdW5jdGlvbihnKSkgaW52YWxpZEFyZ3VtZW50KCdGdXR1cmUuZm9sZCcsIDEsICdiZSBhIGZ1bmN0aW9uJywgZyk7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHJldHVybiBwYXJ0aWFsMihmb2xkJGYkZywgZiwgZyk7XG4gIHJldHVybiBmb2xkJGYkZyhmLCBnLCBtKTtcbn1cblxuZnVuY3Rpb24gZm9sZChmLCBnLCBtKXtcbiAgaWYoIWlzRnVuY3Rpb24oZikpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlLmZvbGQnLCAwLCAnYmUgYSBmdW5jdGlvbicsIGYpO1xuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gcGFydGlhbDEoZm9sZCRmLCBmKTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgcmV0dXJuIGZvbGQkZihmLCBnKTtcbiAgcmV0dXJuIGZvbGQkZihmLCBnLCBtKTtcbn1cblxuZnVuY3Rpb24gZG9uZSRjYWxsYmFjayhjYWxsYmFjaywgbSl7XG4gIGlmKCFpc0Z1dHVyZShtKSkgaW52YWxpZEZ1dHVyZSgnRnV0dXJlLmRvbmUnLCAxLCBtKTtcbiAgcmV0dXJuIG0uZG9uZShjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGRvbmUoY2FsbGJhY2ssIG0pe1xuICBpZighaXNGdW5jdGlvbihjYWxsYmFjaykpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlLmRvbmUnLCAwLCAnYmUgYSBGdW5jdGlvbicsIGNhbGxiYWNrKTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhcnRpYWwxKGRvbmUkY2FsbGJhY2ssIGNhbGxiYWNrKTtcbiAgcmV0dXJuIGRvbmUkY2FsbGJhY2soY2FsbGJhY2ssIG0pO1xufVxuXG5mdW5jdGlvbiBmb3JrJGYkZyhmLCBnLCBtKXtcbiAgaWYoIWlzRnV0dXJlKG0pKSBpbnZhbGlkRnV0dXJlKCdGdXR1cmUuZm9yaycsIDIsIG0pO1xuICByZXR1cm4gbS5fZm9yayhmLCBnKTtcbn1cblxuZnVuY3Rpb24gZm9yayRmKGYsIGcsIG0pe1xuICBpZighaXNGdW5jdGlvbihnKSkgaW52YWxpZEFyZ3VtZW50KCdGdXR1cmUuZm9yaycsIDEsICdiZSBhIGZ1bmN0aW9uJywgZyk7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHJldHVybiBwYXJ0aWFsMihmb3JrJGYkZywgZiwgZyk7XG4gIHJldHVybiBmb3JrJGYkZyhmLCBnLCBtKTtcbn1cblxuZnVuY3Rpb24gZm9yayhmLCBnLCBtKXtcbiAgaWYoIWlzRnVuY3Rpb24oZikpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlLmZvcmsnLCAwLCAnYmUgYSBmdW5jdGlvbicsIGYpO1xuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gcGFydGlhbDEoZm9yayRmLCBmKTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgcmV0dXJuIGZvcmskZihmLCBnKTtcbiAgcmV0dXJuIGZvcmskZihmLCBnLCBtKTtcbn1cblxuZnVuY3Rpb24gcHJvbWlzZShtKXtcbiAgaWYoIWlzRnV0dXJlKG0pKSBpbnZhbGlkRnV0dXJlKCdGdXR1cmUucHJvbWlzZScsIDAsIG0pO1xuICByZXR1cm4gbS5wcm9taXNlKCk7XG59XG5cbmZ1bmN0aW9uIHZhbHVlJGNvbnQoY29udCwgbSl7XG4gIGlmKCFpc0Z1dHVyZShtKSkgaW52YWxpZEZ1dHVyZSgnRnV0dXJlLnZhbHVlJywgMSwgbSk7XG4gIHJldHVybiBtLnZhbHVlKGNvbnQpO1xufVxuXG5mdW5jdGlvbiB2YWx1ZShjb250LCBtKXtcbiAgaWYoIWlzRnVuY3Rpb24oY29udCkpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlLnZhbHVlJywgMCwgJ2JlIGEgRnVuY3Rpb24nLCBjb250KTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhcnRpYWwxKHZhbHVlJGNvbnQsIGNvbnQpO1xuICByZXR1cm4gdmFsdWUkY29udChjb250LCBtKTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdExlZnQobSl7XG4gIGlmKCFpc0Z1dHVyZShtKSkgaW52YWxpZEZ1dHVyZSgnRnV0dXJlLmV4dHJhY3RMZWZ0JywgMCwgbSk7XG4gIHJldHVybiBtLmV4dHJhY3RMZWZ0KCk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RSaWdodChtKXtcbiAgaWYoIWlzRnV0dXJlKG0pKSBpbnZhbGlkRnV0dXJlKCdGdXR1cmUuZXh0cmFjdFJpZ2h0JywgMCwgbSk7XG4gIHJldHVybiBtLmV4dHJhY3RSaWdodCgpO1xufVxuXG5mdW5jdGlvbiBjaGVjayRhcCRmKGYpe1xuICBpZighaXNGdW5jdGlvbihmKSkgdHlwZUVycm9yKFxuICAgICdGdXR1cmUjYXAgZXhwZWN0cyBpdHMgZmlyc3QgYXJndW1lbnQgdG8gYmUgYSBGdXR1cmUgb2YgYSBGdW5jdGlvbidcbiAgICArICdcXG4gIEFjdHVhbDogRnV0dXJlLm9mKCcgKyBzaG93KGYpICsgJyknXG4gICk7XG59XG5cbmZ1bmN0aW9uIFBhcmFsbGVsQXAobXZhbCwgbWZ1bmMpe1xuICB0aGlzLl9tdmFsID0gbXZhbDtcbiAgdGhpcy5fbWZ1bmMgPSBtZnVuYztcbn1cblxuUGFyYWxsZWxBcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvcmUpO1xuXG5QYXJhbGxlbEFwLnByb3RvdHlwZS5fZm9yayA9IGZ1bmN0aW9uIFBhcmFsbGVsQXAkZm9yayhyZWosIHJlcyl7XG4gIHZhciBmdW5jLCB2YWwsIG9rdmFsID0gZmFsc2UsIG9rZnVuYyA9IGZhbHNlLCByZWplY3RlZCA9IGZhbHNlLCBjMSwgYzI7XG5cbiAgZnVuY3Rpb24gUGFyYWxsZWxBcCRyZWooeCl7XG4gICAgaWYoIXJlamVjdGVkKXtcbiAgICAgIHJlamVjdGVkID0gdHJ1ZTtcbiAgICAgIHJlaih4KTtcbiAgICB9XG4gIH1cblxuICBjMSA9IHRoaXMuX212YWwuX2ZvcmsoUGFyYWxsZWxBcCRyZWosIGZ1bmN0aW9uIFBhcmFsbGVsQXAkZm9yayRyZXNWYWwoeCl7XG4gICAgYzEgPSBub29wO1xuICAgIGlmKCFva3ZhbCkgcmV0dXJuIHZvaWQgKG9rZnVuYyA9IHRydWUsIHZhbCA9IHgpO1xuICAgIHJlcyhmdW5jKHgpKTtcbiAgfSk7XG4gIGMyID0gdGhpcy5fbWZ1bmMuX2ZvcmsoUGFyYWxsZWxBcCRyZWosIGZ1bmN0aW9uIFBhcmFsbGVsQXAkZm9yayRyZXNGdW5jKGYpe1xuICAgIGMyID0gbm9vcDtcbiAgICBjaGVjayRhcCRmKGYpO1xuICAgIGlmKCFva2Z1bmMpIHJldHVybiB2b2lkIChva3ZhbCA9IHRydWUsIGZ1bmMgPSBmKTtcbiAgICByZXMoZih2YWwpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIFBhcmFsbGVsQXAkZm9yayRjYW5jZWwoKXtcbiAgICBjMSgpO1xuICAgIGMyKCk7XG4gIH07XG59O1xuXG5QYXJhbGxlbEFwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIFBhcmFsbGVsQXAkdG9TdHJpbmcoKXtcbiAgcmV0dXJuICduZXcgUGFyYWxsZWxBcCgnICsgdGhpcy5fbXZhbC50b1N0cmluZygpICsgJywgJyArIHRoaXMuX21mdW5jLnRvU3RyaW5nKCkgKyAnKSc7XG59O1xuXG5mdW5jdGlvbiBwYXJhbGxlbEFwKG12YWwsIG1mdW5jKXtcbiAgcmV0dXJuIG5ldyBQYXJhbGxlbEFwKG12YWwsIG1mdW5jKTtcbn1cblxuZnVuY3Rpb24gQWZ0ZXIkcmFjZShvdGhlcil7XG4gIHJldHVybiBvdGhlci5pc1NldHRsZWQoKVxuICAgICAgID8gb3RoZXJcbiAgICAgICA6IGlzTmV2ZXIob3RoZXIpXG4gICAgICAgPyB0aGlzXG4gICAgICAgOiB0eXBlb2Ygb3RoZXIuX3RpbWUgPT09ICdudW1iZXInXG4gICAgICAgPyBvdGhlci5fdGltZSA8IHRoaXMuX3RpbWUgPyBvdGhlciA6IHRoaXNcbiAgICAgICA6IENvcmUuX3JhY2UuY2FsbCh0aGlzLCBvdGhlcik7XG59XG5cbmZ1bmN0aW9uIEFmdGVyKHRpbWUsIHZhbHVlKXtcbiAgdGhpcy5fdGltZSA9IHRpbWU7XG4gIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG59XG5cbkFmdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29yZSk7XG5cbkFmdGVyLnByb3RvdHlwZS5fcmFjZSA9IEFmdGVyJHJhY2U7XG5cbkFmdGVyLnByb3RvdHlwZS5fc3dhcCA9IGZ1bmN0aW9uIEFmdGVyJHN3YXAoKXtcbiAgcmV0dXJuIG5ldyBSZWplY3RBZnRlcih0aGlzLl90aW1lLCB0aGlzLl92YWx1ZSk7XG59O1xuXG5BZnRlci5wcm90b3R5cGUuX2ZvcmsgPSBmdW5jdGlvbiBBZnRlciRfZm9yayhyZWosIHJlcyl7XG4gIHZhciBpZCA9IHNldFRpbWVvdXQocmVzLCB0aGlzLl90aW1lLCB0aGlzLl92YWx1ZSk7XG4gIHJldHVybiBmdW5jdGlvbiBBZnRlciRjYW5jZWwoKXsgY2xlYXJUaW1lb3V0KGlkKTsgfTtcbn07XG5cbkFmdGVyLnByb3RvdHlwZS5leHRyYWN0UmlnaHQgPSBmdW5jdGlvbiBBZnRlciRleHRyYWN0UmlnaHQoKXtcbiAgcmV0dXJuIFt0aGlzLl92YWx1ZV07XG59O1xuXG5BZnRlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBBZnRlciR0b1N0cmluZygpe1xuICByZXR1cm4gJ0Z1dHVyZS5hZnRlcignICsgc2hvdyh0aGlzLl90aW1lKSArICcsICcgKyBzaG93KHRoaXMuX3ZhbHVlKSArICcpJztcbn07XG5cbmZ1bmN0aW9uIFJlamVjdEFmdGVyKHRpbWUsIHZhbHVlKXtcbiAgdGhpcy5fdGltZSA9IHRpbWU7XG4gIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG59XG5cblJlamVjdEFmdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29yZSk7XG5cblJlamVjdEFmdGVyLnByb3RvdHlwZS5fcmFjZSA9IEFmdGVyJHJhY2U7XG5cblJlamVjdEFmdGVyLnByb3RvdHlwZS5fc3dhcCA9IGZ1bmN0aW9uIFJlamVjdEFmdGVyJHN3YXAoKXtcbiAgcmV0dXJuIG5ldyBBZnRlcih0aGlzLl90aW1lLCB0aGlzLl92YWx1ZSk7XG59O1xuXG5SZWplY3RBZnRlci5wcm90b3R5cGUuX2ZvcmsgPSBmdW5jdGlvbiBSZWplY3RBZnRlciRfZm9yayhyZWope1xuICB2YXIgaWQgPSBzZXRUaW1lb3V0KHJlaiwgdGhpcy5fdGltZSwgdGhpcy5fdmFsdWUpO1xuICByZXR1cm4gZnVuY3Rpb24gUmVqZWN0QWZ0ZXIkY2FuY2VsKCl7IGNsZWFyVGltZW91dChpZCk7IH07XG59O1xuXG5SZWplY3RBZnRlci5wcm90b3R5cGUuZXh0cmFjdExlZnQgPSBmdW5jdGlvbiBSZWplY3RBZnRlciRleHRyYWN0TGVmdCgpe1xuICByZXR1cm4gW3RoaXMuX3ZhbHVlXTtcbn07XG5cblJlamVjdEFmdGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIFJlamVjdEFmdGVyJHRvU3RyaW5nKCl7XG4gIHJldHVybiAnRnV0dXJlLnJlamVjdEFmdGVyKCcgKyBzaG93KHRoaXMuX3RpbWUpICsgJywgJyArIHNob3codGhpcy5fdmFsdWUpICsgJyknO1xufTtcblxuZnVuY3Rpb24gYWZ0ZXIkdGltZSh0aW1lLCB2YWx1ZSl7XG4gIHJldHVybiB0aW1lID09PSBJbmZpbml0eSA/IG5ldmVyIDogbmV3IEFmdGVyKHRpbWUsIHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gYWZ0ZXIodGltZSwgdmFsdWUpe1xuICBpZighaXNVbnNpZ25lZCh0aW1lKSkgaW52YWxpZEFyZ3VtZW50KCdGdXR1cmUuYWZ0ZXInLCAwLCAnYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJywgdGltZSk7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiBwYXJ0aWFsMShhZnRlciR0aW1lLCB0aW1lKTtcbiAgcmV0dXJuIGFmdGVyJHRpbWUodGltZSwgdmFsdWUpO1xufVxuXG5mdW5jdGlvbiByZWplY3RBZnRlciR0aW1lKHRpbWUsIHJlYXNvbil7XG4gIHJldHVybiB0aW1lID09PSBJbmZpbml0eSA/IG5ldmVyIDogbmV3IFJlamVjdEFmdGVyKHRpbWUsIHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIHJlamVjdEFmdGVyKHRpbWUsIHJlYXNvbil7XG4gIGlmKCFpc1Vuc2lnbmVkKHRpbWUpKSBpbnZhbGlkQXJndW1lbnQoJ0Z1dHVyZS5yZWplY3RBZnRlcicsIDAsICdiZSBhIHBvc2l0aXZlIGludGVnZXInLCB0aW1lKTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhcnRpYWwxKHJlamVjdEFmdGVyJHRpbWUsIHRpbWUpO1xuICByZXR1cm4gcmVqZWN0QWZ0ZXIkdGltZSh0aW1lLCByZWFzb24pO1xufVxuXG5mdW5jdGlvbiBBdHRlbXB0KGZuKXtcbiAgdGhpcy5fZm4gPSBmbjtcbn1cblxuQXR0ZW1wdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvcmUpO1xuXG5BdHRlbXB0LnByb3RvdHlwZS5fZm9yayA9IGZ1bmN0aW9uIEF0dGVtcHQkZm9yayhyZWosIHJlcyl7XG4gIHZhciByO1xuICB0cnl7IHIgPSB0aGlzLl9mbigpOyB9Y2F0Y2goZSl7IHJlaihlKTsgcmV0dXJuIG5vb3AgfVxuICByZXMocik7XG4gIHJldHVybiBub29wO1xufTtcblxuQXR0ZW1wdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBBdHRlbXB0JHRvU3RyaW5nKCl7XG4gIHJldHVybiAnRnV0dXJlLnRyeSgnICsgc2hvd2YodGhpcy5fZm4pICsgJyknO1xufTtcblxuZnVuY3Rpb24gYXR0ZW1wdChmKXtcbiAgaWYoIWlzRnVuY3Rpb24oZikpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlLnRyeScsIDAsICdiZSBhIGZ1bmN0aW9uJywgZik7XG4gIHJldHVybiBuZXcgQXR0ZW1wdChmKTtcbn1cblxudmFyIENvbGQgPSBDYWNoZWQuQ29sZCA9IDA7XG52YXIgUGVuZGluZyA9IENhY2hlZC5QZW5kaW5nID0gMTtcbnZhciBSZWplY3RlZCQxID0gQ2FjaGVkLlJlamVjdGVkID0gMjtcbnZhciBSZXNvbHZlZCQxID0gQ2FjaGVkLlJlc29sdmVkID0gMztcblxuZnVuY3Rpb24gUXVldWVkKHJlaiwgcmVzKXtcbiAgdGhpc1tSZWplY3RlZCQxXSA9IHJlajtcbiAgdGhpc1tSZXNvbHZlZCQxXSA9IHJlcztcbn1cblxuZnVuY3Rpb24gQ2FjaGVkKHB1cmUpe1xuICB0aGlzLl9wdXJlID0gcHVyZTtcbiAgdGhpcy5yZXNldCgpO1xufVxuXG5DYWNoZWQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb3JlKTtcblxuQ2FjaGVkLnByb3RvdHlwZS5pc1JlamVjdGVkID0gZnVuY3Rpb24gQ2FjaGVkJGlzUmVqZWN0ZWQoKXtcbiAgcmV0dXJuIHRoaXMuX3N0YXRlID09PSBSZWplY3RlZCQxO1xufTtcblxuQ2FjaGVkLnByb3RvdHlwZS5pc1Jlc29sdmVkID0gZnVuY3Rpb24gQ2FjaGVkJGlzUmVzb2x2ZWQoKXtcbiAgcmV0dXJuIHRoaXMuX3N0YXRlID09PSBSZXNvbHZlZCQxO1xufTtcblxuQ2FjaGVkLnByb3RvdHlwZS5leHRyYWN0TGVmdCA9IGZ1bmN0aW9uIENhY2hlZCRleHRyYWN0TGVmdCgpe1xuICByZXR1cm4gdGhpcy5pc1JlamVjdGVkKCkgPyBbdGhpcy5fdmFsdWVdIDogW107XG59O1xuXG5DYWNoZWQucHJvdG90eXBlLmV4dHJhY3RSaWdodCA9IGZ1bmN0aW9uIENhY2hlZCRleHRyYWN0UmlnaHQoKXtcbiAgcmV0dXJuIHRoaXMuaXNSZXNvbHZlZCgpID8gW3RoaXMuX3ZhbHVlXSA6IFtdO1xufTtcblxuQ2FjaGVkLnByb3RvdHlwZS5fYWRkVG9RdWV1ZSA9IGZ1bmN0aW9uIENhY2hlZCRhZGRUb1F1ZXVlKHJlaiwgcmVzKXtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgaWYoX3RoaXMuX3N0YXRlID4gUGVuZGluZykgcmV0dXJuIG5vb3A7XG4gIHZhciBpID0gX3RoaXMuX3F1ZXVlLnB1c2gobmV3IFF1ZXVlZChyZWosIHJlcykpIC0gMTtcbiAgX3RoaXMuX3F1ZXVlZCA9IF90aGlzLl9xdWV1ZWQgKyAxO1xuXG4gIHJldHVybiBmdW5jdGlvbiBDYWNoZWQkcmVtb3ZlRnJvbVF1ZXVlKCl7XG4gICAgaWYoX3RoaXMuX3N0YXRlID4gUGVuZGluZykgcmV0dXJuO1xuICAgIF90aGlzLl9xdWV1ZVtpXSA9IHVuZGVmaW5lZDtcbiAgICBfdGhpcy5fcXVldWVkID0gX3RoaXMuX3F1ZXVlZCAtIDE7XG4gICAgaWYoX3RoaXMuX3F1ZXVlZCA9PT0gMCkgX3RoaXMucmVzZXQoKTtcbiAgfTtcbn07XG5cbkNhY2hlZC5wcm90b3R5cGUuX2RyYWluUXVldWUgPSBmdW5jdGlvbiBDYWNoZWQkZHJhaW5RdWV1ZSgpe1xuICBpZih0aGlzLl9zdGF0ZSA8PSBQZW5kaW5nKSByZXR1cm47XG4gIGlmKHRoaXMuX3F1ZXVlZCA9PT0gMCkgcmV0dXJuO1xuICB2YXIgcXVldWUgPSB0aGlzLl9xdWV1ZTtcbiAgdmFyIGxlbmd0aCA9IHF1ZXVlLmxlbmd0aDtcbiAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gIHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlO1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyl7XG4gICAgcXVldWVbaV0gJiYgcXVldWVbaV1bc3RhdGVdKHZhbHVlKTtcbiAgICBxdWV1ZVtpXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRoaXMuX3F1ZXVlID0gdW5kZWZpbmVkO1xuICB0aGlzLl9xdWV1ZWQgPSAwO1xufTtcblxuQ2FjaGVkLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbiBDYWNoZWQkcmVqZWN0KHJlYXNvbil7XG4gIGlmKHRoaXMuX3N0YXRlID4gUGVuZGluZykgcmV0dXJuO1xuICB0aGlzLl92YWx1ZSA9IHJlYXNvbjtcbiAgdGhpcy5fc3RhdGUgPSBSZWplY3RlZCQxO1xuICB0aGlzLl9kcmFpblF1ZXVlKCk7XG59O1xuXG5DYWNoZWQucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiBDYWNoZWQkcmVzb2x2ZSh2YWx1ZSl7XG4gIGlmKHRoaXMuX3N0YXRlID4gUGVuZGluZykgcmV0dXJuO1xuICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICB0aGlzLl9zdGF0ZSA9IFJlc29sdmVkJDE7XG4gIHRoaXMuX2RyYWluUXVldWUoKTtcbn07XG5cbkNhY2hlZC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gQ2FjaGVkJHJ1bigpe1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICBpZihfdGhpcy5fc3RhdGUgPiBDb2xkKSByZXR1cm47XG4gIF90aGlzLl9zdGF0ZSA9IFBlbmRpbmc7XG4gIF90aGlzLl9jYW5jZWwgPSBfdGhpcy5fcHVyZS5fZm9yayhcbiAgICBmdW5jdGlvbiBDYWNoZWQkZm9yayRyZWooeCl7IF90aGlzLnJlamVjdCh4KTsgfSxcbiAgICBmdW5jdGlvbiBDYWNoZWQkZm9yayRyZXMoeCl7IF90aGlzLnJlc29sdmUoeCk7IH1cbiAgKTtcbn07XG5cbkNhY2hlZC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiBDYWNoZWQkcmVzZXQoKXtcbiAgaWYodGhpcy5fc3RhdGUgPT09IENvbGQpIHJldHVybjtcbiAgaWYodGhpcy5fc3RhdGUgPiBQZW5kaW5nKSB0aGlzLl9jYW5jZWwoKTtcbiAgdGhpcy5fY2FuY2VsID0gbm9vcDtcbiAgdGhpcy5fcXVldWUgPSBbXTtcbiAgdGhpcy5fcXVldWVkID0gMDtcbiAgdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XG4gIHRoaXMuX3N0YXRlID0gQ29sZDtcbn07XG5cbkNhY2hlZC5wcm90b3R5cGUuX2ZvcmsgPSBmdW5jdGlvbiBDYWNoZWQkX2ZvcmsocmVqLCByZXMpe1xuICB2YXIgY2FuY2VsID0gbm9vcDtcblxuICBzd2l0Y2godGhpcy5fc3RhdGUpe1xuICAgIGNhc2UgUGVuZGluZzogY2FuY2VsID0gdGhpcy5fYWRkVG9RdWV1ZShyZWosIHJlcyk7IGJyZWFrO1xuICAgIGNhc2UgUmVqZWN0ZWQkMTogcmVqKHRoaXMuX3ZhbHVlKTsgYnJlYWs7XG4gICAgY2FzZSBSZXNvbHZlZCQxOiByZXModGhpcy5fdmFsdWUpOyBicmVhaztcbiAgICBkZWZhdWx0OiBjYW5jZWwgPSB0aGlzLl9hZGRUb1F1ZXVlKHJlaiwgcmVzKTsgdGhpcy5ydW4oKTtcbiAgfVxuXG4gIHJldHVybiBjYW5jZWw7XG59O1xuXG5DYWNoZWQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gQ2FjaGVkJHRvU3RyaW5nKCl7XG4gIHJldHVybiAnRnV0dXJlLmNhY2hlKCcgKyB0aGlzLl9wdXJlLnRvU3RyaW5nKCkgKyAnKSc7XG59O1xuXG5mdW5jdGlvbiBjYWNoZShtKXtcbiAgaWYoIWlzRnV0dXJlKG0pKSBpbnZhbGlkRnV0dXJlKCdGdXR1cmUuY2FjaGUnLCAwLCBtKTtcbiAgcmV0dXJuIG5ldyBDYWNoZWQobSk7XG59XG5cbmZ1bmN0aW9uIEVuY2FzZShmbiwgYSl7XG4gIHRoaXMuX2ZuID0gZm47XG4gIHRoaXMuX2EgPSBhO1xufVxuXG5FbmNhc2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb3JlKTtcblxuRW5jYXNlLnByb3RvdHlwZS5fZm9yayA9IGZ1bmN0aW9uIEVuY2FzZSRmb3JrKHJlaiwgcmVzKXtcbiAgdmFyIHI7XG4gIHRyeXsgciA9IHRoaXMuX2ZuKHRoaXMuX2EpOyB9Y2F0Y2goZSl7IHJlaihlKTsgcmV0dXJuIG5vb3AgfVxuICByZXMocik7XG4gIHJldHVybiBub29wO1xufTtcblxuRW5jYXNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIEVuY2FzZSR0b1N0cmluZygpe1xuICByZXR1cm4gJ0Z1dHVyZS5lbmNhc2UoJyArIHNob3dmKHRoaXMuX2ZuKSArICcsICcgKyBzaG93KHRoaXMuX2EpICsgJyknO1xufTtcblxuZnVuY3Rpb24gZW5jYXNlKGYsIHgpe1xuICBpZighaXNGdW5jdGlvbihmKSkgaW52YWxpZEFyZ3VtZW50KCdGdXR1cmUuZW5jYXNlJywgMCwgJ2JlIGEgZnVuY3Rpb24nLCBmKTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhcnRpYWwxKGVuY2FzZSwgZik7XG4gIHJldHVybiBuZXcgRW5jYXNlKGYsIHgpO1xufVxuXG5mdW5jdGlvbiBFbmNhc2UyKGZuLCBhLCBiKXtcbiAgdGhpcy5fZm4gPSBmbjtcbiAgdGhpcy5fYSA9IGE7XG4gIHRoaXMuX2IgPSBiO1xufVxuXG5FbmNhc2UyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29yZSk7XG5cbkVuY2FzZTIucHJvdG90eXBlLl9mb3JrID0gZnVuY3Rpb24gRW5jYXNlMiRmb3JrKHJlaiwgcmVzKXtcbiAgdmFyIHI7XG4gIHRyeXsgciA9IHRoaXMuX2ZuKHRoaXMuX2EsIHRoaXMuX2IpOyB9Y2F0Y2goZSl7IHJlaihlKTsgcmV0dXJuIG5vb3AgfVxuICByZXMocik7XG4gIHJldHVybiBub29wO1xufTtcblxuRW5jYXNlMi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBFbmNhc2UyJHRvU3RyaW5nKCl7XG4gIHJldHVybiAnRnV0dXJlLmVuY2FzZTIoJyArIHNob3dmKHRoaXMuX2ZuKSArICcsICcgKyBzaG93KHRoaXMuX2EpICsgJywgJyArIHNob3codGhpcy5fYikgKyAnKSc7XG59O1xuXG5mdW5jdGlvbiBlbmNhc2UyKGYsIHgsIHkpe1xuICBpZighaXNGdW5jdGlvbihmKSkgaW52YWxpZEFyZ3VtZW50KCdGdXR1cmUuZW5jYXNlMicsIDAsICdiZSBhIGZ1bmN0aW9uJywgZik7XG5cbiAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIHBhcnRpYWwxKGVuY2FzZTIsIGYpO1xuICAgIGNhc2UgMjogcmV0dXJuIHBhcnRpYWwyKGVuY2FzZTIsIGYsIHgpO1xuICAgIGRlZmF1bHQ6IHJldHVybiBuZXcgRW5jYXNlMihmLCB4LCB5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBFbmNhc2UzKGZuLCBhLCBiLCBjKXtcbiAgdGhpcy5fZm4gPSBmbjtcbiAgdGhpcy5fYSA9IGE7XG4gIHRoaXMuX2IgPSBiO1xuICB0aGlzLl9jID0gYztcbn1cblxuRW5jYXNlMy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvcmUpO1xuXG5FbmNhc2UzLnByb3RvdHlwZS5fZm9yayA9IGZ1bmN0aW9uIEVuY2FzZTMkZm9yayhyZWosIHJlcyl7XG4gIHZhciByO1xuICB0cnl7IHIgPSB0aGlzLl9mbih0aGlzLl9hLCB0aGlzLl9iLCB0aGlzLl9jKTsgfWNhdGNoKGUpeyByZWooZSk7IHJldHVybiBub29wIH1cbiAgcmVzKHIpO1xuICByZXR1cm4gbm9vcDtcbn07XG5cbkVuY2FzZTMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gRW5jYXNlMyR0b1N0cmluZygpe1xuICByZXR1cm4gJ0Z1dHVyZS5lbmNhc2UzKCdcbiAgICAgICArIHNob3dmKHRoaXMuX2ZuKVxuICAgICAgICsgJywgJ1xuICAgICAgICsgc2hvdyh0aGlzLl9hKVxuICAgICAgICsgJywgJ1xuICAgICAgICsgc2hvdyh0aGlzLl9iKVxuICAgICAgICsgJywgJ1xuICAgICAgICsgc2hvdyh0aGlzLl9jKVxuICAgICAgICsgJyknO1xufTtcblxuZnVuY3Rpb24gZW5jYXNlMyhmLCB4LCB5LCB6KXtcbiAgaWYoIWlzRnVuY3Rpb24oZikpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlLmVuY2FzZTMnLCAwLCAnYmUgYSBmdW5jdGlvbicsIGYpO1xuXG4gIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBwYXJ0aWFsMShlbmNhc2UzLCBmKTtcbiAgICBjYXNlIDI6IHJldHVybiBwYXJ0aWFsMihlbmNhc2UzLCBmLCB4KTtcbiAgICBjYXNlIDM6IHJldHVybiBwYXJ0aWFsMyhlbmNhc2UzLCBmLCB4LCB5KTtcbiAgICBkZWZhdWx0OiByZXR1cm4gbmV3IEVuY2FzZTMoZiwgeCwgeSwgeik7XG4gIH1cbn1cblxuZnVuY3Rpb24gRW5jYXNlTihmbiwgYSl7XG4gIHRoaXMuX2ZuID0gZm47XG4gIHRoaXMuX2EgPSBhO1xufVxuXG5FbmNhc2VOLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29yZSk7XG5cbkVuY2FzZU4ucHJvdG90eXBlLl9mb3JrID0gZnVuY3Rpb24gRW5jYXNlTiRmb3JrKHJlaiwgcmVzKXtcbiAgdmFyIG9wZW4gPSB0cnVlO1xuICB0aGlzLl9mbih0aGlzLl9hLCBmdW5jdGlvbiBFbmNhc2VOJGRvbmUoZXJyLCB2YWwpe1xuICAgIGlmKG9wZW4pe1xuICAgICAgb3BlbiA9IGZhbHNlO1xuICAgICAgZXJyID8gcmVqKGVycikgOiByZXModmFsKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gRW5jYXNlTiRjYW5jZWwoKXsgb3BlbiA9IGZhbHNlOyB9O1xufTtcblxuRW5jYXNlTi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBFbmNhc2VOJHRvU3RyaW5nKCl7XG4gIHJldHVybiAnRnV0dXJlLmVuY2FzZU4oJyArIHNob3dmKHRoaXMuX2ZuKSArICcsICcgKyBzaG93KHRoaXMuX2EpICsgJyknO1xufTtcblxuZnVuY3Rpb24gZW5jYXNlTihmLCB4KXtcbiAgaWYoIWlzRnVuY3Rpb24oZikpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlLmVuY2FzZU4nLCAwLCAnYmUgYSBmdW5jdGlvbicsIGYpO1xuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gcGFydGlhbDEoZW5jYXNlTiwgZik7XG4gIHJldHVybiBuZXcgRW5jYXNlTihmLCB4KTtcbn1cblxuZnVuY3Rpb24gRW5jYXNlTjIoZm4sIGEsIGIpe1xuICB0aGlzLl9mbiA9IGZuO1xuICB0aGlzLl9hID0gYTtcbiAgdGhpcy5fYiA9IGI7XG59XG5cbkVuY2FzZU4yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29yZSk7XG5cbkVuY2FzZU4yLnByb3RvdHlwZS5fZm9yayA9IGZ1bmN0aW9uIEVuY2FzZU4yJGZvcmsocmVqLCByZXMpe1xuICB2YXIgb3BlbiA9IHRydWU7XG4gIHRoaXMuX2ZuKHRoaXMuX2EsIHRoaXMuX2IsIGZ1bmN0aW9uIEVuY2FzZU4yJGRvbmUoZXJyLCB2YWwpe1xuICAgIGlmKG9wZW4pe1xuICAgICAgb3BlbiA9IGZhbHNlO1xuICAgICAgZXJyID8gcmVqKGVycikgOiByZXModmFsKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gRW5jYXNlTjIkY2FuY2VsKCl7IG9wZW4gPSBmYWxzZTsgfTtcbn07XG5cbkVuY2FzZU4yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIEVuY2FzZU4yJHRvU3RyaW5nKCl7XG4gIHJldHVybiAnRnV0dXJlLmVuY2FzZU4yKCcgKyBzaG93Zih0aGlzLl9mbikgKyAnLCAnICsgc2hvdyh0aGlzLl9hKSArICcsICcgKyBzaG93KHRoaXMuX2IpICsgJyknO1xufTtcblxuZnVuY3Rpb24gZW5jYXNlTjIoZiwgeCwgeSl7XG4gIGlmKCFpc0Z1bmN0aW9uKGYpKSBpbnZhbGlkQXJndW1lbnQoJ0Z1dHVyZS5lbmNhc2VOMicsIDAsICdiZSBhIGZ1bmN0aW9uJywgZik7XG5cbiAgc3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIHBhcnRpYWwxKGVuY2FzZU4yLCBmKTtcbiAgICBjYXNlIDI6IHJldHVybiBwYXJ0aWFsMihlbmNhc2VOMiwgZiwgeCk7XG4gICAgZGVmYXVsdDogcmV0dXJuIG5ldyBFbmNhc2VOMihmLCB4LCB5KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBFbmNhc2VOJDEoZm4sIGEsIGIsIGMpe1xuICB0aGlzLl9mbiA9IGZuO1xuICB0aGlzLl9hID0gYTtcbiAgdGhpcy5fYiA9IGI7XG4gIHRoaXMuX2MgPSBjO1xufVxuXG5FbmNhc2VOJDEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb3JlKTtcblxuRW5jYXNlTiQxLnByb3RvdHlwZS5fZm9yayA9IGZ1bmN0aW9uIEVuY2FzZU4kMyRmb3JrKHJlaiwgcmVzKXtcbiAgdmFyIG9wZW4gPSB0cnVlO1xuICB0aGlzLl9mbih0aGlzLl9hLCB0aGlzLl9iLCB0aGlzLl9jLCBmdW5jdGlvbiBFbmNhc2VOJDMkZG9uZShlcnIsIHZhbCl7XG4gICAgaWYob3Blbil7XG4gICAgICBvcGVuID0gZmFsc2U7XG4gICAgICBlcnIgPyByZWooZXJyKSA6IHJlcyh2YWwpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbiBFbmNhc2VOJDMkY2FuY2VsKCl7IG9wZW4gPSBmYWxzZTsgfTtcbn07XG5cbkVuY2FzZU4kMS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBFbmNhc2VOJDMkdG9TdHJpbmcoKXtcbiAgcmV0dXJuICdGdXR1cmUuZW5jYXNlTjMoJ1xuICAgICAgICsgc2hvd2YodGhpcy5fZm4pXG4gICAgICAgKyAnLCAnXG4gICAgICAgKyBzaG93KHRoaXMuX2EpXG4gICAgICAgKyAnLCAnXG4gICAgICAgKyBzaG93KHRoaXMuX2IpXG4gICAgICAgKyAnLCAnXG4gICAgICAgKyBzaG93KHRoaXMuX2MpXG4gICAgICAgKyAnKSc7XG59O1xuXG5mdW5jdGlvbiBlbmNhc2VOMyhmLCB4LCB5LCB6KXtcbiAgaWYoIWlzRnVuY3Rpb24oZikpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlLmVuY2FzZU4zJywgMCwgJ2JlIGEgZnVuY3Rpb24nLCBmKTtcblxuICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gcGFydGlhbDEoZW5jYXNlTjMsIGYpO1xuICAgIGNhc2UgMjogcmV0dXJuIHBhcnRpYWwyKGVuY2FzZU4zLCBmLCB4KTtcbiAgICBjYXNlIDM6IHJldHVybiBwYXJ0aWFsMyhlbmNhc2VOMywgZiwgeCwgeSk7XG4gICAgZGVmYXVsdDogcmV0dXJuIG5ldyBFbmNhc2VOJDEoZiwgeCwgeSwgeik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2skcHJvbWlzZShwLCBmLCBhKXtcbiAgcmV0dXJuIGlzVGhlbmFibGUocCkgPyBwIDogdHlwZUVycm9yKFxuICAgICdGdXR1cmUuZW5jYXNlUCBleHBlY3RzIHRoZSBmdW5jdGlvbiBpdFxcJ3MgZ2l2ZW4gdG8gcmV0dXJuIGEgUHJvbWlzZS9UaGVuYWJsZSdcbiAgICArICdcXG4gIEFjdHVhbDogJyArIChzaG93KHApKSArICdcXG4gIEZyb20gY2FsbGluZzogJyArIChzaG93ZihmKSlcbiAgICArICdcXG4gIFdpdGg6ICcgKyAoc2hvdyhhKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gRW5jYXNlUChmbiwgYSl7XG4gIHRoaXMuX2ZuID0gZm47XG4gIHRoaXMuX2EgPSBhO1xufVxuXG5FbmNhc2VQLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29yZSk7XG5cbkVuY2FzZVAucHJvdG90eXBlLl9mb3JrID0gZnVuY3Rpb24gRW5jYXNlUCRmb3JrKHJlaiwgcmVzKXtcbiAgdmFyIF9mbiA9IHRoaXMuX2ZuO1xuICB2YXIgX2EgPSB0aGlzLl9hO1xuICB2YXIgb3BlbiA9IHRydWU7XG4gIGNoZWNrJHByb21pc2UoX2ZuKF9hKSwgX2ZuLCBfYSkudGhlbihpbW1lZGlhdGVseShmdW5jdGlvbiBFbmNhc2VQJHJlcyh4KXtcbiAgICBpZihvcGVuKXtcbiAgICAgIG9wZW4gPSBmYWxzZTtcbiAgICAgIHJlcyh4KTtcbiAgICB9XG4gIH0pLCBpbW1lZGlhdGVseShmdW5jdGlvbiBFbmNhc2VQJHJlaih4KXtcbiAgICBpZihvcGVuKXtcbiAgICAgIG9wZW4gPSBmYWxzZTtcbiAgICAgIHJlaih4KTtcbiAgICB9XG4gIH0pKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIEVuY2FzZVAkY2FuY2VsKCl7IG9wZW4gPSBmYWxzZTsgfTtcbn07XG5cbkVuY2FzZVAucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gRW5jYXNlUCR0b1N0cmluZygpe1xuICByZXR1cm4gJ0Z1dHVyZS5lbmNhc2VQKCcgKyBzaG93Zih0aGlzLl9mbikgKyAnLCAnICsgc2hvdyh0aGlzLl9hKSArICcpJztcbn07XG5cbmZ1bmN0aW9uIGVuY2FzZVAoZiwgeCl7XG4gIGlmKCFpc0Z1bmN0aW9uKGYpKSBpbnZhbGlkQXJndW1lbnQoJ0Z1dHVyZS5lbmNhc2VQJywgMCwgJ2JlIGEgZnVuY3Rpb24nLCBmKTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhcnRpYWwxKGVuY2FzZVAsIGYpO1xuICByZXR1cm4gbmV3IEVuY2FzZVAoZiwgeCk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrJHByb21pc2UkMShwLCBmLCBhLCBiKXtcbiAgcmV0dXJuIGlzVGhlbmFibGUocCkgPyBwIDogdHlwZUVycm9yKFxuICAgICdGdXR1cmUuZW5jYXNlUDIgZXhwZWN0cyB0aGUgZnVuY3Rpb24gaXRcXCdzIGdpdmVuIHRvIHJldHVybiBhIFByb21pc2UvVGhlbmFibGUnXG4gICAgKyAnXFxuICBBY3R1YWw6ICcgKyAoc2hvdyhwKSkgKyAnXFxuICBGcm9tIGNhbGxpbmc6ICcgKyAoc2hvd2YoZikpXG4gICAgKyAnXFxuICBXaXRoIDE6ICcgKyAoc2hvdyhhKSlcbiAgICArICdcXG4gIFdpdGggMjogJyArIChzaG93KGIpKVxuICApO1xufVxuXG5mdW5jdGlvbiBFbmNhc2VQMihmbiwgYSwgYil7XG4gIHRoaXMuX2ZuID0gZm47XG4gIHRoaXMuX2EgPSBhO1xuICB0aGlzLl9iID0gYjtcbn1cblxuRW5jYXNlUDIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb3JlKTtcblxuRW5jYXNlUDIucHJvdG90eXBlLl9mb3JrID0gZnVuY3Rpb24gRW5jYXNlUDIkZm9yayhyZWosIHJlcyl7XG4gIHZhciBfZm4gPSB0aGlzLl9mbjtcbiAgdmFyIF9hID0gdGhpcy5fYTtcbiAgdmFyIF9iID0gdGhpcy5fYjtcbiAgdmFyIG9wZW4gPSB0cnVlO1xuICBjaGVjayRwcm9taXNlJDEoX2ZuKF9hLCBfYiksIF9mbiwgX2EsIF9iKS50aGVuKGltbWVkaWF0ZWx5KGZ1bmN0aW9uIEVuY2FzZVAyJHJlcyh4KXtcbiAgICBpZihvcGVuKXtcbiAgICAgIG9wZW4gPSBmYWxzZTtcbiAgICAgIHJlcyh4KTtcbiAgICB9XG4gIH0pLCBpbW1lZGlhdGVseShmdW5jdGlvbiBFbmNhc2VQMiRyZWooeCl7XG4gICAgaWYob3Blbil7XG4gICAgICBvcGVuID0gZmFsc2U7XG4gICAgICByZWooeCk7XG4gICAgfVxuICB9KSk7XG4gIHJldHVybiBmdW5jdGlvbiBFbmNhc2VQMiRjYW5jZWwoKXsgb3BlbiA9IGZhbHNlOyB9O1xufTtcblxuRW5jYXNlUDIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gRW5jYXNlUDIkdG9TdHJpbmcoKXtcbiAgcmV0dXJuICdGdXR1cmUuZW5jYXNlUDIoJyArIHNob3dmKHRoaXMuX2ZuKSArICcsICcgKyBzaG93KHRoaXMuX2EpICsgJywgJyArIHNob3codGhpcy5fYikgKyAnKSc7XG59O1xuXG5mdW5jdGlvbiBlbmNhc2VQMihmLCB4LCB5KXtcbiAgaWYoIWlzRnVuY3Rpb24oZikpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlLmVuY2FzZVAyJywgMCwgJ2JlIGEgZnVuY3Rpb24nLCBmKTtcblxuICBzd2l0Y2goYXJndW1lbnRzLmxlbmd0aCl7XG4gICAgY2FzZSAxOiByZXR1cm4gcGFydGlhbDEoZW5jYXNlUDIsIGYpO1xuICAgIGNhc2UgMjogcmV0dXJuIHBhcnRpYWwyKGVuY2FzZVAyLCBmLCB4KTtcbiAgICBkZWZhdWx0OiByZXR1cm4gbmV3IEVuY2FzZVAyKGYsIHgsIHkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrJHByb21pc2UkMihwLCBmLCBhLCBiLCBjKXtcbiAgcmV0dXJuIGlzVGhlbmFibGUocCkgPyBwIDogdHlwZUVycm9yKFxuICAgICdGdXR1cmUuZW5jYXNlUDMgZXhwZWN0cyB0aGUgZnVuY3Rpb24gaXRcXCdzIGdpdmVuIHRvIHJldHVybiBhIFByb21pc2UvVGhlbmFibGUnXG4gICAgKyAnXFxuICBBY3R1YWw6ICcgKyAoc2hvdyhwKSkgKyAnXFxuICBGcm9tIGNhbGxpbmc6ICcgKyAoc2hvd2YoZikpXG4gICAgKyAnXFxuICBXaXRoIDE6ICcgKyAoc2hvdyhhKSlcbiAgICArICdcXG4gIFdpdGggMjogJyArIChzaG93KGIpKVxuICAgICsgJ1xcbiAgV2l0aCAzOiAnICsgKHNob3coYykpXG4gICk7XG59XG5cbmZ1bmN0aW9uIEVuY2FzZVAzKGZuLCBhLCBiLCBjKXtcbiAgdGhpcy5fZm4gPSBmbjtcbiAgdGhpcy5fYSA9IGE7XG4gIHRoaXMuX2IgPSBiO1xuICB0aGlzLl9jID0gYztcbn1cblxuRW5jYXNlUDMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb3JlKTtcblxuRW5jYXNlUDMucHJvdG90eXBlLl9mb3JrID0gZnVuY3Rpb24gRW5jYXNlUDMkZm9yayhyZWosIHJlcyl7XG4gIHZhciBfZm4gPSB0aGlzLl9mbjtcbiAgdmFyIF9hID0gdGhpcy5fYTtcbiAgdmFyIF9iID0gdGhpcy5fYjtcbiAgdmFyIF9jID0gdGhpcy5fYztcbiAgdmFyIG9wZW4gPSB0cnVlO1xuICBjaGVjayRwcm9taXNlJDIoX2ZuKF9hLCBfYiwgX2MpLCBfZm4sIF9hLCBfYiwgX2MpLnRoZW4oaW1tZWRpYXRlbHkoZnVuY3Rpb24gRW5jYXNlUDMkcmVzKHgpe1xuICAgIGlmKG9wZW4pe1xuICAgICAgb3BlbiA9IGZhbHNlO1xuICAgICAgcmVzKHgpO1xuICAgIH1cbiAgfSksIGltbWVkaWF0ZWx5KGZ1bmN0aW9uIEVuY2FzZVAzJHJlaih4KXtcbiAgICBpZihvcGVuKXtcbiAgICAgIG9wZW4gPSBmYWxzZTtcbiAgICAgIHJlaih4KTtcbiAgICB9XG4gIH0pKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIEVuY2FzZVAzJGNhbmNlbCgpeyBvcGVuID0gZmFsc2U7IH07XG59O1xuXG5FbmNhc2VQMy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBFbmNhc2VQMyR0b1N0cmluZygpe1xuICByZXR1cm4gJ0Z1dHVyZS5lbmNhc2VQMygnXG4gICAgICAgKyBzaG93Zih0aGlzLl9mbilcbiAgICAgICArICcsICdcbiAgICAgICArIHNob3codGhpcy5fYSlcbiAgICAgICArICcsICdcbiAgICAgICArIHNob3codGhpcy5fYilcbiAgICAgICArICcsICdcbiAgICAgICArIHNob3codGhpcy5fYylcbiAgICAgICArICcpJztcbn07XG5cbmZ1bmN0aW9uIGVuY2FzZVAzKGYsIHgsIHksIHope1xuICBpZighaXNGdW5jdGlvbihmKSkgaW52YWxpZEFyZ3VtZW50KCdGdXR1cmUuZW5jYXNlUDMnLCAwLCAnYmUgYSBmdW5jdGlvbicsIGYpO1xuXG4gIHN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBwYXJ0aWFsMShlbmNhc2VQMywgZik7XG4gICAgY2FzZSAyOiByZXR1cm4gcGFydGlhbDIoZW5jYXNlUDMsIGYsIHgpO1xuICAgIGNhc2UgMzogcmV0dXJuIHBhcnRpYWwzKGVuY2FzZVAzLCBmLCB4LCB5KTtcbiAgICBkZWZhdWx0OiByZXR1cm4gbmV3IEVuY2FzZVAzKGYsIHgsIHksIHopO1xuICB9XG59XG5cbi8qZXNsaW50IGNvbnNpc3RlbnQtcmV0dXJuOiAwKi9cblxuZnVuY3Rpb24gY2hlY2skaXRlcmF0b3IoZyl7XG4gIHJldHVybiBpc0l0ZXJhdG9yKGcpID8gZyA6IGludmFsaWRBcmd1bWVudChcbiAgICAnRnV0dXJlLmRvJywgMCwgJ3JldHVybiBhbiBpdGVyYXRvciwgbWF5YmUgeW91IGZvcmdvdCB0aGUgXCIqXCInLCBnXG4gICk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrJGl0ZXJhdGlvbihvKXtcbiAgaWYoIWlzSXRlcmF0aW9uKG8pKSB0eXBlRXJyb3IoXG4gICAgJ0Z1dHVyZS5kbyB3YXMgZ2l2ZW4gYW4gaW52YWxpZCBnZW5lcmF0b3I6J1xuICAgICsgJyBJdHMgaXRlcmF0b3IgZGlkIG5vdCByZXR1cm4gYSB2YWxpZCBpdGVyYXRpb24gZnJvbSBpdGVyYXRvci5uZXh0KCknXG4gICAgKyAnXFxuICBBY3R1YWw6ICcgKyBzaG93KG8pXG4gICk7XG4gIGlmKG8uZG9uZSB8fCBpc0Z1dHVyZShvLnZhbHVlKSkgcmV0dXJuIG87XG4gIHJldHVybiBpbnZhbGlkRnV0dXJlKFxuICAgICdGdXR1cmUuZG8nLFxuICAgICd0aGUgaXRlcmF0b3IgdG8gcHJvZHVjZSBvbmx5IHZhbGlkIEZ1dHVyZXMnLFxuICAgIG8udmFsdWUsXG4gICAgJ1xcbiAgVGlwOiBJZiB5b3VcXCdyZSB1c2luZyBhIGdlbmVyYXRvciwgbWFrZSBzdXJlIHlvdSBhbHdheXMgeWllbGQgYSBGdXR1cmUnXG4gICk7XG59XG5cbmZ1bmN0aW9uIEdvKGdlbmVyYXRvcil7XG4gIHRoaXMuX2dlbmVyYXRvciA9IGdlbmVyYXRvcjtcbn1cblxuR28ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb3JlKTtcblxuR28ucHJvdG90eXBlLl9mb3JrID0gZnVuY3Rpb24gR28kX2ZvcmsocmVqLCByZXMpe1xuXG4gIHZhciBpdGVyYXRvciA9IGNoZWNrJGl0ZXJhdG9yKHRoaXMuX2dlbmVyYXRvcigpKTtcblxuICB2YXIgdGltaW5nID0gVW5kZXRlcm1pbmVkLCBjYW5jZWwgPSBub29wLCBzdGF0ZSwgdmFsdWU7XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZWQoeCl7XG4gICAgdmFsdWUgPSB4O1xuICAgIGlmKHRpbWluZyA9PT0gQXN5bmNocm9ub3VzKSByZXR1cm4gZHJhaW4oKTtcbiAgICB0aW1pbmcgPSBTeW5jaHJvbm91cztcbiAgICBzdGF0ZSA9IGNoZWNrJGl0ZXJhdGlvbihpdGVyYXRvci5uZXh0KHZhbHVlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkcmFpbigpe1xuICAgIHN0YXRlID0gY2hlY2skaXRlcmF0aW9uKGl0ZXJhdG9yLm5leHQodmFsdWUpKTtcblxuICAgIHdoaWxlKCFzdGF0ZS5kb25lKXtcbiAgICAgIHRpbWluZyA9IFVuZGV0ZXJtaW5lZDtcbiAgICAgIGNhbmNlbCA9IHN0YXRlLnZhbHVlLl9mb3JrKHJlaiwgcmVzb2x2ZWQpO1xuXG4gICAgICBpZih0aW1pbmcgIT09IFN5bmNocm9ub3VzKXtcbiAgICAgICAgdGltaW5nID0gQXN5bmNocm9ub3VzO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzKHN0YXRlLnZhbHVlKTtcbiAgfVxuXG4gIGRyYWluKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIEdvJGNhbmNlbCgpeyBjYW5jZWwoKTsgfTtcblxufTtcblxuR28ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gR28kdG9TdHJpbmcoKXtcbiAgcmV0dXJuICdGdXR1cmUuZG8oJyArIHNob3dmKHRoaXMuX2dlbmVyYXRvcikgKyAnKSc7XG59O1xuXG5mdW5jdGlvbiBnbyhnZW5lcmF0b3Ipe1xuICBpZighaXNGdW5jdGlvbihnZW5lcmF0b3IpKSBpbnZhbGlkQXJndW1lbnQoJ0Z1dHVyZS5kbycsIDAsICdiZSBhIEZ1bmN0aW9uJywgZ2VuZXJhdG9yKTtcbiAgcmV0dXJuIG5ldyBHbyhnZW5lcmF0b3IpO1xufVxuXG5mdW5jdGlvbiBjaGVjayRkaXNwb3NlKG0sIGYsIHgpe1xuICBpZighaXNGdXR1cmUobSkpIGludmFsaWRGdXR1cmUoXG4gICAgJ0Z1dHVyZS5ob29rJyxcbiAgICAndGhlIGZpcnN0IGZ1bmN0aW9uIGl0XFwncyBnaXZlbiB0byByZXR1cm4gYSBGdXR1cmUnLFxuICAgIG0sXG4gICAgJ1xcbiAgRnJvbSBjYWxsaW5nOiAnICsgc2hvd2YoZikgKyAnXFxuICBXaXRoOiAnICsgc2hvdyh4KVxuICApO1xufVxuXG5mdW5jdGlvbiBjaGVjayRjb25zdW1lKG0sIGYsIHgpe1xuICBpZighaXNGdXR1cmUobSkpIGludmFsaWRGdXR1cmUoXG4gICAgJ0Z1dHVyZS5ob29rJyxcbiAgICAndGhlIHNlY29uZCBmdW5jdGlvbiBpdFxcJ3MgZ2l2ZW4gdG8gcmV0dXJuIGEgRnV0dXJlJyxcbiAgICBtLFxuICAgICdcXG4gIEZyb20gY2FsbGluZzogJyArIHNob3dmKGYpICsgJ1xcbiAgV2l0aDogJyArIHNob3coeClcbiAgKTtcbn1cblxuZnVuY3Rpb24gSG9vayhhY3F1aXJlLCBkaXNwb3NlLCBjb25zdW1lKXtcbiAgdGhpcy5fYWNxdWlyZSA9IGFjcXVpcmU7XG4gIHRoaXMuX2Rpc3Bvc2UgPSBkaXNwb3NlO1xuICB0aGlzLl9jb25zdW1lID0gY29uc3VtZTtcbn1cblxuSG9vay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvcmUpO1xuXG5Ib29rLnByb3RvdHlwZS5fZm9yayA9IGZ1bmN0aW9uIEhvb2skZm9yayhyZWosIHJlcyl7XG5cbiAgdmFyIF9hY3F1aXJlID0gdGhpcy5fYWNxdWlyZSwgX2Rpc3Bvc2UgPSB0aGlzLl9kaXNwb3NlLCBfY29uc3VtZSA9IHRoaXMuX2NvbnN1bWU7XG4gIHZhciBjYW5jZWwsIGNhbmNlbEFjcXVpcmUgPSBub29wLCBjYW5jZWxDb25zdW1lID0gbm9vcCwgcmVzb3VyY2UsIHZhbHVlLCBjb250ID0gbm9vcDtcblxuICBmdW5jdGlvbiBIb29rJGRvbmUoKXtcbiAgICBjb250KHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEhvb2skZGlzcG9zZSgpe1xuICAgIHZhciBkaXNwb3NhbCA9IF9kaXNwb3NlKHJlc291cmNlKTtcbiAgICBjaGVjayRkaXNwb3NlKGRpc3Bvc2FsLCBfZGlzcG9zZSwgcmVzb3VyY2UpO1xuICAgIGNhbmNlbCA9IGRpc3Bvc2FsLl9mb3JrKHJlaiwgSG9vayRkb25lKTtcbiAgICByZXR1cm4gY2FuY2VsO1xuICB9XG5cbiAgZnVuY3Rpb24gSG9vayRjYW5jZWxDb25zdXB0aW9uKCl7XG4gICAgY2FuY2VsQ29uc3VtZSgpO1xuICAgIEhvb2skZGlzcG9zZSgpKCk7XG4gIH1cblxuICBmdW5jdGlvbiBIb29rJGNvbnN1bXB0aW9uUmVqZWN0ZWQoeCl7XG4gICAgY29udCA9IHJlajtcbiAgICB2YWx1ZSA9IHg7XG4gICAgSG9vayRkaXNwb3NlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBIb29rJGNvbnN1bXB0aW9uUmVzb2x2ZWQoeCl7XG4gICAgY29udCA9IHJlcztcbiAgICB2YWx1ZSA9IHg7XG4gICAgSG9vayRkaXNwb3NlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBIb29rJGFjcXVpcmVSZXNvbHZlZCh4KXtcbiAgICByZXNvdXJjZSA9IHg7XG4gICAgdmFyIGNvbnN1bXB0aW9uID0gX2NvbnN1bWUocmVzb3VyY2UpO1xuICAgIGNoZWNrJGNvbnN1bWUoY29uc3VtcHRpb24sIF9jb25zdW1lLCByZXNvdXJjZSk7XG4gICAgY2FuY2VsID0gSG9vayRjYW5jZWxDb25zdXB0aW9uO1xuICAgIGNhbmNlbENvbnN1bWUgPSBjb25zdW1wdGlvbi5fZm9yayhIb29rJGNvbnN1bXB0aW9uUmVqZWN0ZWQsIEhvb2skY29uc3VtcHRpb25SZXNvbHZlZCk7XG4gIH1cblxuICBjYW5jZWxBY3F1aXJlID0gX2FjcXVpcmUuX2ZvcmsocmVqLCBIb29rJGFjcXVpcmVSZXNvbHZlZCk7XG5cbiAgY2FuY2VsID0gY2FuY2VsIHx8IGNhbmNlbEFjcXVpcmU7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIEhvb2skZm9yayRjYW5jZWwoKXsgY2FuY2VsKCk7IH07XG5cbn07XG5cbkhvb2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gSG9vayR0b1N0cmluZygpe1xuICByZXR1cm4gJ0Z1dHVyZS5ob29rKCdcbiAgICAgICArIHRoaXMuX2FjcXVpcmUudG9TdHJpbmcoKVxuICAgICAgICsgJywgJ1xuICAgICAgICsgc2hvd2YodGhpcy5fZGlzcG9zZSlcbiAgICAgICArICcsICdcbiAgICAgICArIHNob3dmKHRoaXMuX2NvbnN1bWUpXG4gICAgICAgKyAnKSc7XG59O1xuXG5mdW5jdGlvbiBob29rJGFjcXVpcmUkY2xlYW51cChhY3F1aXJlLCBjbGVhbnVwLCBjb25zdW1lKXtcbiAgaWYoIWlzRnVuY3Rpb24oY29uc3VtZSkpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlLmhvb2snLCAyLCAnYmUgYSBGdXR1cmUnLCBjb25zdW1lKTtcbiAgcmV0dXJuIG5ldyBIb29rKGFjcXVpcmUsIGNsZWFudXAsIGNvbnN1bWUpO1xufVxuXG5mdW5jdGlvbiBob29rJGFjcXVpcmUoYWNxdWlyZSwgY2xlYW51cCwgY29uc3VtZSl7XG4gIGlmKCFpc0Z1bmN0aW9uKGNsZWFudXApKSBpbnZhbGlkQXJndW1lbnQoJ0Z1dHVyZS5ob29rJywgMSwgJ2JlIGEgZnVuY3Rpb24nLCBjbGVhbnVwKTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgcmV0dXJuIHBhcnRpYWwyKGhvb2skYWNxdWlyZSRjbGVhbnVwLCBhY3F1aXJlLCBjbGVhbnVwKTtcbiAgcmV0dXJuIGhvb2skYWNxdWlyZSRjbGVhbnVwKGFjcXVpcmUsIGNsZWFudXAsIGNvbnN1bWUpO1xufVxuXG5mdW5jdGlvbiBob29rKGFjcXVpcmUsIGNsZWFudXAsIGNvbnN1bWUpe1xuICBpZighaXNGdXR1cmUoYWNxdWlyZSkpIGludmFsaWRGdXR1cmUoJ0Z1dHVyZS5ob29rJywgMCwgYWNxdWlyZSk7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiBwYXJ0aWFsMShob29rJGFjcXVpcmUsIGFjcXVpcmUpO1xuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAyKSByZXR1cm4gaG9vayRhY3F1aXJlKGFjcXVpcmUsIGNsZWFudXApO1xuICByZXR1cm4gaG9vayRhY3F1aXJlKGFjcXVpcmUsIGNsZWFudXAsIGNvbnN1bWUpO1xufVxuXG5mdW5jdGlvbiBOb2RlKGZuKXtcbiAgdGhpcy5fZm4gPSBmbjtcbn1cblxuTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvcmUpO1xuXG5Ob2RlLnByb3RvdHlwZS5fZm9yayA9IGZ1bmN0aW9uIE5vZGUkZm9yayhyZWosIHJlcyl7XG4gIHZhciBvcGVuID0gdHJ1ZTtcbiAgdGhpcy5fZm4oZnVuY3Rpb24gTm9kZSRkb25lKGVyciwgdmFsKXtcbiAgICBpZihvcGVuKXtcbiAgICAgIG9wZW4gPSBmYWxzZTtcbiAgICAgIGVyciA/IHJlaihlcnIpIDogcmVzKHZhbCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIE5vZGUkY2FuY2VsKCl7IG9wZW4gPSBmYWxzZTsgfTtcbn07XG5cbk5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gTm9kZSR0b1N0cmluZygpe1xuICByZXR1cm4gJ0Z1dHVyZS5ub2RlKCcgKyBzaG93Zih0aGlzLl9mbikgKyAnKSc7XG59O1xuXG5mdW5jdGlvbiBub2RlKGYpe1xuICBpZighaXNGdW5jdGlvbihmKSkgaW52YWxpZEFyZ3VtZW50KCdGdXR1cmUubm9kZScsIDAsICdiZSBhIGZ1bmN0aW9uJywgZik7XG4gIHJldHVybiBuZXcgTm9kZShmKTtcbn1cblxuZnVuY3Rpb24gY2hlY2skcGFyYWxsZWwobSwgaSl7XG4gIHJldHVybiBpc0Z1dHVyZShtKSA/IG0gOiBpbnZhbGlkRnV0dXJlKFxuICAgICdGdXR1cmUucGFyYWxsZWwnLFxuICAgICdpdHMgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGFuIGFycmF5IG9mIHZhbGlkIEZ1dHVyZXMuICdcbiAgKyAnVGhlIHZhbHVlIGF0IHBvc2l0aW9uICcgKyBpICsgJyBpbiB0aGUgYXJyYXkgaXMgbm90IGEgRnV0dXJlJyxcbiAgICBtXG4gICk7XG59XG5cbmZ1bmN0aW9uIFBhcmFsbGVsKG1heCwgZnV0dXJlcyl7XG4gIHRoaXMuX2Z1dHVyZXMgPSBmdXR1cmVzO1xuICB0aGlzLl9sZW5ndGggPSBmdXR1cmVzLmxlbmd0aDtcbiAgdGhpcy5fbWF4ID0gTWF0aC5taW4odGhpcy5fbGVuZ3RoLCBtYXgpO1xufVxuXG5QYXJhbGxlbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvcmUpO1xuXG5QYXJhbGxlbC5wcm90b3R5cGUuX2ZvcmsgPSBmdW5jdGlvbiBQYXJhbGxlbCRfZm9yayhyZWosIHJlcyl7XG5cbiAgdmFyIF9mdXR1cmVzID0gdGhpcy5fZnV0dXJlcywgX2xlbmd0aCA9IHRoaXMuX2xlbmd0aCwgX21heCA9IHRoaXMuX21heDtcbiAgdmFyIGNhbmNlbHMgPSBuZXcgQXJyYXkoX2xlbmd0aCksIG91dCA9IG5ldyBBcnJheShfbGVuZ3RoKTtcbiAgdmFyIGN1cnNvciA9IDAsIHJ1bm5pbmcgPSAwLCBibG9ja2VkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gUGFyYWxsZWwkY2FuY2VsKCl7XG4gICAgZm9yKHZhciBuID0gMDsgbiA8IF9sZW5ndGg7IG4rKykgY2FuY2Vsc1tuXSAmJiBjYW5jZWxzW25dKCk7XG4gIH1cblxuICBmdW5jdGlvbiBQYXJhbGxlbCRydW4oaWR4KXtcbiAgICBydW5uaW5nKys7XG4gICAgY2FuY2Vsc1tpZHhdID0gX2Z1dHVyZXNbaWR4XS5fZm9yayhmdW5jdGlvbiBQYXJhbGxlbCRyZWoocmVhc29uKXtcbiAgICAgIGNhbmNlbHNbaWR4XSA9IG5vb3A7XG4gICAgICBQYXJhbGxlbCRjYW5jZWwoKTtcbiAgICAgIHJlaihyZWFzb24pO1xuICAgIH0sIGZ1bmN0aW9uIFBhcmFsbGVsJHJlcyh2YWx1ZSl7XG4gICAgICBjYW5jZWxzW2lkeF0gPSBub29wO1xuICAgICAgb3V0W2lkeF0gPSB2YWx1ZTtcbiAgICAgIHJ1bm5pbmctLTtcbiAgICAgIGlmKGN1cnNvciA9PT0gX2xlbmd0aCAmJiBydW5uaW5nID09PSAwKSByZXMob3V0KTtcbiAgICAgIGVsc2UgaWYoYmxvY2tlZCkgUGFyYWxsZWwkZHJhaW4oKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFBhcmFsbGVsJGRyYWluKCl7XG4gICAgYmxvY2tlZCA9IGZhbHNlO1xuICAgIHdoaWxlKGN1cnNvciA8IF9sZW5ndGggJiYgcnVubmluZyA8IF9tYXgpIFBhcmFsbGVsJHJ1bihjdXJzb3IrKyk7XG4gICAgYmxvY2tlZCA9IHRydWU7XG4gIH1cblxuICBQYXJhbGxlbCRkcmFpbigpO1xuXG4gIHJldHVybiBQYXJhbGxlbCRjYW5jZWw7XG5cbn07XG5cblBhcmFsbGVsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIFBhcmFsbGVsJHRvU3RyaW5nKCl7XG4gIHJldHVybiAnRnV0dXJlLnBhcmFsbGVsKCcgKyB0aGlzLl9tYXggKyAnLCAnICsgc2hvdyh0aGlzLl9mdXR1cmVzKSArICcpJztcbn07XG5cbnZhciBlbXB0eUFycmF5ID0gbmV3IFJlc29sdmVkKFtdKTtcblxuZnVuY3Rpb24gcGFyYWxsZWwkbWF4KG1heCwgeHMpe1xuICBpZighaXNBcnJheSh4cykpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlLnBhcmFsbGVsJywgMSwgJ2JlIGFuIGFycmF5JywgeHMpO1xuICB2YXIgZnV0dXJlcyA9IG1hcEFycmF5KHhzLCBjaGVjayRwYXJhbGxlbCk7XG4gIHJldHVybiBmdXR1cmVzLmxlbmd0aCA9PT0gMCA/IGVtcHR5QXJyYXkgOiBuZXcgUGFyYWxsZWwobWF4LCBmdXR1cmVzKTtcbn1cblxuZnVuY3Rpb24gcGFyYWxsZWwobWF4LCB4cyl7XG4gIGlmKCFpc1Vuc2lnbmVkKG1heCkpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlLnBhcmFsbGVsJywgMCwgJ2JlIGEgcG9zaXRpdmUgaW50ZWdlcicsIG1heCk7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiBwYXJ0aWFsMShwYXJhbGxlbCRtYXgsIG1heCk7XG4gIHJldHVybiBwYXJhbGxlbCRtYXgobWF4LCB4cyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrJHByb21pc2UkMyhwLCBmKXtcbiAgcmV0dXJuIGlzVGhlbmFibGUocCkgPyBwIDogdHlwZUVycm9yKFxuICAgICdGdXR1cmUudHJ5UCBleHBlY3RzIHRoZSBmdW5jdGlvbiBpdFxcJ3MgZ2l2ZW4gdG8gcmV0dXJuIGEgUHJvbWlzZS9UaGVuYWJsZSdcbiAgICArICdcXG4gIEFjdHVhbDogJyArIHNob3cocCkgKyAnXFxuICBGcm9tIGNhbGxpbmc6ICcgKyBzaG93ZihmKVxuICApO1xufVxuXG5mdW5jdGlvbiBUcnlQKGZuKXtcbiAgdGhpcy5fZm4gPSBmbjtcbn1cblxuVHJ5UC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvcmUpO1xuXG5UcnlQLnByb3RvdHlwZS5fZm9yayA9IGZ1bmN0aW9uIFRyeVAkZm9yayhyZWosIHJlcyl7XG4gIHZhciBvcGVuID0gdHJ1ZTtcbiAgY2hlY2skcHJvbWlzZSQzKHRoaXMuX2ZuKCksIHRoaXMuX2ZuKS50aGVuKGltbWVkaWF0ZWx5KGZ1bmN0aW9uIFRyeVAkcmVzKHgpe1xuICAgIGlmKG9wZW4pe1xuICAgICAgb3BlbiA9IGZhbHNlO1xuICAgICAgcmVzKHgpO1xuICAgIH1cbiAgfSksIGltbWVkaWF0ZWx5KGZ1bmN0aW9uIFRyeVAkcmVqKHgpe1xuICAgIGlmKG9wZW4pe1xuICAgICAgb3BlbiA9IGZhbHNlO1xuICAgICAgcmVqKHgpO1xuICAgIH1cbiAgfSkpO1xuICByZXR1cm4gZnVuY3Rpb24gVHJ5UCRjYW5jZWwoKXsgb3BlbiA9IGZhbHNlOyB9O1xufTtcblxuVHJ5UC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBUcnlQJHRvU3RyaW5nKCl7XG4gIHJldHVybiAnRnV0dXJlLnRyeVAoJyArIHNob3codGhpcy5fZm4pICsgJyknO1xufTtcblxuZnVuY3Rpb24gdHJ5UChmKXtcbiAgaWYoIWlzRnVuY3Rpb24oZikpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlLnRyeVAnLCAwLCAnYmUgYSBmdW5jdGlvbicsIGYpO1xuICByZXR1cm4gbmV3IFRyeVAoZik7XG59XG5cbmlmKHR5cGVvZiBPYmplY3QuY3JlYXRlICE9PSAnZnVuY3Rpb24nKSBlcnJvcignUGxlYXNlIHBvbHlmaWxsIE9iamVjdC5jcmVhdGUgdG8gdXNlIEZsdXR1cmUnKTtcbmlmKHR5cGVvZiBPYmplY3QuYXNzaWduICE9PSAnZnVuY3Rpb24nKSBlcnJvcignUGxlYXNlIHBvbHlmaWxsIE9iamVjdC5hc3NpZ24gdG8gdXNlIEZsdXR1cmUnKTtcbmlmKHR5cGVvZiBBcnJheS5pc0FycmF5ICE9PSAnZnVuY3Rpb24nKSBlcnJvcignUGxlYXNlIHBvbHlmaWxsIEFycmF5LmlzQXJyYXkgdG8gdXNlIEZsdXR1cmUnKTtcblxuRnV0dXJlLm9mID0gRnV0dXJlW0ZMLm9mXSA9IG9mO1xuRnV0dXJlLmNoYWluUmVjID0gRnV0dXJlW0ZMLmNoYWluUmVjXSA9IGNoYWluUmVjO1xuRnV0dXJlLnJlamVjdCA9IHJlamVjdDtcbkZ1dHVyZS5hcCA9IGFwO1xuRnV0dXJlLm1hcCA9IG1hcDtcbkZ1dHVyZS5iaW1hcCA9IGJpbWFwO1xuRnV0dXJlLmNoYWluID0gY2hhaW47XG5cbnZhciBQYXIgPSBjb25jdXJyaWZ5KEZ1dHVyZSwgbmV2ZXIsIHJhY2UsIHBhcmFsbGVsQXApO1xuUGFyLm9mID0gUGFyW0ZMLm9mXTtcblBhci56ZXJvID0gUGFyW0ZMLnplcm9dO1xuUGFyLm1hcCA9IG1hcDtcblBhci5hcCA9IGFwO1xuUGFyLmFsdCA9IGFsdDtcblxuZnVuY3Rpb24gaXNQYXJhbGxlbCh4KXtcbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBQYXIgfHwgdHlwZSh4KSA9PT0gUGFyWydAQHR5cGUnXTtcbn1cblxuZnVuY3Rpb24gc2VxKHBhcil7XG4gIGlmKCFpc1BhcmFsbGVsKHBhcikpIGludmFsaWRBcmd1bWVudCgnRnV0dXJlLnNlcScsIDAsICd0byBiZSBhIFBhcicsIHBhcik7XG4gIHJldHVybiBwYXIuc2VxdWVudGlhbDtcbn1cblxuXG5cblxudmFyIEZsdXR1cmUgPSBPYmplY3QuZnJlZXplKHtcblx0RnV0dXJlOiBGdXR1cmUsXG5cdGRlZmF1bHQ6IEZ1dHVyZSxcblx0UGFyOiBQYXIsXG5cdGlzUGFyYWxsZWw6IGlzUGFyYWxsZWwsXG5cdHNlcTogc2VxLFxuXHRpc0Z1dHVyZTogaXNGdXR1cmUsXG5cdHJlamVjdDogcmVqZWN0LFxuXHRvZjogb2YsXG5cdG5ldmVyOiBuZXZlcixcblx0aXNOZXZlcjogaXNOZXZlcixcblx0YWZ0ZXI6IGFmdGVyLFxuXHRyZWplY3RBZnRlcjogcmVqZWN0QWZ0ZXIsXG5cdGF0dGVtcHQ6IGF0dGVtcHQsXG5cdHRyeTogYXR0ZW1wdCxcblx0Y2FjaGU6IGNhY2hlLFxuXHRlbmNhc2U6IGVuY2FzZSxcblx0ZW5jYXNlMjogZW5jYXNlMixcblx0ZW5jYXNlMzogZW5jYXNlMyxcblx0ZW5jYXNlTjogZW5jYXNlTixcblx0ZW5jYXNlTjI6IGVuY2FzZU4yLFxuXHRlbmNhc2VOMzogZW5jYXNlTjMsXG5cdGVuY2FzZVA6IGVuY2FzZVAsXG5cdGVuY2FzZVAyOiBlbmNhc2VQMixcblx0ZW5jYXNlUDM6IGVuY2FzZVAzLFxuXHRnbzogZ28sXG5cdGRvOiBnbyxcblx0aG9vazogaG9vayxcblx0bm9kZTogbm9kZSxcblx0cGFyYWxsZWw6IHBhcmFsbGVsLFxuXHR0cnlQOiB0cnlQLFxuXHRhcDogYXAsXG5cdGFsdDogYWx0LFxuXHRtYXA6IG1hcCxcblx0YmltYXA6IGJpbWFwLFxuXHRjaGFpbjogY2hhaW4sXG5cdG1hcFJlajogbWFwUmVqLFxuXHRjaGFpblJlajogY2hhaW5SZWosXG5cdGxhc3RseTogbGFzdGx5LFxuXHRmaW5hbGx5OiBsYXN0bHksXG5cdGFuZDogYW5kLFxuXHRib3RoOiBib3RoLFxuXHRvcjogb3IsXG5cdHJhY2U6IHJhY2UsXG5cdHN3YXA6IHN3YXAsXG5cdGZvbGQ6IGZvbGQsXG5cdGRvbmU6IGRvbmUsXG5cdGZvcms6IGZvcmssXG5cdHByb21pc2U6IHByb21pc2UsXG5cdHZhbHVlOiB2YWx1ZSxcblx0ZXh0cmFjdExlZnQ6IGV4dHJhY3RMZWZ0LFxuXHRleHRyYWN0UmlnaHQ6IGV4dHJhY3RSaWdodFxufSk7XG5cbnZhciBpbmRleF9janMgPSBPYmplY3QuYXNzaWduKEZ1dHVyZSwgRmx1dHVyZSk7XG5cbnJldHVybiBpbmRleF9janM7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9mbHV0dXJlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n             ############                  #\n            ############                  ###\n                  #####                  #####\n                #####      ####################\n              #####       ######################\n            #####                     ###########\n          #####         ######################\n        #####          ####################\n      #####                        #####\n     ############                 ###\n    ############                 */\n\n//. # sanctuary-type-classes\n//.\n//. The [Fantasy Land Specification][FL] \"specifies interoperability of common\n//. algebraic structures\" by defining a number of type classes. For each type\n//. class, it states laws which every member of a type must obey in order for\n//. the type to be a member of the type class. In order for the Maybe type to\n//. be considered a [Functor][], for example, every `Maybe a` value must have\n//. a `fantasy-land/map` method which obeys the identity and composition laws.\n//.\n//. This project provides:\n//.\n//.   - [`TypeClass`](#TypeClass), a function for defining type classes;\n//.   - one `TypeClass` value for each Fantasy Land type class;\n//.   - lawful Fantasy Land methods for JavaScript's built-in types;\n//.   - one function for each Fantasy Land method; and\n//.   - several functions derived from these functions.\n//.\n//. ## Type-class hierarchy\n//.\n/* eslint-disable max-len */\n//. <pre>\n//.  Setoid   Semigroupoid  Semigroup   Foldable        Functor      Contravariant  Filterable\n//. (equals)    (compose)    (concat)   (reduce)         (map)        (contramap)    (filter)\n//.     |           |           |           \\         / | | | | \\\n//.     |           |           |            \\       /  | | | |  \\\n//.     |           |           |             \\     /   | | | |   \\\n//.     |           |           |              \\   /    | | | |    \\\n//.     |           |           |               \\ /     | | | |     \\\n//.    Ord      Category     Monoid         Traversable | | | |      \\\n//.   (lte)       (id)       (empty)        (traverse)  / | | \\       \\\n//.                             |                      /  | |  \\       \\\n//.                             |                     /   / \\   \\       \\\n//.                             |             Profunctor /   \\ Bifunctor \\\n//.                             |              (promap) /     \\ (bimap)   \\\n//.                             |                      /       \\           \\\n//.                           Group                   /         \\           \\\n//.                          (invert)               Alt        Apply      Extend\n//.                                                (alt)        (ap)     (extend)\n//.                                                 /           / \\           \\\n//.                                                /           /   \\           \\\n//.                                               /           /     \\           \\\n//.                                              /           /       \\           \\\n//.                                             /           /         \\           \\\n//.                                           Plus    Applicative    Chain      Comonad\n//.                                          (zero)       (of)      (chain)    (extract)\n//.                                             \\         / \\         / \\\n//.                                              \\       /   \\       /   \\\n//.                                               \\     /     \\     /     \\\n//.                                                \\   /       \\   /       \\\n//.                                                 \\ /         \\ /         \\\n//.                                             Alternative    Monad     ChainRec\n//.                                                                     (chainRec)\n//. </pre>\n/* eslint-enable max-len */\n//.\n//. ## API\n\n(function(f) {\n\n  'use strict';\n\n  /* istanbul ignore else */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f(__webpack_require__(12));\n  } else if (\"function\" === 'function' && __webpack_require__(0) != null) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(12)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {\n    self.sanctuaryTypeClasses = f(self.sanctuaryTypeIdentifiers);\n  }\n\n}(function(type) {\n\n  'use strict';\n\n  //  concat_ :: Array a -> Array a -> Array a\n  function concat_(xs) {\n    return function(ys) {\n      return xs.concat(ys);\n    };\n  }\n\n  //  constant :: a -> b -> a\n  function constant(x) {\n    return function(y) {\n      return x;\n    };\n  }\n\n  //  forEachKey :: (StrMap a, StrMap a ~> String -> Undefined) -> Undefined\n  function forEachKey(strMap, f) {\n    Object.keys(strMap).forEach(f, strMap);\n  }\n\n  //  has :: (String, Object) -> Boolean\n  function has(k, o) {\n    return Object.prototype.hasOwnProperty.call(o, k);\n  }\n\n  //  identity :: a -> a\n  function identity(x) { return x; }\n\n  //  pair :: a -> b -> Pair a b\n  function pair(x) {\n    return function(y) {\n      return [x, y];\n    };\n  }\n\n  //  sameType :: (a, b) -> Boolean\n  function sameType(x, y) {\n    return typeof x === typeof y && type(x) === type(y);\n  }\n\n  //  type Iteration a = { value :: a, done :: Boolean }\n\n  //  iterationNext :: a -> Iteration a\n  function iterationNext(x) { return {value: x, done: false}; }\n\n  //  iterationDone :: a -> Iteration a\n  function iterationDone(x) { return {value: x, done: true}; }\n\n  //# TypeClass :: (String, String, Array TypeClass, a -> Boolean) -> TypeClass\n  //.\n  //. The arguments are:\n  //.\n  //.   - the name of the type class, prefixed by its npm package name;\n  //.   - the documentation URL of the type class;\n  //.   - an array of dependencies; and\n  //.   - a predicate which accepts any JavaScript value and returns `true`\n  //.     if the value satisfies the requirements of the type class; `false`\n  //.     otherwise.\n  //.\n  //. Example:\n  //.\n  //. ```javascript\n  //. //    hasMethod :: String -> a -> Boolean\n  //. const hasMethod = name => x => x != null && typeof x[name] == 'function';\n  //.\n  //. //    Foo :: TypeClass\n  //. const Foo = Z.TypeClass(\n  //.   'my-package/Foo',\n  //.   'http://example.com/my-package#Foo',\n  //.   [],\n  //.   hasMethod('foo')\n  //. );\n  //.\n  //. //    Bar :: TypeClass\n  //. const Bar = Z.TypeClass(\n  //.   'my-package/Bar',\n  //.   'http://example.com/my-package#Bar',\n  //.   [Foo],\n  //.   hasMethod('bar')\n  //. );\n  //. ```\n  //.\n  //. Types whose values have a `foo` method are members of the Foo type class.\n  //. Members of the Foo type class whose values have a `bar` method are also\n  //. members of the Bar type class.\n  //.\n  //. Each `TypeClass` value has a `test` field: a function which accepts\n  //. any JavaScript value and returns `true` if the value satisfies the\n  //. type class's predicate and the predicates of all the type class's\n  //. dependencies; `false` otherwise.\n  //.\n  //. `TypeClass` values may be used with [sanctuary-def][type-classes]\n  //. to define parametrically polymorphic functions which verify their\n  //. type-class constraints at run time.\n  function TypeClass(name, url, dependencies, test) {\n    if (!(this instanceof TypeClass)) {\n      return new TypeClass(name, url, dependencies, test);\n    }\n    this.name = name;\n    this.url = url;\n    this.test = function(x) {\n      return dependencies.every(function(d) { return d.test(x); }) && test(x);\n    };\n  }\n\n  TypeClass['@@type'] = 'sanctuary-type-classes/TypeClass';\n\n  //  data Location = Constructor | Value\n\n  //  Constructor :: Location\n  var Constructor = 'Constructor';\n\n  //  Value :: Location\n  var Value = 'Value';\n\n  //  _funcPath :: (Boolean, Array String, a) -> Nullable Function\n  function _funcPath(allowInheritedProps, path, _x) {\n    var x = _x;\n    for (var idx = 0; idx < path.length; idx += 1) {\n      var k = path[idx];\n      if (x == null || !(allowInheritedProps || has(k, x))) return null;\n      x = x[k];\n    }\n    return typeof x === 'function' ? x : null;\n  }\n\n  //  funcPath :: (Array String, a) -> Nullable Function\n  function funcPath(path, x) {\n    return _funcPath(true, path, x);\n  }\n\n  //  implPath :: Array String -> Nullable Function\n  function implPath(path) {\n    return _funcPath(false, path, implementations);\n  }\n\n  //  functionName :: Function -> String\n  var functionName = has('name', function f() {}) ?\n    function functionName(f) { return f.name; } :\n    /* istanbul ignore next */\n    function functionName(f) {\n      var match = /function (\\w*)/.exec(f);\n      return match == null ? '' : match[1];\n    };\n\n  //  $ :: (String, Array TypeClass, StrMap (Array Location)) -> TypeClass\n  function $(_name, dependencies, requirements) {\n    function getBoundMethod(_name) {\n      var name = 'fantasy-land/' + _name;\n      return requirements[_name] === Constructor ?\n        function(typeRep) {\n          var f = funcPath([name], typeRep);\n          return f == null && typeof typeRep === 'function' ?\n            implPath([functionName(typeRep), name]) :\n            f;\n        } :\n        function(x) {\n          var isPrototype = x != null &&\n                            x.constructor != null &&\n                            x.constructor.prototype === x;\n          var m = null;\n          if (!isPrototype) m = funcPath([name], x);\n          if (m == null)    m = implPath([type(x), 'prototype', name]);\n          return m && m.bind(x);\n        };\n    }\n\n    var version = '8.0.0';  // updated programmatically\n    var keys = Object.keys(requirements);\n\n    var typeClass = TypeClass(\n      'sanctuary-type-classes/' + _name,\n      'https://github.com/sanctuary-js/sanctuary-type-classes/tree/v' + version\n        + '#' + _name,\n      dependencies,\n      function(x) {\n        return keys.every(function(_name) {\n          var arg = requirements[_name] === Constructor ? x.constructor : x;\n          return getBoundMethod(_name)(arg) != null;\n        });\n      }\n    );\n\n    typeClass.methods = keys.reduce(function(methods, _name) {\n      methods[_name] = getBoundMethod(_name);\n      return methods;\n    }, {});\n\n    return typeClass;\n  }\n\n  //# Setoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Setoid][].\n  //.\n  //. ```javascript\n  //. > Setoid.test(null)\n  //. true\n  //. ```\n  var Setoid = $('Setoid', [], {equals: Value});\n\n  //# Ord :: TypeClass\n  //.\n  //. `TypeClass` value for [Ord][].\n  //.\n  //. ```javascript\n  //. > Ord.test(0)\n  //. true\n  //.\n  //. > Ord.test(Math.sqrt)\n  //. false\n  //. ```\n  var Ord = $('Ord', [Setoid], {lte: Value});\n\n  //# Semigroupoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Semigroupoid][].\n  //.\n  //. ```javascript\n  //. > Semigroupoid.test(Math.sqrt)\n  //. true\n  //.\n  //. > Semigroupoid.test(0)\n  //. false\n  //. ```\n  var Semigroupoid = $('Semigroupoid', [], {compose: Value});\n\n  //# Category :: TypeClass\n  //.\n  //. `TypeClass` value for [Category][].\n  //.\n  //. ```javascript\n  //. > Category.test(Math.sqrt)\n  //. true\n  //.\n  //. > Category.test(0)\n  //. false\n  //. ```\n  var Category = $('Category', [Semigroupoid], {id: Constructor});\n\n  //# Semigroup :: TypeClass\n  //.\n  //. `TypeClass` value for [Semigroup][].\n  //.\n  //. ```javascript\n  //. > Semigroup.test('')\n  //. true\n  //.\n  //. > Semigroup.test(0)\n  //. false\n  //. ```\n  var Semigroup = $('Semigroup', [], {concat: Value});\n\n  //# Monoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Monoid][].\n  //.\n  //. ```javascript\n  //. > Monoid.test('')\n  //. true\n  //.\n  //. > Monoid.test(0)\n  //. false\n  //. ```\n  var Monoid = $('Monoid', [Semigroup], {empty: Constructor});\n\n  //# Group :: TypeClass\n  //.\n  //. `TypeClass` value for [Group][].\n  //.\n  //. ```javascript\n  //. > Group.test(Sum(0))\n  //. true\n  //.\n  //. > Group.test('')\n  //. false\n  //. ```\n  var Group = $('Group', [Monoid], {invert: Value});\n\n  //# Filterable :: TypeClass\n  //.\n  //. `TypeClass` value for [Filterable][].\n  //.\n  //. ```javascript\n  //. > Filterable.test({})\n  //. true\n  //.\n  //. > Filterable.test('')\n  //. false\n  //. ```\n  var Filterable = $('Filterable', [], {filter: Value});\n\n  //# Functor :: TypeClass\n  //.\n  //. `TypeClass` value for [Functor][].\n  //.\n  //. ```javascript\n  //. > Functor.test([])\n  //. true\n  //.\n  //. > Functor.test('')\n  //. false\n  //. ```\n  var Functor = $('Functor', [], {map: Value});\n\n  //# Bifunctor :: TypeClass\n  //.\n  //. `TypeClass` value for [Bifunctor][].\n  //.\n  //. ```javascript\n  //. > Bifunctor.test(Tuple('foo', 64))\n  //. true\n  //.\n  //. > Bifunctor.test([])\n  //. false\n  //. ```\n  var Bifunctor = $('Bifunctor', [Functor], {bimap: Value});\n\n  //# Profunctor :: TypeClass\n  //.\n  //. `TypeClass` value for [Profunctor][].\n  //.\n  //. ```javascript\n  //. > Profunctor.test(Math.sqrt)\n  //. true\n  //.\n  //. > Profunctor.test([])\n  //. false\n  //. ```\n  var Profunctor = $('Profunctor', [Functor], {promap: Value});\n\n  //# Apply :: TypeClass\n  //.\n  //. `TypeClass` value for [Apply][].\n  //.\n  //. ```javascript\n  //. > Apply.test([])\n  //. true\n  //.\n  //. > Apply.test('')\n  //. false\n  //. ```\n  var Apply = $('Apply', [Functor], {ap: Value});\n\n  //# Applicative :: TypeClass\n  //.\n  //. `TypeClass` value for [Applicative][].\n  //.\n  //. ```javascript\n  //. > Applicative.test([])\n  //. true\n  //.\n  //. > Applicative.test({})\n  //. false\n  //. ```\n  var Applicative = $('Applicative', [Apply], {of: Constructor});\n\n  //# Chain :: TypeClass\n  //.\n  //. `TypeClass` value for [Chain][].\n  //.\n  //. ```javascript\n  //. > Chain.test([])\n  //. true\n  //.\n  //. > Chain.test({})\n  //. false\n  //. ```\n  var Chain = $('Chain', [Apply], {chain: Value});\n\n  //# ChainRec :: TypeClass\n  //.\n  //. `TypeClass` value for [ChainRec][].\n  //.\n  //. ```javascript\n  //. > ChainRec.test([])\n  //. true\n  //.\n  //. > ChainRec.test({})\n  //. false\n  //. ```\n  var ChainRec = $('ChainRec', [Chain], {chainRec: Constructor});\n\n  //# Monad :: TypeClass\n  //.\n  //. `TypeClass` value for [Monad][].\n  //.\n  //. ```javascript\n  //. > Monad.test([])\n  //. true\n  //.\n  //. > Monad.test({})\n  //. false\n  //. ```\n  var Monad = $('Monad', [Applicative, Chain], {});\n\n  //# Alt :: TypeClass\n  //.\n  //. `TypeClass` value for [Alt][].\n  //.\n  //. ```javascript\n  //. > Alt.test({})\n  //. true\n  //.\n  //. > Alt.test('')\n  //. false\n  //. ```\n  var Alt = $('Alt', [Functor], {alt: Value});\n\n  //# Plus :: TypeClass\n  //.\n  //. `TypeClass` value for [Plus][].\n  //.\n  //. ```javascript\n  //. > Plus.test({})\n  //. true\n  //.\n  //. > Plus.test('')\n  //. false\n  //. ```\n  var Plus = $('Plus', [Alt], {zero: Constructor});\n\n  //# Alternative :: TypeClass\n  //.\n  //. `TypeClass` value for [Alternative][].\n  //.\n  //. ```javascript\n  //. > Alternative.test([])\n  //. true\n  //.\n  //. > Alternative.test({})\n  //. false\n  //. ```\n  var Alternative = $('Alternative', [Applicative, Plus], {});\n\n  //# Foldable :: TypeClass\n  //.\n  //. `TypeClass` value for [Foldable][].\n  //.\n  //. ```javascript\n  //. > Foldable.test({})\n  //. true\n  //.\n  //. > Foldable.test('')\n  //. false\n  //. ```\n  var Foldable = $('Foldable', [], {reduce: Value});\n\n  //# Traversable :: TypeClass\n  //.\n  //. `TypeClass` value for [Traversable][].\n  //.\n  //. ```javascript\n  //. > Traversable.test([])\n  //. true\n  //.\n  //. > Traversable.test('')\n  //. false\n  //. ```\n  var Traversable = $('Traversable', [Functor, Foldable], {traverse: Value});\n\n  //# Extend :: TypeClass\n  //.\n  //. `TypeClass` value for [Extend][].\n  //.\n  //. ```javascript\n  //. > Extend.test([])\n  //. true\n  //.\n  //. > Extend.test({})\n  //. false\n  //. ```\n  var Extend = $('Extend', [Functor], {extend: Value});\n\n  //# Comonad :: TypeClass\n  //.\n  //. `TypeClass` value for [Comonad][].\n  //.\n  //. ```javascript\n  //. > Comonad.test(Identity(0))\n  //. true\n  //.\n  //. > Comonad.test([])\n  //. false\n  //. ```\n  var Comonad = $('Comonad', [Extend], {extract: Value});\n\n  //# Contravariant :: TypeClass\n  //.\n  //. `TypeClass` value for [Contravariant][].\n  //.\n  //. ```javascript\n  //. > Contravariant.test(Math.sqrt)\n  //. true\n  //.\n  //. > Contravariant.test([])\n  //. false\n  //. ```\n  var Contravariant = $('Contravariant', [], {contramap: Value});\n\n  //  Null$prototype$toString :: Null ~> () -> String\n  function Null$prototype$toString() {\n    return 'null';\n  }\n\n  //  Null$prototype$equals :: Null ~> Null -> Boolean\n  function Null$prototype$equals(other) {\n    return true;\n  }\n\n  //  Null$prototype$lte :: Null ~> Null -> Boolean\n  function Null$prototype$lte(other) {\n    return true;\n  }\n\n  //  Undefined$prototype$toString :: Undefined ~> () -> String\n  function Undefined$prototype$toString() {\n    return 'undefined';\n  }\n\n  //  Undefined$prototype$equals :: Undefined ~> Undefined -> Boolean\n  function Undefined$prototype$equals(other) {\n    return true;\n  }\n\n  //  Undefined$prototype$lte :: Undefined ~> Undefined -> Boolean\n  function Undefined$prototype$lte(other) {\n    return true;\n  }\n\n  //  Boolean$prototype$toString :: Boolean ~> () -> String\n  function Boolean$prototype$toString() {\n    return typeof this === 'object' ?\n      'new Boolean(' + toString(this.valueOf()) + ')' :\n      this.toString();\n  }\n\n  //  Boolean$prototype$equals :: Boolean ~> Boolean -> Boolean\n  function Boolean$prototype$equals(other) {\n    return typeof this === 'object' ?\n      equals(this.valueOf(), other.valueOf()) :\n      this === other;\n  }\n\n  //  Boolean$prototype$lte :: Boolean ~> Boolean -> Boolean\n  function Boolean$prototype$lte(other) {\n    return typeof this === 'object' ?\n      lte(this.valueOf(), other.valueOf()) :\n      this === false || other === true;\n  }\n\n  //  Number$prototype$toString :: Number ~> () -> String\n  function Number$prototype$toString() {\n    return typeof this === 'object' ?\n      'new Number(' + toString(this.valueOf()) + ')' :\n      1 / this === -Infinity ? '-0' : this.toString(10);\n  }\n\n  //  Number$prototype$equals :: Number ~> Number -> Boolean\n  function Number$prototype$equals(other) {\n    return typeof this === 'object' ?\n      equals(this.valueOf(), other.valueOf()) :\n      isNaN(this) && isNaN(other) || this === other;\n  }\n\n  //  Number$prototype$lte :: Number ~> Number -> Boolean\n  function Number$prototype$lte(other) {\n    return typeof this === 'object' ?\n      lte(this.valueOf(), other.valueOf()) :\n      isNaN(this) && isNaN(other) || this <= other;\n  }\n\n  //  Date$prototype$toString :: Date ~> () -> String\n  function Date$prototype$toString() {\n    var x = isNaN(this.valueOf()) ? NaN : this.toISOString();\n    return 'new Date(' + toString(x) + ')';\n  }\n\n  //  Date$prototype$equals :: Date ~> Date -> Boolean\n  function Date$prototype$equals(other) {\n    return equals(this.valueOf(), other.valueOf());\n  }\n\n  //  Date$prototype$lte :: Date ~> Date -> Boolean\n  function Date$prototype$lte(other) {\n    return lte(this.valueOf(), other.valueOf());\n  }\n\n  //  RegExp$prototype$equals :: RegExp ~> RegExp -> Boolean\n  function RegExp$prototype$equals(other) {\n    return other.source === this.source &&\n           other.global === this.global &&\n           other.ignoreCase === this.ignoreCase &&\n           other.multiline === this.multiline &&\n           other.sticky === this.sticky &&\n           other.unicode === this.unicode;\n  }\n\n  //  String$empty :: () -> String\n  function String$empty() {\n    return '';\n  }\n\n  //  String$prototype$toString :: String ~> () -> String\n  function String$prototype$toString() {\n    return typeof this === 'object' ?\n      'new String(' + toString(this.valueOf()) + ')' :\n      JSON.stringify(this);\n  }\n\n  //  String$prototype$equals :: String ~> String -> Boolean\n  function String$prototype$equals(other) {\n    return typeof this === 'object' ?\n      equals(this.valueOf(), other.valueOf()) :\n      this === other;\n  }\n\n  //  String$prototype$lte :: String ~> String -> Boolean\n  function String$prototype$lte(other) {\n    return typeof this === 'object' ?\n      lte(this.valueOf(), other.valueOf()) :\n      this <= other;\n  }\n\n  //  String$prototype$concat :: String ~> String -> String\n  function String$prototype$concat(other) {\n    return this + other;\n  }\n\n  //  Array$empty :: () -> Array a\n  function Array$empty() {\n    return [];\n  }\n\n  //  Array$of :: a -> Array a\n  function Array$of(x) {\n    return [x];\n  }\n\n  //  Array$chainRec :: ((a -> c, b -> c, a) -> Array c, a) -> Array b\n  function Array$chainRec(f, x) {\n    var $todo = [x];\n    var $done = [];\n    while ($todo.length > 0) {\n      var xs = f(iterationNext, iterationDone, $todo.shift());\n      var $more = [];\n      for (var idx = 0; idx < xs.length; idx += 1) {\n        (xs[idx].done ? $done : $more).push(xs[idx].value);\n      }\n      Array.prototype.unshift.apply($todo, $more);\n    }\n    return $done;\n  }\n\n  //  Array$zero :: () -> Array a\n  function Array$zero() {\n    return [];\n  }\n\n  //  Array$prototype$toString :: Array a ~> () -> String\n  function Array$prototype$toString() {\n    var reprs = this.map(toString);\n    var keys = Object.keys(this).sort();\n    for (var idx = 0; idx < keys.length; idx += 1) {\n      var k = keys[idx];\n      if (!/^\\d+$/.test(k)) {\n        reprs.push(toString(k) + ': ' + toString(this[k]));\n      }\n    }\n    return '[' + reprs.join(', ') + ']';\n  }\n\n  //  Array$prototype$equals :: Array a ~> Array a -> Boolean\n  function Array$prototype$equals(other) {\n    if (other.length !== this.length) return false;\n    for (var idx = 0; idx < this.length; idx += 1) {\n      if (!equals(this[idx], other[idx])) return false;\n    }\n    return true;\n  }\n\n  //  Array$prototype$lte :: Array a ~> Array a -> Boolean\n  function Array$prototype$lte(other) {\n    for (var idx = 0; true; idx += 1) {\n      if (idx === this.length) return true;\n      if (idx === other.length) return false;\n      if (!equals(this[idx], other[idx])) return lte(this[idx], other[idx]);\n    }\n  }\n\n  //  Array$prototype$concat :: Array a ~> Array a -> Array a\n  function Array$prototype$concat(other) {\n    return this.concat(other);\n  }\n\n  //  Array$prototype$filter :: Array a ~> (a -> Boolean) -> Array a\n  function Array$prototype$filter(pred) {\n    return this.filter(function(x) { return pred(x); });\n  }\n\n  //  Array$prototype$map :: Array a ~> (a -> b) -> Array b\n  function Array$prototype$map(f) {\n    return this.map(function(x) { return f(x); });\n  }\n\n  //  Array$prototype$ap :: Array a ~> Array (a -> b) -> Array b\n  function Array$prototype$ap(fs) {\n    var result = [];\n    for (var idx = 0; idx < fs.length; idx += 1) {\n      for (var idx2 = 0; idx2 < this.length; idx2 += 1) {\n        result.push(fs[idx](this[idx2]));\n      }\n    }\n    return result;\n  }\n\n  //  Array$prototype$chain :: Array a ~> (a -> Array b) -> Array b\n  function Array$prototype$chain(f) {\n    var result = [];\n    this.forEach(function(x) { Array.prototype.push.apply(result, f(x)); });\n    return result;\n  }\n\n  //  Array$prototype$alt :: Array a ~> Array a -> Array a\n  var Array$prototype$alt = Array$prototype$concat;\n\n  //  Array$prototype$reduce :: Array a ~> ((b, a) -> b, b) -> b\n  function Array$prototype$reduce(f, initial) {\n    return this.reduce(function(acc, x) { return f(acc, x); }, initial);\n  }\n\n  //  Array$prototype$traverse :: Applicative f => Array a ~> (TypeRep f, a -> f b) -> f (Array b)\n  function Array$prototype$traverse(typeRep, f) {\n    var xs = this;\n    function go(idx, n) {\n      switch (n) {\n        case 0: return of(typeRep, []);\n        case 2: return lift2(pair, f(xs[idx]), f(xs[idx + 1]));\n        default:\n          var m = Math.floor(n / 4) * 2;\n          return lift2(concat_, go(idx, m), go(idx + m, n - m));\n      }\n    }\n    return this.length % 2 === 1 ?\n      lift2(concat_, map(Array$of, f(this[0])), go(1, this.length - 1)) :\n      go(0, this.length);\n  }\n\n  //  Array$prototype$extend :: Array a ~> (Array a -> b) -> Array b\n  function Array$prototype$extend(f) {\n    return this.map(function(_, idx, xs) { return f(xs.slice(idx)); });\n  }\n\n  //  Arguments$prototype$toString :: Arguments ~> String\n  function Arguments$prototype$toString() {\n    var args = Array.prototype.map.call(this, toString).join(', ');\n    return '(function () { return arguments; }(' + args + '))';\n  }\n\n  //  Arguments$prototype$equals :: Arguments ~> Arguments -> Boolean\n  function Arguments$prototype$equals(other) {\n    return Array$prototype$equals.call(this, other);\n  }\n\n  //  Arguments$prototype$lte :: Arguments ~> Arguments -> Boolean\n  function Arguments$prototype$lte(other) {\n    return Array$prototype$lte.call(this, other);\n  }\n\n  //  Error$prototype$toString :: Error ~> () -> String\n  function Error$prototype$toString() {\n    return 'new ' + this.name + '(' + toString(this.message) + ')';\n  }\n\n  //  Error$prototype$equals :: Error ~> Error -> Boolean\n  function Error$prototype$equals(other) {\n    return equals(this.name, other.name) &&\n           equals(this.message, other.message);\n  }\n\n  //  Object$empty :: () -> StrMap a\n  function Object$empty() {\n    return {};\n  }\n\n  //  Object$zero :: () -> StrMap a\n  function Object$zero() {\n    return {};\n  }\n\n  //  Object$prototype$toString :: StrMap a ~> () -> String\n  function Object$prototype$toString() {\n    var reprs = [];\n    var keys = Object.keys(this).sort();\n    for (var idx = 0; idx < keys.length; idx += 1) {\n      var k = keys[idx];\n      reprs.push(toString(k) + ': ' + toString(this[k]));\n    }\n    return '{' + reprs.join(', ') + '}';\n  }\n\n  //  Object$prototype$equals :: StrMap a ~> StrMap a -> Boolean\n  function Object$prototype$equals(other) {\n    var self = this;\n    var keys = Object.keys(this).sort();\n    return equals(keys, Object.keys(other).sort()) &&\n           keys.every(function(k) { return equals(self[k], other[k]); });\n  }\n\n  //  Object$prototype$lte :: StrMap a ~> StrMap a -> Boolean\n  function Object$prototype$lte(other) {\n    var theseKeys = Object.keys(this).sort();\n    var otherKeys = Object.keys(other).sort();\n    while (true) {\n      if (theseKeys.length === 0) return true;\n      if (otherKeys.length === 0) return false;\n      var k = theseKeys.shift();\n      var z = otherKeys.shift();\n      if (k < z) return true;\n      if (k > z) return false;\n      if (!equals(this[k], other[k])) return lte(this[k], other[k]);\n    }\n  }\n\n  //  Object$prototype$concat :: StrMap a ~> StrMap a -> StrMap a\n  function Object$prototype$concat(other) {\n    var result = {};\n    function assign(k) { result[k] = this[k]; }\n    forEachKey(this, assign);\n    forEachKey(other, assign);\n    return result;\n  }\n\n  //  Object$prototype$filter :: StrMap a ~> (a -> Boolean) -> StrMap a\n  function Object$prototype$filter(pred) {\n    var result = {};\n    forEachKey(this, function(k) { if (pred(this[k])) result[k] = this[k]; });\n    return result;\n  }\n\n  //  Object$prototype$map :: StrMap a ~> (a -> b) -> StrMap b\n  function Object$prototype$map(f) {\n    var result = {};\n    forEachKey(this, function(k) { result[k] = f(this[k]); });\n    return result;\n  }\n\n  //  Object$prototype$ap :: StrMap a ~> StrMap (a -> b) -> StrMap b\n  function Object$prototype$ap(other) {\n    var result = {};\n    forEachKey(this, function(k) {\n      if (has(k, other)) result[k] = other[k](this[k]);\n    });\n    return result;\n  }\n\n  //  Object$prototype$alt :: StrMap a ~> StrMap a -> StrMap a\n  var Object$prototype$alt = Object$prototype$concat;\n\n  //  Object$prototype$reduce :: StrMap a ~> ((b, a) -> b, b) -> b\n  function Object$prototype$reduce(f, initial) {\n    var self = this;\n    function reducer(acc, k) { return f(acc, self[k]); }\n    return Object.keys(this).sort().reduce(reducer, initial);\n  }\n\n  //  Object$prototype$traverse :: Applicative f => StrMap a ~> (TypeRep f, a -> f b) -> f (StrMap b)\n  function Object$prototype$traverse(typeRep, f) {\n    var self = this;\n    return Object.keys(this).reduce(function(applicative, k) {\n      function set(o) {\n        return function(v) {\n          var singleton = {}; singleton[k] = v;\n          return Object$prototype$concat.call(o, singleton);\n        };\n      }\n      return lift2(set, applicative, f(self[k]));\n    }, of(typeRep, {}));\n  }\n\n  //  Function$id :: () -> a -> a\n  function Function$id() {\n    return identity;\n  }\n\n  //  Function$of :: b -> (a -> b)\n  function Function$of(x) {\n    return function(_) { return x; };\n  }\n\n  //  Function$chainRec :: ((a -> c, b -> c, a) -> (z -> c), a) -> (z -> b)\n  function Function$chainRec(f, x) {\n    return function(a) {\n      var step = iterationNext(x);\n      while (!step.done) {\n        step = f(iterationNext, iterationDone, step.value)(a);\n      }\n      return step.value;\n    };\n  }\n\n  //  Function$prototype$equals :: Function ~> Function -> Boolean\n  function Function$prototype$equals(other) {\n    return other === this;\n  }\n\n  //  Function$prototype$compose :: (a -> b) ~> (b -> c) -> (a -> c)\n  function Function$prototype$compose(other) {\n    var semigroupoid = this;\n    return function(x) { return other(semigroupoid(x)); };\n  }\n\n  //  Function$prototype$map :: (a -> b) ~> (b -> c) -> (a -> c)\n  function Function$prototype$map(f) {\n    var functor = this;\n    return function(x) { return f(functor(x)); };\n  }\n\n  //  Function$prototype$promap :: (b -> c) ~> (a -> b, c -> d) -> (a -> d)\n  function Function$prototype$promap(f, g) {\n    var profunctor = this;\n    return function(x) { return g(profunctor(f(x))); };\n  }\n\n  //  Function$prototype$ap :: (a -> b) ~> (a -> b -> c) -> (a -> c)\n  function Function$prototype$ap(f) {\n    var apply = this;\n    return function(x) { return f(x)(apply(x)); };\n  }\n\n  //  Function$prototype$chain :: (a -> b) ~> (b -> a -> c) -> (a -> c)\n  function Function$prototype$chain(f) {\n    var chain = this;\n    return function(x) { return f(chain(x))(x); };\n  }\n\n  //  Function$prototype$extend :: Semigroup a => (a -> b) ~> ((a -> b) -> c) -> (a -> c)\n  function Function$prototype$extend(f) {\n    var extend = this;\n    return function(x) {\n      return f(function(y) { return extend(concat(x, y)); });\n    };\n  }\n\n  //  Function$prototype$contramap :: (b -> c) ~> (a -> b) -> (a -> c)\n  function Function$prototype$contramap(f) {\n    var contravariant = this;\n    return function(x) { return contravariant(f(x)); };\n  }\n\n  /* eslint-disable key-spacing */\n  var implementations = {\n    Null: {\n      prototype: {\n        toString:                   Null$prototype$toString,\n        'fantasy-land/equals':      Null$prototype$equals,\n        'fantasy-land/lte':         Null$prototype$lte\n      }\n    },\n    Undefined: {\n      prototype: {\n        toString:                   Undefined$prototype$toString,\n        'fantasy-land/equals':      Undefined$prototype$equals,\n        'fantasy-land/lte':         Undefined$prototype$lte\n      }\n    },\n    Boolean: {\n      prototype: {\n        toString:                   Boolean$prototype$toString,\n        'fantasy-land/equals':      Boolean$prototype$equals,\n        'fantasy-land/lte':         Boolean$prototype$lte\n      }\n    },\n    Number: {\n      prototype: {\n        toString:                   Number$prototype$toString,\n        'fantasy-land/equals':      Number$prototype$equals,\n        'fantasy-land/lte':         Number$prototype$lte\n      }\n    },\n    Date: {\n      prototype: {\n        toString:                   Date$prototype$toString,\n        'fantasy-land/equals':      Date$prototype$equals,\n        'fantasy-land/lte':         Date$prototype$lte\n      }\n    },\n    RegExp: {\n      prototype: {\n        'fantasy-land/equals':      RegExp$prototype$equals\n      }\n    },\n    String: {\n      'fantasy-land/empty':         String$empty,\n      prototype: {\n        toString:                   String$prototype$toString,\n        'fantasy-land/equals':      String$prototype$equals,\n        'fantasy-land/lte':         String$prototype$lte,\n        'fantasy-land/concat':      String$prototype$concat\n      }\n    },\n    Array: {\n      'fantasy-land/empty':         Array$empty,\n      'fantasy-land/of':            Array$of,\n      'fantasy-land/chainRec':      Array$chainRec,\n      'fantasy-land/zero':          Array$zero,\n      prototype: {\n        toString:                   Array$prototype$toString,\n        'fantasy-land/equals':      Array$prototype$equals,\n        'fantasy-land/lte':         Array$prototype$lte,\n        'fantasy-land/concat':      Array$prototype$concat,\n        'fantasy-land/filter':      Array$prototype$filter,\n        'fantasy-land/map':         Array$prototype$map,\n        'fantasy-land/ap':          Array$prototype$ap,\n        'fantasy-land/chain':       Array$prototype$chain,\n        'fantasy-land/alt':         Array$prototype$alt,\n        'fantasy-land/reduce':      Array$prototype$reduce,\n        'fantasy-land/traverse':    Array$prototype$traverse,\n        'fantasy-land/extend':      Array$prototype$extend\n      }\n    },\n    Arguments: {\n      prototype: {\n        toString:                   Arguments$prototype$toString,\n        'fantasy-land/equals':      Arguments$prototype$equals,\n        'fantasy-land/lte':         Arguments$prototype$lte\n      }\n    },\n    Error: {\n      prototype: {\n        toString:                   Error$prototype$toString,\n        'fantasy-land/equals':      Error$prototype$equals\n      }\n    },\n    Object: {\n      'fantasy-land/empty':         Object$empty,\n      'fantasy-land/zero':          Object$zero,\n      prototype: {\n        toString:                   Object$prototype$toString,\n        'fantasy-land/equals':      Object$prototype$equals,\n        'fantasy-land/lte':         Object$prototype$lte,\n        'fantasy-land/concat':      Object$prototype$concat,\n        'fantasy-land/filter':      Object$prototype$filter,\n        'fantasy-land/map':         Object$prototype$map,\n        'fantasy-land/ap':          Object$prototype$ap,\n        'fantasy-land/alt':         Object$prototype$alt,\n        'fantasy-land/reduce':      Object$prototype$reduce,\n        'fantasy-land/traverse':    Object$prototype$traverse\n      }\n    },\n    Function: {\n      'fantasy-land/id':            Function$id,\n      'fantasy-land/of':            Function$of,\n      'fantasy-land/chainRec':      Function$chainRec,\n      prototype: {\n        'fantasy-land/equals':      Function$prototype$equals,\n        'fantasy-land/compose':     Function$prototype$compose,\n        'fantasy-land/map':         Function$prototype$map,\n        'fantasy-land/promap':      Function$prototype$promap,\n        'fantasy-land/ap':          Function$prototype$ap,\n        'fantasy-land/chain':       Function$prototype$chain,\n        'fantasy-land/extend':      Function$prototype$extend,\n        'fantasy-land/contramap':   Function$prototype$contramap\n      }\n    }\n  };\n  /* eslint-enable key-spacing */\n\n  //# toString :: a -> String\n  //.\n  //. Returns a useful string representation of its argument.\n  //.\n  //. Dispatches to the argument's `toString` method if appropriate.\n  //.\n  //. Where practical, `equals(eval(toString(x)), x) = true`.\n  //.\n  //. `toString` implementations are provided for the following built-in types:\n  //. Null, Undefined, Boolean, Number, Date, String, Array, Arguments, Error,\n  //. and Object.\n  //.\n  //. ```javascript\n  //. > toString(-0)\n  //. '-0'\n  //.\n  //. > toString(['foo', 'bar', 'baz'])\n  //. '[\"foo\", \"bar\", \"baz\"]'\n  //.\n  //. > toString({x: 1, y: 2, z: 3})\n  //. '{\"x\": 1, \"y\": 2, \"z\": 3}'\n  //.\n  //. > toString(Cons(1, Cons(2, Cons(3, Nil))))\n  //. 'Cons(1, Cons(2, Cons(3, Nil)))'\n  //. ```\n  var toString = (function() {\n    //  $seen :: Array Any\n    var $seen = [];\n\n    function call(method, x) {\n      $seen.push(x);\n      try { return method.call(x); } finally { $seen.pop(); }\n    }\n\n    return function toString(x) {\n      if ($seen.indexOf(x) >= 0) return '<Circular>';\n\n      var xType = type(x);\n      if (xType === 'Object') {\n        var result;\n        try { result = call(x.toString, x); } catch (err) {}\n        if (result != null && result !== '[object Object]') return result;\n      }\n\n      return call(implPath([xType, 'prototype', 'toString']) || x.toString, x);\n    };\n  }());\n\n  //# equals :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and equal according\n  //. to the type's [`fantasy-land/equals`][] method; `false` otherwise.\n  //.\n  //. `fantasy-land/equals` implementations are provided for the following\n  //. built-in types: Null, Undefined, Boolean, Number, Date, RegExp, String,\n  //. Array, Arguments, Error, Object, and Function.\n  //.\n  //. The algorithm supports circular data structures. Two arrays are equal\n  //. if they have the same index paths and for each path have equal values.\n  //. Two arrays which represent `[1, [1, [1, [1, [1, ...]]]]]`, for example,\n  //. are equal even if their internal structures differ. Two objects are equal\n  //. if they have the same property paths and for each path have equal values.\n  //.\n  //. ```javascript\n  //. > equals(0, -0)\n  //. true\n  //.\n  //. > equals(NaN, NaN)\n  //. true\n  //.\n  //. > equals(Cons('foo', Cons('bar', Nil)), Cons('foo', Cons('bar', Nil)))\n  //. true\n  //.\n  //. > equals(Cons('foo', Cons('bar', Nil)), Cons('bar', Cons('foo', Nil)))\n  //. false\n  //. ```\n  var equals = (function() {\n    //  $pairs :: Array (Pair Any Any)\n    var $pairs = [];\n\n    return function equals(x, y) {\n      if (!sameType(x, y)) return false;\n\n      //  This algorithm for comparing circular data structures was\n      //  suggested in <http://stackoverflow.com/a/40622794/312785>.\n      if ($pairs.some(function(p) { return p[0] === x && p[1] === y; })) {\n        return true;\n      }\n\n      $pairs.push([x, y]);\n      try {\n        return Setoid.test(x) && Setoid.test(y) && Setoid.methods.equals(x)(y);\n      } finally {\n        $pairs.pop();\n      }\n    };\n  }());\n\n  //# lt :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first is\n  //. less than the second according to the type's [`fantasy-land/lte`][]\n  //. method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`gt`](#gt) and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > lt(0, 0)\n  //. false\n  //.\n  //. > lt(0, 1)\n  //. true\n  //.\n  //. > lt(1, 0)\n  //. false\n  //. ```\n  function lt(x, y) {\n    return sameType(x, y) && !lte(y, x);\n  }\n\n  //# lte :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first\n  //. is less than or equal to the second according to the type's\n  //. [`fantasy-land/lte`][] method; `false` otherwise.\n  //.\n  //. `fantasy-land/lte` implementations are provided for the following\n  //. built-in types: Null, Undefined, Boolean, Number, Date, String, Array,\n  //. Arguments, and Object.\n  //.\n  //. The algorithm supports circular data structures in the same manner as\n  //. [`equals`](#equals).\n  //.\n  //. See also [`lt`](#lt), [`gt`](#gt), and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > lte(0, 0)\n  //. true\n  //.\n  //. > lte(0, 1)\n  //. true\n  //.\n  //. > lte(1, 0)\n  //. false\n  //. ```\n  var lte = (function() {\n    //  $pairs :: Array (Pair Any Any)\n    var $pairs = [];\n\n    return function lte(x, y) {\n      if (!sameType(x, y)) return false;\n\n      //  This algorithm for comparing circular data structures was\n      //  suggested in <http://stackoverflow.com/a/40622794/312785>.\n      if ($pairs.some(function(p) { return p[0] === x && p[1] === y; })) {\n        return equals(x, y);\n      }\n\n      $pairs.push([x, y]);\n      try {\n        return Ord.test(x) && Ord.test(y) && Ord.methods.lte(x)(y);\n      } finally {\n        $pairs.pop();\n      }\n    };\n  }());\n\n  //# gt :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first is\n  //. greater than the second according to the type's [`fantasy-land/lte`][]\n  //. method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`lt`](#lt) and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > gt(0, 0)\n  //. false\n  //.\n  //. > gt(0, 1)\n  //. false\n  //.\n  //. > gt(1, 0)\n  //. true\n  //. ```\n  function gt(x, y) {\n    return lt(y, x);\n  }\n\n  //# gte :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first\n  //. is greater than or equal to the second according to the type's\n  //. [`fantasy-land/lte`][] method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`lt`](#lt) and [`gt`](#gt).\n  //.\n  //. ```javascript\n  //. > gte(0, 0)\n  //. true\n  //.\n  //. > gte(0, 1)\n  //. false\n  //.\n  //. > gte(1, 0)\n  //. true\n  //. ```\n  function gte(x, y) {\n    return lte(y, x);\n  }\n\n  //# min :: Ord a => (a, a) -> a\n  //.\n  //. Returns the smaller of its two arguments.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`max`](#max).\n  //.\n  //. ```javascript\n  //. > min(10, 2)\n  //. 2\n  //.\n  //. > min(new Date('1999-12-31'), new Date('2000-01-01'))\n  //. new Date('1999-12-31')\n  //.\n  //. > min('10', '2')\n  //. '10'\n  //. ```\n  function min(x, y) {\n    return lte(x, y) ? x : y;\n  }\n\n  //# max :: Ord a => (a, a) -> a\n  //.\n  //. Returns the larger of its two arguments.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`min`](#min).\n  //.\n  //. ```javascript\n  //. > max(10, 2)\n  //. 10\n  //.\n  //. > max(new Date('1999-12-31'), new Date('2000-01-01'))\n  //. new Date('2000-01-01')\n  //.\n  //. > max('10', '2')\n  //. '2'\n  //. ```\n  function max(x, y) {\n    return lte(x, y) ? y : x;\n  }\n\n  //# compose :: Semigroupoid c => (c j k, c i j) -> c i k\n  //.\n  //. Function wrapper for [`fantasy-land/compose`][].\n  //.\n  //. `fantasy-land/compose` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > compose(Math.sqrt, x => x + 1)(99)\n  //. 10\n  //. ```\n  function compose(x, y) {\n    return Semigroupoid.methods.compose(y)(x);\n  }\n\n  //# id :: Category c => TypeRep c -> c\n  //.\n  //. Function wrapper for [`fantasy-land/id`][].\n  //.\n  //. `fantasy-land/id` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > id(Function)('foo')\n  //. 'foo'\n  //. ```\n  function id(typeRep) {\n    return Category.methods.id(typeRep)();\n  }\n\n  //# concat :: Semigroup a => (a, a) -> a\n  //.\n  //. Function wrapper for [`fantasy-land/concat`][].\n  //.\n  //. `fantasy-land/concat` implementations are provided for the following\n  //. built-in types: String, Array, and Object.\n  //.\n  //. ```javascript\n  //. > concat('abc', 'def')\n  //. 'abcdef'\n  //.\n  //. > concat([1, 2, 3], [4, 5, 6])\n  //. [1, 2, 3, 4, 5, 6]\n  //.\n  //. > concat({x: 1, y: 2}, {y: 3, z: 4})\n  //. {x: 1, y: 3, z: 4}\n  //.\n  //. > concat(Cons('foo', Cons('bar', Cons('baz', Nil))), Cons('quux', Nil))\n  //. Cons('foo', Cons('bar', Cons('baz', Cons('quux', Nil))))\n  //. ```\n  function concat(x, y) {\n    return Semigroup.methods.concat(x)(y);\n  }\n\n  //# empty :: Monoid m => TypeRep m -> m\n  //.\n  //. Function wrapper for [`fantasy-land/empty`][].\n  //.\n  //. `fantasy-land/empty` implementations are provided for the following\n  //. built-in types: String, Array, and Object.\n  //.\n  //. ```javascript\n  //. > empty(String)\n  //. ''\n  //.\n  //. > empty(Array)\n  //. []\n  //.\n  //. > empty(Object)\n  //. {}\n  //.\n  //. > empty(List)\n  //. Nil\n  //. ```\n  function empty(typeRep) {\n    return Monoid.methods.empty(typeRep)();\n  }\n\n  //# invert :: Group g => g -> g\n  //.\n  //. Function wrapper for [`fantasy-land/invert`][].\n  //.\n  //. ```javascript\n  //. > invert(Sum(5))\n  //. Sum(-5)\n  //. ```\n  function invert(group) {\n    return Group.methods.invert(group)();\n  }\n\n  //# filter :: Filterable f => (a -> Boolean, f a) -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/filter`][]. Discards every element\n  //. of the given structure which does not satisfy the predicate.\n  //.\n  //. `fantasy-land/filter` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. See also [`reject`](#reject).\n  //.\n  //. ```javascript\n  //. > filter(x => x % 2 == 1, [1, 2, 3])\n  //. [1, 3]\n  //.\n  //. > filter(x => x % 2 == 1, {x: 1, y: 2, z: 3})\n  //. {x: 1, z: 3}\n  //.\n  //. > filter(x => x % 2 == 1, Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(1, Cons(3, Nil))\n  //.\n  //. > filter(x => x % 2 == 1, Nothing)\n  //. Nothing\n  //.\n  //. > filter(x => x % 2 == 1, Just(0))\n  //. Nothing\n  //.\n  //. > filter(x => x % 2 == 1, Just(1))\n  //. Just(1)\n  //. ```\n  function filter(pred, filterable) {\n    return Filterable.methods.filter(filterable)(pred);\n  }\n\n  //# reject :: Filterable f => (a -> Boolean, f a) -> f a\n  //.\n  //. Discards every element of the given structure which satisfies the\n  //. predicate.\n  //.\n  //. This function is derived from [`filter`](#filter).\n  //.\n  //. ```javascript\n  //. > reject(x => x % 2 == 1, [1, 2, 3])\n  //. [2]\n  //.\n  //. > reject(x => x % 2 == 1, {x: 1, y: 2, z: 3})\n  //. {y: 2}\n  //.\n  //. > reject(x => x % 2 == 1, Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(2, Nil)\n  //.\n  //. > reject(x => x % 2 == 1, Nothing)\n  //. Nothing\n  //.\n  //. > reject(x => x % 2 == 1, Just(0))\n  //. Just(0)\n  //.\n  //. > reject(x => x % 2 == 1, Just(1))\n  //. Nothing\n  //. ```\n  function reject(pred, filterable) {\n    return filter(function(x) { return !pred(x); }, filterable);\n  }\n\n  //# map :: Functor f => (a -> b, f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/map`][].\n  //.\n  //. `fantasy-land/map` implementations are provided for the following\n  //. built-in types: Array, Object, and Function.\n  //.\n  //. ```javascript\n  //. > map(Math.sqrt, [1, 4, 9])\n  //. [1, 2, 3]\n  //.\n  //. > map(Math.sqrt, {x: 1, y: 4, z: 9})\n  //. {x: 1, y: 2, z: 3}\n  //.\n  //. > map(Math.sqrt, s => s.length)('Sanctuary')\n  //. 3\n  //.\n  //. > map(Math.sqrt, Tuple('foo', 64))\n  //. Tuple('foo', 8)\n  //.\n  //. > map(Math.sqrt, Nil)\n  //. Nil\n  //.\n  //. > map(Math.sqrt, Cons(1, Cons(4, Cons(9, Nil))))\n  //. Cons(1, Cons(2, Cons(3, Nil)))\n  //. ```\n  function map(f, functor) {\n    return Functor.methods.map(functor)(f);\n  }\n\n  //# bimap :: Bifunctor f => (a -> b, c -> d, f a c) -> f b d\n  //.\n  //. Function wrapper for [`fantasy-land/bimap`][].\n  //.\n  //. ```javascript\n  //. > bimap(s => s.toUpperCase(), Math.sqrt, Tuple('foo', 64))\n  //. Tuple('FOO', 8)\n  //. ```\n  function bimap(f, g, bifunctor) {\n    return Bifunctor.methods.bimap(bifunctor)(f, g);\n  }\n\n  //# promap :: Profunctor p => (a -> b, c -> d, p b c) -> p a d\n  //.\n  //. Function wrapper for [`fantasy-land/promap`][].\n  //.\n  //. `fantasy-land/promap` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > promap(Math.abs, x => x + 1, Math.sqrt)(-100)\n  //. 11\n  //. ```\n  function promap(f, g, profunctor) {\n    return Profunctor.methods.promap(profunctor)(f, g);\n  }\n\n  //# ap :: Apply f => (f (a -> b), f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/ap`][].\n  //.\n  //. `fantasy-land/ap` implementations are provided for the following\n  //. built-in types: Array, Object, and Function.\n  //.\n  //. ```javascript\n  //. > ap([Math.sqrt, x => x * x], [1, 4, 9, 16, 25])\n  //. [1, 2, 3, 4, 5, 1, 16, 81, 256, 625]\n  //.\n  //. > ap({a: Math.sqrt, b: x => x * x}, {a: 16, b: 10, c: 1})\n  //. {a: 4, b: 100}\n  //.\n  //. > ap(s => n => s.slice(0, n), s => Math.ceil(s.length / 2))('Haskell')\n  //. 'Hask'\n  //.\n  //. > ap(Identity(Math.sqrt), Identity(64))\n  //. Identity(8)\n  //.\n  //. > ap(Cons(Math.sqrt, Cons(x => x * x, Nil)), Cons(16, Cons(100, Nil)))\n  //. Cons(4, Cons(10, Cons(256, Cons(10000, Nil))))\n  //. ```\n  function ap(applyF, applyX) {\n    return Apply.methods.ap(applyX)(applyF);\n  }\n\n  //# lift2 :: Apply f => (a -> b -> c, f a, f b) -> f c\n  //.\n  //. Lifts `a -> b -> c` to `Apply f => f a -> f b -> f c` and returns the\n  //. result of applying this to the given arguments.\n  //.\n  //. This function is derived from [`map`](#map) and [`ap`](#ap).\n  //.\n  //. See also [`lift3`](#lift3).\n  //.\n  //. ```javascript\n  //. > lift2(x => y => Math.pow(x, y), [10], [1, 2, 3])\n  //. [10, 100, 1000]\n  //.\n  //. > lift2(x => y => Math.pow(x, y), Identity(10), Identity(3))\n  //. Identity(1000)\n  //. ```\n  function lift2(f, x, y) {\n    return ap(map(f, x), y);\n  }\n\n  //# lift3 :: Apply f => (a -> b -> c -> d, f a, f b, f c) -> f d\n  //.\n  //. Lifts `a -> b -> c -> d` to `Apply f => f a -> f b -> f c -> f d` and\n  //. returns the result of applying this to the given arguments.\n  //.\n  //. This function is derived from [`map`](#map) and [`ap`](#ap).\n  //.\n  //. See also [`lift2`](#lift2).\n  //.\n  //. ```javascript\n  //. > lift3(x => y => z => x + z + y, ['<'], ['>'], ['foo', 'bar', 'baz'])\n  //. ['<foo>', '<bar>', '<baz>']\n  //.\n  //. > lift3(x => y => z => x + z + y, Identity('<'), Identity('>'), Identity('baz'))\n  //. Identity('<baz>')\n  //. ```\n  function lift3(f, x, y, z) {\n    return ap(ap(map(f, x), y), z);\n  }\n\n  //# apFirst :: Apply f => (f a, f b) -> f a\n  //.\n  //. Combines two effectful actions, keeping only the result of the first.\n  //. Equivalent to Haskell's `(<*)` function.\n  //.\n  //. This function is derived from [`lift2`](#lift2).\n  //.\n  //. See also [`apSecond`](#apSecond).\n  //.\n  //. ```javascript\n  //. > apFirst([1, 2], [3, 4])\n  //. [1, 1, 2, 2]\n  //.\n  //. > apFirst(Identity(1), Identity(2))\n  //. Identity(1)\n  //. ```\n  function apFirst(x, y) {\n    return lift2(constant, x, y);\n  }\n\n  //# apSecond :: Apply f => (f a, f b) -> f b\n  //.\n  //. Combines two effectful actions, keeping only the result of the second.\n  //. Equivalent to Haskell's `(*>)` function.\n  //.\n  //. This function is derived from [`lift2`](#lift2).\n  //.\n  //. See also [`apFirst`](#apFirst).\n  //.\n  //. ```javascript\n  //. > apSecond([1, 2], [3, 4])\n  //. [3, 4, 3, 4]\n  //.\n  //. > apSecond(Identity(1), Identity(2))\n  //. Identity(2)\n  //. ```\n  function apSecond(x, y) {\n    return lift2(constant(identity), x, y);\n  }\n\n  //# of :: Applicative f => (TypeRep f, a) -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/of`][].\n  //.\n  //. `fantasy-land/of` implementations are provided for the following\n  //. built-in types: Array and Function.\n  //.\n  //. ```javascript\n  //. > of(Array, 42)\n  //. [42]\n  //.\n  //. > of(Function, 42)(null)\n  //. 42\n  //.\n  //. > of(List, 42)\n  //. Cons(42, Nil)\n  //. ```\n  function of(typeRep, x) {\n    return Applicative.methods.of(typeRep)(x);\n  }\n\n  //# append :: (Applicative f, Semigroup (f a)) => (a, f a) -> f a\n  //.\n  //. Returns the result of appending the first argument to the second.\n  //.\n  //. This function is derived from [`concat`](#concat) and [`of`](#of).\n  //.\n  //. See also [`prepend`](#prepend).\n  //.\n  //. ```javascript\n  //. > append(3, [1, 2])\n  //. [1, 2, 3]\n  //.\n  //. > append(3, Cons(1, Cons(2, Nil)))\n  //. Cons(1, Cons(2, Cons(3, Nil)))\n  //. ```\n  function append(x, xs) {\n    return concat(xs, of(xs.constructor, x));\n  }\n\n  //# prepend :: (Applicative f, Semigroup (f a)) => (a, f a) -> f a\n  //.\n  //. Returns the result of prepending the first argument to the second.\n  //.\n  //. This function is derived from [`concat`](#concat) and [`of`](#of).\n  //.\n  //. See also [`append`](#append).\n  //.\n  //. ```javascript\n  //. > prepend(1, [2, 3])\n  //. [1, 2, 3]\n  //.\n  //. > prepend(1, Cons(2, Cons(3, Nil)))\n  //. Cons(1, Cons(2, Cons(3, Nil)))\n  //. ```\n  function prepend(x, xs) {\n    return concat(of(xs.constructor, x), xs);\n  }\n\n  //# chain :: Chain m => (a -> m b, m a) -> m b\n  //.\n  //. Function wrapper for [`fantasy-land/chain`][].\n  //.\n  //. `fantasy-land/chain` implementations are provided for the following\n  //. built-in types: Array and Function.\n  //.\n  //. ```javascript\n  //. > chain(x => [x, x], [1, 2, 3])\n  //. [1, 1, 2, 2, 3, 3]\n  //.\n  //. > chain(x => x % 2 == 1 ? of(List, x) : Nil, Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(1, Cons(3, Nil))\n  //.\n  //. > chain(n => s => s.slice(0, n), s => Math.ceil(s.length / 2))('Haskell')\n  //. 'Hask'\n  //. ```\n  function chain(f, chain_) {\n    return Chain.methods.chain(chain_)(f);\n  }\n\n  //# join :: Chain m => m (m a) -> m a\n  //.\n  //. Removes one level of nesting from a nested monadic structure.\n  //.\n  //. This function is derived from [`chain`](#chain).\n  //.\n  //. ```javascript\n  //. > join([[1], [2], [3]])\n  //. [1, 2, 3]\n  //.\n  //. > join([[[1, 2, 3]]])\n  //. [[1, 2, 3]]\n  //.\n  //. > join(Identity(Identity(1)))\n  //. Identity(1)\n  //. ```\n  function join(chain_) {\n    return chain(identity, chain_);\n  }\n\n  //# chainRec :: ChainRec m => (TypeRep m, (a -> c, b -> c, a) -> m c, a) -> m b\n  //.\n  //. Function wrapper for [`fantasy-land/chainRec`][].\n  //.\n  //. `fantasy-land/chainRec` implementations are provided for the following\n  //. built-in types: Array.\n  //.\n  //. ```javascript\n  //. > chainRec(\n  //. .   Array,\n  //. .   (next, done, s) => s.length == 2 ? [s + '!', s + '?'].map(done)\n  //. .                                    : [s + 'o', s + 'n'].map(next),\n  //. .   ''\n  //. . )\n  //. ['oo!', 'oo?', 'on!', 'on?', 'no!', 'no?', 'nn!', 'nn?']\n  //. ```\n  function chainRec(typeRep, f, x) {\n    return ChainRec.methods.chainRec(typeRep)(f, x);\n  }\n\n  //# alt :: Alt f => (f a, f a) -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/alt`][].\n  //.\n  //. `fantasy-land/alt` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > alt([1, 2, 3], [4, 5, 6])\n  //. [1, 2, 3, 4, 5, 6]\n  //.\n  //. > alt(Nothing, Nothing)\n  //. Nothing\n  //.\n  //. > alt(Nothing, Just(1))\n  //. Just(1)\n  //.\n  //. > alt(Just(2), Just(3))\n  //. Just(2)\n  //. ```\n  function alt(x, y) {\n    return Alt.methods.alt(x)(y);\n  }\n\n  //# zero :: Plus f => TypeRep f -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/zero`][].\n  //.\n  //. `fantasy-land/zero` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > zero(Array)\n  //. []\n  //.\n  //. > zero(Object)\n  //. {}\n  //.\n  //. > zero(Maybe)\n  //. Nothing\n  //. ```\n  function zero(typeRep) {\n    return Plus.methods.zero(typeRep)();\n  }\n\n  //# reduce :: Foldable f => ((b, a) -> b, b, f a) -> b\n  //.\n  //. Function wrapper for [`fantasy-land/reduce`][].\n  //.\n  //. `fantasy-land/reduce` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > reduce((xs, x) => [x].concat(xs), [], [1, 2, 3])\n  //. [3, 2, 1]\n  //.\n  //. > reduce(concat, '', Cons('foo', Cons('bar', Cons('baz', Nil))))\n  //. 'foobarbaz'\n  //. ```\n  function reduce(f, x, foldable) {\n    return Foldable.methods.reduce(foldable)(f, x);\n  }\n\n  //# size :: Foldable f => f a -> Integer\n  //.\n  //. Returns the number of elements of the given structure.\n  //.\n  //. This function is derived from [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > size([])\n  //. 0\n  //.\n  //. > size(['foo', 'bar', 'baz'])\n  //. 3\n  //.\n  //. > size(Nil)\n  //. 0\n  //.\n  //. > size(Cons('foo', Cons('bar', Cons('baz', Nil))))\n  //. 3\n  //. ```\n  function size(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray(foldable)) return foldable.length;\n    return reduce(function(n, _) { return n + 1; }, 0, foldable);\n  }\n\n  //# elem :: (Setoid a, Foldable f) => (a, f a) -> Boolean\n  //.\n  //. Takes a value and a structure and returns `true` if the\n  //. value is an element of the structure; `false` otherwise.\n  //.\n  //. This function is derived from [`equals`](#equals) and\n  //. [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > elem('c', ['a', 'b', 'c'])\n  //. true\n  //.\n  //. > elem('x', ['a', 'b', 'c'])\n  //. false\n  //.\n  //. > elem(3, {x: 1, y: 2, z: 3})\n  //. true\n  //.\n  //. > elem(8, {x: 1, y: 2, z: 3})\n  //. false\n  //.\n  //. > elem(0, Just(0))\n  //. true\n  //.\n  //. > elem(0, Just(1))\n  //. false\n  //.\n  //. > elem(0, Nothing)\n  //. false\n  //. ```\n  function elem(x, foldable) {\n    return reduce(function(b, y) { return b || equals(x, y); },\n                  false,\n                  foldable);\n  }\n\n  //# reverse :: (Applicative f, Foldable f, Monoid (f a)) => f a -> f a\n  //.\n  //. Reverses the elements of the given structure.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > reverse([1, 2, 3])\n  //. [3, 2, 1]\n  //.\n  //. > reverse(Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(3, Cons(2, Cons(1, Nil)))\n  //. ```\n  function reverse(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray(foldable)) return foldable.slice().reverse();\n    var F = foldable.constructor;\n    return reduce(function(xs, x) { return concat(of(F, x), xs); },\n                  empty(F),\n                  foldable);\n  }\n\n  //# sort :: (Ord a, Applicative f, Foldable f, Monoid (f a)) => f a -> f a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure,\n  //. using [`lte`](#lte) for comparisons.\n  //.\n  //. This function is derived from [`lte`](#lte), [`concat`](#concat),\n  //. [`empty`](#empty), [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`sortBy`](#sortBy).\n  //.\n  //. ```javascript\n  //. > sort(['foo', 'bar', 'baz'])\n  //. ['bar', 'baz', 'foo']\n  //.\n  //. > sort([Just(2), Nothing, Just(1)])\n  //. [Nothing, Just(1), Just(2)]\n  //.\n  //. > sort(Cons('foo', Cons('bar', Cons('baz', Nil))))\n  //. Cons('bar', Cons('baz', Cons('foo', Nil)))\n  //. ```\n  function sort(foldable) {\n    return sortBy(identity, foldable);\n  }\n\n  //# sortBy :: (Ord b, Applicative f, Foldable f, Monoid (f a)) => (a -> b, f a) -> f a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure,\n  //. using [`lte`](#lte) to compare the values produced by applying the\n  //. given function to each element of the structure.\n  //.\n  //. This function is derived from [`lte`](#lte), [`concat`](#concat),\n  //. [`empty`](#empty), [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`sort`](#sort).\n  //.\n  //. ```javascript\n  //. > sortBy(s => s.length, ['red', 'green', 'blue'])\n  //. ['red', 'blue', 'green']\n  //.\n  //. > sortBy(s => s.length, ['black', 'white'])\n  //. ['black', 'white']\n  //.\n  //. > sortBy(s => s.length, ['white', 'black'])\n  //. ['white', 'black']\n  //.\n  //. > sortBy(s => s.length, Cons('red', Cons('green', Cons('blue', Nil))))\n  //. Cons('red', Cons('blue', Cons('green', Nil)))\n  //. ```\n  function sortBy(f, foldable) {\n    var rs = reduce(function(xs, x) {\n      var fx = f(x);\n      var lower = 0;\n      var upper = xs.length;\n      while (lower < upper) {\n        var idx = Math.floor((lower + upper) / 2);\n        if (lte(xs[idx].fx, fx)) lower = idx + 1; else upper = idx;\n      }\n      xs.splice(lower, 0, {x: x, fx: fx});\n      return xs;\n    }, [], foldable);\n\n    var F = foldable.constructor;\n    var result = empty(F);\n    for (var idx = 0; idx < rs.length; idx += 1) {\n      result = concat(result, of(F, rs[idx].x));\n    }\n    return result;\n  }\n\n  //# takeWhile :: (Applicative f, Foldable f, Monoid (f a)) => (a -> Boolean, f a) -> f a\n  //.\n  //. Discards the first inner value which does not satisfy the predicate, and\n  //. all subsequent inner values.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`dropWhile`](#dropWhile).\n  //.\n  //. ```javascript\n  //. > takeWhile(s => /x/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xy', 'xz', 'yx']\n  //.\n  //. > takeWhile(s => /y/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xy']\n  //.\n  //. > takeWhile(s => /z/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. []\n  //. ```\n  function takeWhile(pred, foldable) {\n    var take = true;\n    return filter(function(x) { return take = take && pred(x); }, foldable);\n  }\n\n  //# dropWhile :: (Applicative f, Foldable f, Monoid (f a)) => (a -> Boolean, f a) -> f a\n  //.\n  //. Retains the first inner value which does not satisfy the predicate, and\n  //. all subsequent inner values.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`takeWhile`](#takeWhile).\n  //.\n  //. ```javascript\n  //. > dropWhile(s => /x/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['yz', 'zx', 'zy']\n  //.\n  //. > dropWhile(s => /y/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xz', 'yx', 'yz', 'zx', 'zy']\n  //.\n  //. > dropWhile(s => /z/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xy', 'xz', 'yx', 'yz', 'zx', 'zy']\n  //. ```\n  function dropWhile(pred, foldable) {\n    var take = false;\n    return filter(function(x) { return take = take || !pred(x); }, foldable);\n  }\n\n  //# traverse :: (Applicative f, Traversable t) => (TypeRep f, a -> f b, t a) -> f (t b)\n  //.\n  //. Function wrapper for [`fantasy-land/traverse`][].\n  //.\n  //. `fantasy-land/traverse` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. See also [`sequence`](#sequence).\n  //.\n  //. ```javascript\n  //. > traverse(Array, x => x, [[1, 2, 3], [4, 5]])\n  //. [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]\n  //.\n  //. > traverse(Identity, x => Identity(x + 1), [1, 2, 3])\n  //. Identity([2, 3, 4])\n  //. ```\n  function traverse(typeRep, f, traversable) {\n    return Traversable.methods.traverse(traversable)(typeRep, f);\n  }\n\n  //# sequence :: (Applicative f, Traversable t) => (TypeRep f, t (f a)) -> f (t a)\n  //.\n  //. Inverts the given `t (f a)` to produce an `f (t a)`.\n  //.\n  //. This function is derived from [`traverse`](#traverse).\n  //.\n  //. ```javascript\n  //. > sequence(Array, Identity([1, 2, 3]))\n  //. [Identity(1), Identity(2), Identity(3)]\n  //.\n  //. > sequence(Identity, [Identity(1), Identity(2), Identity(3)])\n  //. Identity([1, 2, 3])\n  //. ```\n  function sequence(typeRep, traversable) {\n    return traverse(typeRep, identity, traversable);\n  }\n\n  //# extend :: Extend w => (w a -> b, w a) -> w b\n  //.\n  //. Function wrapper for [`fantasy-land/extend`][].\n  //.\n  //. `fantasy-land/extend` implementations are provided for the following\n  //. built-in types: Array and Function.\n  //.\n  //. ```javascript\n  //. > extend(ss => ss.join(''), ['x', 'y', 'z'])\n  //. ['xyz', 'yz', 'z']\n  //.\n  //. > extend(f => f([3, 4]), reverse)([1, 2])\n  //. [4, 3, 2, 1]\n  //. ```\n  function extend(f, extend_) {\n    return Extend.methods.extend(extend_)(f);\n  }\n\n  //# duplicate :: Extend w => w a -> w (w a)\n  //.\n  //. Adds one level of nesting to a comonadic structure.\n  //.\n  //. This function is derived from [`extend`](#extend).\n  //.\n  //. ```javascript\n  //. > duplicate(Identity(1))\n  //. Identity(Identity(1))\n  //.\n  //. > duplicate([1])\n  //. [[1]]\n  //.\n  //. > duplicate([1, 2, 3])\n  //. [[1, 2, 3], [2, 3], [3]]\n  //.\n  //. > duplicate(reverse)([1, 2])([3, 4])\n  //. [4, 3, 2, 1]\n  //. ```\n  function duplicate(extend_) {\n    return extend(identity, extend_);\n  }\n\n  //# extract :: Comonad w => w a -> a\n  //.\n  //. Function wrapper for [`fantasy-land/extract`][].\n  //.\n  //. ```javascript\n  //. > extract(Identity(42))\n  //. 42\n  //. ```\n  function extract(comonad) {\n    return Comonad.methods.extract(comonad)();\n  }\n\n  //# contramap :: Contravariant f => (b -> a, f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/contramap`][].\n  //.\n  //. `fantasy-land/contramap` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > contramap(s => s.length, Math.sqrt)('Sanctuary')\n  //. 3\n  //. ```\n  function contramap(f, contravariant) {\n    return Contravariant.methods.contramap(contravariant)(f);\n  }\n\n  return {\n    TypeClass: TypeClass,\n    Setoid: Setoid,\n    Ord: Ord,\n    Semigroupoid: Semigroupoid,\n    Category: Category,\n    Semigroup: Semigroup,\n    Monoid: Monoid,\n    Group: Group,\n    Filterable: Filterable,\n    Functor: Functor,\n    Bifunctor: Bifunctor,\n    Profunctor: Profunctor,\n    Apply: Apply,\n    Applicative: Applicative,\n    Chain: Chain,\n    ChainRec: ChainRec,\n    Monad: Monad,\n    Alt: Alt,\n    Plus: Plus,\n    Alternative: Alternative,\n    Foldable: Foldable,\n    Traversable: Traversable,\n    Extend: Extend,\n    Comonad: Comonad,\n    Contravariant: Contravariant,\n    toString: toString,\n    equals: equals,\n    lt: lt,\n    lte: lte,\n    gt: gt,\n    gte: gte,\n    min: min,\n    max: max,\n    compose: compose,\n    id: id,\n    concat: concat,\n    empty: empty,\n    invert: invert,\n    filter: filter,\n    reject: reject,\n    map: map,\n    bimap: bimap,\n    promap: promap,\n    ap: ap,\n    lift2: lift2,\n    lift3: lift3,\n    apFirst: apFirst,\n    apSecond: apSecond,\n    of: of,\n    append: append,\n    prepend: prepend,\n    chain: chain,\n    join: join,\n    chainRec: chainRec,\n    alt: alt,\n    zero: zero,\n    reduce: reduce,\n    size: size,\n    elem: elem,\n    reverse: reverse,\n    sort: sort,\n    sortBy: sortBy,\n    takeWhile: takeWhile,\n    dropWhile: dropWhile,\n    traverse: traverse,\n    sequence: sequence,\n    extend: extend,\n    duplicate: duplicate,\n    extract: extract,\n    contramap: contramap\n  };\n\n}));\n\n//. [Alt]:                      https://github.com/fantasyland/fantasy-land#alt\n//. [Alternative]:              https://github.com/fantasyland/fantasy-land#alternative\n//. [Applicative]:              https://github.com/fantasyland/fantasy-land#applicative\n//. [Apply]:                    https://github.com/fantasyland/fantasy-land#apply\n//. [Bifunctor]:                https://github.com/fantasyland/fantasy-land#bifunctor\n//. [Category]:                 https://github.com/fantasyland/fantasy-land#category\n//. [Chain]:                    https://github.com/fantasyland/fantasy-land#chain\n//. [ChainRec]:                 https://github.com/fantasyland/fantasy-land#chainrec\n//. [Comonad]:                  https://github.com/fantasyland/fantasy-land#comonad\n//. [Contravariant]:            https://github.com/fantasyland/fantasy-land#contravariant\n//. [Extend]:                   https://github.com/fantasyland/fantasy-land#extend\n//. [FL]:                       https://github.com/fantasyland/fantasy-land\n//. [Filterable]:               https://github.com/fantasyland/fantasy-land#filterable\n//. [Foldable]:                 https://github.com/fantasyland/fantasy-land#foldable\n//. [Functor]:                  https://github.com/fantasyland/fantasy-land#functor\n//. [Group]:                    https://github.com/fantasyland/fantasy-land#group\n//. [Monad]:                    https://github.com/fantasyland/fantasy-land#monad\n//. [Monoid]:                   https://github.com/fantasyland/fantasy-land#monoid\n//. [Ord]:                      https://github.com/fantasyland/fantasy-land#ord\n//. [Plus]:                     https://github.com/fantasyland/fantasy-land#plus\n//. [Profunctor]:               https://github.com/fantasyland/fantasy-land#profunctor\n//. [Semigroup]:                https://github.com/fantasyland/fantasy-land#semigroup\n//. [Semigroupoid]:             https://github.com/fantasyland/fantasy-land#semigroupoid\n//. [Setoid]:                   https://github.com/fantasyland/fantasy-land#setoid\n//. [Traversable]:              https://github.com/fantasyland/fantasy-land#traversable\n//. [`fantasy-land/alt`]:       https://github.com/fantasyland/fantasy-land#alt-method\n//. [`fantasy-land/ap`]:        https://github.com/fantasyland/fantasy-land#ap-method\n//. [`fantasy-land/bimap`]:     https://github.com/fantasyland/fantasy-land#bimap-method\n//. [`fantasy-land/chain`]:     https://github.com/fantasyland/fantasy-land#chain-method\n//. [`fantasy-land/chainRec`]:  https://github.com/fantasyland/fantasy-land#chainrec-method\n//. [`fantasy-land/compose`]:   https://github.com/fantasyland/fantasy-land#compose-method\n//. [`fantasy-land/concat`]:    https://github.com/fantasyland/fantasy-land#concat-method\n//. [`fantasy-land/contramap`]: https://github.com/fantasyland/fantasy-land#contramap-method\n//. [`fantasy-land/empty`]:     https://github.com/fantasyland/fantasy-land#empty-method\n//. [`fantasy-land/equals`]:    https://github.com/fantasyland/fantasy-land#equals-method\n//. [`fantasy-land/extend`]:    https://github.com/fantasyland/fantasy-land#extend-method\n//. [`fantasy-land/extract`]:   https://github.com/fantasyland/fantasy-land#extract-method\n//. [`fantasy-land/filter`]:    https://github.com/fantasyland/fantasy-land#filter-method\n//. [`fantasy-land/id`]:        https://github.com/fantasyland/fantasy-land#id-method\n//. [`fantasy-land/invert`]:    https://github.com/fantasyland/fantasy-land#invert-method\n//. [`fantasy-land/lte`]:       https://github.com/fantasyland/fantasy-land#lte-method\n//. [`fantasy-land/map`]:       https://github.com/fantasyland/fantasy-land#map-method\n//. [`fantasy-land/of`]:        https://github.com/fantasyland/fantasy-land#of-method\n//. [`fantasy-land/promap`]:    https://github.com/fantasyland/fantasy-land#promap-method\n//. [`fantasy-land/reduce`]:    https://github.com/fantasyland/fantasy-land#reduce-method\n//. [`fantasy-land/traverse`]:  https://github.com/fantasyland/fantasy-land#traverse-method\n//. [`fantasy-land/zero`]:      https://github.com/fantasyland/fantasy-land#zero-method\n//. [stable sort]:              https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\n//. [type-classes]:             https://github.com/sanctuary-js/sanctuary-def#type-classes\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5LXR5cGUtY2xhc3Nlcy9pbmRleC5qcz9lNTBjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgICAgICAgICAgIyMjIyMjIyMjIyMjICAgICAgICAgICAgICAgICAgI1xuICAgICAgICAgICAgIyMjIyMjIyMjIyMjICAgICAgICAgICAgICAgICAgIyMjXG4gICAgICAgICAgICAgICAgICAjIyMjIyAgICAgICAgICAgICAgICAgICMjIyMjXG4gICAgICAgICAgICAgICAgIyMjIyMgICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjI1xuICAgICAgICAgICAgICAjIyMjIyAgICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gICAgICAgICAgICAjIyMjIyAgICAgICAgICAgICAgICAgICAgICMjIyMjIyMjIyMjXG4gICAgICAgICAgIyMjIyMgICAgICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gICAgICAgICMjIyMjICAgICAgICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gICAgICAjIyMjIyAgICAgICAgICAgICAgICAgICAgICAgICMjIyMjXG4gICAgICMjIyMjIyMjIyMjIyAgICAgICAgICAgICAgICAgIyMjXG4gICAgIyMjIyMjIyMjIyMjICAgICAgICAgICAgICAgICAqL1xuXG4vLy4gIyBzYW5jdHVhcnktdHlwZS1jbGFzc2VzXG4vLy5cbi8vLiBUaGUgW0ZhbnRhc3kgTGFuZCBTcGVjaWZpY2F0aW9uXVtGTF0gXCJzcGVjaWZpZXMgaW50ZXJvcGVyYWJpbGl0eSBvZiBjb21tb25cbi8vLiBhbGdlYnJhaWMgc3RydWN0dXJlc1wiIGJ5IGRlZmluaW5nIGEgbnVtYmVyIG9mIHR5cGUgY2xhc3Nlcy4gRm9yIGVhY2ggdHlwZVxuLy8uIGNsYXNzLCBpdCBzdGF0ZXMgbGF3cyB3aGljaCBldmVyeSBtZW1iZXIgb2YgYSB0eXBlIG11c3Qgb2JleSBpbiBvcmRlciBmb3Jcbi8vLiB0aGUgdHlwZSB0byBiZSBhIG1lbWJlciBvZiB0aGUgdHlwZSBjbGFzcy4gSW4gb3JkZXIgZm9yIHRoZSBNYXliZSB0eXBlIHRvXG4vLy4gYmUgY29uc2lkZXJlZCBhIFtGdW5jdG9yXVtdLCBmb3IgZXhhbXBsZSwgZXZlcnkgYE1heWJlIGFgIHZhbHVlIG11c3QgaGF2ZVxuLy8uIGEgYGZhbnRhc3ktbGFuZC9tYXBgIG1ldGhvZCB3aGljaCBvYmV5cyB0aGUgaWRlbnRpdHkgYW5kIGNvbXBvc2l0aW9uIGxhd3MuXG4vLy5cbi8vLiBUaGlzIHByb2plY3QgcHJvdmlkZXM6XG4vLy5cbi8vLiAgIC0gW2BUeXBlQ2xhc3NgXSgjVHlwZUNsYXNzKSwgYSBmdW5jdGlvbiBmb3IgZGVmaW5pbmcgdHlwZSBjbGFzc2VzO1xuLy8uICAgLSBvbmUgYFR5cGVDbGFzc2AgdmFsdWUgZm9yIGVhY2ggRmFudGFzeSBMYW5kIHR5cGUgY2xhc3M7XG4vLy4gICAtIGxhd2Z1bCBGYW50YXN5IExhbmQgbWV0aG9kcyBmb3IgSmF2YVNjcmlwdCdzIGJ1aWx0LWluIHR5cGVzO1xuLy8uICAgLSBvbmUgZnVuY3Rpb24gZm9yIGVhY2ggRmFudGFzeSBMYW5kIG1ldGhvZDsgYW5kXG4vLy4gICAtIHNldmVyYWwgZnVuY3Rpb25zIGRlcml2ZWQgZnJvbSB0aGVzZSBmdW5jdGlvbnMuXG4vLy5cbi8vLiAjIyBUeXBlLWNsYXNzIGhpZXJhcmNoeVxuLy8uXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4vLy4gPHByZT5cbi8vLiAgU2V0b2lkICAgU2VtaWdyb3Vwb2lkICBTZW1pZ3JvdXAgICBGb2xkYWJsZSAgICAgICAgRnVuY3RvciAgICAgIENvbnRyYXZhcmlhbnQgIEZpbHRlcmFibGVcbi8vLiAoZXF1YWxzKSAgICAoY29tcG9zZSkgICAgKGNvbmNhdCkgICAocmVkdWNlKSAgICAgICAgIChtYXApICAgICAgICAoY29udHJhbWFwKSAgICAoZmlsdGVyKVxuLy8uICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICBcXCAgICAgICAgIC8gfCB8IHwgfCBcXFxuLy8uICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgXFwgICAgICAgLyAgfCB8IHwgfCAgXFxcbi8vLiAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICBcXCAgICAgLyAgIHwgfCB8IHwgICBcXFxuLy8uICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICBcXCAgIC8gICAgfCB8IHwgfCAgICBcXFxuLy8uICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgXFwgLyAgICAgfCB8IHwgfCAgICAgXFxcbi8vLiAgICBPcmQgICAgICBDYXRlZ29yeSAgICAgTW9ub2lkICAgICAgICAgVHJhdmVyc2FibGUgfCB8IHwgfCAgICAgIFxcXG4vLy4gICAobHRlKSAgICAgICAoaWQpICAgICAgIChlbXB0eSkgICAgICAgICh0cmF2ZXJzZSkgIC8gfCB8IFxcICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgLyAgfCB8ICBcXCAgICAgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgLyAgIC8gXFwgICBcXCAgICAgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIFByb2Z1bmN0b3IgLyAgIFxcIEJpZnVuY3RvciBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAocHJvbWFwKSAvICAgICBcXCAoYmltYXApICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAvICAgICAgIFxcICAgICAgICAgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgR3JvdXAgICAgICAgICAgICAgICAgICAgLyAgICAgICAgIFxcICAgICAgICAgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAoaW52ZXJ0KSAgICAgICAgICAgICAgIEFsdCAgICAgICAgQXBwbHkgICAgICBFeHRlbmRcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhbHQpICAgICAgICAoYXApICAgICAoZXh0ZW5kKVxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgICAgIC8gXFwgICAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvICAgICAgICAgICAvICAgXFwgICAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgICAgIC8gICAgIFxcICAgICAgICAgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgICAgIC8gICAgICAgXFwgICAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvICAgICAgICAgICAvICAgICAgICAgXFwgICAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUGx1cyAgICBBcHBsaWNhdGl2ZSAgICBDaGFpbiAgICAgIENvbW9uYWRcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh6ZXJvKSAgICAgICAob2YpICAgICAgKGNoYWluKSAgICAoZXh0cmFjdClcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcICAgICAgICAgLyBcXCAgICAgICAgIC8gXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXCAgICAgICAvICAgXFwgICAgICAgLyAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcICAgICAvICAgICBcXCAgICAgLyAgICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcICAgLyAgICAgICBcXCAgIC8gICAgICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXCAvICAgICAgICAgXFwgLyAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbHRlcm5hdGl2ZSAgICBNb25hZCAgICAgQ2hhaW5SZWNcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjaGFpblJlYylcbi8vLiA8L3ByZT5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuLy8uXG4vLy4gIyMgQVBJXG5cbihmdW5jdGlvbihmKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmKHJlcXVpcmUoJ3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzJykpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCAhPSBudWxsKSB7XG4gICAgZGVmaW5lKFsnc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMnXSwgZik7XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5zYW5jdHVhcnlUeXBlQ2xhc3NlcyA9IGYoc2VsZi5zYW5jdHVhcnlUeXBlSWRlbnRpZmllcnMpO1xuICB9XG5cbn0oZnVuY3Rpb24odHlwZSkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyAgY29uY2F0XyA6OiBBcnJheSBhIC0+IEFycmF5IGEgLT4gQXJyYXkgYVxuICBmdW5jdGlvbiBjb25jYXRfKHhzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHlzKSB7XG4gICAgICByZXR1cm4geHMuY29uY2F0KHlzKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gIGNvbnN0YW50IDo6IGEgLT4gYiAtPiBhXG4gIGZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgfVxuXG4gIC8vICBmb3JFYWNoS2V5IDo6IChTdHJNYXAgYSwgU3RyTWFwIGEgfj4gU3RyaW5nIC0+IFVuZGVmaW5lZCkgLT4gVW5kZWZpbmVkXG4gIGZ1bmN0aW9uIGZvckVhY2hLZXkoc3RyTWFwLCBmKSB7XG4gICAgT2JqZWN0LmtleXMoc3RyTWFwKS5mb3JFYWNoKGYsIHN0ck1hcCk7XG4gIH1cblxuICAvLyAgaGFzIDo6IChTdHJpbmcsIE9iamVjdCkgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBoYXMoaywgbykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgayk7XG4gIH1cblxuICAvLyAgaWRlbnRpdHkgOjogYSAtPiBhXG4gIGZ1bmN0aW9uIGlkZW50aXR5KHgpIHsgcmV0dXJuIHg7IH1cblxuICAvLyAgcGFpciA6OiBhIC0+IGIgLT4gUGFpciBhIGJcbiAgZnVuY3Rpb24gcGFpcih4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfTtcbiAgfVxuXG4gIC8vICBzYW1lVHlwZSA6OiAoYSwgYikgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBzYW1lVHlwZSh4LCB5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSB0eXBlb2YgeSAmJiB0eXBlKHgpID09PSB0eXBlKHkpO1xuICB9XG5cbiAgLy8gIHR5cGUgSXRlcmF0aW9uIGEgPSB7IHZhbHVlIDo6IGEsIGRvbmUgOjogQm9vbGVhbiB9XG5cbiAgLy8gIGl0ZXJhdGlvbk5leHQgOjogYSAtPiBJdGVyYXRpb24gYVxuICBmdW5jdGlvbiBpdGVyYXRpb25OZXh0KHgpIHsgcmV0dXJuIHt2YWx1ZTogeCwgZG9uZTogZmFsc2V9OyB9XG5cbiAgLy8gIGl0ZXJhdGlvbkRvbmUgOjogYSAtPiBJdGVyYXRpb24gYVxuICBmdW5jdGlvbiBpdGVyYXRpb25Eb25lKHgpIHsgcmV0dXJuIHt2YWx1ZTogeCwgZG9uZTogdHJ1ZX07IH1cblxuICAvLyMgVHlwZUNsYXNzIDo6IChTdHJpbmcsIFN0cmluZywgQXJyYXkgVHlwZUNsYXNzLCBhIC0+IEJvb2xlYW4pIC0+IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIFRoZSBhcmd1bWVudHMgYXJlOlxuICAvLy5cbiAgLy8uICAgLSB0aGUgbmFtZSBvZiB0aGUgdHlwZSBjbGFzcywgcHJlZml4ZWQgYnkgaXRzIG5wbSBwYWNrYWdlIG5hbWU7XG4gIC8vLiAgIC0gdGhlIGRvY3VtZW50YXRpb24gVVJMIG9mIHRoZSB0eXBlIGNsYXNzO1xuICAvLy4gICAtIGFuIGFycmF5IG9mIGRlcGVuZGVuY2llczsgYW5kXG4gIC8vLiAgIC0gYSBwcmVkaWNhdGUgd2hpY2ggYWNjZXB0cyBhbnkgSmF2YVNjcmlwdCB2YWx1ZSBhbmQgcmV0dXJucyBgdHJ1ZWBcbiAgLy8uICAgICBpZiB0aGUgdmFsdWUgc2F0aXNmaWVzIHRoZSByZXF1aXJlbWVudHMgb2YgdGhlIHR5cGUgY2xhc3M7IGBmYWxzZWBcbiAgLy8uICAgICBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gRXhhbXBsZTpcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiAvLyAgICBoYXNNZXRob2QgOjogU3RyaW5nIC0+IGEgLT4gQm9vbGVhblxuICAvLy4gY29uc3QgaGFzTWV0aG9kID0gbmFtZSA9PiB4ID0+IHggIT0gbnVsbCAmJiB0eXBlb2YgeFtuYW1lXSA9PSAnZnVuY3Rpb24nO1xuICAvLy5cbiAgLy8uIC8vICAgIEZvbyA6OiBUeXBlQ2xhc3NcbiAgLy8uIGNvbnN0IEZvbyA9IFouVHlwZUNsYXNzKFxuICAvLy4gICAnbXktcGFja2FnZS9Gb28nLFxuICAvLy4gICAnaHR0cDovL2V4YW1wbGUuY29tL215LXBhY2thZ2UjRm9vJyxcbiAgLy8uICAgW10sXG4gIC8vLiAgIGhhc01ldGhvZCgnZm9vJylcbiAgLy8uICk7XG4gIC8vLlxuICAvLy4gLy8gICAgQmFyIDo6IFR5cGVDbGFzc1xuICAvLy4gY29uc3QgQmFyID0gWi5UeXBlQ2xhc3MoXG4gIC8vLiAgICdteS1wYWNrYWdlL0JhcicsXG4gIC8vLiAgICdodHRwOi8vZXhhbXBsZS5jb20vbXktcGFja2FnZSNCYXInLFxuICAvLy4gICBbRm9vXSxcbiAgLy8uICAgaGFzTWV0aG9kKCdiYXInKVxuICAvLy4gKTtcbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uIFR5cGVzIHdob3NlIHZhbHVlcyBoYXZlIGEgYGZvb2AgbWV0aG9kIGFyZSBtZW1iZXJzIG9mIHRoZSBGb28gdHlwZSBjbGFzcy5cbiAgLy8uIE1lbWJlcnMgb2YgdGhlIEZvbyB0eXBlIGNsYXNzIHdob3NlIHZhbHVlcyBoYXZlIGEgYGJhcmAgbWV0aG9kIGFyZSBhbHNvXG4gIC8vLiBtZW1iZXJzIG9mIHRoZSBCYXIgdHlwZSBjbGFzcy5cbiAgLy8uXG4gIC8vLiBFYWNoIGBUeXBlQ2xhc3NgIHZhbHVlIGhhcyBhIGB0ZXN0YCBmaWVsZDogYSBmdW5jdGlvbiB3aGljaCBhY2NlcHRzXG4gIC8vLiBhbnkgSmF2YVNjcmlwdCB2YWx1ZSBhbmQgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIHNhdGlzZmllcyB0aGVcbiAgLy8uIHR5cGUgY2xhc3MncyBwcmVkaWNhdGUgYW5kIHRoZSBwcmVkaWNhdGVzIG9mIGFsbCB0aGUgdHlwZSBjbGFzcydzXG4gIC8vLiBkZXBlbmRlbmNpZXM7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlcyBtYXkgYmUgdXNlZCB3aXRoIFtzYW5jdHVhcnktZGVmXVt0eXBlLWNsYXNzZXNdXG4gIC8vLiB0byBkZWZpbmUgcGFyYW1ldHJpY2FsbHkgcG9seW1vcnBoaWMgZnVuY3Rpb25zIHdoaWNoIHZlcmlmeSB0aGVpclxuICAvLy4gdHlwZS1jbGFzcyBjb25zdHJhaW50cyBhdCBydW4gdGltZS5cbiAgZnVuY3Rpb24gVHlwZUNsYXNzKG5hbWUsIHVybCwgZGVwZW5kZW5jaWVzLCB0ZXN0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFR5cGVDbGFzcykpIHtcbiAgICAgIHJldHVybiBuZXcgVHlwZUNsYXNzKG5hbWUsIHVybCwgZGVwZW5kZW5jaWVzLCB0ZXN0KTtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnRlc3QgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gZGVwZW5kZW5jaWVzLmV2ZXJ5KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudGVzdCh4KTsgfSkgJiYgdGVzdCh4KTtcbiAgICB9O1xuICB9XG5cbiAgVHlwZUNsYXNzWydAQHR5cGUnXSA9ICdzYW5jdHVhcnktdHlwZS1jbGFzc2VzL1R5cGVDbGFzcyc7XG5cbiAgLy8gIGRhdGEgTG9jYXRpb24gPSBDb25zdHJ1Y3RvciB8IFZhbHVlXG5cbiAgLy8gIENvbnN0cnVjdG9yIDo6IExvY2F0aW9uXG4gIHZhciBDb25zdHJ1Y3RvciA9ICdDb25zdHJ1Y3Rvcic7XG5cbiAgLy8gIFZhbHVlIDo6IExvY2F0aW9uXG4gIHZhciBWYWx1ZSA9ICdWYWx1ZSc7XG5cbiAgLy8gIF9mdW5jUGF0aCA6OiAoQm9vbGVhbiwgQXJyYXkgU3RyaW5nLCBhKSAtPiBOdWxsYWJsZSBGdW5jdGlvblxuICBmdW5jdGlvbiBfZnVuY1BhdGgoYWxsb3dJbmhlcml0ZWRQcm9wcywgcGF0aCwgX3gpIHtcbiAgICB2YXIgeCA9IF94O1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHBhdGgubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgICAgdmFyIGsgPSBwYXRoW2lkeF07XG4gICAgICBpZiAoeCA9PSBudWxsIHx8ICEoYWxsb3dJbmhlcml0ZWRQcm9wcyB8fCBoYXMoaywgeCkpKSByZXR1cm4gbnVsbDtcbiAgICAgIHggPSB4W2tdO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgPyB4IDogbnVsbDtcbiAgfVxuXG4gIC8vICBmdW5jUGF0aCA6OiAoQXJyYXkgU3RyaW5nLCBhKSAtPiBOdWxsYWJsZSBGdW5jdGlvblxuICBmdW5jdGlvbiBmdW5jUGF0aChwYXRoLCB4KSB7XG4gICAgcmV0dXJuIF9mdW5jUGF0aCh0cnVlLCBwYXRoLCB4KTtcbiAgfVxuXG4gIC8vICBpbXBsUGF0aCA6OiBBcnJheSBTdHJpbmcgLT4gTnVsbGFibGUgRnVuY3Rpb25cbiAgZnVuY3Rpb24gaW1wbFBhdGgocGF0aCkge1xuICAgIHJldHVybiBfZnVuY1BhdGgoZmFsc2UsIHBhdGgsIGltcGxlbWVudGF0aW9ucyk7XG4gIH1cblxuICAvLyAgZnVuY3Rpb25OYW1lIDo6IEZ1bmN0aW9uIC0+IFN0cmluZ1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaGFzKCduYW1lJywgZnVuY3Rpb24gZigpIHt9KSA/XG4gICAgZnVuY3Rpb24gZnVuY3Rpb25OYW1lKGYpIHsgcmV0dXJuIGYubmFtZTsgfSA6XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbk5hbWUoZikge1xuICAgICAgdmFyIG1hdGNoID0gL2Z1bmN0aW9uIChcXHcqKS8uZXhlYyhmKTtcbiAgICAgIHJldHVybiBtYXRjaCA9PSBudWxsID8gJycgOiBtYXRjaFsxXTtcbiAgICB9O1xuXG4gIC8vICAkIDo6IChTdHJpbmcsIEFycmF5IFR5cGVDbGFzcywgU3RyTWFwIChBcnJheSBMb2NhdGlvbikpIC0+IFR5cGVDbGFzc1xuICBmdW5jdGlvbiAkKF9uYW1lLCBkZXBlbmRlbmNpZXMsIHJlcXVpcmVtZW50cykge1xuICAgIGZ1bmN0aW9uIGdldEJvdW5kTWV0aG9kKF9uYW1lKSB7XG4gICAgICB2YXIgbmFtZSA9ICdmYW50YXN5LWxhbmQvJyArIF9uYW1lO1xuICAgICAgcmV0dXJuIHJlcXVpcmVtZW50c1tfbmFtZV0gPT09IENvbnN0cnVjdG9yID9cbiAgICAgICAgZnVuY3Rpb24odHlwZVJlcCkge1xuICAgICAgICAgIHZhciBmID0gZnVuY1BhdGgoW25hbWVdLCB0eXBlUmVwKTtcbiAgICAgICAgICByZXR1cm4gZiA9PSBudWxsICYmIHR5cGVvZiB0eXBlUmVwID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIGltcGxQYXRoKFtmdW5jdGlvbk5hbWUodHlwZVJlcCksIG5hbWVdKSA6XG4gICAgICAgICAgICBmO1xuICAgICAgICB9IDpcbiAgICAgICAgZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHZhciBpc1Byb3RvdHlwZSA9IHggIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguY29uc3RydWN0b3IgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguY29uc3RydWN0b3IucHJvdG90eXBlID09PSB4O1xuICAgICAgICAgIHZhciBtID0gbnVsbDtcbiAgICAgICAgICBpZiAoIWlzUHJvdG90eXBlKSBtID0gZnVuY1BhdGgoW25hbWVdLCB4KTtcbiAgICAgICAgICBpZiAobSA9PSBudWxsKSAgICBtID0gaW1wbFBhdGgoW3R5cGUoeCksICdwcm90b3R5cGUnLCBuYW1lXSk7XG4gICAgICAgICAgcmV0dXJuIG0gJiYgbS5iaW5kKHgpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciB2ZXJzaW9uID0gJzguMC4wJzsgIC8vIHVwZGF0ZWQgcHJvZ3JhbW1hdGljYWxseVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVxdWlyZW1lbnRzKTtcblxuICAgIHZhciB0eXBlQ2xhc3MgPSBUeXBlQ2xhc3MoXG4gICAgICAnc2FuY3R1YXJ5LXR5cGUtY2xhc3Nlcy8nICsgX25hbWUsXG4gICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3NhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzL3RyZWUvdicgKyB2ZXJzaW9uXG4gICAgICAgICsgJyMnICsgX25hbWUsXG4gICAgICBkZXBlbmRlbmNpZXMsXG4gICAgICBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KGZ1bmN0aW9uKF9uYW1lKSB7XG4gICAgICAgICAgdmFyIGFyZyA9IHJlcXVpcmVtZW50c1tfbmFtZV0gPT09IENvbnN0cnVjdG9yID8geC5jb25zdHJ1Y3RvciA6IHg7XG4gICAgICAgICAgcmV0dXJuIGdldEJvdW5kTWV0aG9kKF9uYW1lKShhcmcpICE9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG5cbiAgICB0eXBlQ2xhc3MubWV0aG9kcyA9IGtleXMucmVkdWNlKGZ1bmN0aW9uKG1ldGhvZHMsIF9uYW1lKSB7XG4gICAgICBtZXRob2RzW19uYW1lXSA9IGdldEJvdW5kTWV0aG9kKF9uYW1lKTtcbiAgICAgIHJldHVybiBtZXRob2RzO1xuICAgIH0sIHt9KTtcblxuICAgIHJldHVybiB0eXBlQ2xhc3M7XG4gIH1cblxuICAvLyMgU2V0b2lkIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbU2V0b2lkXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gU2V0b2lkLnRlc3QobnVsbClcbiAgLy8uIHRydWVcbiAgLy8uIGBgYFxuICB2YXIgU2V0b2lkID0gJCgnU2V0b2lkJywgW10sIHtlcXVhbHM6IFZhbHVlfSk7XG5cbiAgLy8jIE9yZCA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW09yZF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IE9yZC50ZXN0KDApXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBPcmQudGVzdChNYXRoLnNxcnQpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBPcmQgPSAkKCdPcmQnLCBbU2V0b2lkXSwge2x0ZTogVmFsdWV9KTtcblxuICAvLyMgU2VtaWdyb3Vwb2lkIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbU2VtaWdyb3Vwb2lkXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gU2VtaWdyb3Vwb2lkLnRlc3QoTWF0aC5zcXJ0KVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gU2VtaWdyb3Vwb2lkLnRlc3QoMClcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIFNlbWlncm91cG9pZCA9ICQoJ1NlbWlncm91cG9pZCcsIFtdLCB7Y29tcG9zZTogVmFsdWV9KTtcblxuICAvLyMgQ2F0ZWdvcnkgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtDYXRlZ29yeV1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IENhdGVnb3J5LnRlc3QoTWF0aC5zcXJ0KVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gQ2F0ZWdvcnkudGVzdCgwKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgQ2F0ZWdvcnkgPSAkKCdDYXRlZ29yeScsIFtTZW1pZ3JvdXBvaWRdLCB7aWQ6IENvbnN0cnVjdG9yfSk7XG5cbiAgLy8jIFNlbWlncm91cCA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW1NlbWlncm91cF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFNlbWlncm91cC50ZXN0KCcnKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gU2VtaWdyb3VwLnRlc3QoMClcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIFNlbWlncm91cCA9ICQoJ1NlbWlncm91cCcsIFtdLCB7Y29uY2F0OiBWYWx1ZX0pO1xuXG4gIC8vIyBNb25vaWQgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtNb25vaWRdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBNb25vaWQudGVzdCgnJylcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IE1vbm9pZC50ZXN0KDApXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBNb25vaWQgPSAkKCdNb25vaWQnLCBbU2VtaWdyb3VwXSwge2VtcHR5OiBDb25zdHJ1Y3Rvcn0pO1xuXG4gIC8vIyBHcm91cCA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0dyb3VwXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gR3JvdXAudGVzdChTdW0oMCkpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBHcm91cC50ZXN0KCcnKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgR3JvdXAgPSAkKCdHcm91cCcsIFtNb25vaWRdLCB7aW52ZXJ0OiBWYWx1ZX0pO1xuXG4gIC8vIyBGaWx0ZXJhYmxlIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbRmlsdGVyYWJsZV1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IEZpbHRlcmFibGUudGVzdCh7fSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IEZpbHRlcmFibGUudGVzdCgnJylcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIEZpbHRlcmFibGUgPSAkKCdGaWx0ZXJhYmxlJywgW10sIHtmaWx0ZXI6IFZhbHVlfSk7XG5cbiAgLy8jIEZ1bmN0b3IgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtGdW5jdG9yXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gRnVuY3Rvci50ZXN0KFtdKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gRnVuY3Rvci50ZXN0KCcnKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgRnVuY3RvciA9ICQoJ0Z1bmN0b3InLCBbXSwge21hcDogVmFsdWV9KTtcblxuICAvLyMgQmlmdW5jdG9yIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbQmlmdW5jdG9yXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQmlmdW5jdG9yLnRlc3QoVHVwbGUoJ2ZvbycsIDY0KSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IEJpZnVuY3Rvci50ZXN0KFtdKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgQmlmdW5jdG9yID0gJCgnQmlmdW5jdG9yJywgW0Z1bmN0b3JdLCB7YmltYXA6IFZhbHVlfSk7XG5cbiAgLy8jIFByb2Z1bmN0b3IgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtQcm9mdW5jdG9yXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUHJvZnVuY3Rvci50ZXN0KE1hdGguc3FydClcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFByb2Z1bmN0b3IudGVzdChbXSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIFByb2Z1bmN0b3IgPSAkKCdQcm9mdW5jdG9yJywgW0Z1bmN0b3JdLCB7cHJvbWFwOiBWYWx1ZX0pO1xuXG4gIC8vIyBBcHBseSA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0FwcGx5XVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQXBwbHkudGVzdChbXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IEFwcGx5LnRlc3QoJycpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBBcHBseSA9ICQoJ0FwcGx5JywgW0Z1bmN0b3JdLCB7YXA6IFZhbHVlfSk7XG5cbiAgLy8jIEFwcGxpY2F0aXZlIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbQXBwbGljYXRpdmVdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBBcHBsaWNhdGl2ZS50ZXN0KFtdKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gQXBwbGljYXRpdmUudGVzdCh7fSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIEFwcGxpY2F0aXZlID0gJCgnQXBwbGljYXRpdmUnLCBbQXBwbHldLCB7b2Y6IENvbnN0cnVjdG9yfSk7XG5cbiAgLy8jIENoYWluIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbQ2hhaW5dW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBDaGFpbi50ZXN0KFtdKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gQ2hhaW4udGVzdCh7fSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIENoYWluID0gJCgnQ2hhaW4nLCBbQXBwbHldLCB7Y2hhaW46IFZhbHVlfSk7XG5cbiAgLy8jIENoYWluUmVjIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbQ2hhaW5SZWNdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBDaGFpblJlYy50ZXN0KFtdKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gQ2hhaW5SZWMudGVzdCh7fSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIENoYWluUmVjID0gJCgnQ2hhaW5SZWMnLCBbQ2hhaW5dLCB7Y2hhaW5SZWM6IENvbnN0cnVjdG9yfSk7XG5cbiAgLy8jIE1vbmFkIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbTW9uYWRdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBNb25hZC50ZXN0KFtdKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gTW9uYWQudGVzdCh7fSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIE1vbmFkID0gJCgnTW9uYWQnLCBbQXBwbGljYXRpdmUsIENoYWluXSwge30pO1xuXG4gIC8vIyBBbHQgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtBbHRdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBBbHQudGVzdCh7fSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IEFsdC50ZXN0KCcnKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgQWx0ID0gJCgnQWx0JywgW0Z1bmN0b3JdLCB7YWx0OiBWYWx1ZX0pO1xuXG4gIC8vIyBQbHVzIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbUGx1c11bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFBsdXMudGVzdCh7fSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFBsdXMudGVzdCgnJylcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIFBsdXMgPSAkKCdQbHVzJywgW0FsdF0sIHt6ZXJvOiBDb25zdHJ1Y3Rvcn0pO1xuXG4gIC8vIyBBbHRlcm5hdGl2ZSA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0FsdGVybmF0aXZlXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQWx0ZXJuYXRpdmUudGVzdChbXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IEFsdGVybmF0aXZlLnRlc3Qoe30pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBBbHRlcm5hdGl2ZSA9ICQoJ0FsdGVybmF0aXZlJywgW0FwcGxpY2F0aXZlLCBQbHVzXSwge30pO1xuXG4gIC8vIyBGb2xkYWJsZSA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0ZvbGRhYmxlXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gRm9sZGFibGUudGVzdCh7fSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IEZvbGRhYmxlLnRlc3QoJycpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBGb2xkYWJsZSA9ICQoJ0ZvbGRhYmxlJywgW10sIHtyZWR1Y2U6IFZhbHVlfSk7XG5cbiAgLy8jIFRyYXZlcnNhYmxlIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbVHJhdmVyc2FibGVdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBUcmF2ZXJzYWJsZS50ZXN0KFtdKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gVHJhdmVyc2FibGUudGVzdCgnJylcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIFRyYXZlcnNhYmxlID0gJCgnVHJhdmVyc2FibGUnLCBbRnVuY3RvciwgRm9sZGFibGVdLCB7dHJhdmVyc2U6IFZhbHVlfSk7XG5cbiAgLy8jIEV4dGVuZCA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0V4dGVuZF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IEV4dGVuZC50ZXN0KFtdKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gRXh0ZW5kLnRlc3Qoe30pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBFeHRlbmQgPSAkKCdFeHRlbmQnLCBbRnVuY3Rvcl0sIHtleHRlbmQ6IFZhbHVlfSk7XG5cbiAgLy8jIENvbW9uYWQgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtDb21vbmFkXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQ29tb25hZC50ZXN0KElkZW50aXR5KDApKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gQ29tb25hZC50ZXN0KFtdKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgQ29tb25hZCA9ICQoJ0NvbW9uYWQnLCBbRXh0ZW5kXSwge2V4dHJhY3Q6IFZhbHVlfSk7XG5cbiAgLy8jIENvbnRyYXZhcmlhbnQgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtDb250cmF2YXJpYW50XVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQ29udHJhdmFyaWFudC50ZXN0KE1hdGguc3FydClcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IENvbnRyYXZhcmlhbnQudGVzdChbXSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIENvbnRyYXZhcmlhbnQgPSAkKCdDb250cmF2YXJpYW50JywgW10sIHtjb250cmFtYXA6IFZhbHVlfSk7XG5cbiAgLy8gIE51bGwkcHJvdG90eXBlJHRvU3RyaW5nIDo6IE51bGwgfj4gKCkgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIE51bGwkcHJvdG90eXBlJHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH1cblxuICAvLyAgTnVsbCRwcm90b3R5cGUkZXF1YWxzIDo6IE51bGwgfj4gTnVsbCAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIE51bGwkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gIE51bGwkcHJvdG90eXBlJGx0ZSA6OiBOdWxsIH4+IE51bGwgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBOdWxsJHByb3RvdHlwZSRsdGUob3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vICBVbmRlZmluZWQkcHJvdG90eXBlJHRvU3RyaW5nIDo6IFVuZGVmaW5lZCB+PiAoKSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gVW5kZWZpbmVkJHByb3RvdHlwZSR0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICAvLyAgVW5kZWZpbmVkJHByb3RvdHlwZSRlcXVhbHMgOjogVW5kZWZpbmVkIH4+IFVuZGVmaW5lZCAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIFVuZGVmaW5lZCRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyAgVW5kZWZpbmVkJHByb3RvdHlwZSRsdGUgOjogVW5kZWZpbmVkIH4+IFVuZGVmaW5lZCAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIFVuZGVmaW5lZCRwcm90b3R5cGUkbHRlKG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyAgQm9vbGVhbiRwcm90b3R5cGUkdG9TdHJpbmcgOjogQm9vbGVhbiB+PiAoKSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gQm9vbGVhbiRwcm90b3R5cGUkdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzID09PSAnb2JqZWN0JyA/XG4gICAgICAnbmV3IEJvb2xlYW4oJyArIHRvU3RyaW5nKHRoaXMudmFsdWVPZigpKSArICcpJyA6XG4gICAgICB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cblxuICAvLyAgQm9vbGVhbiRwcm90b3R5cGUkZXF1YWxzIDo6IEJvb2xlYW4gfj4gQm9vbGVhbiAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIEJvb2xlYW4kcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcyA9PT0gJ29iamVjdCcgP1xuICAgICAgZXF1YWxzKHRoaXMudmFsdWVPZigpLCBvdGhlci52YWx1ZU9mKCkpIDpcbiAgICAgIHRoaXMgPT09IG90aGVyO1xuICB9XG5cbiAgLy8gIEJvb2xlYW4kcHJvdG90eXBlJGx0ZSA6OiBCb29sZWFuIH4+IEJvb2xlYW4gLT4gQm9vbGVhblxuICBmdW5jdGlvbiBCb29sZWFuJHByb3RvdHlwZSRsdGUob3RoZXIpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMgPT09ICdvYmplY3QnID9cbiAgICAgIGx0ZSh0aGlzLnZhbHVlT2YoKSwgb3RoZXIudmFsdWVPZigpKSA6XG4gICAgICB0aGlzID09PSBmYWxzZSB8fCBvdGhlciA9PT0gdHJ1ZTtcbiAgfVxuXG4gIC8vICBOdW1iZXIkcHJvdG90eXBlJHRvU3RyaW5nIDo6IE51bWJlciB+PiAoKSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gTnVtYmVyJHByb3RvdHlwZSR0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMgPT09ICdvYmplY3QnID9cbiAgICAgICduZXcgTnVtYmVyKCcgKyB0b1N0cmluZyh0aGlzLnZhbHVlT2YoKSkgKyAnKScgOlxuICAgICAgMSAvIHRoaXMgPT09IC1JbmZpbml0eSA/ICctMCcgOiB0aGlzLnRvU3RyaW5nKDEwKTtcbiAgfVxuXG4gIC8vICBOdW1iZXIkcHJvdG90eXBlJGVxdWFscyA6OiBOdW1iZXIgfj4gTnVtYmVyIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gTnVtYmVyJHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMgPT09ICdvYmplY3QnID9cbiAgICAgIGVxdWFscyh0aGlzLnZhbHVlT2YoKSwgb3RoZXIudmFsdWVPZigpKSA6XG4gICAgICBpc05hTih0aGlzKSAmJiBpc05hTihvdGhlcikgfHwgdGhpcyA9PT0gb3RoZXI7XG4gIH1cblxuICAvLyAgTnVtYmVyJHByb3RvdHlwZSRsdGUgOjogTnVtYmVyIH4+IE51bWJlciAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIE51bWJlciRwcm90b3R5cGUkbHRlKG90aGVyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzID09PSAnb2JqZWN0JyA/XG4gICAgICBsdGUodGhpcy52YWx1ZU9mKCksIG90aGVyLnZhbHVlT2YoKSkgOlxuICAgICAgaXNOYU4odGhpcykgJiYgaXNOYU4ob3RoZXIpIHx8IHRoaXMgPD0gb3RoZXI7XG4gIH1cblxuICAvLyAgRGF0ZSRwcm90b3R5cGUkdG9TdHJpbmcgOjogRGF0ZSB+PiAoKSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gRGF0ZSRwcm90b3R5cGUkdG9TdHJpbmcoKSB7XG4gICAgdmFyIHggPSBpc05hTih0aGlzLnZhbHVlT2YoKSkgPyBOYU4gOiB0aGlzLnRvSVNPU3RyaW5nKCk7XG4gICAgcmV0dXJuICduZXcgRGF0ZSgnICsgdG9TdHJpbmcoeCkgKyAnKSc7XG4gIH1cblxuICAvLyAgRGF0ZSRwcm90b3R5cGUkZXF1YWxzIDo6IERhdGUgfj4gRGF0ZSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIERhdGUkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBlcXVhbHModGhpcy52YWx1ZU9mKCksIG90aGVyLnZhbHVlT2YoKSk7XG4gIH1cblxuICAvLyAgRGF0ZSRwcm90b3R5cGUkbHRlIDo6IERhdGUgfj4gRGF0ZSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIERhdGUkcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIHJldHVybiBsdGUodGhpcy52YWx1ZU9mKCksIG90aGVyLnZhbHVlT2YoKSk7XG4gIH1cblxuICAvLyAgUmVnRXhwJHByb3RvdHlwZSRlcXVhbHMgOjogUmVnRXhwIH4+IFJlZ0V4cCAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIFJlZ0V4cCRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLnNvdXJjZSA9PT0gdGhpcy5zb3VyY2UgJiZcbiAgICAgICAgICAgb3RoZXIuZ2xvYmFsID09PSB0aGlzLmdsb2JhbCAmJlxuICAgICAgICAgICBvdGhlci5pZ25vcmVDYXNlID09PSB0aGlzLmlnbm9yZUNhc2UgJiZcbiAgICAgICAgICAgb3RoZXIubXVsdGlsaW5lID09PSB0aGlzLm11bHRpbGluZSAmJlxuICAgICAgICAgICBvdGhlci5zdGlja3kgPT09IHRoaXMuc3RpY2t5ICYmXG4gICAgICAgICAgIG90aGVyLnVuaWNvZGUgPT09IHRoaXMudW5pY29kZTtcbiAgfVxuXG4gIC8vICBTdHJpbmckZW1wdHkgOjogKCkgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIFN0cmluZyRlbXB0eSgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvLyAgU3RyaW5nJHByb3RvdHlwZSR0b1N0cmluZyA6OiBTdHJpbmcgfj4gKCkgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIFN0cmluZyRwcm90b3R5cGUkdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzID09PSAnb2JqZWN0JyA/XG4gICAgICAnbmV3IFN0cmluZygnICsgdG9TdHJpbmcodGhpcy52YWx1ZU9mKCkpICsgJyknIDpcbiAgICAgIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICB9XG5cbiAgLy8gIFN0cmluZyRwcm90b3R5cGUkZXF1YWxzIDo6IFN0cmluZyB+PiBTdHJpbmcgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBTdHJpbmckcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcyA9PT0gJ29iamVjdCcgP1xuICAgICAgZXF1YWxzKHRoaXMudmFsdWVPZigpLCBvdGhlci52YWx1ZU9mKCkpIDpcbiAgICAgIHRoaXMgPT09IG90aGVyO1xuICB9XG5cbiAgLy8gIFN0cmluZyRwcm90b3R5cGUkbHRlIDo6IFN0cmluZyB+PiBTdHJpbmcgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBTdHJpbmckcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcyA9PT0gJ29iamVjdCcgP1xuICAgICAgbHRlKHRoaXMudmFsdWVPZigpLCBvdGhlci52YWx1ZU9mKCkpIDpcbiAgICAgIHRoaXMgPD0gb3RoZXI7XG4gIH1cblxuICAvLyAgU3RyaW5nJHByb3RvdHlwZSRjb25jYXQgOjogU3RyaW5nIH4+IFN0cmluZyAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gU3RyaW5nJHByb3RvdHlwZSRjb25jYXQob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcyArIG90aGVyO1xuICB9XG5cbiAgLy8gIEFycmF5JGVtcHR5IDo6ICgpIC0+IEFycmF5IGFcbiAgZnVuY3Rpb24gQXJyYXkkZW1wdHkoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLy8gIEFycmF5JG9mIDo6IGEgLT4gQXJyYXkgYVxuICBmdW5jdGlvbiBBcnJheSRvZih4KSB7XG4gICAgcmV0dXJuIFt4XTtcbiAgfVxuXG4gIC8vICBBcnJheSRjaGFpblJlYyA6OiAoKGEgLT4gYywgYiAtPiBjLCBhKSAtPiBBcnJheSBjLCBhKSAtPiBBcnJheSBiXG4gIGZ1bmN0aW9uIEFycmF5JGNoYWluUmVjKGYsIHgpIHtcbiAgICB2YXIgJHRvZG8gPSBbeF07XG4gICAgdmFyICRkb25lID0gW107XG4gICAgd2hpbGUgKCR0b2RvLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciB4cyA9IGYoaXRlcmF0aW9uTmV4dCwgaXRlcmF0aW9uRG9uZSwgJHRvZG8uc2hpZnQoKSk7XG4gICAgICB2YXIgJG1vcmUgPSBbXTtcbiAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHhzLmxlbmd0aDsgaWR4ICs9IDEpIHtcbiAgICAgICAgKHhzW2lkeF0uZG9uZSA/ICRkb25lIDogJG1vcmUpLnB1c2goeHNbaWR4XS52YWx1ZSk7XG4gICAgICB9XG4gICAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseSgkdG9kbywgJG1vcmUpO1xuICAgIH1cbiAgICByZXR1cm4gJGRvbmU7XG4gIH1cblxuICAvLyAgQXJyYXkkemVybyA6OiAoKSAtPiBBcnJheSBhXG4gIGZ1bmN0aW9uIEFycmF5JHplcm8oKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSR0b1N0cmluZyA6OiBBcnJheSBhIH4+ICgpIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBBcnJheSRwcm90b3R5cGUkdG9TdHJpbmcoKSB7XG4gICAgdmFyIHJlcHJzID0gdGhpcy5tYXAodG9TdHJpbmcpO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcykuc29ydCgpO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGtleXMubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgICAgdmFyIGsgPSBrZXlzW2lkeF07XG4gICAgICBpZiAoIS9eXFxkKyQvLnRlc3QoaykpIHtcbiAgICAgICAgcmVwcnMucHVzaCh0b1N0cmluZyhrKSArICc6ICcgKyB0b1N0cmluZyh0aGlzW2tdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnWycgKyByZXBycy5qb2luKCcsICcpICsgJ10nO1xuICB9XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSRlcXVhbHMgOjogQXJyYXkgYSB+PiBBcnJheSBhIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIGlmIChvdGhlci5sZW5ndGggIT09IHRoaXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgdGhpcy5sZW5ndGg7IGlkeCArPSAxKSB7XG4gICAgICBpZiAoIWVxdWFscyh0aGlzW2lkeF0sIG90aGVyW2lkeF0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSRsdGUgOjogQXJyYXkgYSB+PiBBcnJheSBhIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIGZvciAodmFyIGlkeCA9IDA7IHRydWU7IGlkeCArPSAxKSB7XG4gICAgICBpZiAoaWR4ID09PSB0aGlzLmxlbmd0aCkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoaWR4ID09PSBvdGhlci5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghZXF1YWxzKHRoaXNbaWR4XSwgb3RoZXJbaWR4XSkpIHJldHVybiBsdGUodGhpc1tpZHhdLCBvdGhlcltpZHhdKTtcbiAgICB9XG4gIH1cblxuICAvLyAgQXJyYXkkcHJvdG90eXBlJGNvbmNhdCA6OiBBcnJheSBhIH4+IEFycmF5IGEgLT4gQXJyYXkgYVxuICBmdW5jdGlvbiBBcnJheSRwcm90b3R5cGUkY29uY2F0KG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uY2F0KG90aGVyKTtcbiAgfVxuXG4gIC8vICBBcnJheSRwcm90b3R5cGUkZmlsdGVyIDo6IEFycmF5IGEgfj4gKGEgLT4gQm9vbGVhbikgLT4gQXJyYXkgYVxuICBmdW5jdGlvbiBBcnJheSRwcm90b3R5cGUkZmlsdGVyKHByZWQpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4gcHJlZCh4KTsgfSk7XG4gIH1cblxuICAvLyAgQXJyYXkkcHJvdG90eXBlJG1hcCA6OiBBcnJheSBhIH4+IChhIC0+IGIpIC0+IEFycmF5IGJcbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJG1hcChmKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGYoeCk7IH0pO1xuICB9XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSRhcCA6OiBBcnJheSBhIH4+IEFycmF5IChhIC0+IGIpIC0+IEFycmF5IGJcbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJGFwKGZzKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGZzLmxlbmd0aDsgaWR4ICs9IDEpIHtcbiAgICAgIGZvciAodmFyIGlkeDIgPSAwOyBpZHgyIDwgdGhpcy5sZW5ndGg7IGlkeDIgKz0gMSkge1xuICAgICAgICByZXN1bHQucHVzaChmc1tpZHhdKHRoaXNbaWR4Ml0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vICBBcnJheSRwcm90b3R5cGUkY2hhaW4gOjogQXJyYXkgYSB+PiAoYSAtPiBBcnJheSBiKSAtPiBBcnJheSBiXG4gIGZ1bmN0aW9uIEFycmF5JHByb3RvdHlwZSRjaGFpbihmKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih4KSB7IEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdCwgZih4KSk7IH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyAgQXJyYXkkcHJvdG90eXBlJGFsdCA6OiBBcnJheSBhIH4+IEFycmF5IGEgLT4gQXJyYXkgYVxuICB2YXIgQXJyYXkkcHJvdG90eXBlJGFsdCA9IEFycmF5JHByb3RvdHlwZSRjb25jYXQ7XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSRyZWR1Y2UgOjogQXJyYXkgYSB+PiAoKGIsIGEpIC0+IGIsIGIpIC0+IGJcbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJHJlZHVjZShmLCBpbml0aWFsKSB7XG4gICAgcmV0dXJuIHRoaXMucmVkdWNlKGZ1bmN0aW9uKGFjYywgeCkgeyByZXR1cm4gZihhY2MsIHgpOyB9LCBpbml0aWFsKTtcbiAgfVxuXG4gIC8vICBBcnJheSRwcm90b3R5cGUkdHJhdmVyc2UgOjogQXBwbGljYXRpdmUgZiA9PiBBcnJheSBhIH4+IChUeXBlUmVwIGYsIGEgLT4gZiBiKSAtPiBmIChBcnJheSBiKVxuICBmdW5jdGlvbiBBcnJheSRwcm90b3R5cGUkdHJhdmVyc2UodHlwZVJlcCwgZikge1xuICAgIHZhciB4cyA9IHRoaXM7XG4gICAgZnVuY3Rpb24gZ28oaWR4LCBuKSB7XG4gICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gb2YodHlwZVJlcCwgW10pO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBsaWZ0MihwYWlyLCBmKHhzW2lkeF0pLCBmKHhzW2lkeCArIDFdKSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmFyIG0gPSBNYXRoLmZsb29yKG4gLyA0KSAqIDI7XG4gICAgICAgICAgcmV0dXJuIGxpZnQyKGNvbmNhdF8sIGdvKGlkeCwgbSksIGdvKGlkeCArIG0sIG4gLSBtKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxlbmd0aCAlIDIgPT09IDEgP1xuICAgICAgbGlmdDIoY29uY2F0XywgbWFwKEFycmF5JG9mLCBmKHRoaXNbMF0pKSwgZ28oMSwgdGhpcy5sZW5ndGggLSAxKSkgOlxuICAgICAgZ28oMCwgdGhpcy5sZW5ndGgpO1xuICB9XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSRleHRlbmQgOjogQXJyYXkgYSB+PiAoQXJyYXkgYSAtPiBiKSAtPiBBcnJheSBiXG4gIGZ1bmN0aW9uIEFycmF5JHByb3RvdHlwZSRleHRlbmQoZikge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihfLCBpZHgsIHhzKSB7IHJldHVybiBmKHhzLnNsaWNlKGlkeCkpOyB9KTtcbiAgfVxuXG4gIC8vICBBcmd1bWVudHMkcHJvdG90eXBlJHRvU3RyaW5nIDo6IEFyZ3VtZW50cyB+PiBTdHJpbmdcbiAgZnVuY3Rpb24gQXJndW1lbnRzJHByb3RvdHlwZSR0b1N0cmluZygpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCh0aGlzLCB0b1N0cmluZykuam9pbignLCAnKTtcbiAgICByZXR1cm4gJyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oJyArIGFyZ3MgKyAnKSknO1xuICB9XG5cbiAgLy8gIEFyZ3VtZW50cyRwcm90b3R5cGUkZXF1YWxzIDo6IEFyZ3VtZW50cyB+PiBBcmd1bWVudHMgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBBcmd1bWVudHMkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBBcnJheSRwcm90b3R5cGUkZXF1YWxzLmNhbGwodGhpcywgb3RoZXIpO1xuICB9XG5cbiAgLy8gIEFyZ3VtZW50cyRwcm90b3R5cGUkbHRlIDo6IEFyZ3VtZW50cyB+PiBBcmd1bWVudHMgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBBcmd1bWVudHMkcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIHJldHVybiBBcnJheSRwcm90b3R5cGUkbHRlLmNhbGwodGhpcywgb3RoZXIpO1xuICB9XG5cbiAgLy8gIEVycm9yJHByb3RvdHlwZSR0b1N0cmluZyA6OiBFcnJvciB+PiAoKSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gRXJyb3IkcHJvdG90eXBlJHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnbmV3ICcgKyB0aGlzLm5hbWUgKyAnKCcgKyB0b1N0cmluZyh0aGlzLm1lc3NhZ2UpICsgJyknO1xuICB9XG5cbiAgLy8gIEVycm9yJHByb3RvdHlwZSRlcXVhbHMgOjogRXJyb3Igfj4gRXJyb3IgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBFcnJvciRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIGVxdWFscyh0aGlzLm5hbWUsIG90aGVyLm5hbWUpICYmXG4gICAgICAgICAgIGVxdWFscyh0aGlzLm1lc3NhZ2UsIG90aGVyLm1lc3NhZ2UpO1xuICB9XG5cbiAgLy8gIE9iamVjdCRlbXB0eSA6OiAoKSAtPiBTdHJNYXAgYVxuICBmdW5jdGlvbiBPYmplY3QkZW1wdHkoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLy8gIE9iamVjdCR6ZXJvIDo6ICgpIC0+IFN0ck1hcCBhXG4gIGZ1bmN0aW9uIE9iamVjdCR6ZXJvKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8vICBPYmplY3QkcHJvdG90eXBlJHRvU3RyaW5nIDo6IFN0ck1hcCBhIH4+ICgpIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBPYmplY3QkcHJvdG90eXBlJHRvU3RyaW5nKCkge1xuICAgIHZhciByZXBycyA9IFtdO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcykuc29ydCgpO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGtleXMubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgICAgdmFyIGsgPSBrZXlzW2lkeF07XG4gICAgICByZXBycy5wdXNoKHRvU3RyaW5nKGspICsgJzogJyArIHRvU3RyaW5nKHRoaXNba10pKTtcbiAgICB9XG4gICAgcmV0dXJuICd7JyArIHJlcHJzLmpvaW4oJywgJykgKyAnfSc7XG4gIH1cblxuICAvLyAgT2JqZWN0JHByb3RvdHlwZSRlcXVhbHMgOjogU3RyTWFwIGEgfj4gU3RyTWFwIGEgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBPYmplY3QkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpLnNvcnQoKTtcbiAgICByZXR1cm4gZXF1YWxzKGtleXMsIE9iamVjdC5rZXlzKG90aGVyKS5zb3J0KCkpICYmXG4gICAgICAgICAgIGtleXMuZXZlcnkoZnVuY3Rpb24oaykgeyByZXR1cm4gZXF1YWxzKHNlbGZba10sIG90aGVyW2tdKTsgfSk7XG4gIH1cblxuICAvLyAgT2JqZWN0JHByb3RvdHlwZSRsdGUgOjogU3RyTWFwIGEgfj4gU3RyTWFwIGEgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBPYmplY3QkcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIHZhciB0aGVzZUtleXMgPSBPYmplY3Qua2V5cyh0aGlzKS5zb3J0KCk7XG4gICAgdmFyIG90aGVyS2V5cyA9IE9iamVjdC5rZXlzKG90aGVyKS5zb3J0KCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh0aGVzZUtleXMubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChvdGhlcktleXMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgayA9IHRoZXNlS2V5cy5zaGlmdCgpO1xuICAgICAgdmFyIHogPSBvdGhlcktleXMuc2hpZnQoKTtcbiAgICAgIGlmIChrIDwgeikgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoayA+IHopIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghZXF1YWxzKHRoaXNba10sIG90aGVyW2tdKSkgcmV0dXJuIGx0ZSh0aGlzW2tdLCBvdGhlcltrXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gIE9iamVjdCRwcm90b3R5cGUkY29uY2F0IDo6IFN0ck1hcCBhIH4+IFN0ck1hcCBhIC0+IFN0ck1hcCBhXG4gIGZ1bmN0aW9uIE9iamVjdCRwcm90b3R5cGUkY29uY2F0KG90aGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZ1bmN0aW9uIGFzc2lnbihrKSB7IHJlc3VsdFtrXSA9IHRoaXNba107IH1cbiAgICBmb3JFYWNoS2V5KHRoaXMsIGFzc2lnbik7XG4gICAgZm9yRWFjaEtleShvdGhlciwgYXNzaWduKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gIE9iamVjdCRwcm90b3R5cGUkZmlsdGVyIDo6IFN0ck1hcCBhIH4+IChhIC0+IEJvb2xlYW4pIC0+IFN0ck1hcCBhXG4gIGZ1bmN0aW9uIE9iamVjdCRwcm90b3R5cGUkZmlsdGVyKHByZWQpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yRWFjaEtleSh0aGlzLCBmdW5jdGlvbihrKSB7IGlmIChwcmVkKHRoaXNba10pKSByZXN1bHRba10gPSB0aGlzW2tdOyB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gIE9iamVjdCRwcm90b3R5cGUkbWFwIDo6IFN0ck1hcCBhIH4+IChhIC0+IGIpIC0+IFN0ck1hcCBiXG4gIGZ1bmN0aW9uIE9iamVjdCRwcm90b3R5cGUkbWFwKGYpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yRWFjaEtleSh0aGlzLCBmdW5jdGlvbihrKSB7IHJlc3VsdFtrXSA9IGYodGhpc1trXSk7IH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyAgT2JqZWN0JHByb3RvdHlwZSRhcCA6OiBTdHJNYXAgYSB+PiBTdHJNYXAgKGEgLT4gYikgLT4gU3RyTWFwIGJcbiAgZnVuY3Rpb24gT2JqZWN0JHByb3RvdHlwZSRhcChvdGhlcikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3JFYWNoS2V5KHRoaXMsIGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChoYXMoaywgb3RoZXIpKSByZXN1bHRba10gPSBvdGhlcltrXSh0aGlzW2tdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gIE9iamVjdCRwcm90b3R5cGUkYWx0IDo6IFN0ck1hcCBhIH4+IFN0ck1hcCBhIC0+IFN0ck1hcCBhXG4gIHZhciBPYmplY3QkcHJvdG90eXBlJGFsdCA9IE9iamVjdCRwcm90b3R5cGUkY29uY2F0O1xuXG4gIC8vICBPYmplY3QkcHJvdG90eXBlJHJlZHVjZSA6OiBTdHJNYXAgYSB+PiAoKGIsIGEpIC0+IGIsIGIpIC0+IGJcbiAgZnVuY3Rpb24gT2JqZWN0JHByb3RvdHlwZSRyZWR1Y2UoZiwgaW5pdGlhbCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmdW5jdGlvbiByZWR1Y2VyKGFjYywgaykgeyByZXR1cm4gZihhY2MsIHNlbGZba10pOyB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMpLnNvcnQoKS5yZWR1Y2UocmVkdWNlciwgaW5pdGlhbCk7XG4gIH1cblxuICAvLyAgT2JqZWN0JHByb3RvdHlwZSR0cmF2ZXJzZSA6OiBBcHBsaWNhdGl2ZSBmID0+IFN0ck1hcCBhIH4+IChUeXBlUmVwIGYsIGEgLT4gZiBiKSAtPiBmIChTdHJNYXAgYilcbiAgZnVuY3Rpb24gT2JqZWN0JHByb3RvdHlwZSR0cmF2ZXJzZSh0eXBlUmVwLCBmKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzKS5yZWR1Y2UoZnVuY3Rpb24oYXBwbGljYXRpdmUsIGspIHtcbiAgICAgIGZ1bmN0aW9uIHNldChvKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdmFyIHNpbmdsZXRvbiA9IHt9OyBzaW5nbGV0b25ba10gPSB2O1xuICAgICAgICAgIHJldHVybiBPYmplY3QkcHJvdG90eXBlJGNvbmNhdC5jYWxsKG8sIHNpbmdsZXRvbik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbGlmdDIoc2V0LCBhcHBsaWNhdGl2ZSwgZihzZWxmW2tdKSk7XG4gICAgfSwgb2YodHlwZVJlcCwge30pKTtcbiAgfVxuXG4gIC8vICBGdW5jdGlvbiRpZCA6OiAoKSAtPiBhIC0+IGFcbiAgZnVuY3Rpb24gRnVuY3Rpb24kaWQoKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJG9mIDo6IGIgLT4gKGEgLT4gYilcbiAgZnVuY3Rpb24gRnVuY3Rpb24kb2YoeCkge1xuICAgIHJldHVybiBmdW5jdGlvbihfKSB7IHJldHVybiB4OyB9O1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJGNoYWluUmVjIDo6ICgoYSAtPiBjLCBiIC0+IGMsIGEpIC0+ICh6IC0+IGMpLCBhKSAtPiAoeiAtPiBiKVxuICBmdW5jdGlvbiBGdW5jdGlvbiRjaGFpblJlYyhmLCB4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEpIHtcbiAgICAgIHZhciBzdGVwID0gaXRlcmF0aW9uTmV4dCh4KTtcbiAgICAgIHdoaWxlICghc3RlcC5kb25lKSB7XG4gICAgICAgIHN0ZXAgPSBmKGl0ZXJhdGlvbk5leHQsIGl0ZXJhdGlvbkRvbmUsIHN0ZXAudmFsdWUpKGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0ZXAudmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIC8vICBGdW5jdGlvbiRwcm90b3R5cGUkZXF1YWxzIDo6IEZ1bmN0aW9uIH4+IEZ1bmN0aW9uIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gRnVuY3Rpb24kcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBvdGhlciA9PT0gdGhpcztcbiAgfVxuXG4gIC8vICBGdW5jdGlvbiRwcm90b3R5cGUkY29tcG9zZSA6OiAoYSAtPiBiKSB+PiAoYiAtPiBjKSAtPiAoYSAtPiBjKVxuICBmdW5jdGlvbiBGdW5jdGlvbiRwcm90b3R5cGUkY29tcG9zZShvdGhlcikge1xuICAgIHZhciBzZW1pZ3JvdXBvaWQgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiBvdGhlcihzZW1pZ3JvdXBvaWQoeCkpOyB9O1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJHByb3RvdHlwZSRtYXAgOjogKGEgLT4gYikgfj4gKGIgLT4gYykgLT4gKGEgLT4gYylcbiAgZnVuY3Rpb24gRnVuY3Rpb24kcHJvdG90eXBlJG1hcChmKSB7XG4gICAgdmFyIGZ1bmN0b3IgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiBmKGZ1bmN0b3IoeCkpOyB9O1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJHByb3RvdHlwZSRwcm9tYXAgOjogKGIgLT4gYykgfj4gKGEgLT4gYiwgYyAtPiBkKSAtPiAoYSAtPiBkKVxuICBmdW5jdGlvbiBGdW5jdGlvbiRwcm90b3R5cGUkcHJvbWFwKGYsIGcpIHtcbiAgICB2YXIgcHJvZnVuY3RvciA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGcocHJvZnVuY3RvcihmKHgpKSk7IH07XG4gIH1cblxuICAvLyAgRnVuY3Rpb24kcHJvdG90eXBlJGFwIDo6IChhIC0+IGIpIH4+IChhIC0+IGIgLT4gYykgLT4gKGEgLT4gYylcbiAgZnVuY3Rpb24gRnVuY3Rpb24kcHJvdG90eXBlJGFwKGYpIHtcbiAgICB2YXIgYXBwbHkgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiBmKHgpKGFwcGx5KHgpKTsgfTtcbiAgfVxuXG4gIC8vICBGdW5jdGlvbiRwcm90b3R5cGUkY2hhaW4gOjogKGEgLT4gYikgfj4gKGIgLT4gYSAtPiBjKSAtPiAoYSAtPiBjKVxuICBmdW5jdGlvbiBGdW5jdGlvbiRwcm90b3R5cGUkY2hhaW4oZikge1xuICAgIHZhciBjaGFpbiA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGYoY2hhaW4oeCkpKHgpOyB9O1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJHByb3RvdHlwZSRleHRlbmQgOjogU2VtaWdyb3VwIGEgPT4gKGEgLT4gYikgfj4gKChhIC0+IGIpIC0+IGMpIC0+IChhIC0+IGMpXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uJHByb3RvdHlwZSRleHRlbmQoZikge1xuICAgIHZhciBleHRlbmQgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gZihmdW5jdGlvbih5KSB7IHJldHVybiBleHRlbmQoY29uY2F0KHgsIHkpKTsgfSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vICBGdW5jdGlvbiRwcm90b3R5cGUkY29udHJhbWFwIDo6IChiIC0+IGMpIH4+IChhIC0+IGIpIC0+IChhIC0+IGMpXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uJHByb3RvdHlwZSRjb250cmFtYXAoZikge1xuICAgIHZhciBjb250cmF2YXJpYW50ID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gY29udHJhdmFyaWFudChmKHgpKTsgfTtcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gIHZhciBpbXBsZW1lbnRhdGlvbnMgPSB7XG4gICAgTnVsbDoge1xuICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgIHRvU3RyaW5nOiAgICAgICAgICAgICAgICAgICBOdWxsJHByb3RvdHlwZSR0b1N0cmluZyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnOiAgICAgIE51bGwkcHJvdG90eXBlJGVxdWFscyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9sdGUnOiAgICAgICAgIE51bGwkcHJvdG90eXBlJGx0ZVxuICAgICAgfVxuICAgIH0sXG4gICAgVW5kZWZpbmVkOiB7XG4gICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgdG9TdHJpbmc6ICAgICAgICAgICAgICAgICAgIFVuZGVmaW5lZCRwcm90b3R5cGUkdG9TdHJpbmcsXG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBVbmRlZmluZWQkcHJvdG90eXBlJGVxdWFscyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9sdGUnOiAgICAgICAgIFVuZGVmaW5lZCRwcm90b3R5cGUkbHRlXG4gICAgICB9XG4gICAgfSxcbiAgICBCb29sZWFuOiB7XG4gICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgdG9TdHJpbmc6ICAgICAgICAgICAgICAgICAgIEJvb2xlYW4kcHJvdG90eXBlJHRvU3RyaW5nLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgQm9vbGVhbiRwcm90b3R5cGUkZXF1YWxzLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2x0ZSc6ICAgICAgICAgQm9vbGVhbiRwcm90b3R5cGUkbHRlXG4gICAgICB9XG4gICAgfSxcbiAgICBOdW1iZXI6IHtcbiAgICAgIHByb3RvdHlwZToge1xuICAgICAgICB0b1N0cmluZzogICAgICAgICAgICAgICAgICAgTnVtYmVyJHByb3RvdHlwZSR0b1N0cmluZyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnOiAgICAgIE51bWJlciRwcm90b3R5cGUkZXF1YWxzLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2x0ZSc6ICAgICAgICAgTnVtYmVyJHByb3RvdHlwZSRsdGVcbiAgICAgIH1cbiAgICB9LFxuICAgIERhdGU6IHtcbiAgICAgIHByb3RvdHlwZToge1xuICAgICAgICB0b1N0cmluZzogICAgICAgICAgICAgICAgICAgRGF0ZSRwcm90b3R5cGUkdG9TdHJpbmcsXG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBEYXRlJHByb3RvdHlwZSRlcXVhbHMsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbHRlJzogICAgICAgICBEYXRlJHByb3RvdHlwZSRsdGVcbiAgICAgIH1cbiAgICB9LFxuICAgIFJlZ0V4cDoge1xuICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBSZWdFeHAkcHJvdG90eXBlJGVxdWFsc1xuICAgICAgfVxuICAgIH0sXG4gICAgU3RyaW5nOiB7XG4gICAgICAnZmFudGFzeS1sYW5kL2VtcHR5JzogICAgICAgICBTdHJpbmckZW1wdHksXG4gICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgdG9TdHJpbmc6ICAgICAgICAgICAgICAgICAgIFN0cmluZyRwcm90b3R5cGUkdG9TdHJpbmcsXG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBTdHJpbmckcHJvdG90eXBlJGVxdWFscyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9sdGUnOiAgICAgICAgIFN0cmluZyRwcm90b3R5cGUkbHRlLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2NvbmNhdCc6ICAgICAgU3RyaW5nJHByb3RvdHlwZSRjb25jYXRcbiAgICAgIH1cbiAgICB9LFxuICAgIEFycmF5OiB7XG4gICAgICAnZmFudGFzeS1sYW5kL2VtcHR5JzogICAgICAgICBBcnJheSRlbXB0eSxcbiAgICAgICdmYW50YXN5LWxhbmQvb2YnOiAgICAgICAgICAgIEFycmF5JG9mLFxuICAgICAgJ2ZhbnRhc3ktbGFuZC9jaGFpblJlYyc6ICAgICAgQXJyYXkkY2hhaW5SZWMsXG4gICAgICAnZmFudGFzeS1sYW5kL3plcm8nOiAgICAgICAgICBBcnJheSR6ZXJvLFxuICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgIHRvU3RyaW5nOiAgICAgICAgICAgICAgICAgICBBcnJheSRwcm90b3R5cGUkdG9TdHJpbmcsXG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBBcnJheSRwcm90b3R5cGUkZXF1YWxzLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2x0ZSc6ICAgICAgICAgQXJyYXkkcHJvdG90eXBlJGx0ZSxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9jb25jYXQnOiAgICAgIEFycmF5JHByb3RvdHlwZSRjb25jYXQsXG4gICAgICAgICdmYW50YXN5LWxhbmQvZmlsdGVyJzogICAgICBBcnJheSRwcm90b3R5cGUkZmlsdGVyLFxuICAgICAgICAnZmFudGFzeS1sYW5kL21hcCc6ICAgICAgICAgQXJyYXkkcHJvdG90eXBlJG1hcCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9hcCc6ICAgICAgICAgIEFycmF5JHByb3RvdHlwZSRhcCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9jaGFpbic6ICAgICAgIEFycmF5JHByb3RvdHlwZSRjaGFpbixcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9hbHQnOiAgICAgICAgIEFycmF5JHByb3RvdHlwZSRhbHQsXG4gICAgICAgICdmYW50YXN5LWxhbmQvcmVkdWNlJzogICAgICBBcnJheSRwcm90b3R5cGUkcmVkdWNlLFxuICAgICAgICAnZmFudGFzeS1sYW5kL3RyYXZlcnNlJzogICAgQXJyYXkkcHJvdG90eXBlJHRyYXZlcnNlLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2V4dGVuZCc6ICAgICAgQXJyYXkkcHJvdG90eXBlJGV4dGVuZFxuICAgICAgfVxuICAgIH0sXG4gICAgQXJndW1lbnRzOiB7XG4gICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgdG9TdHJpbmc6ICAgICAgICAgICAgICAgICAgIEFyZ3VtZW50cyRwcm90b3R5cGUkdG9TdHJpbmcsXG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBBcmd1bWVudHMkcHJvdG90eXBlJGVxdWFscyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9sdGUnOiAgICAgICAgIEFyZ3VtZW50cyRwcm90b3R5cGUkbHRlXG4gICAgICB9XG4gICAgfSxcbiAgICBFcnJvcjoge1xuICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgIHRvU3RyaW5nOiAgICAgICAgICAgICAgICAgICBFcnJvciRwcm90b3R5cGUkdG9TdHJpbmcsXG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBFcnJvciRwcm90b3R5cGUkZXF1YWxzXG4gICAgICB9XG4gICAgfSxcbiAgICBPYmplY3Q6IHtcbiAgICAgICdmYW50YXN5LWxhbmQvZW1wdHknOiAgICAgICAgIE9iamVjdCRlbXB0eSxcbiAgICAgICdmYW50YXN5LWxhbmQvemVybyc6ICAgICAgICAgIE9iamVjdCR6ZXJvLFxuICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgIHRvU3RyaW5nOiAgICAgICAgICAgICAgICAgICBPYmplY3QkcHJvdG90eXBlJHRvU3RyaW5nLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgT2JqZWN0JHByb3RvdHlwZSRlcXVhbHMsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbHRlJzogICAgICAgICBPYmplY3QkcHJvdG90eXBlJGx0ZSxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9jb25jYXQnOiAgICAgIE9iamVjdCRwcm90b3R5cGUkY29uY2F0LFxuICAgICAgICAnZmFudGFzeS1sYW5kL2ZpbHRlcic6ICAgICAgT2JqZWN0JHByb3RvdHlwZSRmaWx0ZXIsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbWFwJzogICAgICAgICBPYmplY3QkcHJvdG90eXBlJG1hcCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9hcCc6ICAgICAgICAgIE9iamVjdCRwcm90b3R5cGUkYXAsXG4gICAgICAgICdmYW50YXN5LWxhbmQvYWx0JzogICAgICAgICBPYmplY3QkcHJvdG90eXBlJGFsdCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9yZWR1Y2UnOiAgICAgIE9iamVjdCRwcm90b3R5cGUkcmVkdWNlLFxuICAgICAgICAnZmFudGFzeS1sYW5kL3RyYXZlcnNlJzogICAgT2JqZWN0JHByb3RvdHlwZSR0cmF2ZXJzZVxuICAgICAgfVxuICAgIH0sXG4gICAgRnVuY3Rpb246IHtcbiAgICAgICdmYW50YXN5LWxhbmQvaWQnOiAgICAgICAgICAgIEZ1bmN0aW9uJGlkLFxuICAgICAgJ2ZhbnRhc3ktbGFuZC9vZic6ICAgICAgICAgICAgRnVuY3Rpb24kb2YsXG4gICAgICAnZmFudGFzeS1sYW5kL2NoYWluUmVjJzogICAgICBGdW5jdGlvbiRjaGFpblJlYyxcbiAgICAgIHByb3RvdHlwZToge1xuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgRnVuY3Rpb24kcHJvdG90eXBlJGVxdWFscyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9jb21wb3NlJzogICAgIEZ1bmN0aW9uJHByb3RvdHlwZSRjb21wb3NlLFxuICAgICAgICAnZmFudGFzeS1sYW5kL21hcCc6ICAgICAgICAgRnVuY3Rpb24kcHJvdG90eXBlJG1hcCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9wcm9tYXAnOiAgICAgIEZ1bmN0aW9uJHByb3RvdHlwZSRwcm9tYXAsXG4gICAgICAgICdmYW50YXN5LWxhbmQvYXAnOiAgICAgICAgICBGdW5jdGlvbiRwcm90b3R5cGUkYXAsXG4gICAgICAgICdmYW50YXN5LWxhbmQvY2hhaW4nOiAgICAgICBGdW5jdGlvbiRwcm90b3R5cGUkY2hhaW4sXG4gICAgICAgICdmYW50YXN5LWxhbmQvZXh0ZW5kJzogICAgICBGdW5jdGlvbiRwcm90b3R5cGUkZXh0ZW5kLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2NvbnRyYW1hcCc6ICAgRnVuY3Rpb24kcHJvdG90eXBlJGNvbnRyYW1hcFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuXG4gIC8vIyB0b1N0cmluZyA6OiBhIC0+IFN0cmluZ1xuICAvLy5cbiAgLy8uIFJldHVybnMgYSB1c2VmdWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGl0cyBhcmd1bWVudC5cbiAgLy8uXG4gIC8vLiBEaXNwYXRjaGVzIHRvIHRoZSBhcmd1bWVudCdzIGB0b1N0cmluZ2AgbWV0aG9kIGlmIGFwcHJvcHJpYXRlLlxuICAvLy5cbiAgLy8uIFdoZXJlIHByYWN0aWNhbCwgYGVxdWFscyhldmFsKHRvU3RyaW5nKHgpKSwgeCkgPSB0cnVlYC5cbiAgLy8uXG4gIC8vLiBgdG9TdHJpbmdgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmcgYnVpbHQtaW4gdHlwZXM6XG4gIC8vLiBOdWxsLCBVbmRlZmluZWQsIEJvb2xlYW4sIE51bWJlciwgRGF0ZSwgU3RyaW5nLCBBcnJheSwgQXJndW1lbnRzLCBFcnJvcixcbiAgLy8uIGFuZCBPYmplY3QuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiB0b1N0cmluZygtMClcbiAgLy8uICctMCdcbiAgLy8uXG4gIC8vLiA+IHRvU3RyaW5nKFsnZm9vJywgJ2JhcicsICdiYXonXSlcbiAgLy8uICdbXCJmb29cIiwgXCJiYXJcIiwgXCJiYXpcIl0nXG4gIC8vLlxuICAvLy4gPiB0b1N0cmluZyh7eDogMSwgeTogMiwgejogM30pXG4gIC8vLiAne1wieFwiOiAxLCBcInlcIjogMiwgXCJ6XCI6IDN9J1xuICAvLy5cbiAgLy8uID4gdG9TdHJpbmcoQ29ucygxLCBDb25zKDIsIENvbnMoMywgTmlsKSkpKVxuICAvLy4gJ0NvbnMoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKSdcbiAgLy8uIGBgYFxuICB2YXIgdG9TdHJpbmcgPSAoZnVuY3Rpb24oKSB7XG4gICAgLy8gICRzZWVuIDo6IEFycmF5IEFueVxuICAgIHZhciAkc2VlbiA9IFtdO1xuXG4gICAgZnVuY3Rpb24gY2FsbChtZXRob2QsIHgpIHtcbiAgICAgICRzZWVuLnB1c2goeCk7XG4gICAgICB0cnkgeyByZXR1cm4gbWV0aG9kLmNhbGwoeCk7IH0gZmluYWxseSB7ICRzZWVuLnBvcCgpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvU3RyaW5nKHgpIHtcbiAgICAgIGlmICgkc2Vlbi5pbmRleE9mKHgpID49IDApIHJldHVybiAnPENpcmN1bGFyPic7XG5cbiAgICAgIHZhciB4VHlwZSA9IHR5cGUoeCk7XG4gICAgICBpZiAoeFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7IHJlc3VsdCA9IGNhbGwoeC50b1N0cmluZywgeCk7IH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsICYmIHJlc3VsdCAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxsKGltcGxQYXRoKFt4VHlwZSwgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddKSB8fCB4LnRvU3RyaW5nLCB4KTtcbiAgICB9O1xuICB9KCkpO1xuXG4gIC8vIyBlcXVhbHMgOjogKGEsIGIpIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBpZiBpdHMgYXJndW1lbnRzIGFyZSBvZiB0aGUgc2FtZSB0eXBlIGFuZCBlcXVhbCBhY2NvcmRpbmdcbiAgLy8uIHRvIHRoZSB0eXBlJ3MgW2BmYW50YXN5LWxhbmQvZXF1YWxzYF1bXSBtZXRob2Q7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvZXF1YWxzYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogTnVsbCwgVW5kZWZpbmVkLCBCb29sZWFuLCBOdW1iZXIsIERhdGUsIFJlZ0V4cCwgU3RyaW5nLFxuICAvLy4gQXJyYXksIEFyZ3VtZW50cywgRXJyb3IsIE9iamVjdCwgYW5kIEZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIFRoZSBhbGdvcml0aG0gc3VwcG9ydHMgY2lyY3VsYXIgZGF0YSBzdHJ1Y3R1cmVzLiBUd28gYXJyYXlzIGFyZSBlcXVhbFxuICAvLy4gaWYgdGhleSBoYXZlIHRoZSBzYW1lIGluZGV4IHBhdGhzIGFuZCBmb3IgZWFjaCBwYXRoIGhhdmUgZXF1YWwgdmFsdWVzLlxuICAvLy4gVHdvIGFycmF5cyB3aGljaCByZXByZXNlbnQgYFsxLCBbMSwgWzEsIFsxLCBbMSwgLi4uXV1dXV1gLCBmb3IgZXhhbXBsZSxcbiAgLy8uIGFyZSBlcXVhbCBldmVuIGlmIHRoZWlyIGludGVybmFsIHN0cnVjdHVyZXMgZGlmZmVyLiBUd28gb2JqZWN0cyBhcmUgZXF1YWxcbiAgLy8uIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBwcm9wZXJ0eSBwYXRocyBhbmQgZm9yIGVhY2ggcGF0aCBoYXZlIGVxdWFsIHZhbHVlcy5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGVxdWFscygwLCAtMClcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IGVxdWFscyhOYU4sIE5hTilcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IGVxdWFscyhDb25zKCdmb28nLCBDb25zKCdiYXInLCBOaWwpKSwgQ29ucygnZm9vJywgQ29ucygnYmFyJywgTmlsKSkpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBlcXVhbHMoQ29ucygnZm9vJywgQ29ucygnYmFyJywgTmlsKSksIENvbnMoJ2JhcicsIENvbnMoJ2ZvbycsIE5pbCkpKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgZXF1YWxzID0gKGZ1bmN0aW9uKCkge1xuICAgIC8vICAkcGFpcnMgOjogQXJyYXkgKFBhaXIgQW55IEFueSlcbiAgICB2YXIgJHBhaXJzID0gW107XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZXF1YWxzKHgsIHkpIHtcbiAgICAgIGlmICghc2FtZVR5cGUoeCwgeSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gIFRoaXMgYWxnb3JpdGhtIGZvciBjb21wYXJpbmcgY2lyY3VsYXIgZGF0YSBzdHJ1Y3R1cmVzIHdhc1xuICAgICAgLy8gIHN1Z2dlc3RlZCBpbiA8aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDA2MjI3OTQvMzEyNzg1Pi5cbiAgICAgIGlmICgkcGFpcnMuc29tZShmdW5jdGlvbihwKSB7IHJldHVybiBwWzBdID09PSB4ICYmIHBbMV0gPT09IHk7IH0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAkcGFpcnMucHVzaChbeCwgeV0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFNldG9pZC50ZXN0KHgpICYmIFNldG9pZC50ZXN0KHkpICYmIFNldG9pZC5tZXRob2RzLmVxdWFscyh4KSh5KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICRwYWlycy5wb3AoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KCkpO1xuXG4gIC8vIyBsdCA6OiAoYSwgYikgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIGlmIGl0cyBhcmd1bWVudHMgYXJlIG9mIHRoZSBzYW1lIHR5cGUgYW5kIHRoZSBmaXJzdCBpc1xuICAvLy4gbGVzcyB0aGFuIHRoZSBzZWNvbmQgYWNjb3JkaW5nIHRvIHRoZSB0eXBlJ3MgW2BmYW50YXN5LWxhbmQvbHRlYF1bXVxuICAvLy4gbWV0aG9kOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGx0ZWBdKCNsdGUpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZ3RgXSgjZ3QpIGFuZCBbYGd0ZWBdKCNndGUpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gbHQoMCwgMClcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBsdCgwLCAxKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gbHQoMSwgMClcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbHQoeCwgeSkge1xuICAgIHJldHVybiBzYW1lVHlwZSh4LCB5KSAmJiAhbHRlKHksIHgpO1xuICB9XG5cbiAgLy8jIGx0ZSA6OiAoYSwgYikgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIGlmIGl0cyBhcmd1bWVudHMgYXJlIG9mIHRoZSBzYW1lIHR5cGUgYW5kIHRoZSBmaXJzdFxuICAvLy4gaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQgYWNjb3JkaW5nIHRvIHRoZSB0eXBlJ3NcbiAgLy8uIFtgZmFudGFzeS1sYW5kL2x0ZWBdW10gbWV0aG9kOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2x0ZWAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IE51bGwsIFVuZGVmaW5lZCwgQm9vbGVhbiwgTnVtYmVyLCBEYXRlLCBTdHJpbmcsIEFycmF5LFxuICAvLy4gQXJndW1lbnRzLCBhbmQgT2JqZWN0LlxuICAvLy5cbiAgLy8uIFRoZSBhbGdvcml0aG0gc3VwcG9ydHMgY2lyY3VsYXIgZGF0YSBzdHJ1Y3R1cmVzIGluIHRoZSBzYW1lIG1hbm5lciBhc1xuICAvLy4gW2BlcXVhbHNgXSgjZXF1YWxzKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGx0YF0oI2x0KSwgW2BndGBdKCNndCksIGFuZCBbYGd0ZWBdKCNndGUpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gbHRlKDAsIDApXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBsdGUoMCwgMSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IGx0ZSgxLCAwKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgbHRlID0gKGZ1bmN0aW9uKCkge1xuICAgIC8vICAkcGFpcnMgOjogQXJyYXkgKFBhaXIgQW55IEFueSlcbiAgICB2YXIgJHBhaXJzID0gW107XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbHRlKHgsIHkpIHtcbiAgICAgIGlmICghc2FtZVR5cGUoeCwgeSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gIFRoaXMgYWxnb3JpdGhtIGZvciBjb21wYXJpbmcgY2lyY3VsYXIgZGF0YSBzdHJ1Y3R1cmVzIHdhc1xuICAgICAgLy8gIHN1Z2dlc3RlZCBpbiA8aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDA2MjI3OTQvMzEyNzg1Pi5cbiAgICAgIGlmICgkcGFpcnMuc29tZShmdW5jdGlvbihwKSB7IHJldHVybiBwWzBdID09PSB4ICYmIHBbMV0gPT09IHk7IH0pKSB7XG4gICAgICAgIHJldHVybiBlcXVhbHMoeCwgeSk7XG4gICAgICB9XG5cbiAgICAgICRwYWlycy5wdXNoKFt4LCB5XSk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gT3JkLnRlc3QoeCkgJiYgT3JkLnRlc3QoeSkgJiYgT3JkLm1ldGhvZHMubHRlKHgpKHkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgJHBhaXJzLnBvcCgpO1xuICAgICAgfVxuICAgIH07XG4gIH0oKSk7XG5cbiAgLy8jIGd0IDo6IChhLCBiKSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gUmV0dXJucyBgdHJ1ZWAgaWYgaXRzIGFyZ3VtZW50cyBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhbmQgdGhlIGZpcnN0IGlzXG4gIC8vLiBncmVhdGVyIHRoYW4gdGhlIHNlY29uZCBhY2NvcmRpbmcgdG8gdGhlIHR5cGUncyBbYGZhbnRhc3ktbGFuZC9sdGVgXVtdXG4gIC8vLiBtZXRob2Q7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgbHRlYF0oI2x0ZSkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BsdGBdKCNsdCkgYW5kIFtgZ3RlYF0oI2d0ZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBndCgwLCAwKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IGd0KDAsIDEpXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gZ3QoMSwgMClcbiAgLy8uIHRydWVcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBndCh4LCB5KSB7XG4gICAgcmV0dXJuIGx0KHksIHgpO1xuICB9XG5cbiAgLy8jIGd0ZSA6OiAoYSwgYikgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIGlmIGl0cyBhcmd1bWVudHMgYXJlIG9mIHRoZSBzYW1lIHR5cGUgYW5kIHRoZSBmaXJzdFxuICAvLy4gaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQgYWNjb3JkaW5nIHRvIHRoZSB0eXBlJ3NcbiAgLy8uIFtgZmFudGFzeS1sYW5kL2x0ZWBdW10gbWV0aG9kOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGx0ZWBdKCNsdGUpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbHRgXSgjbHQpIGFuZCBbYGd0YF0oI2d0KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGd0ZSgwLCAwKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gZ3RlKDAsIDEpXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gZ3RlKDEsIDApXG4gIC8vLiB0cnVlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZ3RlKHgsIHkpIHtcbiAgICByZXR1cm4gbHRlKHksIHgpO1xuICB9XG5cbiAgLy8jIG1pbiA6OiBPcmQgYSA9PiAoYSwgYSkgLT4gYVxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIHNtYWxsZXIgb2YgaXRzIHR3byBhcmd1bWVudHMuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BsdGVgXSgjbHRlKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYG1heGBdKCNtYXgpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gbWluKDEwLCAyKVxuICAvLy4gMlxuICAvLy5cbiAgLy8uID4gbWluKG5ldyBEYXRlKCcxOTk5LTEyLTMxJyksIG5ldyBEYXRlKCcyMDAwLTAxLTAxJykpXG4gIC8vLiBuZXcgRGF0ZSgnMTk5OS0xMi0zMScpXG4gIC8vLlxuICAvLy4gPiBtaW4oJzEwJywgJzInKVxuICAvLy4gJzEwJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG1pbih4LCB5KSB7XG4gICAgcmV0dXJuIGx0ZSh4LCB5KSA/IHggOiB5O1xuICB9XG5cbiAgLy8jIG1heCA6OiBPcmQgYSA9PiAoYSwgYSkgLT4gYVxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIGxhcmdlciBvZiBpdHMgdHdvIGFyZ3VtZW50cy5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGx0ZWBdKCNsdGUpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbWluYF0oI21pbikuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBtYXgoMTAsIDIpXG4gIC8vLiAxMFxuICAvLy5cbiAgLy8uID4gbWF4KG5ldyBEYXRlKCcxOTk5LTEyLTMxJyksIG5ldyBEYXRlKCcyMDAwLTAxLTAxJykpXG4gIC8vLiBuZXcgRGF0ZSgnMjAwMC0wMS0wMScpXG4gIC8vLlxuICAvLy4gPiBtYXgoJzEwJywgJzInKVxuICAvLy4gJzInXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbWF4KHgsIHkpIHtcbiAgICByZXR1cm4gbHRlKHgsIHkpID8geSA6IHg7XG4gIH1cblxuICAvLyMgY29tcG9zZSA6OiBTZW1pZ3JvdXBvaWQgYyA9PiAoYyBqIGssIGMgaSBqKSAtPiBjIGkga1xuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2NvbXBvc2VgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvY29tcG9zZWAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gY29tcG9zZShNYXRoLnNxcnQsIHggPT4geCArIDEpKDk5KVxuICAvLy4gMTBcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBjb21wb3NlKHgsIHkpIHtcbiAgICByZXR1cm4gU2VtaWdyb3Vwb2lkLm1ldGhvZHMuY29tcG9zZSh5KSh4KTtcbiAgfVxuXG4gIC8vIyBpZCA6OiBDYXRlZ29yeSBjID0+IFR5cGVSZXAgYyAtPiBjXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvaWRgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvaWRgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBGdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGlkKEZ1bmN0aW9uKSgnZm9vJylcbiAgLy8uICdmb28nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gaWQodHlwZVJlcCkge1xuICAgIHJldHVybiBDYXRlZ29yeS5tZXRob2RzLmlkKHR5cGVSZXApKCk7XG4gIH1cblxuICAvLyMgY29uY2F0IDo6IFNlbWlncm91cCBhID0+IChhLCBhKSAtPiBhXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvY29uY2F0YF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2NvbmNhdGAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IFN0cmluZywgQXJyYXksIGFuZCBPYmplY3QuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBjb25jYXQoJ2FiYycsICdkZWYnKVxuICAvLy4gJ2FiY2RlZidcbiAgLy8uXG4gIC8vLiA+IGNvbmNhdChbMSwgMiwgM10sIFs0LCA1LCA2XSlcbiAgLy8uIFsxLCAyLCAzLCA0LCA1LCA2XVxuICAvLy5cbiAgLy8uID4gY29uY2F0KHt4OiAxLCB5OiAyfSwge3k6IDMsIHo6IDR9KVxuICAvLy4ge3g6IDEsIHk6IDMsIHo6IDR9XG4gIC8vLlxuICAvLy4gPiBjb25jYXQoQ29ucygnZm9vJywgQ29ucygnYmFyJywgQ29ucygnYmF6JywgTmlsKSkpLCBDb25zKCdxdXV4JywgTmlsKSlcbiAgLy8uIENvbnMoJ2ZvbycsIENvbnMoJ2JhcicsIENvbnMoJ2JheicsIENvbnMoJ3F1dXgnLCBOaWwpKSkpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gY29uY2F0KHgsIHkpIHtcbiAgICByZXR1cm4gU2VtaWdyb3VwLm1ldGhvZHMuY29uY2F0KHgpKHkpO1xuICB9XG5cbiAgLy8jIGVtcHR5IDo6IE1vbm9pZCBtID0+IFR5cGVSZXAgbSAtPiBtXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvZW1wdHlgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvZW1wdHlgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBTdHJpbmcsIEFycmF5LCBhbmQgT2JqZWN0LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZW1wdHkoU3RyaW5nKVxuICAvLy4gJydcbiAgLy8uXG4gIC8vLiA+IGVtcHR5KEFycmF5KVxuICAvLy4gW11cbiAgLy8uXG4gIC8vLiA+IGVtcHR5KE9iamVjdClcbiAgLy8uIHt9XG4gIC8vLlxuICAvLy4gPiBlbXB0eShMaXN0KVxuICAvLy4gTmlsXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZW1wdHkodHlwZVJlcCkge1xuICAgIHJldHVybiBNb25vaWQubWV0aG9kcy5lbXB0eSh0eXBlUmVwKSgpO1xuICB9XG5cbiAgLy8jIGludmVydCA6OiBHcm91cCBnID0+IGcgLT4gZ1xuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2ludmVydGBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBpbnZlcnQoU3VtKDUpKVxuICAvLy4gU3VtKC01KVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGludmVydChncm91cCkge1xuICAgIHJldHVybiBHcm91cC5tZXRob2RzLmludmVydChncm91cCkoKTtcbiAgfVxuXG4gIC8vIyBmaWx0ZXIgOjogRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4sIGYgYSkgLT4gZiBhXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvZmlsdGVyYF1bXS4gRGlzY2FyZHMgZXZlcnkgZWxlbWVudFxuICAvLy4gb2YgdGhlIGdpdmVuIHN0cnVjdHVyZSB3aGljaCBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9maWx0ZXJgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBBcnJheSBhbmQgT2JqZWN0LlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgcmVqZWN0YF0oI3JlamVjdCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBmaWx0ZXIoeCA9PiB4ICUgMiA9PSAxLCBbMSwgMiwgM10pXG4gIC8vLiBbMSwgM11cbiAgLy8uXG4gIC8vLiA+IGZpbHRlcih4ID0+IHggJSAyID09IDEsIHt4OiAxLCB5OiAyLCB6OiAzfSlcbiAgLy8uIHt4OiAxLCB6OiAzfVxuICAvLy5cbiAgLy8uID4gZmlsdGVyKHggPT4geCAlIDIgPT0gMSwgQ29ucygxLCBDb25zKDIsIENvbnMoMywgTmlsKSkpKVxuICAvLy4gQ29ucygxLCBDb25zKDMsIE5pbCkpXG4gIC8vLlxuICAvLy4gPiBmaWx0ZXIoeCA9PiB4ICUgMiA9PSAxLCBOb3RoaW5nKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gZmlsdGVyKHggPT4geCAlIDIgPT0gMSwgSnVzdCgwKSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IGZpbHRlcih4ID0+IHggJSAyID09IDEsIEp1c3QoMSkpXG4gIC8vLiBKdXN0KDEpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZmlsdGVyKHByZWQsIGZpbHRlcmFibGUpIHtcbiAgICByZXR1cm4gRmlsdGVyYWJsZS5tZXRob2RzLmZpbHRlcihmaWx0ZXJhYmxlKShwcmVkKTtcbiAgfVxuXG4gIC8vIyByZWplY3QgOjogRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4sIGYgYSkgLT4gZiBhXG4gIC8vLlxuICAvLy4gRGlzY2FyZHMgZXZlcnkgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gc3RydWN0dXJlIHdoaWNoIHNhdGlzZmllcyB0aGVcbiAgLy8uIHByZWRpY2F0ZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGZpbHRlcmBdKCNmaWx0ZXIpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gcmVqZWN0KHggPT4geCAlIDIgPT0gMSwgWzEsIDIsIDNdKVxuICAvLy4gWzJdXG4gIC8vLlxuICAvLy4gPiByZWplY3QoeCA9PiB4ICUgMiA9PSAxLCB7eDogMSwgeTogMiwgejogM30pXG4gIC8vLiB7eTogMn1cbiAgLy8uXG4gIC8vLiA+IHJlamVjdCh4ID0+IHggJSAyID09IDEsIENvbnMoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKSlcbiAgLy8uIENvbnMoMiwgTmlsKVxuICAvLy5cbiAgLy8uID4gcmVqZWN0KHggPT4geCAlIDIgPT0gMSwgTm90aGluZylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IHJlamVjdCh4ID0+IHggJSAyID09IDEsIEp1c3QoMCkpXG4gIC8vLiBKdXN0KDApXG4gIC8vLlxuICAvLy4gPiByZWplY3QoeCA9PiB4ICUgMiA9PSAxLCBKdXN0KDEpKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHJlamVjdChwcmVkLCBmaWx0ZXJhYmxlKSB7XG4gICAgcmV0dXJuIGZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiAhcHJlZCh4KTsgfSwgZmlsdGVyYWJsZSk7XG4gIH1cblxuICAvLyMgbWFwIDo6IEZ1bmN0b3IgZiA9PiAoYSAtPiBiLCBmIGEpIC0+IGYgYlxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL21hcGBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9tYXBgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBBcnJheSwgT2JqZWN0LCBhbmQgRnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBtYXAoTWF0aC5zcXJ0LCBbMSwgNCwgOV0pXG4gIC8vLiBbMSwgMiwgM11cbiAgLy8uXG4gIC8vLiA+IG1hcChNYXRoLnNxcnQsIHt4OiAxLCB5OiA0LCB6OiA5fSlcbiAgLy8uIHt4OiAxLCB5OiAyLCB6OiAzfVxuICAvLy5cbiAgLy8uID4gbWFwKE1hdGguc3FydCwgcyA9PiBzLmxlbmd0aCkoJ1NhbmN0dWFyeScpXG4gIC8vLiAzXG4gIC8vLlxuICAvLy4gPiBtYXAoTWF0aC5zcXJ0LCBUdXBsZSgnZm9vJywgNjQpKVxuICAvLy4gVHVwbGUoJ2ZvbycsIDgpXG4gIC8vLlxuICAvLy4gPiBtYXAoTWF0aC5zcXJ0LCBOaWwpXG4gIC8vLiBOaWxcbiAgLy8uXG4gIC8vLiA+IG1hcChNYXRoLnNxcnQsIENvbnMoMSwgQ29ucyg0LCBDb25zKDksIE5pbCkpKSlcbiAgLy8uIENvbnMoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG1hcChmLCBmdW5jdG9yKSB7XG4gICAgcmV0dXJuIEZ1bmN0b3IubWV0aG9kcy5tYXAoZnVuY3RvcikoZik7XG4gIH1cblxuICAvLyMgYmltYXAgOjogQmlmdW5jdG9yIGYgPT4gKGEgLT4gYiwgYyAtPiBkLCBmIGEgYykgLT4gZiBiIGRcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9iaW1hcGBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBiaW1hcChzID0+IHMudG9VcHBlckNhc2UoKSwgTWF0aC5zcXJ0LCBUdXBsZSgnZm9vJywgNjQpKVxuICAvLy4gVHVwbGUoJ0ZPTycsIDgpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gYmltYXAoZiwgZywgYmlmdW5jdG9yKSB7XG4gICAgcmV0dXJuIEJpZnVuY3Rvci5tZXRob2RzLmJpbWFwKGJpZnVuY3RvcikoZiwgZyk7XG4gIH1cblxuICAvLyMgcHJvbWFwIDo6IFByb2Z1bmN0b3IgcCA9PiAoYSAtPiBiLCBjIC0+IGQsIHAgYiBjKSAtPiBwIGEgZFxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL3Byb21hcGBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9wcm9tYXBgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBGdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHByb21hcChNYXRoLmFicywgeCA9PiB4ICsgMSwgTWF0aC5zcXJ0KSgtMTAwKVxuICAvLy4gMTFcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBwcm9tYXAoZiwgZywgcHJvZnVuY3Rvcikge1xuICAgIHJldHVybiBQcm9mdW5jdG9yLm1ldGhvZHMucHJvbWFwKHByb2Z1bmN0b3IpKGYsIGcpO1xuICB9XG5cbiAgLy8jIGFwIDo6IEFwcGx5IGYgPT4gKGYgKGEgLT4gYiksIGYgYSkgLT4gZiBiXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvYXBgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvYXBgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBBcnJheSwgT2JqZWN0LCBhbmQgRnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBhcChbTWF0aC5zcXJ0LCB4ID0+IHggKiB4XSwgWzEsIDQsIDksIDE2LCAyNV0pXG4gIC8vLiBbMSwgMiwgMywgNCwgNSwgMSwgMTYsIDgxLCAyNTYsIDYyNV1cbiAgLy8uXG4gIC8vLiA+IGFwKHthOiBNYXRoLnNxcnQsIGI6IHggPT4geCAqIHh9LCB7YTogMTYsIGI6IDEwLCBjOiAxfSlcbiAgLy8uIHthOiA0LCBiOiAxMDB9XG4gIC8vLlxuICAvLy4gPiBhcChzID0+IG4gPT4gcy5zbGljZSgwLCBuKSwgcyA9PiBNYXRoLmNlaWwocy5sZW5ndGggLyAyKSkoJ0hhc2tlbGwnKVxuICAvLy4gJ0hhc2snXG4gIC8vLlxuICAvLy4gPiBhcChJZGVudGl0eShNYXRoLnNxcnQpLCBJZGVudGl0eSg2NCkpXG4gIC8vLiBJZGVudGl0eSg4KVxuICAvLy5cbiAgLy8uID4gYXAoQ29ucyhNYXRoLnNxcnQsIENvbnMoeCA9PiB4ICogeCwgTmlsKSksIENvbnMoMTYsIENvbnMoMTAwLCBOaWwpKSlcbiAgLy8uIENvbnMoNCwgQ29ucygxMCwgQ29ucygyNTYsIENvbnMoMTAwMDAsIE5pbCkpKSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBhcChhcHBseUYsIGFwcGx5WCkge1xuICAgIHJldHVybiBBcHBseS5tZXRob2RzLmFwKGFwcGx5WCkoYXBwbHlGKTtcbiAgfVxuXG4gIC8vIyBsaWZ0MiA6OiBBcHBseSBmID0+IChhIC0+IGIgLT4gYywgZiBhLCBmIGIpIC0+IGYgY1xuICAvLy5cbiAgLy8uIExpZnRzIGBhIC0+IGIgLT4gY2AgdG8gYEFwcGx5IGYgPT4gZiBhIC0+IGYgYiAtPiBmIGNgIGFuZCByZXR1cm5zIHRoZVxuICAvLy4gcmVzdWx0IG9mIGFwcGx5aW5nIHRoaXMgdG8gdGhlIGdpdmVuIGFyZ3VtZW50cy5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYG1hcGBdKCNtYXApIGFuZCBbYGFwYF0oI2FwKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGxpZnQzYF0oI2xpZnQzKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGxpZnQyKHggPT4geSA9PiBNYXRoLnBvdyh4LCB5KSwgWzEwXSwgWzEsIDIsIDNdKVxuICAvLy4gWzEwLCAxMDAsIDEwMDBdXG4gIC8vLlxuICAvLy4gPiBsaWZ0Mih4ID0+IHkgPT4gTWF0aC5wb3coeCwgeSksIElkZW50aXR5KDEwKSwgSWRlbnRpdHkoMykpXG4gIC8vLiBJZGVudGl0eSgxMDAwKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGxpZnQyKGYsIHgsIHkpIHtcbiAgICByZXR1cm4gYXAobWFwKGYsIHgpLCB5KTtcbiAgfVxuXG4gIC8vIyBsaWZ0MyA6OiBBcHBseSBmID0+IChhIC0+IGIgLT4gYyAtPiBkLCBmIGEsIGYgYiwgZiBjKSAtPiBmIGRcbiAgLy8uXG4gIC8vLiBMaWZ0cyBgYSAtPiBiIC0+IGMgLT4gZGAgdG8gYEFwcGx5IGYgPT4gZiBhIC0+IGYgYiAtPiBmIGMgLT4gZiBkYCBhbmRcbiAgLy8uIHJldHVybnMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGlzIHRvIHRoZSBnaXZlbiBhcmd1bWVudHMuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BtYXBgXSgjbWFwKSBhbmQgW2BhcGBdKCNhcCkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BsaWZ0MmBdKCNsaWZ0MikuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBsaWZ0Myh4ID0+IHkgPT4geiA9PiB4ICsgeiArIHksIFsnPCddLCBbJz4nXSwgWydmb28nLCAnYmFyJywgJ2JheiddKVxuICAvLy4gWyc8Zm9vPicsICc8YmFyPicsICc8YmF6PiddXG4gIC8vLlxuICAvLy4gPiBsaWZ0Myh4ID0+IHkgPT4geiA9PiB4ICsgeiArIHksIElkZW50aXR5KCc8JyksIElkZW50aXR5KCc+JyksIElkZW50aXR5KCdiYXonKSlcbiAgLy8uIElkZW50aXR5KCc8YmF6PicpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbGlmdDMoZiwgeCwgeSwgeikge1xuICAgIHJldHVybiBhcChhcChtYXAoZiwgeCksIHkpLCB6KTtcbiAgfVxuXG4gIC8vIyBhcEZpcnN0IDo6IEFwcGx5IGYgPT4gKGYgYSwgZiBiKSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBDb21iaW5lcyB0d28gZWZmZWN0ZnVsIGFjdGlvbnMsIGtlZXBpbmcgb25seSB0aGUgcmVzdWx0IG9mIHRoZSBmaXJzdC5cbiAgLy8uIEVxdWl2YWxlbnQgdG8gSGFza2VsbCdzIGAoPCopYCBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGxpZnQyYF0oI2xpZnQyKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGFwU2Vjb25kYF0oI2FwU2Vjb25kKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGFwRmlyc3QoWzEsIDJdLCBbMywgNF0pXG4gIC8vLiBbMSwgMSwgMiwgMl1cbiAgLy8uXG4gIC8vLiA+IGFwRmlyc3QoSWRlbnRpdHkoMSksIElkZW50aXR5KDIpKVxuICAvLy4gSWRlbnRpdHkoMSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBhcEZpcnN0KHgsIHkpIHtcbiAgICByZXR1cm4gbGlmdDIoY29uc3RhbnQsIHgsIHkpO1xuICB9XG5cbiAgLy8jIGFwU2Vjb25kIDo6IEFwcGx5IGYgPT4gKGYgYSwgZiBiKSAtPiBmIGJcbiAgLy8uXG4gIC8vLiBDb21iaW5lcyB0d28gZWZmZWN0ZnVsIGFjdGlvbnMsIGtlZXBpbmcgb25seSB0aGUgcmVzdWx0IG9mIHRoZSBzZWNvbmQuXG4gIC8vLiBFcXVpdmFsZW50IHRvIEhhc2tlbGwncyBgKCo+KWAgZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BsaWZ0MmBdKCNsaWZ0MikuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BhcEZpcnN0YF0oI2FwRmlyc3QpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gYXBTZWNvbmQoWzEsIDJdLCBbMywgNF0pXG4gIC8vLiBbMywgNCwgMywgNF1cbiAgLy8uXG4gIC8vLiA+IGFwU2Vjb25kKElkZW50aXR5KDEpLCBJZGVudGl0eSgyKSlcbiAgLy8uIElkZW50aXR5KDIpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gYXBTZWNvbmQoeCwgeSkge1xuICAgIHJldHVybiBsaWZ0Mihjb25zdGFudChpZGVudGl0eSksIHgsIHkpO1xuICB9XG5cbiAgLy8jIG9mIDo6IEFwcGxpY2F0aXZlIGYgPT4gKFR5cGVSZXAgZiwgYSkgLT4gZiBhXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvb2ZgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvb2ZgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBBcnJheSBhbmQgRnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBvZihBcnJheSwgNDIpXG4gIC8vLiBbNDJdXG4gIC8vLlxuICAvLy4gPiBvZihGdW5jdGlvbiwgNDIpKG51bGwpXG4gIC8vLiA0MlxuICAvLy5cbiAgLy8uID4gb2YoTGlzdCwgNDIpXG4gIC8vLiBDb25zKDQyLCBOaWwpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gb2YodHlwZVJlcCwgeCkge1xuICAgIHJldHVybiBBcHBsaWNhdGl2ZS5tZXRob2RzLm9mKHR5cGVSZXApKHgpO1xuICB9XG5cbiAgLy8jIGFwcGVuZCA6OiAoQXBwbGljYXRpdmUgZiwgU2VtaWdyb3VwIChmIGEpKSA9PiAoYSwgZiBhKSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwZW5kaW5nIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgc2Vjb25kLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgY29uY2F0YF0oI2NvbmNhdCkgYW5kIFtgb2ZgXSgjb2YpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgcHJlcGVuZGBdKCNwcmVwZW5kKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGFwcGVuZCgzLCBbMSwgMl0pXG4gIC8vLiBbMSwgMiwgM11cbiAgLy8uXG4gIC8vLiA+IGFwcGVuZCgzLCBDb25zKDEsIENvbnMoMiwgTmlsKSkpXG4gIC8vLiBDb25zKDEsIENvbnMoMiwgQ29ucygzLCBOaWwpKSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBhcHBlbmQoeCwgeHMpIHtcbiAgICByZXR1cm4gY29uY2F0KHhzLCBvZih4cy5jb25zdHJ1Y3RvciwgeCkpO1xuICB9XG5cbiAgLy8jIHByZXBlbmQgOjogKEFwcGxpY2F0aXZlIGYsIFNlbWlncm91cCAoZiBhKSkgPT4gKGEsIGYgYSkgLT4gZiBhXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHByZXBlbmRpbmcgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2Bjb25jYXRgXSgjY29uY2F0KSBhbmQgW2BvZmBdKCNvZikuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BhcHBlbmRgXSgjYXBwZW5kKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHByZXBlbmQoMSwgWzIsIDNdKVxuICAvLy4gWzEsIDIsIDNdXG4gIC8vLlxuICAvLy4gPiBwcmVwZW5kKDEsIENvbnMoMiwgQ29ucygzLCBOaWwpKSlcbiAgLy8uIENvbnMoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHByZXBlbmQoeCwgeHMpIHtcbiAgICByZXR1cm4gY29uY2F0KG9mKHhzLmNvbnN0cnVjdG9yLCB4KSwgeHMpO1xuICB9XG5cbiAgLy8jIGNoYWluIDo6IENoYWluIG0gPT4gKGEgLT4gbSBiLCBtIGEpIC0+IG0gYlxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2NoYWluYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2NoYWluYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogQXJyYXkgYW5kIEZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gY2hhaW4oeCA9PiBbeCwgeF0sIFsxLCAyLCAzXSlcbiAgLy8uIFsxLCAxLCAyLCAyLCAzLCAzXVxuICAvLy5cbiAgLy8uID4gY2hhaW4oeCA9PiB4ICUgMiA9PSAxID8gb2YoTGlzdCwgeCkgOiBOaWwsIENvbnMoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKSlcbiAgLy8uIENvbnMoMSwgQ29ucygzLCBOaWwpKVxuICAvLy5cbiAgLy8uID4gY2hhaW4obiA9PiBzID0+IHMuc2xpY2UoMCwgbiksIHMgPT4gTWF0aC5jZWlsKHMubGVuZ3RoIC8gMikpKCdIYXNrZWxsJylcbiAgLy8uICdIYXNrJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGNoYWluKGYsIGNoYWluXykge1xuICAgIHJldHVybiBDaGFpbi5tZXRob2RzLmNoYWluKGNoYWluXykoZik7XG4gIH1cblxuICAvLyMgam9pbiA6OiBDaGFpbiBtID0+IG0gKG0gYSkgLT4gbSBhXG4gIC8vLlxuICAvLy4gUmVtb3ZlcyBvbmUgbGV2ZWwgb2YgbmVzdGluZyBmcm9tIGEgbmVzdGVkIG1vbmFkaWMgc3RydWN0dXJlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgY2hhaW5gXSgjY2hhaW4pLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gam9pbihbWzFdLCBbMl0sIFszXV0pXG4gIC8vLiBbMSwgMiwgM11cbiAgLy8uXG4gIC8vLiA+IGpvaW4oW1tbMSwgMiwgM11dXSlcbiAgLy8uIFtbMSwgMiwgM11dXG4gIC8vLlxuICAvLy4gPiBqb2luKElkZW50aXR5KElkZW50aXR5KDEpKSlcbiAgLy8uIElkZW50aXR5KDEpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gam9pbihjaGFpbl8pIHtcbiAgICByZXR1cm4gY2hhaW4oaWRlbnRpdHksIGNoYWluXyk7XG4gIH1cblxuICAvLyMgY2hhaW5SZWMgOjogQ2hhaW5SZWMgbSA9PiAoVHlwZVJlcCBtLCAoYSAtPiBjLCBiIC0+IGMsIGEpIC0+IG0gYywgYSkgLT4gbSBiXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvY2hhaW5SZWNgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvY2hhaW5SZWNgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBBcnJheS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGNoYWluUmVjKFxuICAvLy4gLiAgIEFycmF5LFxuICAvLy4gLiAgIChuZXh0LCBkb25lLCBzKSA9PiBzLmxlbmd0aCA9PSAyID8gW3MgKyAnIScsIHMgKyAnPyddLm1hcChkb25lKVxuICAvLy4gLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogW3MgKyAnbycsIHMgKyAnbiddLm1hcChuZXh0KSxcbiAgLy8uIC4gICAnJ1xuICAvLy4gLiApXG4gIC8vLiBbJ29vIScsICdvbz8nLCAnb24hJywgJ29uPycsICdubyEnLCAnbm8/JywgJ25uIScsICdubj8nXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGNoYWluUmVjKHR5cGVSZXAsIGYsIHgpIHtcbiAgICByZXR1cm4gQ2hhaW5SZWMubWV0aG9kcy5jaGFpblJlYyh0eXBlUmVwKShmLCB4KTtcbiAgfVxuXG4gIC8vIyBhbHQgOjogQWx0IGYgPT4gKGYgYSwgZiBhKSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9hbHRgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvYWx0YCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogQXJyYXkgYW5kIE9iamVjdC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGFsdChbMSwgMiwgM10sIFs0LCA1LCA2XSlcbiAgLy8uIFsxLCAyLCAzLCA0LCA1LCA2XVxuICAvLy5cbiAgLy8uID4gYWx0KE5vdGhpbmcsIE5vdGhpbmcpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBhbHQoTm90aGluZywgSnVzdCgxKSlcbiAgLy8uIEp1c3QoMSlcbiAgLy8uXG4gIC8vLiA+IGFsdChKdXN0KDIpLCBKdXN0KDMpKVxuICAvLy4gSnVzdCgyKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGFsdCh4LCB5KSB7XG4gICAgcmV0dXJuIEFsdC5tZXRob2RzLmFsdCh4KSh5KTtcbiAgfVxuXG4gIC8vIyB6ZXJvIDo6IFBsdXMgZiA9PiBUeXBlUmVwIGYgLT4gZiBhXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvemVyb2BdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC96ZXJvYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogQXJyYXkgYW5kIE9iamVjdC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHplcm8oQXJyYXkpXG4gIC8vLiBbXVxuICAvLy5cbiAgLy8uID4gemVybyhPYmplY3QpXG4gIC8vLiB7fVxuICAvLy5cbiAgLy8uID4gemVybyhNYXliZSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiB6ZXJvKHR5cGVSZXApIHtcbiAgICByZXR1cm4gUGx1cy5tZXRob2RzLnplcm8odHlwZVJlcCkoKTtcbiAgfVxuXG4gIC8vIyByZWR1Y2UgOjogRm9sZGFibGUgZiA9PiAoKGIsIGEpIC0+IGIsIGIsIGYgYSkgLT4gYlxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL3JlZHVjZWBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9yZWR1Y2VgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBBcnJheSBhbmQgT2JqZWN0LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gcmVkdWNlKCh4cywgeCkgPT4gW3hdLmNvbmNhdCh4cyksIFtdLCBbMSwgMiwgM10pXG4gIC8vLiBbMywgMiwgMV1cbiAgLy8uXG4gIC8vLiA+IHJlZHVjZShjb25jYXQsICcnLCBDb25zKCdmb28nLCBDb25zKCdiYXInLCBDb25zKCdiYXonLCBOaWwpKSkpXG4gIC8vLiAnZm9vYmFyYmF6J1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHJlZHVjZShmLCB4LCBmb2xkYWJsZSkge1xuICAgIHJldHVybiBGb2xkYWJsZS5tZXRob2RzLnJlZHVjZShmb2xkYWJsZSkoZiwgeCk7XG4gIH1cblxuICAvLyMgc2l6ZSA6OiBGb2xkYWJsZSBmID0+IGYgYSAtPiBJbnRlZ2VyXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBzdHJ1Y3R1cmUuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2ByZWR1Y2VgXSgjcmVkdWNlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHNpemUoW10pXG4gIC8vLiAwXG4gIC8vLlxuICAvLy4gPiBzaXplKFsnZm9vJywgJ2JhcicsICdiYXonXSlcbiAgLy8uIDNcbiAgLy8uXG4gIC8vLiA+IHNpemUoTmlsKVxuICAvLy4gMFxuICAvLy5cbiAgLy8uID4gc2l6ZShDb25zKCdmb28nLCBDb25zKCdiYXInLCBDb25zKCdiYXonLCBOaWwpKSkpXG4gIC8vLiAzXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gc2l6ZShmb2xkYWJsZSkge1xuICAgIC8vICBGYXN0IHBhdGggZm9yIGFycmF5cy5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShmb2xkYWJsZSkpIHJldHVybiBmb2xkYWJsZS5sZW5ndGg7XG4gICAgcmV0dXJuIHJlZHVjZShmdW5jdGlvbihuLCBfKSB7IHJldHVybiBuICsgMTsgfSwgMCwgZm9sZGFibGUpO1xuICB9XG5cbiAgLy8jIGVsZW0gOjogKFNldG9pZCBhLCBGb2xkYWJsZSBmKSA9PiAoYSwgZiBhKSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gVGFrZXMgYSB2YWx1ZSBhbmQgYSBzdHJ1Y3R1cmUgYW5kIHJldHVybnMgYHRydWVgIGlmIHRoZVxuICAvLy4gdmFsdWUgaXMgYW4gZWxlbWVudCBvZiB0aGUgc3RydWN0dXJlOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGVxdWFsc2BdKCNlcXVhbHMpIGFuZFxuICAvLy4gW2ByZWR1Y2VgXSgjcmVkdWNlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGVsZW0oJ2MnLCBbJ2EnLCAnYicsICdjJ10pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBlbGVtKCd4JywgWydhJywgJ2InLCAnYyddKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IGVsZW0oMywge3g6IDEsIHk6IDIsIHo6IDN9KVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gZWxlbSg4LCB7eDogMSwgeTogMiwgejogM30pXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gZWxlbSgwLCBKdXN0KDApKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gZWxlbSgwLCBKdXN0KDEpKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IGVsZW0oMCwgTm90aGluZylcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZWxlbSh4LCBmb2xkYWJsZSkge1xuICAgIHJldHVybiByZWR1Y2UoZnVuY3Rpb24oYiwgeSkgeyByZXR1cm4gYiB8fCBlcXVhbHMoeCwgeSk7IH0sXG4gICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIGZvbGRhYmxlKTtcbiAgfVxuXG4gIC8vIyByZXZlcnNlIDo6IChBcHBsaWNhdGl2ZSBmLCBGb2xkYWJsZSBmLCBNb25vaWQgKGYgYSkpID0+IGYgYSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBSZXZlcnNlcyB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHN0cnVjdHVyZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGNvbmNhdGBdKCNjb25jYXQpLCBbYGVtcHR5YF0oI2VtcHR5KSxcbiAgLy8uIFtgb2ZgXSgjb2YpLCBhbmQgW2ByZWR1Y2VgXSgjcmVkdWNlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHJldmVyc2UoWzEsIDIsIDNdKVxuICAvLy4gWzMsIDIsIDFdXG4gIC8vLlxuICAvLy4gPiByZXZlcnNlKENvbnMoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKSlcbiAgLy8uIENvbnMoMywgQ29ucygyLCBDb25zKDEsIE5pbCkpKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHJldmVyc2UoZm9sZGFibGUpIHtcbiAgICAvLyAgRmFzdCBwYXRoIGZvciBhcnJheXMuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm9sZGFibGUpKSByZXR1cm4gZm9sZGFibGUuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgdmFyIEYgPSBmb2xkYWJsZS5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gcmVkdWNlKGZ1bmN0aW9uKHhzLCB4KSB7IHJldHVybiBjb25jYXQob2YoRiwgeCksIHhzKTsgfSxcbiAgICAgICAgICAgICAgICAgIGVtcHR5KEYpLFxuICAgICAgICAgICAgICAgICAgZm9sZGFibGUpO1xuICB9XG5cbiAgLy8jIHNvcnQgOjogKE9yZCBhLCBBcHBsaWNhdGl2ZSBmLCBGb2xkYWJsZSBmLCBNb25vaWQgKGYgYSkpID0+IGYgYSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBQZXJmb3JtcyBhIFtzdGFibGUgc29ydF1bXSBvZiB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHN0cnVjdHVyZSxcbiAgLy8uIHVzaW5nIFtgbHRlYF0oI2x0ZSkgZm9yIGNvbXBhcmlzb25zLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgbHRlYF0oI2x0ZSksIFtgY29uY2F0YF0oI2NvbmNhdCksXG4gIC8vLiBbYGVtcHR5YF0oI2VtcHR5KSwgW2BvZmBdKCNvZiksIGFuZCBbYHJlZHVjZWBdKCNyZWR1Y2UpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgc29ydEJ5YF0oI3NvcnRCeSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBzb3J0KFsnZm9vJywgJ2JhcicsICdiYXonXSlcbiAgLy8uIFsnYmFyJywgJ2JheicsICdmb28nXVxuICAvLy5cbiAgLy8uID4gc29ydChbSnVzdCgyKSwgTm90aGluZywgSnVzdCgxKV0pXG4gIC8vLiBbTm90aGluZywgSnVzdCgxKSwgSnVzdCgyKV1cbiAgLy8uXG4gIC8vLiA+IHNvcnQoQ29ucygnZm9vJywgQ29ucygnYmFyJywgQ29ucygnYmF6JywgTmlsKSkpKVxuICAvLy4gQ29ucygnYmFyJywgQ29ucygnYmF6JywgQ29ucygnZm9vJywgTmlsKSkpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gc29ydChmb2xkYWJsZSkge1xuICAgIHJldHVybiBzb3J0QnkoaWRlbnRpdHksIGZvbGRhYmxlKTtcbiAgfVxuXG4gIC8vIyBzb3J0QnkgOjogKE9yZCBiLCBBcHBsaWNhdGl2ZSBmLCBGb2xkYWJsZSBmLCBNb25vaWQgKGYgYSkpID0+IChhIC0+IGIsIGYgYSkgLT4gZiBhXG4gIC8vLlxuICAvLy4gUGVyZm9ybXMgYSBbc3RhYmxlIHNvcnRdW10gb2YgdGhlIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBzdHJ1Y3R1cmUsXG4gIC8vLiB1c2luZyBbYGx0ZWBdKCNsdGUpIHRvIGNvbXBhcmUgdGhlIHZhbHVlcyBwcm9kdWNlZCBieSBhcHBseWluZyB0aGVcbiAgLy8uIGdpdmVuIGZ1bmN0aW9uIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgc3RydWN0dXJlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgbHRlYF0oI2x0ZSksIFtgY29uY2F0YF0oI2NvbmNhdCksXG4gIC8vLiBbYGVtcHR5YF0oI2VtcHR5KSwgW2BvZmBdKCNvZiksIGFuZCBbYHJlZHVjZWBdKCNyZWR1Y2UpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgc29ydGBdKCNzb3J0KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHNvcnRCeShzID0+IHMubGVuZ3RoLCBbJ3JlZCcsICdncmVlbicsICdibHVlJ10pXG4gIC8vLiBbJ3JlZCcsICdibHVlJywgJ2dyZWVuJ11cbiAgLy8uXG4gIC8vLiA+IHNvcnRCeShzID0+IHMubGVuZ3RoLCBbJ2JsYWNrJywgJ3doaXRlJ10pXG4gIC8vLiBbJ2JsYWNrJywgJ3doaXRlJ11cbiAgLy8uXG4gIC8vLiA+IHNvcnRCeShzID0+IHMubGVuZ3RoLCBbJ3doaXRlJywgJ2JsYWNrJ10pXG4gIC8vLiBbJ3doaXRlJywgJ2JsYWNrJ11cbiAgLy8uXG4gIC8vLiA+IHNvcnRCeShzID0+IHMubGVuZ3RoLCBDb25zKCdyZWQnLCBDb25zKCdncmVlbicsIENvbnMoJ2JsdWUnLCBOaWwpKSkpXG4gIC8vLiBDb25zKCdyZWQnLCBDb25zKCdibHVlJywgQ29ucygnZ3JlZW4nLCBOaWwpKSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBzb3J0QnkoZiwgZm9sZGFibGUpIHtcbiAgICB2YXIgcnMgPSByZWR1Y2UoZnVuY3Rpb24oeHMsIHgpIHtcbiAgICAgIHZhciBmeCA9IGYoeCk7XG4gICAgICB2YXIgbG93ZXIgPSAwO1xuICAgICAgdmFyIHVwcGVyID0geHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxvd2VyIDwgdXBwZXIpIHtcbiAgICAgICAgdmFyIGlkeCA9IE1hdGguZmxvb3IoKGxvd2VyICsgdXBwZXIpIC8gMik7XG4gICAgICAgIGlmIChsdGUoeHNbaWR4XS5meCwgZngpKSBsb3dlciA9IGlkeCArIDE7IGVsc2UgdXBwZXIgPSBpZHg7XG4gICAgICB9XG4gICAgICB4cy5zcGxpY2UobG93ZXIsIDAsIHt4OiB4LCBmeDogZnh9KTtcbiAgICAgIHJldHVybiB4cztcbiAgICB9LCBbXSwgZm9sZGFibGUpO1xuXG4gICAgdmFyIEYgPSBmb2xkYWJsZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcmVzdWx0ID0gZW1wdHkoRik7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgcnMubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgICAgcmVzdWx0ID0gY29uY2F0KHJlc3VsdCwgb2YoRiwgcnNbaWR4XS54KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyMgdGFrZVdoaWxlIDo6IChBcHBsaWNhdGl2ZSBmLCBGb2xkYWJsZSBmLCBNb25vaWQgKGYgYSkpID0+IChhIC0+IEJvb2xlYW4sIGYgYSkgLT4gZiBhXG4gIC8vLlxuICAvLy4gRGlzY2FyZHMgdGhlIGZpcnN0IGlubmVyIHZhbHVlIHdoaWNoIGRvZXMgbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZSwgYW5kXG4gIC8vLiBhbGwgc3Vic2VxdWVudCBpbm5lciB2YWx1ZXMuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2Bjb25jYXRgXSgjY29uY2F0KSwgW2BlbXB0eWBdKCNlbXB0eSksXG4gIC8vLiBbYG9mYF0oI29mKSwgYW5kIFtgcmVkdWNlYF0oI3JlZHVjZSkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2Bkcm9wV2hpbGVgXSgjZHJvcFdoaWxlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHRha2VXaGlsZShzID0+IC94Ly50ZXN0KHMpLCBbJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5J10pXG4gIC8vLiBbJ3h5JywgJ3h6JywgJ3l4J11cbiAgLy8uXG4gIC8vLiA+IHRha2VXaGlsZShzID0+IC95Ly50ZXN0KHMpLCBbJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5J10pXG4gIC8vLiBbJ3h5J11cbiAgLy8uXG4gIC8vLiA+IHRha2VXaGlsZShzID0+IC96Ly50ZXN0KHMpLCBbJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5J10pXG4gIC8vLiBbXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHRha2VXaGlsZShwcmVkLCBmb2xkYWJsZSkge1xuICAgIHZhciB0YWtlID0gdHJ1ZTtcbiAgICByZXR1cm4gZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHRha2UgPSB0YWtlICYmIHByZWQoeCk7IH0sIGZvbGRhYmxlKTtcbiAgfVxuXG4gIC8vIyBkcm9wV2hpbGUgOjogKEFwcGxpY2F0aXZlIGYsIEZvbGRhYmxlIGYsIE1vbm9pZCAoZiBhKSkgPT4gKGEgLT4gQm9vbGVhbiwgZiBhKSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBSZXRhaW5zIHRoZSBmaXJzdCBpbm5lciB2YWx1ZSB3aGljaCBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUsIGFuZFxuICAvLy4gYWxsIHN1YnNlcXVlbnQgaW5uZXIgdmFsdWVzLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgY29uY2F0YF0oI2NvbmNhdCksIFtgZW1wdHlgXSgjZW1wdHkpLFxuICAvLy4gW2BvZmBdKCNvZiksIGFuZCBbYHJlZHVjZWBdKCNyZWR1Y2UpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgdGFrZVdoaWxlYF0oI3Rha2VXaGlsZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBkcm9wV2hpbGUocyA9PiAveC8udGVzdChzKSwgWyd4eScsICd4eicsICd5eCcsICd5eicsICd6eCcsICd6eSddKVxuICAvLy4gWyd5eicsICd6eCcsICd6eSddXG4gIC8vLlxuICAvLy4gPiBkcm9wV2hpbGUocyA9PiAveS8udGVzdChzKSwgWyd4eScsICd4eicsICd5eCcsICd5eicsICd6eCcsICd6eSddKVxuICAvLy4gWyd4eicsICd5eCcsICd5eicsICd6eCcsICd6eSddXG4gIC8vLlxuICAvLy4gPiBkcm9wV2hpbGUocyA9PiAvei8udGVzdChzKSwgWyd4eScsICd4eicsICd5eCcsICd5eicsICd6eCcsICd6eSddKVxuICAvLy4gWyd4eScsICd4eicsICd5eCcsICd5eicsICd6eCcsICd6eSddXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZHJvcFdoaWxlKHByZWQsIGZvbGRhYmxlKSB7XG4gICAgdmFyIHRha2UgPSBmYWxzZTtcbiAgICByZXR1cm4gZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHRha2UgPSB0YWtlIHx8ICFwcmVkKHgpOyB9LCBmb2xkYWJsZSk7XG4gIH1cblxuICAvLyMgdHJhdmVyc2UgOjogKEFwcGxpY2F0aXZlIGYsIFRyYXZlcnNhYmxlIHQpID0+IChUeXBlUmVwIGYsIGEgLT4gZiBiLCB0IGEpIC0+IGYgKHQgYilcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC90cmF2ZXJzZWBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC90cmF2ZXJzZWAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEFycmF5IGFuZCBPYmplY3QuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BzZXF1ZW5jZWBdKCNzZXF1ZW5jZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiB0cmF2ZXJzZShBcnJheSwgeCA9PiB4LCBbWzEsIDIsIDNdLCBbNCwgNV1dKVxuICAvLy4gW1sxLCA0XSwgWzEsIDVdLCBbMiwgNF0sIFsyLCA1XSwgWzMsIDRdLCBbMywgNV1dXG4gIC8vLlxuICAvLy4gPiB0cmF2ZXJzZShJZGVudGl0eSwgeCA9PiBJZGVudGl0eSh4ICsgMSksIFsxLCAyLCAzXSlcbiAgLy8uIElkZW50aXR5KFsyLCAzLCA0XSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiB0cmF2ZXJzZSh0eXBlUmVwLCBmLCB0cmF2ZXJzYWJsZSkge1xuICAgIHJldHVybiBUcmF2ZXJzYWJsZS5tZXRob2RzLnRyYXZlcnNlKHRyYXZlcnNhYmxlKSh0eXBlUmVwLCBmKTtcbiAgfVxuXG4gIC8vIyBzZXF1ZW5jZSA6OiAoQXBwbGljYXRpdmUgZiwgVHJhdmVyc2FibGUgdCkgPT4gKFR5cGVSZXAgZiwgdCAoZiBhKSkgLT4gZiAodCBhKVxuICAvLy5cbiAgLy8uIEludmVydHMgdGhlIGdpdmVuIGB0IChmIGEpYCB0byBwcm9kdWNlIGFuIGBmICh0IGEpYC5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYHRyYXZlcnNlYF0oI3RyYXZlcnNlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHNlcXVlbmNlKEFycmF5LCBJZGVudGl0eShbMSwgMiwgM10pKVxuICAvLy4gW0lkZW50aXR5KDEpLCBJZGVudGl0eSgyKSwgSWRlbnRpdHkoMyldXG4gIC8vLlxuICAvLy4gPiBzZXF1ZW5jZShJZGVudGl0eSwgW0lkZW50aXR5KDEpLCBJZGVudGl0eSgyKSwgSWRlbnRpdHkoMyldKVxuICAvLy4gSWRlbnRpdHkoWzEsIDIsIDNdKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHNlcXVlbmNlKHR5cGVSZXAsIHRyYXZlcnNhYmxlKSB7XG4gICAgcmV0dXJuIHRyYXZlcnNlKHR5cGVSZXAsIGlkZW50aXR5LCB0cmF2ZXJzYWJsZSk7XG4gIH1cblxuICAvLyMgZXh0ZW5kIDo6IEV4dGVuZCB3ID0+ICh3IGEgLT4gYiwgdyBhKSAtPiB3IGJcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9leHRlbmRgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvZXh0ZW5kYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogQXJyYXkgYW5kIEZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZXh0ZW5kKHNzID0+IHNzLmpvaW4oJycpLCBbJ3gnLCAneScsICd6J10pXG4gIC8vLiBbJ3h5eicsICd5eicsICd6J11cbiAgLy8uXG4gIC8vLiA+IGV4dGVuZChmID0+IGYoWzMsIDRdKSwgcmV2ZXJzZSkoWzEsIDJdKVxuICAvLy4gWzQsIDMsIDIsIDFdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZXh0ZW5kKGYsIGV4dGVuZF8pIHtcbiAgICByZXR1cm4gRXh0ZW5kLm1ldGhvZHMuZXh0ZW5kKGV4dGVuZF8pKGYpO1xuICB9XG5cbiAgLy8jIGR1cGxpY2F0ZSA6OiBFeHRlbmQgdyA9PiB3IGEgLT4gdyAodyBhKVxuICAvLy5cbiAgLy8uIEFkZHMgb25lIGxldmVsIG9mIG5lc3RpbmcgdG8gYSBjb21vbmFkaWMgc3RydWN0dXJlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgZXh0ZW5kYF0oI2V4dGVuZCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBkdXBsaWNhdGUoSWRlbnRpdHkoMSkpXG4gIC8vLiBJZGVudGl0eShJZGVudGl0eSgxKSlcbiAgLy8uXG4gIC8vLiA+IGR1cGxpY2F0ZShbMV0pXG4gIC8vLiBbWzFdXVxuICAvLy5cbiAgLy8uID4gZHVwbGljYXRlKFsxLCAyLCAzXSlcbiAgLy8uIFtbMSwgMiwgM10sIFsyLCAzXSwgWzNdXVxuICAvLy5cbiAgLy8uID4gZHVwbGljYXRlKHJldmVyc2UpKFsxLCAyXSkoWzMsIDRdKVxuICAvLy4gWzQsIDMsIDIsIDFdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZHVwbGljYXRlKGV4dGVuZF8pIHtcbiAgICByZXR1cm4gZXh0ZW5kKGlkZW50aXR5LCBleHRlbmRfKTtcbiAgfVxuXG4gIC8vIyBleHRyYWN0IDo6IENvbW9uYWQgdyA9PiB3IGEgLT4gYVxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2V4dHJhY3RgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZXh0cmFjdChJZGVudGl0eSg0MikpXG4gIC8vLiA0MlxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGV4dHJhY3QoY29tb25hZCkge1xuICAgIHJldHVybiBDb21vbmFkLm1ldGhvZHMuZXh0cmFjdChjb21vbmFkKSgpO1xuICB9XG5cbiAgLy8jIGNvbnRyYW1hcCA6OiBDb250cmF2YXJpYW50IGYgPT4gKGIgLT4gYSwgZiBhKSAtPiBmIGJcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9jb250cmFtYXBgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvY29udHJhbWFwYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogRnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBjb250cmFtYXAocyA9PiBzLmxlbmd0aCwgTWF0aC5zcXJ0KSgnU2FuY3R1YXJ5JylcbiAgLy8uIDNcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBjb250cmFtYXAoZiwgY29udHJhdmFyaWFudCkge1xuICAgIHJldHVybiBDb250cmF2YXJpYW50Lm1ldGhvZHMuY29udHJhbWFwKGNvbnRyYXZhcmlhbnQpKGYpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBUeXBlQ2xhc3M6IFR5cGVDbGFzcyxcbiAgICBTZXRvaWQ6IFNldG9pZCxcbiAgICBPcmQ6IE9yZCxcbiAgICBTZW1pZ3JvdXBvaWQ6IFNlbWlncm91cG9pZCxcbiAgICBDYXRlZ29yeTogQ2F0ZWdvcnksXG4gICAgU2VtaWdyb3VwOiBTZW1pZ3JvdXAsXG4gICAgTW9ub2lkOiBNb25vaWQsXG4gICAgR3JvdXA6IEdyb3VwLFxuICAgIEZpbHRlcmFibGU6IEZpbHRlcmFibGUsXG4gICAgRnVuY3RvcjogRnVuY3RvcixcbiAgICBCaWZ1bmN0b3I6IEJpZnVuY3RvcixcbiAgICBQcm9mdW5jdG9yOiBQcm9mdW5jdG9yLFxuICAgIEFwcGx5OiBBcHBseSxcbiAgICBBcHBsaWNhdGl2ZTogQXBwbGljYXRpdmUsXG4gICAgQ2hhaW46IENoYWluLFxuICAgIENoYWluUmVjOiBDaGFpblJlYyxcbiAgICBNb25hZDogTW9uYWQsXG4gICAgQWx0OiBBbHQsXG4gICAgUGx1czogUGx1cyxcbiAgICBBbHRlcm5hdGl2ZTogQWx0ZXJuYXRpdmUsXG4gICAgRm9sZGFibGU6IEZvbGRhYmxlLFxuICAgIFRyYXZlcnNhYmxlOiBUcmF2ZXJzYWJsZSxcbiAgICBFeHRlbmQ6IEV4dGVuZCxcbiAgICBDb21vbmFkOiBDb21vbmFkLFxuICAgIENvbnRyYXZhcmlhbnQ6IENvbnRyYXZhcmlhbnQsXG4gICAgdG9TdHJpbmc6IHRvU3RyaW5nLFxuICAgIGVxdWFsczogZXF1YWxzLFxuICAgIGx0OiBsdCxcbiAgICBsdGU6IGx0ZSxcbiAgICBndDogZ3QsXG4gICAgZ3RlOiBndGUsXG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXgsXG4gICAgY29tcG9zZTogY29tcG9zZSxcbiAgICBpZDogaWQsXG4gICAgY29uY2F0OiBjb25jYXQsXG4gICAgZW1wdHk6IGVtcHR5LFxuICAgIGludmVydDogaW52ZXJ0LFxuICAgIGZpbHRlcjogZmlsdGVyLFxuICAgIHJlamVjdDogcmVqZWN0LFxuICAgIG1hcDogbWFwLFxuICAgIGJpbWFwOiBiaW1hcCxcbiAgICBwcm9tYXA6IHByb21hcCxcbiAgICBhcDogYXAsXG4gICAgbGlmdDI6IGxpZnQyLFxuICAgIGxpZnQzOiBsaWZ0MyxcbiAgICBhcEZpcnN0OiBhcEZpcnN0LFxuICAgIGFwU2Vjb25kOiBhcFNlY29uZCxcbiAgICBvZjogb2YsXG4gICAgYXBwZW5kOiBhcHBlbmQsXG4gICAgcHJlcGVuZDogcHJlcGVuZCxcbiAgICBjaGFpbjogY2hhaW4sXG4gICAgam9pbjogam9pbixcbiAgICBjaGFpblJlYzogY2hhaW5SZWMsXG4gICAgYWx0OiBhbHQsXG4gICAgemVybzogemVybyxcbiAgICByZWR1Y2U6IHJlZHVjZSxcbiAgICBzaXplOiBzaXplLFxuICAgIGVsZW06IGVsZW0sXG4gICAgcmV2ZXJzZTogcmV2ZXJzZSxcbiAgICBzb3J0OiBzb3J0LFxuICAgIHNvcnRCeTogc29ydEJ5LFxuICAgIHRha2VXaGlsZTogdGFrZVdoaWxlLFxuICAgIGRyb3BXaGlsZTogZHJvcFdoaWxlLFxuICAgIHRyYXZlcnNlOiB0cmF2ZXJzZSxcbiAgICBzZXF1ZW5jZTogc2VxdWVuY2UsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgZHVwbGljYXRlOiBkdXBsaWNhdGUsXG4gICAgZXh0cmFjdDogZXh0cmFjdCxcbiAgICBjb250cmFtYXA6IGNvbnRyYW1hcFxuICB9O1xuXG59KSk7XG5cbi8vLiBbQWx0XTogICAgICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhbHRcbi8vLiBbQWx0ZXJuYXRpdmVdOiAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhbHRlcm5hdGl2ZVxuLy8uIFtBcHBsaWNhdGl2ZV06ICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FwcGxpY2F0aXZlXG4vLy4gW0FwcGx5XTogICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYXBwbHlcbi8vLiBbQmlmdW5jdG9yXTogICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNiaWZ1bmN0b3Jcbi8vLiBbQ2F0ZWdvcnldOiAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjYXRlZ29yeVxuLy8uIFtDaGFpbl06ICAgICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NoYWluXG4vLy4gW0NoYWluUmVjXTogICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjY2hhaW5yZWNcbi8vLiBbQ29tb25hZF06ICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjb21vbmFkXG4vLy4gW0NvbnRyYXZhcmlhbnRdOiAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjY29udHJhdmFyaWFudFxuLy8uIFtFeHRlbmRdOiAgICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2V4dGVuZFxuLy8uIFtGTF06ICAgICAgICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kXG4vLy4gW0ZpbHRlcmFibGVdOiAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZmlsdGVyYWJsZVxuLy8uIFtGb2xkYWJsZV06ICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2ZvbGRhYmxlXG4vLy4gW0Z1bmN0b3JdOiAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZnVuY3RvclxuLy8uIFtHcm91cF06ICAgICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2dyb3VwXG4vLy4gW01vbmFkXTogICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjbW9uYWRcbi8vLiBbTW9ub2lkXTogICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNtb25vaWRcbi8vLiBbT3JkXTogICAgICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNvcmRcbi8vLiBbUGx1c106ICAgICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNwbHVzXG4vLy4gW1Byb2Z1bmN0b3JdOiAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjcHJvZnVuY3RvclxuLy8uIFtTZW1pZ3JvdXBdOiAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3NlbWlncm91cFxuLy8uIFtTZW1pZ3JvdXBvaWRdOiAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3NlbWlncm91cG9pZFxuLy8uIFtTZXRvaWRdOiAgICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3NldG9pZFxuLy8uIFtUcmF2ZXJzYWJsZV06ICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3RyYXZlcnNhYmxlXG4vLy4gW2BmYW50YXN5LWxhbmQvYWx0YF06ICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYWx0LW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2FwYF06ICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FwLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2JpbWFwYF06ICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2JpbWFwLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2NoYWluYF06ICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NoYWluLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2NoYWluUmVjYF06ICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NoYWlucmVjLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2NvbXBvc2VgXTogICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NvbXBvc2UtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvY29uY2F0YF06ICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjY29uY2F0LW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2NvbnRyYW1hcGBdOiBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NvbnRyYW1hcC1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9lbXB0eWBdOiAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNlbXB0eS1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9lcXVhbHNgXTogICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNlcXVhbHMtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvZXh0ZW5kYF06ICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZXh0ZW5kLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2V4dHJhY3RgXTogICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2V4dHJhY3QtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvZmlsdGVyYF06ICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZmlsdGVyLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2lkYF06ICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2lkLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2ludmVydGBdOiAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2ludmVydC1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9sdGVgXTogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNsdGUtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvbWFwYF06ICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjbWFwLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL29mYF06ICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI29mLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL3Byb21hcGBdOiAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3Byb21hcC1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9yZWR1Y2VgXTogICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNyZWR1Y2UtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvdHJhdmVyc2VgXTogIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjdHJhdmVyc2UtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvemVyb2BdOiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjemVyby1tZXRob2Rcbi8vLiBbc3RhYmxlIHNvcnRdOiAgICAgICAgICAgICAgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU29ydGluZ19hbGdvcml0aG0jU3RhYmlsaXR5XG4vLy4gW3R5cGUtY2xhc3Nlc106ICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW5jdHVhcnktanMvc2FuY3R1YXJ5LWRlZiN0eXBlLWNsYXNzZXNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n        @@@@@@@            @@@@@@@         @@\n      @@       @@        @@       @@      @@@\n    @@   @@@ @@  @@    @@   @@@ @@  @@   @@@@@@ @@   @@@  @@ @@@      @@@@\n   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@   @@\n   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@@@@@@\n   @@  @@   @@@  @@   @@  @@   @@@  @@    @@@   @@   @@@  @@@   @@  @@@\n    @@   @@@ @@@@@     @@   @@@ @@@@@      @@@    @@@ @@  @@@@@@      @@@@@\n      @@                 @@                           @@  @@\n        @@@@@@@            @@@@@@@               @@@@@    @@\n                                                          */\n//. # sanctuary-type-identifiers\n//.\n//. A type is a set of values. Boolean, for example, is the type comprising\n//. `true` and `false`. A value may be a member of multiple types (`42` is a\n//. member of Number, PositiveNumber, Integer, and many other types).\n//.\n//. In certain situations it is useful to divide JavaScript values into\n//. non-overlapping types. The language provides two constructs for this\n//. purpose: the [`typeof`][1] operator and [`Object.prototype.toString`][2].\n//. Each has pros and cons, but neither supports user-defined types.\n//.\n//. This package specifies an [algorithm][3] for deriving a _type identifier_\n//. from any JavaScript value, and exports an implementation of the algorithm.\n//. Authors of algebraic data types may follow this specification in order to\n//. make their data types compatible with the algorithm.\n//.\n//. ### Algorithm\n//.\n//. 1.  Take any JavaScript value `x`.\n//.\n//. 2.  If `x` is `null` or `undefined`, go to step 6.\n//.\n//. 3.  If `x.constructor` evaluates to `null` or `undefined`, go to step 6.\n//.\n//. 4.  If `x.constructor.prototype === x`, go to step 6. This check prevents a\n//.     prototype object from being considered a member of its associated type.\n//.\n//. 5.  If `typeof x.constructor['@@type']` evaluates to `'string'`, return\n//.     the value of `x.constructor['@@type']`.\n//.\n//. 6.  Return the [`Object.prototype.toString`][2] representation of `x`\n//.     without the leading `'[object '` and trailing `']'`.\n//.\n//. ### Compatibility\n//.\n//. For an algebraic data type to be compatible with the [algorithm][3]:\n//.\n//.   - every member of the type must have a `constructor` property pointing\n//.     to an object known as the _type representative_;\n//.\n//.   - the type representative must have a `@@type` property; and\n//.\n//.   - the type representative's `@@type` property (the _type identifier_)\n//.     must be a string primitive, ideally `'<npm-package-name>/<type-name>'`.\n//.\n//. For example:\n//.\n//. ```javascript\n//. //  Identity :: a -> Identity a\n//. function Identity(x) {\n//.   if (!(this instanceof Identity)) return new Identity(x);\n//.   this.value = x;\n//. }\n//.\n//. Identity['@@type'] = 'my-package/Identity';\n//. ```\n//.\n//. Note that by using a constructor function the `constructor` property is set\n//. implicitly for each value created. Constructor functions are convenient for\n//. this reason, but are not required. This definition is also valid:\n//.\n//. ```javascript\n//. //  IdentityTypeRep :: TypeRep Identity\n//. var IdentityTypeRep = {\n//.   '@@type': 'my-package/Identity'\n//. };\n//.\n//. //  Identity :: a -> Identity a\n//. function Identity(x) {\n//.   return {constructor: IdentityTypeRep, value: x};\n//. }\n//. ```\n//.\n//. ### Usage\n//.\n//. ```javascript\n//. var Identity = require('my-package').Identity;\n//. var type = require('sanctuary-type-identifiers');\n//.\n//. type(null);         // => 'Null'\n//. type(true);         // => 'Boolean'\n//. type([1, 2, 3]);    // => 'Array'\n//. type(Identity);     // => 'Function'\n//. type(Identity(0));  // => 'my-package/Identity'\n//. ```\n//.\n//.\n//. [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\n//. [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n//. [3]: #algorithm\n\n(function(f) {\n\n  'use strict';\n\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f();\n  } else if (\"function\" === 'function' && __webpack_require__(0) != null) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {\n    self.sanctuaryTypeIdentifiers = f();\n  }\n\n}(function() {\n\n  'use strict';\n\n  //  $$type :: String\n  var $$type = '@@type';\n\n  //  type :: Any -> String\n  function type(x) {\n    return x != null &&\n           x.constructor != null &&\n           x.constructor.prototype !== x &&\n           typeof x.constructor[$$type] === 'string' ?\n      x.constructor[$$type] :\n      Object.prototype.toString.call(x).slice('[object '.length, -']'.length);\n  }\n\n  return type;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5LXR5cGUtY2xhc3Nlcy9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMvaW5kZXguanM/NmFmYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgICAgICBAQEBAQEBAICAgICAgICAgICAgQEBAQEBAQCAgICAgICAgIEBAXG4gICAgICBAQCAgICAgICBAQCAgICAgICAgQEAgICAgICAgQEAgICAgICBAQEBcbiAgICBAQCAgIEBAQCBAQCAgQEAgICAgQEAgICBAQEAgQEAgIEBAICAgQEBAQEBAIEBAICAgQEBAICBAQCBAQEAgICAgICBAQEBAXG4gICBAQCAgQEAgICBAQEAgICBAQCAgQEAgIEBAICAgQEBAICAgQEAgICBAQEAgICBAQCAgIEBAQCAgQEBAICAgQEAgIEBAQCAgIEBAXG4gICBAQCAgQEAgICBAQEAgICBAQCAgQEAgIEBAICAgQEBAICAgQEAgICBAQEAgICBAQCAgIEBAQCAgQEBAICAgQEAgIEBAQEBAQEBAXG4gICBAQCAgQEAgICBAQEAgIEBAICAgQEAgIEBAICAgQEBAICBAQCAgICBAQEAgICBAQCAgIEBAQCAgQEBAICAgQEAgIEBAQFxuICAgIEBAICAgQEBAIEBAQEBAICAgICBAQCAgIEBAQCBAQEBAQCAgICAgIEBAQCAgICBAQEAgQEAgIEBAQEBAQCAgICAgIEBAQEBAXG4gICAgICBAQCAgICAgICAgICAgICAgICAgQEAgICAgICAgICAgICAgICAgICAgICAgICAgICBAQCAgQEBcbiAgICAgICAgQEBAQEBAQCAgICAgICAgICAgIEBAQEBAQEAgICAgICAgICAgICAgICBAQEBAQCAgICBAQFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vLy4gIyBzYW5jdHVhcnktdHlwZS1pZGVudGlmaWVyc1xuLy8uXG4vLy4gQSB0eXBlIGlzIGEgc2V0IG9mIHZhbHVlcy4gQm9vbGVhbiwgZm9yIGV4YW1wbGUsIGlzIHRoZSB0eXBlIGNvbXByaXNpbmdcbi8vLiBgdHJ1ZWAgYW5kIGBmYWxzZWAuIEEgdmFsdWUgbWF5IGJlIGEgbWVtYmVyIG9mIG11bHRpcGxlIHR5cGVzIChgNDJgIGlzIGFcbi8vLiBtZW1iZXIgb2YgTnVtYmVyLCBQb3NpdGl2ZU51bWJlciwgSW50ZWdlciwgYW5kIG1hbnkgb3RoZXIgdHlwZXMpLlxuLy8uXG4vLy4gSW4gY2VydGFpbiBzaXR1YXRpb25zIGl0IGlzIHVzZWZ1bCB0byBkaXZpZGUgSmF2YVNjcmlwdCB2YWx1ZXMgaW50b1xuLy8uIG5vbi1vdmVybGFwcGluZyB0eXBlcy4gVGhlIGxhbmd1YWdlIHByb3ZpZGVzIHR3byBjb25zdHJ1Y3RzIGZvciB0aGlzXG4vLy4gcHVycG9zZTogdGhlIFtgdHlwZW9mYF1bMV0gb3BlcmF0b3IgYW5kIFtgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2BdWzJdLlxuLy8uIEVhY2ggaGFzIHByb3MgYW5kIGNvbnMsIGJ1dCBuZWl0aGVyIHN1cHBvcnRzIHVzZXItZGVmaW5lZCB0eXBlcy5cbi8vLlxuLy8uIFRoaXMgcGFja2FnZSBzcGVjaWZpZXMgYW4gW2FsZ29yaXRobV1bM10gZm9yIGRlcml2aW5nIGEgX3R5cGUgaWRlbnRpZmllcl9cbi8vLiBmcm9tIGFueSBKYXZhU2NyaXB0IHZhbHVlLCBhbmQgZXhwb3J0cyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYWxnb3JpdGhtLlxuLy8uIEF1dGhvcnMgb2YgYWxnZWJyYWljIGRhdGEgdHlwZXMgbWF5IGZvbGxvdyB0aGlzIHNwZWNpZmljYXRpb24gaW4gb3JkZXIgdG9cbi8vLiBtYWtlIHRoZWlyIGRhdGEgdHlwZXMgY29tcGF0aWJsZSB3aXRoIHRoZSBhbGdvcml0aG0uXG4vLy5cbi8vLiAjIyMgQWxnb3JpdGhtXG4vLy5cbi8vLiAxLiAgVGFrZSBhbnkgSmF2YVNjcmlwdCB2YWx1ZSBgeGAuXG4vLy5cbi8vLiAyLiAgSWYgYHhgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgZ28gdG8gc3RlcCA2LlxuLy8uXG4vLy4gMy4gIElmIGB4LmNvbnN0cnVjdG9yYCBldmFsdWF0ZXMgdG8gYG51bGxgIG9yIGB1bmRlZmluZWRgLCBnbyB0byBzdGVwIDYuXG4vLy5cbi8vLiA0LiAgSWYgYHguY29uc3RydWN0b3IucHJvdG90eXBlID09PSB4YCwgZ28gdG8gc3RlcCA2LiBUaGlzIGNoZWNrIHByZXZlbnRzIGFcbi8vLiAgICAgcHJvdG90eXBlIG9iamVjdCBmcm9tIGJlaW5nIGNvbnNpZGVyZWQgYSBtZW1iZXIgb2YgaXRzIGFzc29jaWF0ZWQgdHlwZS5cbi8vLlxuLy8uIDUuICBJZiBgdHlwZW9mIHguY29uc3RydWN0b3JbJ0BAdHlwZSddYCBldmFsdWF0ZXMgdG8gYCdzdHJpbmcnYCwgcmV0dXJuXG4vLy4gICAgIHRoZSB2YWx1ZSBvZiBgeC5jb25zdHJ1Y3RvclsnQEB0eXBlJ11gLlxuLy8uXG4vLy4gNi4gIFJldHVybiB0aGUgW2BPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYF1bMl0gcmVwcmVzZW50YXRpb24gb2YgYHhgXG4vLy4gICAgIHdpdGhvdXQgdGhlIGxlYWRpbmcgYCdbb2JqZWN0ICdgIGFuZCB0cmFpbGluZyBgJ10nYC5cbi8vLlxuLy8uICMjIyBDb21wYXRpYmlsaXR5XG4vLy5cbi8vLiBGb3IgYW4gYWxnZWJyYWljIGRhdGEgdHlwZSB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlIFthbGdvcml0aG1dWzNdOlxuLy8uXG4vLy4gICAtIGV2ZXJ5IG1lbWJlciBvZiB0aGUgdHlwZSBtdXN0IGhhdmUgYSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHBvaW50aW5nXG4vLy4gICAgIHRvIGFuIG9iamVjdCBrbm93biBhcyB0aGUgX3R5cGUgcmVwcmVzZW50YXRpdmVfO1xuLy8uXG4vLy4gICAtIHRoZSB0eXBlIHJlcHJlc2VudGF0aXZlIG11c3QgaGF2ZSBhIGBAQHR5cGVgIHByb3BlcnR5OyBhbmRcbi8vLlxuLy8uICAgLSB0aGUgdHlwZSByZXByZXNlbnRhdGl2ZSdzIGBAQHR5cGVgIHByb3BlcnR5ICh0aGUgX3R5cGUgaWRlbnRpZmllcl8pXG4vLy4gICAgIG11c3QgYmUgYSBzdHJpbmcgcHJpbWl0aXZlLCBpZGVhbGx5IGAnPG5wbS1wYWNrYWdlLW5hbWU+Lzx0eXBlLW5hbWU+J2AuXG4vLy5cbi8vLiBGb3IgZXhhbXBsZTpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiAvLyAgSWRlbnRpdHkgOjogYSAtPiBJZGVudGl0eSBhXG4vLy4gZnVuY3Rpb24gSWRlbnRpdHkoeCkge1xuLy8uICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIElkZW50aXR5KSkgcmV0dXJuIG5ldyBJZGVudGl0eSh4KTtcbi8vLiAgIHRoaXMudmFsdWUgPSB4O1xuLy8uIH1cbi8vLlxuLy8uIElkZW50aXR5WydAQHR5cGUnXSA9ICdteS1wYWNrYWdlL0lkZW50aXR5Jztcbi8vLiBgYGBcbi8vLlxuLy8uIE5vdGUgdGhhdCBieSB1c2luZyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGlzIHNldFxuLy8uIGltcGxpY2l0bHkgZm9yIGVhY2ggdmFsdWUgY3JlYXRlZC4gQ29uc3RydWN0b3IgZnVuY3Rpb25zIGFyZSBjb252ZW5pZW50IGZvclxuLy8uIHRoaXMgcmVhc29uLCBidXQgYXJlIG5vdCByZXF1aXJlZC4gVGhpcyBkZWZpbml0aW9uIGlzIGFsc28gdmFsaWQ6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gLy8gIElkZW50aXR5VHlwZVJlcCA6OiBUeXBlUmVwIElkZW50aXR5XG4vLy4gdmFyIElkZW50aXR5VHlwZVJlcCA9IHtcbi8vLiAgICdAQHR5cGUnOiAnbXktcGFja2FnZS9JZGVudGl0eSdcbi8vLiB9O1xuLy8uXG4vLy4gLy8gIElkZW50aXR5IDo6IGEgLT4gSWRlbnRpdHkgYVxuLy8uIGZ1bmN0aW9uIElkZW50aXR5KHgpIHtcbi8vLiAgIHJldHVybiB7Y29uc3RydWN0b3I6IElkZW50aXR5VHlwZVJlcCwgdmFsdWU6IHh9O1xuLy8uIH1cbi8vLiBgYGBcbi8vLlxuLy8uICMjIyBVc2FnZVxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIHZhciBJZGVudGl0eSA9IHJlcXVpcmUoJ215LXBhY2thZ2UnKS5JZGVudGl0eTtcbi8vLiB2YXIgdHlwZSA9IHJlcXVpcmUoJ3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzJyk7XG4vLy5cbi8vLiB0eXBlKG51bGwpOyAgICAgICAgIC8vID0+ICdOdWxsJ1xuLy8uIHR5cGUodHJ1ZSk7ICAgICAgICAgLy8gPT4gJ0Jvb2xlYW4nXG4vLy4gdHlwZShbMSwgMiwgM10pOyAgICAvLyA9PiAnQXJyYXknXG4vLy4gdHlwZShJZGVudGl0eSk7ICAgICAvLyA9PiAnRnVuY3Rpb24nXG4vLy4gdHlwZShJZGVudGl0eSgwKSk7ICAvLyA9PiAnbXktcGFja2FnZS9JZGVudGl0eSdcbi8vLiBgYGBcbi8vLlxuLy8uXG4vLy4gWzFdOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvdHlwZW9mXG4vLy4gWzJdOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvdG9TdHJpbmdcbi8vLiBbM106ICNhbGdvcml0aG1cblxuKGZ1bmN0aW9uKGYpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGYoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgIT0gbnVsbCkge1xuICAgIGRlZmluZShbXSwgZik7XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5zYW5jdHVhcnlUeXBlSWRlbnRpZmllcnMgPSBmKCk7XG4gIH1cblxufShmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gICQkdHlwZSA6OiBTdHJpbmdcbiAgdmFyICQkdHlwZSA9ICdAQHR5cGUnO1xuXG4gIC8vICB0eXBlIDo6IEFueSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gdHlwZSh4KSB7XG4gICAgcmV0dXJuIHggIT0gbnVsbCAmJlxuICAgICAgICAgICB4LmNvbnN0cnVjdG9yICE9IG51bGwgJiZcbiAgICAgICAgICAgeC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgIT09IHggJiZcbiAgICAgICAgICAgdHlwZW9mIHguY29uc3RydWN0b3JbJCR0eXBlXSA9PT0gJ3N0cmluZycgP1xuICAgICAgeC5jb25zdHJ1Y3RvclskJHR5cGVdIDpcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KS5zbGljZSgnW29iamVjdCAnLmxlbmd0aCwgLSddJy5sZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIHR5cGU7XG5cbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMvbm9kZV9tb2R1bGVzL3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n             ############                  #\n            ############                  ###\n                  #####                  #####\n                #####      ####################\n              #####       ######################\n            #####                     ###########\n          #####         ######################\n        #####          ####################\n      #####                        #####\n     ############                 ###\n    ############                 */\n\n//. # sanctuary-type-classes\n//.\n//. The [Fantasy Land Specification][FL] \"specifies interoperability of common\n//. algebraic structures\" by defining a number of type classes. For each type\n//. class, it states laws which every member of a type must obey in order for\n//. the type to be a member of the type class. In order for the Maybe type to\n//. be considered a [Functor][], for example, every `Maybe a` value must have\n//. a `fantasy-land/map` method which obeys the identity and composition laws.\n//.\n//. This project provides:\n//.\n//.   - [`TypeClass`](#TypeClass), a function for defining type classes;\n//.   - one `TypeClass` value for each Fantasy Land type class;\n//.   - lawful Fantasy Land methods for JavaScript's built-in types;\n//.   - one function for each Fantasy Land method; and\n//.   - several functions derived from these functions.\n//.\n//. ## Type-class hierarchy\n//.\n/* eslint-disable max-len */\n//. <pre>\n//.  Setoid   Semigroupoid  Semigroup   Foldable        Functor      Contravariant\n//. (equals)    (compose)    (concat)   (reduce)         (map)        (contramap)\n//.     |           |           |           \\         / | | | | \\\n//.     |           |           |            \\       /  | | | |  \\\n//.     |           |           |             \\     /   | | | |   \\\n//.     |           |           |              \\   /    | | | |    \\\n//.     |           |           |               \\ /     | | | |     \\\n//.    Ord      Category     Monoid         Traversable | | | |      \\\n//.   (lte)       (id)       (empty)        (traverse)  / | | \\       \\\n//.                             |                      /  | |  \\       \\\n//.                             |                     /   / \\   \\       \\\n//.                             |             Profunctor /   \\ Bifunctor \\\n//.                             |              (promap) /     \\ (bimap)   \\\n//.                             |                      /       \\           \\\n//.                           Group                   /         \\           \\\n//.                          (invert)               Alt        Apply      Extend\n//.                                                (alt)        (ap)     (extend)\n//.                                                 /           / \\           \\\n//.                                                /           /   \\           \\\n//.                                               /           /     \\           \\\n//.                                              /           /       \\           \\\n//.                                             /           /         \\           \\\n//.                                           Plus    Applicative    Chain      Comonad\n//.                                          (zero)       (of)      (chain)    (extract)\n//.                                             \\         / \\         / \\\n//.                                              \\       /   \\       /   \\\n//.                                               \\     /     \\     /     \\\n//.                                                \\   /       \\   /       \\\n//.                                                 \\ /         \\ /         \\\n//.                                             Alternative    Monad     ChainRec\n//.                                                                     (chainRec)\n//. </pre>\n/* eslint-enable max-len */\n//.\n//. ## API\n\n(function(f) {\n\n  'use strict';\n\n  /* istanbul ignore else */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f(__webpack_require__(14));\n  } else if (\"function\" === 'function' && __webpack_require__(0) != null) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(14)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {\n    self.sanctuaryTypeClasses = f(self.sanctuaryTypeIdentifiers);\n  }\n\n}(function(type) {\n\n  'use strict';\n\n  //  concat_ :: Array a -> Array a -> Array a\n  function concat_(xs) {\n    return function(ys) {\n      return xs.concat(ys);\n    };\n  }\n\n  //  constant :: a -> b -> a\n  function constant(x) {\n    return function(y) {\n      return x;\n    };\n  }\n\n  //  forEachKey :: (StrMap a, StrMap a ~> String -> Undefined) -> Undefined\n  function forEachKey(strMap, f) {\n    Object.keys(strMap).forEach(f, strMap);\n  }\n\n  //  has :: (String, Object) -> Boolean\n  function has(k, o) {\n    return Object.prototype.hasOwnProperty.call(o, k);\n  }\n\n  //  identity :: a -> a\n  function identity(x) { return x; }\n\n  //  pair :: a -> b -> Pair a b\n  function pair(x) {\n    return function(y) {\n      return [x, y];\n    };\n  }\n\n  //  sameType :: (a, b) -> Boolean\n  function sameType(x, y) {\n    return typeof x === typeof y && type(x) === type(y);\n  }\n\n  //  type Iteration a = { value :: a, done :: Boolean }\n\n  //  iterationNext :: a -> Iteration a\n  function iterationNext(x) { return {value: x, done: false}; }\n\n  //  iterationDone :: a -> Iteration a\n  function iterationDone(x) { return {value: x, done: true}; }\n\n  //# TypeClass :: (String, String, Array TypeClass, a -> Boolean) -> TypeClass\n  //.\n  //. The arguments are:\n  //.\n  //.   - the name of the type class, prefixed by its npm package name;\n  //.   - the documentation URL of the type class;\n  //.   - an array of dependencies; and\n  //.   - a predicate which accepts any JavaScript value and returns `true`\n  //.     if the value satisfies the requirements of the type class; `false`\n  //.     otherwise.\n  //.\n  //. Example:\n  //.\n  //. ```javascript\n  //. //    hasMethod :: String -> a -> Boolean\n  //. const hasMethod = name => x => x != null && typeof x[name] == 'function';\n  //.\n  //. //    Foo :: TypeClass\n  //. const Foo = Z.TypeClass(\n  //.   'my-package/Foo',\n  //.   'http://example.com/my-package#Foo',\n  //.   [],\n  //.   hasMethod('foo')\n  //. );\n  //.\n  //. //    Bar :: TypeClass\n  //. const Bar = Z.TypeClass(\n  //.   'my-package/Bar',\n  //.   'http://example.com/my-package#Bar',\n  //.   [Foo],\n  //.   hasMethod('bar')\n  //. );\n  //. ```\n  //.\n  //. Types whose values have a `foo` method are members of the Foo type class.\n  //. Members of the Foo type class whose values have a `bar` method are also\n  //. members of the Bar type class.\n  //.\n  //. Each `TypeClass` value has a `test` field: a function which accepts\n  //. any JavaScript value and returns `true` if the value satisfies the\n  //. type class's predicate and the predicates of all the type class's\n  //. dependencies; `false` otherwise.\n  //.\n  //. `TypeClass` values may be used with [sanctuary-def][type-classes]\n  //. to define parametrically polymorphic functions which verify their\n  //. type-class constraints at run time.\n  function TypeClass(name, url, dependencies, test) {\n    if (!(this instanceof TypeClass)) {\n      return new TypeClass(name, url, dependencies, test);\n    }\n    this.name = name;\n    this.url = url;\n    this.test = function(x) {\n      return dependencies.every(function(d) { return d.test(x); }) && test(x);\n    };\n  }\n\n  TypeClass['@@type'] = 'sanctuary-type-classes/TypeClass';\n\n  //  data Location = Constructor | Value\n\n  //  Constructor :: Location\n  var Constructor = 'Constructor';\n\n  //  Value :: Location\n  var Value = 'Value';\n\n  //  _funcPath :: (Boolean, Array String, a) -> Nullable Function\n  function _funcPath(allowInheritedProps, path, _x) {\n    var x = _x;\n    for (var idx = 0; idx < path.length; idx += 1) {\n      var k = path[idx];\n      if (x == null || !(allowInheritedProps || has(k, x))) return null;\n      x = x[k];\n    }\n    return typeof x === 'function' ? x : null;\n  }\n\n  //  funcPath :: (Array String, a) -> Nullable Function\n  function funcPath(path, x) {\n    return _funcPath(true, path, x);\n  }\n\n  //  implPath :: Array String -> Nullable Function\n  function implPath(path) {\n    return _funcPath(false, path, implementations);\n  }\n\n  //  functionName :: Function -> String\n  var functionName = has('name', function f() {}) ?\n    function functionName(f) { return f.name; } :\n    /* istanbul ignore next */\n    function functionName(f) {\n      var match = /function (\\w*)/.exec(f);\n      return match == null ? '' : match[1];\n    };\n\n  //  $ :: (String, Array TypeClass, StrMap (Array Location)) -> TypeClass\n  function $(_name, dependencies, requirements) {\n    function getBoundMethod(_name) {\n      var name = 'fantasy-land/' + _name;\n      return requirements[_name] === Constructor ?\n        function(typeRep) {\n          var f = funcPath([name], typeRep);\n          return f == null && typeof typeRep === 'function' ?\n            implPath([functionName(typeRep), name]) :\n            f;\n        } :\n        function(x) {\n          var isPrototype = x != null &&\n                            x.constructor != null &&\n                            x.constructor.prototype === x;\n          var m = null;\n          if (!isPrototype) m = funcPath([name], x);\n          if (m == null)    m = implPath([type(x), 'prototype', name]);\n          return m && m.bind(x);\n        };\n    }\n\n    var version = '7.1.1';  // updated programmatically\n    var keys = Object.keys(requirements);\n\n    var typeClass = TypeClass(\n      'sanctuary-type-classes/' + _name,\n      'https://github.com/sanctuary-js/sanctuary-type-classes/tree/v' + version\n        + '#' + _name,\n      dependencies,\n      function(x) {\n        return keys.every(function(_name) {\n          var arg = requirements[_name] === Constructor ? x.constructor : x;\n          return getBoundMethod(_name)(arg) != null;\n        });\n      }\n    );\n\n    typeClass.methods = keys.reduce(function(methods, _name) {\n      methods[_name] = getBoundMethod(_name);\n      return methods;\n    }, {});\n\n    return typeClass;\n  }\n\n  //# Setoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Setoid][].\n  //.\n  //. ```javascript\n  //. > Setoid.test(null)\n  //. true\n  //. ```\n  var Setoid = $('Setoid', [], {equals: Value});\n\n  //# Ord :: TypeClass\n  //.\n  //. `TypeClass` value for [Ord][].\n  //.\n  //. ```javascript\n  //. > Ord.test(0)\n  //. true\n  //.\n  //. > Ord.test(Math.sqrt)\n  //. false\n  //. ```\n  var Ord = $('Ord', [Setoid], {lte: Value});\n\n  //# Semigroupoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Semigroupoid][].\n  //.\n  //. ```javascript\n  //. > Semigroupoid.test(Math.sqrt)\n  //. true\n  //.\n  //. > Semigroupoid.test(0)\n  //. false\n  //. ```\n  var Semigroupoid = $('Semigroupoid', [], {compose: Value});\n\n  //# Category :: TypeClass\n  //.\n  //. `TypeClass` value for [Category][].\n  //.\n  //. ```javascript\n  //. > Category.test(Math.sqrt)\n  //. true\n  //.\n  //. > Category.test(0)\n  //. false\n  //. ```\n  var Category = $('Category', [Semigroupoid], {id: Constructor});\n\n  //# Semigroup :: TypeClass\n  //.\n  //. `TypeClass` value for [Semigroup][].\n  //.\n  //. ```javascript\n  //. > Semigroup.test('')\n  //. true\n  //.\n  //. > Semigroup.test(0)\n  //. false\n  //. ```\n  var Semigroup = $('Semigroup', [], {concat: Value});\n\n  //# Monoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Monoid][].\n  //.\n  //. ```javascript\n  //. > Monoid.test('')\n  //. true\n  //.\n  //. > Monoid.test(0)\n  //. false\n  //. ```\n  var Monoid = $('Monoid', [Semigroup], {empty: Constructor});\n\n  //# Group :: TypeClass\n  //.\n  //. `TypeClass` value for [Group][].\n  //.\n  //. ```javascript\n  //. > Group.test(Sum(0))\n  //. true\n  //.\n  //. > Group.test('')\n  //. false\n  //. ```\n  var Group = $('Group', [Monoid], {invert: Value});\n\n  //# Functor :: TypeClass\n  //.\n  //. `TypeClass` value for [Functor][].\n  //.\n  //. ```javascript\n  //. > Functor.test([])\n  //. true\n  //.\n  //. > Functor.test('')\n  //. false\n  //. ```\n  var Functor = $('Functor', [], {map: Value});\n\n  //# Bifunctor :: TypeClass\n  //.\n  //. `TypeClass` value for [Bifunctor][].\n  //.\n  //. ```javascript\n  //. > Bifunctor.test(Tuple('foo', 64))\n  //. true\n  //.\n  //. > Bifunctor.test([])\n  //. false\n  //. ```\n  var Bifunctor = $('Bifunctor', [Functor], {bimap: Value});\n\n  //# Profunctor :: TypeClass\n  //.\n  //. `TypeClass` value for [Profunctor][].\n  //.\n  //. ```javascript\n  //. > Profunctor.test(Math.sqrt)\n  //. true\n  //.\n  //. > Profunctor.test([])\n  //. false\n  //. ```\n  var Profunctor = $('Profunctor', [Functor], {promap: Value});\n\n  //# Apply :: TypeClass\n  //.\n  //. `TypeClass` value for [Apply][].\n  //.\n  //. ```javascript\n  //. > Apply.test([])\n  //. true\n  //.\n  //. > Apply.test('')\n  //. false\n  //. ```\n  var Apply = $('Apply', [Functor], {ap: Value});\n\n  //# Applicative :: TypeClass\n  //.\n  //. `TypeClass` value for [Applicative][].\n  //.\n  //. ```javascript\n  //. > Applicative.test([])\n  //. true\n  //.\n  //. > Applicative.test({})\n  //. false\n  //. ```\n  var Applicative = $('Applicative', [Apply], {of: Constructor});\n\n  //# Chain :: TypeClass\n  //.\n  //. `TypeClass` value for [Chain][].\n  //.\n  //. ```javascript\n  //. > Chain.test([])\n  //. true\n  //.\n  //. > Chain.test({})\n  //. false\n  //. ```\n  var Chain = $('Chain', [Apply], {chain: Value});\n\n  //# ChainRec :: TypeClass\n  //.\n  //. `TypeClass` value for [ChainRec][].\n  //.\n  //. ```javascript\n  //. > ChainRec.test([])\n  //. true\n  //.\n  //. > ChainRec.test({})\n  //. false\n  //. ```\n  var ChainRec = $('ChainRec', [Chain], {chainRec: Constructor});\n\n  //# Monad :: TypeClass\n  //.\n  //. `TypeClass` value for [Monad][].\n  //.\n  //. ```javascript\n  //. > Monad.test([])\n  //. true\n  //.\n  //. > Monad.test({})\n  //. false\n  //. ```\n  var Monad = $('Monad', [Applicative, Chain], {});\n\n  //# Alt :: TypeClass\n  //.\n  //. `TypeClass` value for [Alt][].\n  //.\n  //. ```javascript\n  //. > Alt.test({})\n  //. true\n  //.\n  //. > Alt.test('')\n  //. false\n  //. ```\n  var Alt = $('Alt', [Functor], {alt: Value});\n\n  //# Plus :: TypeClass\n  //.\n  //. `TypeClass` value for [Plus][].\n  //.\n  //. ```javascript\n  //. > Plus.test({})\n  //. true\n  //.\n  //. > Plus.test('')\n  //. false\n  //. ```\n  var Plus = $('Plus', [Alt], {zero: Constructor});\n\n  //# Alternative :: TypeClass\n  //.\n  //. `TypeClass` value for [Alternative][].\n  //.\n  //. ```javascript\n  //. > Alternative.test([])\n  //. true\n  //.\n  //. > Alternative.test({})\n  //. false\n  //. ```\n  var Alternative = $('Alternative', [Applicative, Plus], {});\n\n  //# Foldable :: TypeClass\n  //.\n  //. `TypeClass` value for [Foldable][].\n  //.\n  //. ```javascript\n  //. > Foldable.test({})\n  //. true\n  //.\n  //. > Foldable.test('')\n  //. false\n  //. ```\n  var Foldable = $('Foldable', [], {reduce: Value});\n\n  //# Traversable :: TypeClass\n  //.\n  //. `TypeClass` value for [Traversable][].\n  //.\n  //. ```javascript\n  //. > Traversable.test([])\n  //. true\n  //.\n  //. > Traversable.test('')\n  //. false\n  //. ```\n  var Traversable = $('Traversable', [Functor, Foldable], {traverse: Value});\n\n  //# Extend :: TypeClass\n  //.\n  //. `TypeClass` value for [Extend][].\n  //.\n  //. ```javascript\n  //. > Extend.test([])\n  //. true\n  //.\n  //. > Extend.test({})\n  //. false\n  //. ```\n  var Extend = $('Extend', [Functor], {extend: Value});\n\n  //# Comonad :: TypeClass\n  //.\n  //. `TypeClass` value for [Comonad][].\n  //.\n  //. ```javascript\n  //. > Comonad.test(Identity(0))\n  //. true\n  //.\n  //. > Comonad.test([])\n  //. false\n  //. ```\n  var Comonad = $('Comonad', [Extend], {extract: Value});\n\n  //# Contravariant :: TypeClass\n  //.\n  //. `TypeClass` value for [Contravariant][].\n  //.\n  //. ```javascript\n  //. > Contravariant.test(Math.sqrt)\n  //. true\n  //.\n  //. > Contravariant.test([])\n  //. false\n  //. ```\n  var Contravariant = $('Contravariant', [], {contramap: Value});\n\n  //  Null$prototype$toString :: Null ~> () -> String\n  function Null$prototype$toString() {\n    return 'null';\n  }\n\n  //  Null$prototype$equals :: Null ~> Null -> Boolean\n  function Null$prototype$equals(other) {\n    return true;\n  }\n\n  //  Null$prototype$lte :: Null ~> Null -> Boolean\n  function Null$prototype$lte(other) {\n    return true;\n  }\n\n  //  Undefined$prototype$toString :: Undefined ~> () -> String\n  function Undefined$prototype$toString() {\n    return 'undefined';\n  }\n\n  //  Undefined$prototype$equals :: Undefined ~> Undefined -> Boolean\n  function Undefined$prototype$equals(other) {\n    return true;\n  }\n\n  //  Undefined$prototype$lte :: Undefined ~> Undefined -> Boolean\n  function Undefined$prototype$lte(other) {\n    return true;\n  }\n\n  //  Boolean$prototype$toString :: Boolean ~> () -> String\n  function Boolean$prototype$toString() {\n    return typeof this === 'object' ?\n      'new Boolean(' + toString(this.valueOf()) + ')' :\n      this.toString();\n  }\n\n  //  Boolean$prototype$equals :: Boolean ~> Boolean -> Boolean\n  function Boolean$prototype$equals(other) {\n    return typeof this === 'object' ?\n      equals(this.valueOf(), other.valueOf()) :\n      this === other;\n  }\n\n  //  Boolean$prototype$lte :: Boolean ~> Boolean -> Boolean\n  function Boolean$prototype$lte(other) {\n    return typeof this === 'object' ?\n      lte(this.valueOf(), other.valueOf()) :\n      this === false || other === true;\n  }\n\n  //  Number$prototype$toString :: Number ~> () -> String\n  function Number$prototype$toString() {\n    return typeof this === 'object' ?\n      'new Number(' + toString(this.valueOf()) + ')' :\n      1 / this === -Infinity ? '-0' : this.toString(10);\n  }\n\n  //  Number$prototype$equals :: Number ~> Number -> Boolean\n  function Number$prototype$equals(other) {\n    return typeof this === 'object' ?\n      equals(this.valueOf(), other.valueOf()) :\n      isNaN(this) && isNaN(other) || this === other;\n  }\n\n  //  Number$prototype$lte :: Number ~> Number -> Boolean\n  function Number$prototype$lte(other) {\n    return typeof this === 'object' ?\n      lte(this.valueOf(), other.valueOf()) :\n      isNaN(this) && isNaN(other) || this <= other;\n  }\n\n  //  Date$prototype$toString :: Date ~> () -> String\n  function Date$prototype$toString() {\n    var x = isNaN(this.valueOf()) ? NaN : this.toISOString();\n    return 'new Date(' + toString(x) + ')';\n  }\n\n  //  Date$prototype$equals :: Date ~> Date -> Boolean\n  function Date$prototype$equals(other) {\n    return equals(this.valueOf(), other.valueOf());\n  }\n\n  //  Date$prototype$lte :: Date ~> Date -> Boolean\n  function Date$prototype$lte(other) {\n    return lte(this.valueOf(), other.valueOf());\n  }\n\n  //  RegExp$prototype$equals :: RegExp ~> RegExp -> Boolean\n  function RegExp$prototype$equals(other) {\n    return other.source === this.source &&\n           other.global === this.global &&\n           other.ignoreCase === this.ignoreCase &&\n           other.multiline === this.multiline &&\n           other.sticky === this.sticky &&\n           other.unicode === this.unicode;\n  }\n\n  //  String$empty :: () -> String\n  function String$empty() {\n    return '';\n  }\n\n  //  String$prototype$toString :: String ~> () -> String\n  function String$prototype$toString() {\n    return typeof this === 'object' ?\n      'new String(' + toString(this.valueOf()) + ')' :\n      JSON.stringify(this);\n  }\n\n  //  String$prototype$equals :: String ~> String -> Boolean\n  function String$prototype$equals(other) {\n    return typeof this === 'object' ?\n      equals(this.valueOf(), other.valueOf()) :\n      this === other;\n  }\n\n  //  String$prototype$lte :: String ~> String -> Boolean\n  function String$prototype$lte(other) {\n    return typeof this === 'object' ?\n      lte(this.valueOf(), other.valueOf()) :\n      this <= other;\n  }\n\n  //  String$prototype$concat :: String ~> String -> String\n  function String$prototype$concat(other) {\n    return this + other;\n  }\n\n  //  Array$empty :: () -> Array a\n  function Array$empty() {\n    return [];\n  }\n\n  //  Array$of :: a -> Array a\n  function Array$of(x) {\n    return [x];\n  }\n\n  //  Array$chainRec :: ((a -> c, b -> c, a) -> Array c, a) -> Array b\n  function Array$chainRec(f, x) {\n    var $todo = [x];\n    var $done = [];\n    while ($todo.length > 0) {\n      var xs = f(iterationNext, iterationDone, $todo.shift());\n      var $more = [];\n      for (var idx = 0; idx < xs.length; idx += 1) {\n        (xs[idx].done ? $done : $more).push(xs[idx].value);\n      }\n      Array.prototype.unshift.apply($todo, $more);\n    }\n    return $done;\n  }\n\n  //  Array$zero :: () -> Array a\n  function Array$zero() {\n    return [];\n  }\n\n  //  Array$prototype$toString :: Array a ~> () -> String\n  function Array$prototype$toString() {\n    var reprs = this.map(toString);\n    var keys = Object.keys(this).sort();\n    for (var idx = 0; idx < keys.length; idx += 1) {\n      var k = keys[idx];\n      if (!/^\\d+$/.test(k)) {\n        reprs.push(toString(k) + ': ' + toString(this[k]));\n      }\n    }\n    return '[' + reprs.join(', ') + ']';\n  }\n\n  //  Array$prototype$equals :: Array a ~> Array a -> Boolean\n  function Array$prototype$equals(other) {\n    if (other.length !== this.length) return false;\n    for (var idx = 0; idx < this.length; idx += 1) {\n      if (!equals(this[idx], other[idx])) return false;\n    }\n    return true;\n  }\n\n  //  Array$prototype$lte :: Array a ~> Array a -> Boolean\n  function Array$prototype$lte(other) {\n    for (var idx = 0; true; idx += 1) {\n      if (idx === this.length) return true;\n      if (idx === other.length) return false;\n      if (!equals(this[idx], other[idx])) return lte(this[idx], other[idx]);\n    }\n  }\n\n  //  Array$prototype$concat :: Array a ~> Array a -> Array a\n  function Array$prototype$concat(other) {\n    return this.concat(other);\n  }\n\n  //  Array$prototype$map :: Array a ~> (a -> b) -> Array b\n  function Array$prototype$map(f) {\n    return this.map(function(x) { return f(x); });\n  }\n\n  //  Array$prototype$ap :: Array a ~> Array (a -> b) -> Array b\n  function Array$prototype$ap(fs) {\n    var result = [];\n    for (var idx = 0; idx < fs.length; idx += 1) {\n      for (var idx2 = 0; idx2 < this.length; idx2 += 1) {\n        result.push(fs[idx](this[idx2]));\n      }\n    }\n    return result;\n  }\n\n  //  Array$prototype$chain :: Array a ~> (a -> Array b) -> Array b\n  function Array$prototype$chain(f) {\n    var result = [];\n    this.forEach(function(x) { Array.prototype.push.apply(result, f(x)); });\n    return result;\n  }\n\n  //  Array$prototype$alt :: Array a ~> Array a -> Array a\n  var Array$prototype$alt = Array$prototype$concat;\n\n  //  Array$prototype$reduce :: Array a ~> ((b, a) -> b, b) -> b\n  function Array$prototype$reduce(f, initial) {\n    return this.reduce(function(acc, x) { return f(acc, x); }, initial);\n  }\n\n  //  Array$prototype$traverse :: Applicative f => Array a ~> (TypeRep f, a -> f b) -> f (Array b)\n  function Array$prototype$traverse(typeRep, f) {\n    var xs = this;\n    function go(idx, n) {\n      switch (n) {\n        case 0: return of(typeRep, []);\n        case 2: return lift2(pair, f(xs[idx]), f(xs[idx + 1]));\n        default:\n          var m = Math.floor(n / 4) * 2;\n          return lift2(concat_, go(idx, m), go(idx + m, n - m));\n      }\n    }\n    return this.length % 2 === 1 ?\n      lift2(concat_, map(Array$of, f(this[0])), go(1, this.length - 1)) :\n      go(0, this.length);\n  }\n\n  //  Array$prototype$extend :: Array a ~> (Array a -> b) -> Array b\n  function Array$prototype$extend(f) {\n    return this.map(function(_, idx, xs) { return f(xs.slice(idx)); });\n  }\n\n  //  Arguments$prototype$toString :: Arguments ~> String\n  function Arguments$prototype$toString() {\n    var args = Array.prototype.map.call(this, toString).join(', ');\n    return '(function () { return arguments; }(' + args + '))';\n  }\n\n  //  Arguments$prototype$equals :: Arguments ~> Arguments -> Boolean\n  function Arguments$prototype$equals(other) {\n    return Array$prototype$equals.call(this, other);\n  }\n\n  //  Arguments$prototype$lte :: Arguments ~> Arguments -> Boolean\n  function Arguments$prototype$lte(other) {\n    return Array$prototype$lte.call(this, other);\n  }\n\n  //  Error$prototype$toString :: Error ~> () -> String\n  function Error$prototype$toString() {\n    return 'new ' + this.name + '(' + toString(this.message) + ')';\n  }\n\n  //  Error$prototype$equals :: Error ~> Error -> Boolean\n  function Error$prototype$equals(other) {\n    return equals(this.name, other.name) &&\n           equals(this.message, other.message);\n  }\n\n  //  Object$empty :: () -> StrMap a\n  function Object$empty() {\n    return {};\n  }\n\n  //  Object$zero :: () -> StrMap a\n  function Object$zero() {\n    return {};\n  }\n\n  //  Object$prototype$toString :: StrMap a ~> () -> String\n  function Object$prototype$toString() {\n    var reprs = [];\n    var keys = Object.keys(this).sort();\n    for (var idx = 0; idx < keys.length; idx += 1) {\n      var k = keys[idx];\n      reprs.push(toString(k) + ': ' + toString(this[k]));\n    }\n    return '{' + reprs.join(', ') + '}';\n  }\n\n  //  Object$prototype$equals :: StrMap a ~> StrMap a -> Boolean\n  function Object$prototype$equals(other) {\n    var self = this;\n    var keys = Object.keys(this).sort();\n    return equals(keys, Object.keys(other).sort()) &&\n           keys.every(function(k) { return equals(self[k], other[k]); });\n  }\n\n  //  Object$prototype$lte :: StrMap a ~> StrMap a -> Boolean\n  function Object$prototype$lte(other) {\n    var theseKeys = Object.keys(this).sort();\n    var otherKeys = Object.keys(other).sort();\n    while (true) {\n      if (theseKeys.length === 0) return true;\n      if (otherKeys.length === 0) return false;\n      var k = theseKeys.shift();\n      var z = otherKeys.shift();\n      if (k < z) return true;\n      if (k > z) return false;\n      if (!equals(this[k], other[k])) return lte(this[k], other[k]);\n    }\n  }\n\n  //  Object$prototype$concat :: StrMap a ~> StrMap a -> StrMap a\n  function Object$prototype$concat(other) {\n    var result = {};\n    function assign(k) { result[k] = this[k]; }\n    forEachKey(this, assign);\n    forEachKey(other, assign);\n    return result;\n  }\n\n  //  Object$prototype$map :: StrMap a ~> (a -> b) -> StrMap b\n  function Object$prototype$map(f) {\n    var result = {};\n    forEachKey(this, function(k) { result[k] = f(this[k]); });\n    return result;\n  }\n\n  //  Object$prototype$ap :: StrMap a ~> StrMap (a -> b) -> StrMap b\n  function Object$prototype$ap(other) {\n    var result = {};\n    forEachKey(this, function(k) {\n      if (has(k, other)) result[k] = other[k](this[k]);\n    });\n    return result;\n  }\n\n  //  Object$prototype$alt :: StrMap a ~> StrMap a -> StrMap a\n  var Object$prototype$alt = Object$prototype$concat;\n\n  //  Object$prototype$reduce :: StrMap a ~> ((b, a) -> b, b) -> b\n  function Object$prototype$reduce(f, initial) {\n    var self = this;\n    function reducer(acc, k) { return f(acc, self[k]); }\n    return Object.keys(this).sort().reduce(reducer, initial);\n  }\n\n  //  Object$prototype$traverse :: Applicative f => StrMap a ~> (TypeRep f, a -> f b) -> f (StrMap b)\n  function Object$prototype$traverse(typeRep, f) {\n    var self = this;\n    return Object.keys(this).reduce(function(applicative, k) {\n      function set(o) {\n        return function(v) {\n          var singleton = {}; singleton[k] = v;\n          return Object$prototype$concat.call(o, singleton);\n        };\n      }\n      return lift2(set, applicative, f(self[k]));\n    }, of(typeRep, {}));\n  }\n\n  //  Function$id :: () -> a -> a\n  function Function$id() {\n    return identity;\n  }\n\n  //  Function$of :: b -> (a -> b)\n  function Function$of(x) {\n    return function(_) { return x; };\n  }\n\n  //  Function$chainRec :: ((a -> c, b -> c, a) -> (z -> c), a) -> (z -> b)\n  function Function$chainRec(f, x) {\n    return function(a) {\n      var step = iterationNext(x);\n      while (!step.done) {\n        step = f(iterationNext, iterationDone, step.value)(a);\n      }\n      return step.value;\n    };\n  }\n\n  //  Function$prototype$equals :: Function ~> Function -> Boolean\n  function Function$prototype$equals(other) {\n    return other === this;\n  }\n\n  //  Function$prototype$compose :: (a -> b) ~> (b -> c) -> (a -> c)\n  function Function$prototype$compose(other) {\n    var semigroupoid = this;\n    return function(x) { return other(semigroupoid(x)); };\n  }\n\n  //  Function$prototype$map :: (a -> b) ~> (b -> c) -> (a -> c)\n  function Function$prototype$map(f) {\n    var functor = this;\n    return function(x) { return f(functor(x)); };\n  }\n\n  //  Function$prototype$promap :: (b -> c) ~> (a -> b, c -> d) -> (a -> d)\n  function Function$prototype$promap(f, g) {\n    var profunctor = this;\n    return function(x) { return g(profunctor(f(x))); };\n  }\n\n  //  Function$prototype$ap :: (a -> b) ~> (a -> b -> c) -> (a -> c)\n  function Function$prototype$ap(f) {\n    var apply = this;\n    return function(x) { return f(x)(apply(x)); };\n  }\n\n  //  Function$prototype$chain :: (a -> b) ~> (b -> a -> c) -> (a -> c)\n  function Function$prototype$chain(f) {\n    var chain = this;\n    return function(x) { return f(chain(x))(x); };\n  }\n\n  //  Function$prototype$contramap :: (b -> c) ~> (a -> b) -> (a -> c)\n  function Function$prototype$contramap(f) {\n    var contravariant = this;\n    return function(x) { return contravariant(f(x)); };\n  }\n\n  /* eslint-disable key-spacing */\n  var implementations = {\n    Null: {\n      prototype: {\n        toString:                   Null$prototype$toString,\n        'fantasy-land/equals':      Null$prototype$equals,\n        'fantasy-land/lte':         Null$prototype$lte\n      }\n    },\n    Undefined: {\n      prototype: {\n        toString:                   Undefined$prototype$toString,\n        'fantasy-land/equals':      Undefined$prototype$equals,\n        'fantasy-land/lte':         Undefined$prototype$lte\n      }\n    },\n    Boolean: {\n      prototype: {\n        toString:                   Boolean$prototype$toString,\n        'fantasy-land/equals':      Boolean$prototype$equals,\n        'fantasy-land/lte':         Boolean$prototype$lte\n      }\n    },\n    Number: {\n      prototype: {\n        toString:                   Number$prototype$toString,\n        'fantasy-land/equals':      Number$prototype$equals,\n        'fantasy-land/lte':         Number$prototype$lte\n      }\n    },\n    Date: {\n      prototype: {\n        toString:                   Date$prototype$toString,\n        'fantasy-land/equals':      Date$prototype$equals,\n        'fantasy-land/lte':         Date$prototype$lte\n      }\n    },\n    RegExp: {\n      prototype: {\n        'fantasy-land/equals':      RegExp$prototype$equals\n      }\n    },\n    String: {\n      'fantasy-land/empty':         String$empty,\n      prototype: {\n        toString:                   String$prototype$toString,\n        'fantasy-land/equals':      String$prototype$equals,\n        'fantasy-land/lte':         String$prototype$lte,\n        'fantasy-land/concat':      String$prototype$concat\n      }\n    },\n    Array: {\n      'fantasy-land/empty':         Array$empty,\n      'fantasy-land/of':            Array$of,\n      'fantasy-land/chainRec':      Array$chainRec,\n      'fantasy-land/zero':          Array$zero,\n      prototype: {\n        toString:                   Array$prototype$toString,\n        'fantasy-land/equals':      Array$prototype$equals,\n        'fantasy-land/lte':         Array$prototype$lte,\n        'fantasy-land/concat':      Array$prototype$concat,\n        'fantasy-land/map':         Array$prototype$map,\n        'fantasy-land/ap':          Array$prototype$ap,\n        'fantasy-land/chain':       Array$prototype$chain,\n        'fantasy-land/alt':         Array$prototype$alt,\n        'fantasy-land/reduce':      Array$prototype$reduce,\n        'fantasy-land/traverse':    Array$prototype$traverse,\n        'fantasy-land/extend':      Array$prototype$extend\n      }\n    },\n    Arguments: {\n      prototype: {\n        toString:                   Arguments$prototype$toString,\n        'fantasy-land/equals':      Arguments$prototype$equals,\n        'fantasy-land/lte':         Arguments$prototype$lte\n      }\n    },\n    Error: {\n      prototype: {\n        toString:                   Error$prototype$toString,\n        'fantasy-land/equals':      Error$prototype$equals\n      }\n    },\n    Object: {\n      'fantasy-land/empty':         Object$empty,\n      'fantasy-land/zero':          Object$zero,\n      prototype: {\n        toString:                   Object$prototype$toString,\n        'fantasy-land/equals':      Object$prototype$equals,\n        'fantasy-land/lte':         Object$prototype$lte,\n        'fantasy-land/concat':      Object$prototype$concat,\n        'fantasy-land/map':         Object$prototype$map,\n        'fantasy-land/ap':          Object$prototype$ap,\n        'fantasy-land/alt':         Object$prototype$alt,\n        'fantasy-land/reduce':      Object$prototype$reduce,\n        'fantasy-land/traverse':    Object$prototype$traverse\n      }\n    },\n    Function: {\n      'fantasy-land/id':            Function$id,\n      'fantasy-land/of':            Function$of,\n      'fantasy-land/chainRec':      Function$chainRec,\n      prototype: {\n        'fantasy-land/equals':      Function$prototype$equals,\n        'fantasy-land/compose':     Function$prototype$compose,\n        'fantasy-land/map':         Function$prototype$map,\n        'fantasy-land/promap':      Function$prototype$promap,\n        'fantasy-land/ap':          Function$prototype$ap,\n        'fantasy-land/chain':       Function$prototype$chain,\n        'fantasy-land/contramap':   Function$prototype$contramap\n      }\n    }\n  };\n  /* eslint-enable key-spacing */\n\n  //# toString :: a -> String\n  //.\n  //. Returns a useful string representation of its argument.\n  //.\n  //. Dispatches to the argument's `toString` method if appropriate.\n  //.\n  //. Where practical, `equals(eval(toString(x)), x) = true`.\n  //.\n  //. `toString` implementations are provided for the following built-in types:\n  //. Null, Undefined, Boolean, Number, Date, String, Array, Arguments, Error,\n  //. and Object.\n  //.\n  //. ```javascript\n  //. > toString(-0)\n  //. '-0'\n  //.\n  //. > toString(['foo', 'bar', 'baz'])\n  //. '[\"foo\", \"bar\", \"baz\"]'\n  //.\n  //. > toString({x: 1, y: 2, z: 3})\n  //. '{\"x\": 1, \"y\": 2, \"z\": 3}'\n  //.\n  //. > toString(Cons(1, Cons(2, Cons(3, Nil))))\n  //. 'Cons(1, Cons(2, Cons(3, Nil)))'\n  //. ```\n  var toString = (function() {\n    //  $seen :: Array Any\n    var $seen = [];\n\n    function call(method, x) {\n      $seen.push(x);\n      try { return method.call(x); } finally { $seen.pop(); }\n    }\n\n    return function toString(x) {\n      if ($seen.indexOf(x) >= 0) return '<Circular>';\n\n      var xType = type(x);\n      if (xType === 'Object') {\n        var result;\n        try { result = call(x.toString, x); } catch (err) {}\n        if (result != null && result !== '[object Object]') return result;\n      }\n\n      return call(implPath([xType, 'prototype', 'toString']) || x.toString, x);\n    };\n  }());\n\n  //# equals :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and equal according\n  //. to the type's [`fantasy-land/equals`][] method; `false` otherwise.\n  //.\n  //. `fantasy-land/equals` implementations are provided for the following\n  //. built-in types: Null, Undefined, Boolean, Number, Date, RegExp, String,\n  //. Array, Arguments, Error, Object, and Function.\n  //.\n  //. The algorithm supports circular data structures. Two arrays are equal\n  //. if they have the same index paths and for each path have equal values.\n  //. Two arrays which represent `[1, [1, [1, [1, [1, ...]]]]]`, for example,\n  //. are equal even if their internal structures differ. Two objects are equal\n  //. if they have the same property paths and for each path have equal values.\n  //.\n  //. ```javascript\n  //. > equals(0, -0)\n  //. true\n  //.\n  //. > equals(NaN, NaN)\n  //. true\n  //.\n  //. > equals(Cons('foo', Cons('bar', Nil)), Cons('foo', Cons('bar', Nil)))\n  //. true\n  //.\n  //. > equals(Cons('foo', Cons('bar', Nil)), Cons('bar', Cons('foo', Nil)))\n  //. false\n  //. ```\n  var equals = (function() {\n    //  $pairs :: Array (Pair Any Any)\n    var $pairs = [];\n\n    return function equals(x, y) {\n      if (!sameType(x, y)) return false;\n\n      //  This algorithm for comparing circular data structures was\n      //  suggested in <http://stackoverflow.com/a/40622794/312785>.\n      if ($pairs.some(function(p) { return p[0] === x && p[1] === y; })) {\n        return true;\n      }\n\n      $pairs.push([x, y]);\n      try {\n        return Setoid.test(x) && Setoid.test(y) && Setoid.methods.equals(x)(y);\n      } finally {\n        $pairs.pop();\n      }\n    };\n  }());\n\n  //# lt :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first is\n  //. less than the second according to the type's [`fantasy-land/lte`][]\n  //. method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`gt`](#gt) and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > lt(0, 0)\n  //. false\n  //.\n  //. > lt(0, 1)\n  //. true\n  //.\n  //. > lt(1, 0)\n  //. false\n  //. ```\n  function lt(x, y) {\n    return sameType(x, y) && !lte(y, x);\n  }\n\n  //# lte :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first\n  //. is less than or equal to the second according to the type's\n  //. [`fantasy-land/lte`][] method; `false` otherwise.\n  //.\n  //. `fantasy-land/lte` implementations are provided for the following\n  //. built-in types: Null, Undefined, Boolean, Number, Date, String, Array,\n  //. Arguments, and Object.\n  //.\n  //. The algorithm supports circular data structures in the same manner as\n  //. [`equals`](#equals).\n  //.\n  //. See also [`lt`](#lt), [`gt`](#gt), and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > lte(0, 0)\n  //. true\n  //.\n  //. > lte(0, 1)\n  //. true\n  //.\n  //. > lte(1, 0)\n  //. false\n  //. ```\n  var lte = (function() {\n    //  $pairs :: Array (Pair Any Any)\n    var $pairs = [];\n\n    return function lte(x, y) {\n      if (!sameType(x, y)) return false;\n\n      //  This algorithm for comparing circular data structures was\n      //  suggested in <http://stackoverflow.com/a/40622794/312785>.\n      if ($pairs.some(function(p) { return p[0] === x && p[1] === y; })) {\n        return equals(x, y);\n      }\n\n      $pairs.push([x, y]);\n      try {\n        return Ord.test(x) && Ord.test(y) && Ord.methods.lte(x)(y);\n      } finally {\n        $pairs.pop();\n      }\n    };\n  }());\n\n  //# gt :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first is\n  //. greater than the second according to the type's [`fantasy-land/lte`][]\n  //. method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`lt`](#lt) and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > gt(0, 0)\n  //. false\n  //.\n  //. > gt(0, 1)\n  //. false\n  //.\n  //. > gt(1, 0)\n  //. true\n  //. ```\n  function gt(x, y) {\n    return lt(y, x);\n  }\n\n  //# gte :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first\n  //. is greater than or equal to the second according to the type's\n  //. [`fantasy-land/lte`][] method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`lt`](#lt) and [`gt`](#gt).\n  //.\n  //. ```javascript\n  //. > gte(0, 0)\n  //. true\n  //.\n  //. > gte(0, 1)\n  //. false\n  //.\n  //. > gte(1, 0)\n  //. true\n  //. ```\n  function gte(x, y) {\n    return lte(y, x);\n  }\n\n  //# min :: Ord a => (a, a) -> a\n  //.\n  //. Returns the smaller of its two arguments.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`max`](#max).\n  //.\n  //. ```javascript\n  //. > min(10, 2)\n  //. 2\n  //.\n  //. > min(new Date('1999-12-31'), new Date('2000-01-01'))\n  //. new Date('1999-12-31')\n  //.\n  //. > min('10', '2')\n  //. '10'\n  //. ```\n  function min(x, y) {\n    return lte(x, y) ? x : y;\n  }\n\n  //# max :: Ord a => (a, a) -> a\n  //.\n  //. Returns the larger of its two arguments.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`min`](#min).\n  //.\n  //. ```javascript\n  //. > max(10, 2)\n  //. 10\n  //.\n  //. > max(new Date('1999-12-31'), new Date('2000-01-01'))\n  //. new Date('2000-01-01')\n  //.\n  //. > max('10', '2')\n  //. '2'\n  //. ```\n  function max(x, y) {\n    return lte(x, y) ? y : x;\n  }\n\n  //# compose :: Semigroupoid c => (c j k, c i j) -> c i k\n  //.\n  //. Function wrapper for [`fantasy-land/compose`][].\n  //.\n  //. `fantasy-land/compose` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > compose(Math.sqrt, x => x + 1)(99)\n  //. 10\n  //. ```\n  function compose(x, y) {\n    return Semigroupoid.methods.compose(y)(x);\n  }\n\n  //# id :: Category c => TypeRep c -> c\n  //.\n  //. Function wrapper for [`fantasy-land/id`][].\n  //.\n  //. `fantasy-land/id` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > id(Function)('foo')\n  //. 'foo'\n  //. ```\n  function id(typeRep) {\n    return Category.methods.id(typeRep)();\n  }\n\n  //# concat :: Semigroup a => (a, a) -> a\n  //.\n  //. Function wrapper for [`fantasy-land/concat`][].\n  //.\n  //. `fantasy-land/concat` implementations are provided for the following\n  //. built-in types: String, Array, and Object.\n  //.\n  //. ```javascript\n  //. > concat('abc', 'def')\n  //. 'abcdef'\n  //.\n  //. > concat([1, 2, 3], [4, 5, 6])\n  //. [1, 2, 3, 4, 5, 6]\n  //.\n  //. > concat({x: 1, y: 2}, {y: 3, z: 4})\n  //. {x: 1, y: 3, z: 4}\n  //.\n  //. > concat(Cons('foo', Cons('bar', Cons('baz', Nil))), Cons('quux', Nil))\n  //. Cons('foo', Cons('bar', Cons('baz', Cons('quux', Nil))))\n  //. ```\n  function concat(x, y) {\n    return Semigroup.methods.concat(x)(y);\n  }\n\n  //# empty :: Monoid m => TypeRep m -> m\n  //.\n  //. Function wrapper for [`fantasy-land/empty`][].\n  //.\n  //. `fantasy-land/empty` implementations are provided for the following\n  //. built-in types: String, Array, and Object.\n  //.\n  //. ```javascript\n  //. > empty(String)\n  //. ''\n  //.\n  //. > empty(Array)\n  //. []\n  //.\n  //. > empty(Object)\n  //. {}\n  //.\n  //. > empty(List)\n  //. Nil\n  //. ```\n  function empty(typeRep) {\n    return Monoid.methods.empty(typeRep)();\n  }\n\n  //# invert :: Group g => g -> g\n  //.\n  //. Function wrapper for [`fantasy-land/invert`][].\n  //.\n  //. ```javascript\n  //. invert(Sum(5))\n  //. Sum(-5)\n  //. ```\n  function invert(group) {\n    return Group.methods.invert(group)();\n  }\n\n  //# map :: Functor f => (a -> b, f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/map`][].\n  //.\n  //. `fantasy-land/map` implementations are provided for the following\n  //. built-in types: Array, Object, and Function.\n  //.\n  //. ```javascript\n  //. > map(Math.sqrt, [1, 4, 9])\n  //. [1, 2, 3]\n  //.\n  //. > map(Math.sqrt, {x: 1, y: 4, z: 9})\n  //. {x: 1, y: 2, z: 3}\n  //.\n  //. > map(Math.sqrt, s => s.length)('Sanctuary')\n  //. 3\n  //.\n  //. > map(Math.sqrt, Tuple('foo', 64))\n  //. Tuple('foo', 8)\n  //.\n  //. > map(Math.sqrt, Nil)\n  //. Nil\n  //.\n  //. > map(Math.sqrt, Cons(1, Cons(4, Cons(9, Nil))))\n  //. Cons(1, Cons(2, Cons(3, Nil)))\n  //. ```\n  function map(f, functor) {\n    return Functor.methods.map(functor)(f);\n  }\n\n  //# bimap :: Bifunctor f => (a -> b, c -> d, f a c) -> f b d\n  //.\n  //. Function wrapper for [`fantasy-land/bimap`][].\n  //.\n  //. ```javascript\n  //. > bimap(s => s.toUpperCase(), Math.sqrt, Tuple('foo', 64))\n  //. Tuple('FOO', 8)\n  //. ```\n  function bimap(f, g, bifunctor) {\n    return Bifunctor.methods.bimap(bifunctor)(f, g);\n  }\n\n  //# promap :: Profunctor p => (a -> b, c -> d, p b c) -> p a d\n  //.\n  //. Function wrapper for [`fantasy-land/promap`][].\n  //.\n  //. `fantasy-land/promap` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > promap(Math.abs, x => x + 1, Math.sqrt)(-100)\n  //. 11\n  //. ```\n  function promap(f, g, profunctor) {\n    return Profunctor.methods.promap(profunctor)(f, g);\n  }\n\n  //# ap :: Apply f => (f (a -> b), f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/ap`][].\n  //.\n  //. `fantasy-land/ap` implementations are provided for the following\n  //. built-in types: Array, Object, and Function.\n  //.\n  //. ```javascript\n  //. > ap([Math.sqrt, x => x * x], [1, 4, 9, 16, 25])\n  //. [1, 2, 3, 4, 5, 1, 16, 81, 256, 625]\n  //.\n  //. > ap({a: Math.sqrt, b: x => x * x}, {a: 16, b: 10, c: 1})\n  //. {a: 4, b: 100}\n  //.\n  //. > ap(s => n => s.slice(0, n), s => Math.ceil(s.length / 2))('Haskell')\n  //. 'Hask'\n  //.\n  //. > ap(Identity(Math.sqrt), Identity(64))\n  //. Identity(8)\n  //.\n  //. > ap(Cons(Math.sqrt, Cons(x => x * x, Nil)), Cons(16, Cons(100, Nil)))\n  //. Cons(4, Cons(10, Cons(256, Cons(10000, Nil))))\n  //. ```\n  function ap(applyF, applyX) {\n    return Apply.methods.ap(applyX)(applyF);\n  }\n\n  //# lift2 :: Apply f => (a -> b -> c, f a, f b) -> f c\n  //.\n  //. Lifts `a -> b -> c` to `Apply f => f a -> f b -> f c` and returns the\n  //. result of applying this to the given arguments.\n  //.\n  //. This function is derived from [`map`](#map) and [`ap`](#ap).\n  //.\n  //. See also [`lift3`](#lift3).\n  //.\n  //. ```javascript\n  //. > lift2(x => y => Math.pow(x, y), [10], [1, 2, 3])\n  //. [10, 100, 1000]\n  //.\n  //. > lift2(x => y => Math.pow(x, y), Identity(10), Identity(3))\n  //. Identity(1000)\n  //. ```\n  function lift2(f, x, y) {\n    return ap(map(f, x), y);\n  }\n\n  //# lift3 :: Apply f => (a -> b -> c -> d, f a, f b, f c) -> f d\n  //.\n  //. Lifts `a -> b -> c -> d` to `Apply f => f a -> f b -> f c -> f d` and\n  //. returns the result of applying this to the given arguments.\n  //.\n  //. This function is derived from [`map`](#map) and [`ap`](#ap).\n  //.\n  //. See also [`lift2`](#lift2).\n  //.\n  //. ```javascript\n  //. > lift3(x => y => z => x + z + y, ['<'], ['>'], ['foo', 'bar', 'baz'])\n  //. ['<foo>', '<bar>', '<baz>']\n  //.\n  //. > lift3(x => y => z => x + z + y, Identity('<'), Identity('>'), Identity('baz'))\n  //. Identity('<baz>')\n  //. ```\n  function lift3(f, x, y, z) {\n    return ap(ap(map(f, x), y), z);\n  }\n\n  //# apFirst :: Apply f => (f a, f b) -> f a\n  //.\n  //. Combines two effectful actions, keeping only the result of the first.\n  //. Equivalent to Haskell's `(<*)` function.\n  //.\n  //. This function is derived from [`lift2`](#lift2).\n  //.\n  //. See also [`apSecond`](#apSecond).\n  //.\n  //. ```javascript\n  //. > apFirst([1, 2], [3, 4])\n  //. [1, 1, 2, 2]\n  //.\n  //. > apFirst(Identity(1), Identity(2))\n  //. Identity(1)\n  //. ```\n  function apFirst(x, y) {\n    return lift2(constant, x, y);\n  }\n\n  //# apSecond :: Apply f => (f a, f b) -> f b\n  //.\n  //. Combines two effectful actions, keeping only the result of the second.\n  //. Equivalent to Haskell's `(*>)` function.\n  //.\n  //. This function is derived from [`lift2`](#lift2).\n  //.\n  //. See also [`apFirst`](#apFirst).\n  //.\n  //. ```javascript\n  //. > apSecond([1, 2], [3, 4])\n  //. [3, 4, 3, 4]\n  //.\n  //. > apSecond(Identity(1), Identity(2))\n  //. Identity(2)\n  //. ```\n  function apSecond(x, y) {\n    return lift2(constant(identity), x, y);\n  }\n\n  //# of :: Applicative f => (TypeRep f, a) -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/of`][].\n  //.\n  //. `fantasy-land/of` implementations are provided for the following\n  //. built-in types: Array and Function.\n  //.\n  //. ```javascript\n  //. > of(Array, 42)\n  //. [42]\n  //.\n  //. > of(Function, 42)(null)\n  //. 42\n  //.\n  //. > of(List, 42)\n  //. Cons(42, Nil)\n  //. ```\n  function of(typeRep, x) {\n    return Applicative.methods.of(typeRep)(x);\n  }\n\n  //# append :: (Applicative f, Semigroup (f a)) => (a, f a) -> f a\n  //.\n  //. Returns the result of appending the first argument to the second.\n  //.\n  //. This function is derived from [`concat`](#concat) and [`of`](#of).\n  //.\n  //. See also [`prepend`](#prepend).\n  //.\n  //. ```javascript\n  //. > append(3, [1, 2])\n  //. [1, 2, 3]\n  //.\n  //. > append(3, Cons(1, Cons(2, Nil)))\n  //. Cons(1, Cons(2, Cons(3, Nil)))\n  //. ```\n  function append(x, xs) {\n    return concat(xs, of(xs.constructor, x));\n  }\n\n  //# prepend :: (Applicative f, Semigroup (f a)) => (a, f a) -> f a\n  //.\n  //. Returns the result of prepending the first argument to the second.\n  //.\n  //. This function is derived from [`concat`](#concat) and [`of`](#of).\n  //.\n  //. See also [`append`](#append).\n  //.\n  //. ```javascript\n  //. > prepend(1, [2, 3])\n  //. [1, 2, 3]\n  //.\n  //. > prepend(1, Cons(2, Cons(3, Nil)))\n  //. Cons(1, Cons(2, Cons(3, Nil)))\n  //. ```\n  function prepend(x, xs) {\n    return concat(of(xs.constructor, x), xs);\n  }\n\n  //# chain :: Chain m => (a -> m b, m a) -> m b\n  //.\n  //. Function wrapper for [`fantasy-land/chain`][].\n  //.\n  //. `fantasy-land/chain` implementations are provided for the following\n  //. built-in types: Array and Function.\n  //.\n  //. ```javascript\n  //. > chain(x => [x, x], [1, 2, 3])\n  //. [1, 1, 2, 2, 3, 3]\n  //.\n  //. > chain(x => x % 2 == 1 ? of(List, x) : Nil, Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(1, Cons(3, Nil))\n  //.\n  //. > chain(n => s => s.slice(0, n), s => Math.ceil(s.length / 2))('Haskell')\n  //. 'Hask'\n  //. ```\n  function chain(f, chain_) {\n    return Chain.methods.chain(chain_)(f);\n  }\n\n  //# join :: Chain m => m (m a) -> m a\n  //.\n  //. Removes one level of nesting from a nested monadic structure.\n  //.\n  //. This function is derived from [`chain`](#chain).\n  //.\n  //. ```javascript\n  //. > join([[1], [2], [3]])\n  //. [1, 2, 3]\n  //.\n  //. > join([[[1, 2, 3]]])\n  //. [[1, 2, 3]]\n  //.\n  //. > join(Identity(Identity(1)))\n  //. Identity(1)\n  //. ```\n  function join(chain_) {\n    return chain(identity, chain_);\n  }\n\n  //# chainRec :: ChainRec m => (TypeRep m, (a -> c, b -> c, a) -> m c, a) -> m b\n  //.\n  //. Function wrapper for [`fantasy-land/chainRec`][].\n  //.\n  //. `fantasy-land/chainRec` implementations are provided for the following\n  //. built-in types: Array.\n  //.\n  //. ```javascript\n  //. > chainRec(\n  //. .   Array,\n  //. .   (next, done, s) => s.length == 2 ? [s + '!', s + '?'].map(done)\n  //. .                                    : [s + 'o', s + 'n'].map(next),\n  //. .   ''\n  //. . )\n  //. ['oo!', 'oo?', 'on!', 'on?', 'no!', 'no?', 'nn!', 'nn?']\n  //. ```\n  function chainRec(typeRep, f, x) {\n    return ChainRec.methods.chainRec(typeRep)(f, x);\n  }\n\n  //# filter :: (Applicative f, Foldable f, Monoid (f a)) => (a -> Boolean, f a) -> f a\n  //.\n  //. Filters its second argument in accordance with the given predicate.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`filterM`](#filterM).\n  //.\n  //. ```javascript\n  //. > filter(x => x % 2 == 1, [1, 2, 3])\n  //. [1, 3]\n  //.\n  //. > filter(x => x % 2 == 1, Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(1, Cons(3, Nil))\n  //. ```\n  function filter(pred, m) {\n    //  Fast path for arrays.\n    if (Array.isArray(m)) return m.filter(function(x) { return pred(x); });\n    var M = m.constructor;\n    return reduce(function(m, x) { return pred(x) ? concat(m, of(M, x)) : m; },\n                  empty(M),\n                  m);\n  }\n\n  //# filterM :: (Alternative m, Monad m) => (a -> Boolean, m a) -> m a\n  //.\n  //. Filters its second argument in accordance with the given predicate.\n  //.\n  //. This function is derived from [`of`](#of), [`chain`](#chain), and\n  //. [`zero`](#zero).\n  //.\n  //. See also [`filter`](#filter).\n  //.\n  //. ```javascript\n  //. > filterM(x => x % 2 == 1, [1, 2, 3])\n  //. [1, 3]\n  //.\n  //. > filterM(x => x % 2 == 1, Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(1, Cons(3, Nil))\n  //.\n  //. > filterM(x => x % 2 == 1, Nothing)\n  //. Nothing\n  //.\n  //. > filterM(x => x % 2 == 1, Just(0))\n  //. Nothing\n  //.\n  //. > filterM(x => x % 2 == 1, Just(1))\n  //. Just(1)\n  //. ```\n  function filterM(pred, m) {\n    var M = m.constructor;\n    var z = zero(M);\n    return chain(function(x) { return pred(x) ? of(M, x) : z; }, m);\n  }\n\n  //# alt :: Alt f => (f a, f a) -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/alt`][].\n  //.\n  //. `fantasy-land/alt` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > alt([1, 2, 3], [4, 5, 6])\n  //. [1, 2, 3, 4, 5, 6]\n  //.\n  //. > alt(Nothing, Nothing)\n  //. Nothing\n  //.\n  //. > alt(Nothing, Just(1))\n  //. Just(1)\n  //.\n  //. > alt(Just(2), Just(3))\n  //. Just(2)\n  //. ```\n  function alt(x, y) {\n    return Alt.methods.alt(x)(y);\n  }\n\n  //# zero :: Plus f => TypeRep f -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/zero`][].\n  //.\n  //. `fantasy-land/zero` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > zero(Array)\n  //. []\n  //.\n  //. > zero(Object)\n  //. {}\n  //.\n  //. > zero(Maybe)\n  //. Nothing\n  //. ```\n  function zero(typeRep) {\n    return Plus.methods.zero(typeRep)();\n  }\n\n  //# reduce :: Foldable f => ((b, a) -> b, b, f a) -> b\n  //.\n  //. Function wrapper for [`fantasy-land/reduce`][].\n  //.\n  //. `fantasy-land/reduce` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > reduce((xs, x) => [x].concat(xs), [], [1, 2, 3])\n  //. [3, 2, 1]\n  //.\n  //. > reduce(concat, '', Cons('foo', Cons('bar', Cons('baz', Nil))))\n  //. 'foobarbaz'\n  //. ```\n  function reduce(f, x, foldable) {\n    return Foldable.methods.reduce(foldable)(f, x);\n  }\n\n  //# size :: Foldable f => f a -> Integer\n  //.\n  //. Returns the number of elements of the given structure.\n  //.\n  //. This function is derived from [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > size([])\n  //. 0\n  //.\n  //. > size(['foo', 'bar', 'baz'])\n  //. 3\n  //.\n  //. > size(Nil)\n  //. 0\n  //.\n  //. > size(Cons('foo', Cons('bar', Cons('baz', Nil))))\n  //. 3\n  //. ```\n  function size(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray(foldable)) return foldable.length;\n    return reduce(function(n, _) { return n + 1; }, 0, foldable);\n  }\n\n  //# elem :: (Setoid a, Foldable f) => (a, f a) -> Boolean\n  //.\n  //. Takes a value and a structure and returns `true` if the\n  //. value is an element of the structure; `false` otherwise.\n  //.\n  //. This function is derived from [`equals`](#equals) and\n  //. [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > elem('c', ['a', 'b', 'c'])\n  //. true\n  //.\n  //. > elem('x', ['a', 'b', 'c'])\n  //. false\n  //.\n  //. > elem(3, {x: 1, y: 2, z: 3})\n  //. true\n  //.\n  //. > elem(8, {x: 1, y: 2, z: 3})\n  //. false\n  //.\n  //. > elem(0, Just(0))\n  //. true\n  //.\n  //. > elem(0, Just(1))\n  //. false\n  //.\n  //. > elem(0, Nothing)\n  //. false\n  //. ```\n  function elem(x, foldable) {\n    return reduce(function(b, y) { return b || equals(x, y); },\n                  false,\n                  foldable);\n  }\n\n  //# reverse :: (Applicative f, Foldable f, Monoid (f a)) => f a -> f a\n  //.\n  //. Reverses the elements of the given structure.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > reverse([1, 2, 3])\n  //. [3, 2, 1]\n  //.\n  //. > reverse(Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(3, Cons(2, Cons(1, Nil)))\n  //. ```\n  function reverse(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray(foldable)) return foldable.slice().reverse();\n    var F = foldable.constructor;\n    return reduce(function(xs, x) { return concat(of(F, x), xs); },\n                  empty(F),\n                  foldable);\n  }\n\n  //# sort :: (Ord a, Applicative f, Foldable f, Monoid (f a)) => f a -> f a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure,\n  //. using [`lte`](#lte) for comparisons.\n  //.\n  //. This function is derived from [`lte`](#lte), [`concat`](#concat),\n  //. [`empty`](#empty), [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`sortBy`](#sortBy).\n  //.\n  //. ```javascript\n  //. > sort(['foo', 'bar', 'baz'])\n  //. ['bar', 'baz', 'foo']\n  //.\n  //. > sort([Just(2), Nothing, Just(1)])\n  //. [Nothing, Just(1), Just(2)]\n  //.\n  //. > sort(Cons('foo', Cons('bar', Cons('baz', Nil))))\n  //. Cons('bar', Cons('baz', Cons('foo', Nil)))\n  //. ```\n  function sort(foldable) {\n    return sortBy(identity, foldable);\n  }\n\n  //# sortBy :: (Ord b, Applicative f, Foldable f, Monoid (f a)) => (a -> b, f a) -> f a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure,\n  //. using [`lte`](#lte) to compare the values produced by applying the\n  //. given function to each element of the structure.\n  //.\n  //. This function is derived from [`lte`](#lte), [`concat`](#concat),\n  //. [`empty`](#empty), [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`sort`](#sort).\n  //.\n  //. ```javascript\n  //. > sortBy(s => s.length, ['red', 'green', 'blue'])\n  //. ['red', 'blue', 'green']\n  //.\n  //. > sortBy(s => s.length, ['black', 'white'])\n  //. ['black', 'white']\n  //.\n  //. > sortBy(s => s.length, ['white', 'black'])\n  //. ['white', 'black']\n  //.\n  //. > sortBy(s => s.length, Cons('red', Cons('green', Cons('blue', Nil))))\n  //. Cons('red', Cons('blue', Cons('green', Nil)))\n  //. ```\n  function sortBy(f, foldable) {\n    var rs = reduce(function(xs, x) {\n      var fx = f(x);\n      var lower = 0;\n      var upper = xs.length;\n      while (lower < upper) {\n        var idx = Math.floor((lower + upper) / 2);\n        if (lte(xs[idx].fx, fx)) lower = idx + 1; else upper = idx;\n      }\n      xs.splice(lower, 0, {x: x, fx: fx});\n      return xs;\n    }, [], foldable);\n\n    var F = foldable.constructor;\n    var result = empty(F);\n    for (var idx = 0; idx < rs.length; idx += 1) {\n      result = concat(result, of(F, rs[idx].x));\n    }\n    return result;\n  }\n\n  //# takeWhile :: (Applicative f, Foldable f, Monoid (f a)) => (a -> Boolean, f a) -> f a\n  //.\n  //. Discards the first inner value which does not satisfy the predicate, and\n  //. all subsequent inner values.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`dropWhile`](#dropWhile).\n  //.\n  //. ```javascript\n  //. > takeWhile(s => /x/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xy', 'xz', 'yx']\n  //.\n  //. > takeWhile(s => /y/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xy']\n  //.\n  //. > takeWhile(s => /z/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. []\n  //. ```\n  function takeWhile(pred, foldable) {\n    var take = true;\n    return filter(function(x) { return take = take && pred(x); }, foldable);\n  }\n\n  //# dropWhile :: (Applicative f, Foldable f, Monoid (f a)) => (a -> Boolean, f a) -> f a\n  //.\n  //. Retains the first inner value which does not satisfy the predicate, and\n  //. all subsequent inner values.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`takeWhile`](#takeWhile).\n  //.\n  //. ```javascript\n  //. > dropWhile(s => /x/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['yz', 'zx', 'zy']\n  //.\n  //. > dropWhile(s => /y/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xz', 'yx', 'yz', 'zx', 'zy']\n  //.\n  //. > dropWhile(s => /z/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xy', 'xz', 'yx', 'yz', 'zx', 'zy']\n  //. ```\n  function dropWhile(pred, foldable) {\n    var take = false;\n    return filter(function(x) { return take = take || !pred(x); }, foldable);\n  }\n\n  //# traverse :: (Applicative f, Traversable t) => (TypeRep f, a -> f b, t a) -> f (t b)\n  //.\n  //. Function wrapper for [`fantasy-land/traverse`][].\n  //.\n  //. `fantasy-land/traverse` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. See also [`sequence`](#sequence).\n  //.\n  //. ```javascript\n  //. > traverse(Array, x => x, [[1, 2, 3], [4, 5]])\n  //. [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]\n  //.\n  //. > traverse(Identity, x => Identity(x + 1), [1, 2, 3])\n  //. Identity([2, 3, 4])\n  //. ```\n  function traverse(typeRep, f, traversable) {\n    return Traversable.methods.traverse(traversable)(typeRep, f);\n  }\n\n  //# sequence :: (Applicative f, Traversable t) => (TypeRep f, t (f a)) -> f (t a)\n  //.\n  //. Inverts the given `t (f a)` to produce an `f (t a)`.\n  //.\n  //. This function is derived from [`traverse`](#traverse).\n  //.\n  //. ```javascript\n  //. > sequence(Array, Identity([1, 2, 3]))\n  //. [Identity(1), Identity(2), Identity(3)]\n  //.\n  //. > sequence(Identity, [Identity(1), Identity(2), Identity(3)])\n  //. Identity([1, 2, 3])\n  //. ```\n  function sequence(typeRep, traversable) {\n    return traverse(typeRep, identity, traversable);\n  }\n\n  //# extend :: Extend w => (w a -> b, w a) -> w b\n  //.\n  //. Function wrapper for [`fantasy-land/extend`][].\n  //.\n  //. `fantasy-land/extend` implementations are provided for the following\n  //. built-in types: Array.\n  //.\n  //. ```javascript\n  //. > extend(ss => ss.join(''), ['x', 'y', 'z'])\n  //. ['xyz', 'yz', 'z']\n  //. ```\n  function extend(f, extend_) {\n    return Extend.methods.extend(extend_)(f);\n  }\n\n  //# extract :: Comonad w => w a -> a\n  //.\n  //. Function wrapper for [`fantasy-land/extract`][].\n  //.\n  //. ```javascript\n  //. > extract(Identity(42))\n  //. 42\n  //. ```\n  function extract(comonad) {\n    return Comonad.methods.extract(comonad)();\n  }\n\n  //# contramap :: Contravariant f => (b -> a, f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/contramap`][].\n  //.\n  //. `fantasy-land/contramap` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > contramap(s => s.length, Math.sqrt)('Sanctuary')\n  //. 3\n  //. ```\n  function contramap(f, contravariant) {\n    return Contravariant.methods.contramap(contravariant)(f);\n  }\n\n  return {\n    TypeClass: TypeClass,\n    Setoid: Setoid,\n    Ord: Ord,\n    Semigroupoid: Semigroupoid,\n    Category: Category,\n    Semigroup: Semigroup,\n    Monoid: Monoid,\n    Group: Group,\n    Functor: Functor,\n    Bifunctor: Bifunctor,\n    Profunctor: Profunctor,\n    Apply: Apply,\n    Applicative: Applicative,\n    Chain: Chain,\n    ChainRec: ChainRec,\n    Monad: Monad,\n    Alt: Alt,\n    Plus: Plus,\n    Alternative: Alternative,\n    Foldable: Foldable,\n    Traversable: Traversable,\n    Extend: Extend,\n    Comonad: Comonad,\n    Contravariant: Contravariant,\n    toString: toString,\n    equals: equals,\n    lt: lt,\n    lte: lte,\n    gt: gt,\n    gte: gte,\n    min: min,\n    max: max,\n    compose: compose,\n    id: id,\n    concat: concat,\n    empty: empty,\n    invert: invert,\n    map: map,\n    bimap: bimap,\n    promap: promap,\n    ap: ap,\n    lift2: lift2,\n    lift3: lift3,\n    apFirst: apFirst,\n    apSecond: apSecond,\n    of: of,\n    append: append,\n    prepend: prepend,\n    chain: chain,\n    join: join,\n    chainRec: chainRec,\n    filter: filter,\n    filterM: filterM,\n    alt: alt,\n    zero: zero,\n    reduce: reduce,\n    size: size,\n    elem: elem,\n    reverse: reverse,\n    sort: sort,\n    sortBy: sortBy,\n    takeWhile: takeWhile,\n    dropWhile: dropWhile,\n    traverse: traverse,\n    sequence: sequence,\n    extend: extend,\n    extract: extract,\n    contramap: contramap\n  };\n\n}));\n\n//. [Alt]:                      https://github.com/fantasyland/fantasy-land#alt\n//. [Alternative]:              https://github.com/fantasyland/fantasy-land#alternative\n//. [Applicative]:              https://github.com/fantasyland/fantasy-land#applicative\n//. [Apply]:                    https://github.com/fantasyland/fantasy-land#apply\n//. [Bifunctor]:                https://github.com/fantasyland/fantasy-land#bifunctor\n//. [Category]:                 https://github.com/fantasyland/fantasy-land#category\n//. [Chain]:                    https://github.com/fantasyland/fantasy-land#chain\n//. [ChainRec]:                 https://github.com/fantasyland/fantasy-land#chainrec\n//. [Comonad]:                  https://github.com/fantasyland/fantasy-land#comonad\n//. [Contravariant]:            https://github.com/fantasyland/fantasy-land#contravariant\n//. [Extend]:                   https://github.com/fantasyland/fantasy-land#extend\n//. [FL]:                       https://github.com/fantasyland/fantasy-land\n//. [Foldable]:                 https://github.com/fantasyland/fantasy-land#foldable\n//. [Functor]:                  https://github.com/fantasyland/fantasy-land#functor\n//. [Group]:                    https://github.com/fantasyland/fantasy-land#group\n//. [Monad]:                    https://github.com/fantasyland/fantasy-land#monad\n//. [Monoid]:                   https://github.com/fantasyland/fantasy-land#monoid\n//. [Ord]:                      https://github.com/fantasyland/fantasy-land#ord\n//. [Plus]:                     https://github.com/fantasyland/fantasy-land#plus\n//. [Profunctor]:               https://github.com/fantasyland/fantasy-land#profunctor\n//. [Semigroup]:                https://github.com/fantasyland/fantasy-land#semigroup\n//. [Semigroupoid]:             https://github.com/fantasyland/fantasy-land#semigroupoid\n//. [Setoid]:                   https://github.com/fantasyland/fantasy-land#setoid\n//. [Traversable]:              https://github.com/fantasyland/fantasy-land#traversable\n//. [`fantasy-land/alt`]:       https://github.com/fantasyland/fantasy-land#alt-method\n//. [`fantasy-land/ap`]:        https://github.com/fantasyland/fantasy-land#ap-method\n//. [`fantasy-land/bimap`]:     https://github.com/fantasyland/fantasy-land#bimap-method\n//. [`fantasy-land/chain`]:     https://github.com/fantasyland/fantasy-land#chain-method\n//. [`fantasy-land/chainRec`]:  https://github.com/fantasyland/fantasy-land#chainrec-method\n//. [`fantasy-land/compose`]:   https://github.com/fantasyland/fantasy-land#compose-method\n//. [`fantasy-land/concat`]:    https://github.com/fantasyland/fantasy-land#concat-method\n//. [`fantasy-land/contramap`]: https://github.com/fantasyland/fantasy-land#contramap-method\n//. [`fantasy-land/empty`]:     https://github.com/fantasyland/fantasy-land#empty-method\n//. [`fantasy-land/equals`]:    https://github.com/fantasyland/fantasy-land#equals-method\n//. [`fantasy-land/extend`]:    https://github.com/fantasyland/fantasy-land#extend-method\n//. [`fantasy-land/extract`]:   https://github.com/fantasyland/fantasy-land#extract-method\n//. [`fantasy-land/id`]:        https://github.com/fantasyland/fantasy-land#id-method\n//. [`fantasy-land/invert`]:    https://github.com/fantasyland/fantasy-land#invert-method\n//. [`fantasy-land/lte`]:       https://github.com/fantasyland/fantasy-land#lte-method\n//. [`fantasy-land/map`]:       https://github.com/fantasyland/fantasy-land#map-method\n//. [`fantasy-land/of`]:        https://github.com/fantasyland/fantasy-land#of-method\n//. [`fantasy-land/promap`]:    https://github.com/fantasyland/fantasy-land#promap-method\n//. [`fantasy-land/reduce`]:    https://github.com/fantasyland/fantasy-land#reduce-method\n//. [`fantasy-land/traverse`]:  https://github.com/fantasyland/fantasy-land#traverse-method\n//. [`fantasy-land/zero`]:      https://github.com/fantasyland/fantasy-land#zero-method\n//. [stable sort]:              https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\n//. [type-classes]:             https://github.com/sanctuary-js/sanctuary-def#type-classes\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5LWRlZi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5LXR5cGUtY2xhc3Nlcy9pbmRleC5qcz81Nzg5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgICAgICAgICAgIyMjIyMjIyMjIyMjICAgICAgICAgICAgICAgICAgI1xuICAgICAgICAgICAgIyMjIyMjIyMjIyMjICAgICAgICAgICAgICAgICAgIyMjXG4gICAgICAgICAgICAgICAgICAjIyMjIyAgICAgICAgICAgICAgICAgICMjIyMjXG4gICAgICAgICAgICAgICAgIyMjIyMgICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjI1xuICAgICAgICAgICAgICAjIyMjIyAgICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gICAgICAgICAgICAjIyMjIyAgICAgICAgICAgICAgICAgICAgICMjIyMjIyMjIyMjXG4gICAgICAgICAgIyMjIyMgICAgICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gICAgICAgICMjIyMjICAgICAgICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gICAgICAjIyMjIyAgICAgICAgICAgICAgICAgICAgICAgICMjIyMjXG4gICAgICMjIyMjIyMjIyMjIyAgICAgICAgICAgICAgICAgIyMjXG4gICAgIyMjIyMjIyMjIyMjICAgICAgICAgICAgICAgICAqL1xuXG4vLy4gIyBzYW5jdHVhcnktdHlwZS1jbGFzc2VzXG4vLy5cbi8vLiBUaGUgW0ZhbnRhc3kgTGFuZCBTcGVjaWZpY2F0aW9uXVtGTF0gXCJzcGVjaWZpZXMgaW50ZXJvcGVyYWJpbGl0eSBvZiBjb21tb25cbi8vLiBhbGdlYnJhaWMgc3RydWN0dXJlc1wiIGJ5IGRlZmluaW5nIGEgbnVtYmVyIG9mIHR5cGUgY2xhc3Nlcy4gRm9yIGVhY2ggdHlwZVxuLy8uIGNsYXNzLCBpdCBzdGF0ZXMgbGF3cyB3aGljaCBldmVyeSBtZW1iZXIgb2YgYSB0eXBlIG11c3Qgb2JleSBpbiBvcmRlciBmb3Jcbi8vLiB0aGUgdHlwZSB0byBiZSBhIG1lbWJlciBvZiB0aGUgdHlwZSBjbGFzcy4gSW4gb3JkZXIgZm9yIHRoZSBNYXliZSB0eXBlIHRvXG4vLy4gYmUgY29uc2lkZXJlZCBhIFtGdW5jdG9yXVtdLCBmb3IgZXhhbXBsZSwgZXZlcnkgYE1heWJlIGFgIHZhbHVlIG11c3QgaGF2ZVxuLy8uIGEgYGZhbnRhc3ktbGFuZC9tYXBgIG1ldGhvZCB3aGljaCBvYmV5cyB0aGUgaWRlbnRpdHkgYW5kIGNvbXBvc2l0aW9uIGxhd3MuXG4vLy5cbi8vLiBUaGlzIHByb2plY3QgcHJvdmlkZXM6XG4vLy5cbi8vLiAgIC0gW2BUeXBlQ2xhc3NgXSgjVHlwZUNsYXNzKSwgYSBmdW5jdGlvbiBmb3IgZGVmaW5pbmcgdHlwZSBjbGFzc2VzO1xuLy8uICAgLSBvbmUgYFR5cGVDbGFzc2AgdmFsdWUgZm9yIGVhY2ggRmFudGFzeSBMYW5kIHR5cGUgY2xhc3M7XG4vLy4gICAtIGxhd2Z1bCBGYW50YXN5IExhbmQgbWV0aG9kcyBmb3IgSmF2YVNjcmlwdCdzIGJ1aWx0LWluIHR5cGVzO1xuLy8uICAgLSBvbmUgZnVuY3Rpb24gZm9yIGVhY2ggRmFudGFzeSBMYW5kIG1ldGhvZDsgYW5kXG4vLy4gICAtIHNldmVyYWwgZnVuY3Rpb25zIGRlcml2ZWQgZnJvbSB0aGVzZSBmdW5jdGlvbnMuXG4vLy5cbi8vLiAjIyBUeXBlLWNsYXNzIGhpZXJhcmNoeVxuLy8uXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4vLy4gPHByZT5cbi8vLiAgU2V0b2lkICAgU2VtaWdyb3Vwb2lkICBTZW1pZ3JvdXAgICBGb2xkYWJsZSAgICAgICAgRnVuY3RvciAgICAgIENvbnRyYXZhcmlhbnRcbi8vLiAoZXF1YWxzKSAgICAoY29tcG9zZSkgICAgKGNvbmNhdCkgICAocmVkdWNlKSAgICAgICAgIChtYXApICAgICAgICAoY29udHJhbWFwKVxuLy8uICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICBcXCAgICAgICAgIC8gfCB8IHwgfCBcXFxuLy8uICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgXFwgICAgICAgLyAgfCB8IHwgfCAgXFxcbi8vLiAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICBcXCAgICAgLyAgIHwgfCB8IHwgICBcXFxuLy8uICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICBcXCAgIC8gICAgfCB8IHwgfCAgICBcXFxuLy8uICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgXFwgLyAgICAgfCB8IHwgfCAgICAgXFxcbi8vLiAgICBPcmQgICAgICBDYXRlZ29yeSAgICAgTW9ub2lkICAgICAgICAgVHJhdmVyc2FibGUgfCB8IHwgfCAgICAgIFxcXG4vLy4gICAobHRlKSAgICAgICAoaWQpICAgICAgIChlbXB0eSkgICAgICAgICh0cmF2ZXJzZSkgIC8gfCB8IFxcICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgLyAgfCB8ICBcXCAgICAgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgLyAgIC8gXFwgICBcXCAgICAgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIFByb2Z1bmN0b3IgLyAgIFxcIEJpZnVuY3RvciBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAocHJvbWFwKSAvICAgICBcXCAoYmltYXApICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAvICAgICAgIFxcICAgICAgICAgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgR3JvdXAgICAgICAgICAgICAgICAgICAgLyAgICAgICAgIFxcICAgICAgICAgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAoaW52ZXJ0KSAgICAgICAgICAgICAgIEFsdCAgICAgICAgQXBwbHkgICAgICBFeHRlbmRcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhbHQpICAgICAgICAoYXApICAgICAoZXh0ZW5kKVxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgICAgIC8gXFwgICAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvICAgICAgICAgICAvICAgXFwgICAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgICAgIC8gICAgIFxcICAgICAgICAgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgICAgIC8gICAgICAgXFwgICAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvICAgICAgICAgICAvICAgICAgICAgXFwgICAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUGx1cyAgICBBcHBsaWNhdGl2ZSAgICBDaGFpbiAgICAgIENvbW9uYWRcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh6ZXJvKSAgICAgICAob2YpICAgICAgKGNoYWluKSAgICAoZXh0cmFjdClcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcICAgICAgICAgLyBcXCAgICAgICAgIC8gXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXCAgICAgICAvICAgXFwgICAgICAgLyAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcICAgICAvICAgICBcXCAgICAgLyAgICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcICAgLyAgICAgICBcXCAgIC8gICAgICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXCAvICAgICAgICAgXFwgLyAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbHRlcm5hdGl2ZSAgICBNb25hZCAgICAgQ2hhaW5SZWNcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjaGFpblJlYylcbi8vLiA8L3ByZT5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuLy8uXG4vLy4gIyMgQVBJXG5cbihmdW5jdGlvbihmKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmKHJlcXVpcmUoJ3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzJykpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCAhPSBudWxsKSB7XG4gICAgZGVmaW5lKFsnc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMnXSwgZik7XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5zYW5jdHVhcnlUeXBlQ2xhc3NlcyA9IGYoc2VsZi5zYW5jdHVhcnlUeXBlSWRlbnRpZmllcnMpO1xuICB9XG5cbn0oZnVuY3Rpb24odHlwZSkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyAgY29uY2F0XyA6OiBBcnJheSBhIC0+IEFycmF5IGEgLT4gQXJyYXkgYVxuICBmdW5jdGlvbiBjb25jYXRfKHhzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHlzKSB7XG4gICAgICByZXR1cm4geHMuY29uY2F0KHlzKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gIGNvbnN0YW50IDo6IGEgLT4gYiAtPiBhXG4gIGZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgfVxuXG4gIC8vICBmb3JFYWNoS2V5IDo6IChTdHJNYXAgYSwgU3RyTWFwIGEgfj4gU3RyaW5nIC0+IFVuZGVmaW5lZCkgLT4gVW5kZWZpbmVkXG4gIGZ1bmN0aW9uIGZvckVhY2hLZXkoc3RyTWFwLCBmKSB7XG4gICAgT2JqZWN0LmtleXMoc3RyTWFwKS5mb3JFYWNoKGYsIHN0ck1hcCk7XG4gIH1cblxuICAvLyAgaGFzIDo6IChTdHJpbmcsIE9iamVjdCkgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBoYXMoaywgbykge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgayk7XG4gIH1cblxuICAvLyAgaWRlbnRpdHkgOjogYSAtPiBhXG4gIGZ1bmN0aW9uIGlkZW50aXR5KHgpIHsgcmV0dXJuIHg7IH1cblxuICAvLyAgcGFpciA6OiBhIC0+IGIgLT4gUGFpciBhIGJcbiAgZnVuY3Rpb24gcGFpcih4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfTtcbiAgfVxuXG4gIC8vICBzYW1lVHlwZSA6OiAoYSwgYikgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBzYW1lVHlwZSh4LCB5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSB0eXBlb2YgeSAmJiB0eXBlKHgpID09PSB0eXBlKHkpO1xuICB9XG5cbiAgLy8gIHR5cGUgSXRlcmF0aW9uIGEgPSB7IHZhbHVlIDo6IGEsIGRvbmUgOjogQm9vbGVhbiB9XG5cbiAgLy8gIGl0ZXJhdGlvbk5leHQgOjogYSAtPiBJdGVyYXRpb24gYVxuICBmdW5jdGlvbiBpdGVyYXRpb25OZXh0KHgpIHsgcmV0dXJuIHt2YWx1ZTogeCwgZG9uZTogZmFsc2V9OyB9XG5cbiAgLy8gIGl0ZXJhdGlvbkRvbmUgOjogYSAtPiBJdGVyYXRpb24gYVxuICBmdW5jdGlvbiBpdGVyYXRpb25Eb25lKHgpIHsgcmV0dXJuIHt2YWx1ZTogeCwgZG9uZTogdHJ1ZX07IH1cblxuICAvLyMgVHlwZUNsYXNzIDo6IChTdHJpbmcsIFN0cmluZywgQXJyYXkgVHlwZUNsYXNzLCBhIC0+IEJvb2xlYW4pIC0+IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIFRoZSBhcmd1bWVudHMgYXJlOlxuICAvLy5cbiAgLy8uICAgLSB0aGUgbmFtZSBvZiB0aGUgdHlwZSBjbGFzcywgcHJlZml4ZWQgYnkgaXRzIG5wbSBwYWNrYWdlIG5hbWU7XG4gIC8vLiAgIC0gdGhlIGRvY3VtZW50YXRpb24gVVJMIG9mIHRoZSB0eXBlIGNsYXNzO1xuICAvLy4gICAtIGFuIGFycmF5IG9mIGRlcGVuZGVuY2llczsgYW5kXG4gIC8vLiAgIC0gYSBwcmVkaWNhdGUgd2hpY2ggYWNjZXB0cyBhbnkgSmF2YVNjcmlwdCB2YWx1ZSBhbmQgcmV0dXJucyBgdHJ1ZWBcbiAgLy8uICAgICBpZiB0aGUgdmFsdWUgc2F0aXNmaWVzIHRoZSByZXF1aXJlbWVudHMgb2YgdGhlIHR5cGUgY2xhc3M7IGBmYWxzZWBcbiAgLy8uICAgICBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gRXhhbXBsZTpcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiAvLyAgICBoYXNNZXRob2QgOjogU3RyaW5nIC0+IGEgLT4gQm9vbGVhblxuICAvLy4gY29uc3QgaGFzTWV0aG9kID0gbmFtZSA9PiB4ID0+IHggIT0gbnVsbCAmJiB0eXBlb2YgeFtuYW1lXSA9PSAnZnVuY3Rpb24nO1xuICAvLy5cbiAgLy8uIC8vICAgIEZvbyA6OiBUeXBlQ2xhc3NcbiAgLy8uIGNvbnN0IEZvbyA9IFouVHlwZUNsYXNzKFxuICAvLy4gICAnbXktcGFja2FnZS9Gb28nLFxuICAvLy4gICAnaHR0cDovL2V4YW1wbGUuY29tL215LXBhY2thZ2UjRm9vJyxcbiAgLy8uICAgW10sXG4gIC8vLiAgIGhhc01ldGhvZCgnZm9vJylcbiAgLy8uICk7XG4gIC8vLlxuICAvLy4gLy8gICAgQmFyIDo6IFR5cGVDbGFzc1xuICAvLy4gY29uc3QgQmFyID0gWi5UeXBlQ2xhc3MoXG4gIC8vLiAgICdteS1wYWNrYWdlL0JhcicsXG4gIC8vLiAgICdodHRwOi8vZXhhbXBsZS5jb20vbXktcGFja2FnZSNCYXInLFxuICAvLy4gICBbRm9vXSxcbiAgLy8uICAgaGFzTWV0aG9kKCdiYXInKVxuICAvLy4gKTtcbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uIFR5cGVzIHdob3NlIHZhbHVlcyBoYXZlIGEgYGZvb2AgbWV0aG9kIGFyZSBtZW1iZXJzIG9mIHRoZSBGb28gdHlwZSBjbGFzcy5cbiAgLy8uIE1lbWJlcnMgb2YgdGhlIEZvbyB0eXBlIGNsYXNzIHdob3NlIHZhbHVlcyBoYXZlIGEgYGJhcmAgbWV0aG9kIGFyZSBhbHNvXG4gIC8vLiBtZW1iZXJzIG9mIHRoZSBCYXIgdHlwZSBjbGFzcy5cbiAgLy8uXG4gIC8vLiBFYWNoIGBUeXBlQ2xhc3NgIHZhbHVlIGhhcyBhIGB0ZXN0YCBmaWVsZDogYSBmdW5jdGlvbiB3aGljaCBhY2NlcHRzXG4gIC8vLiBhbnkgSmF2YVNjcmlwdCB2YWx1ZSBhbmQgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIHNhdGlzZmllcyB0aGVcbiAgLy8uIHR5cGUgY2xhc3MncyBwcmVkaWNhdGUgYW5kIHRoZSBwcmVkaWNhdGVzIG9mIGFsbCB0aGUgdHlwZSBjbGFzcydzXG4gIC8vLiBkZXBlbmRlbmNpZXM7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlcyBtYXkgYmUgdXNlZCB3aXRoIFtzYW5jdHVhcnktZGVmXVt0eXBlLWNsYXNzZXNdXG4gIC8vLiB0byBkZWZpbmUgcGFyYW1ldHJpY2FsbHkgcG9seW1vcnBoaWMgZnVuY3Rpb25zIHdoaWNoIHZlcmlmeSB0aGVpclxuICAvLy4gdHlwZS1jbGFzcyBjb25zdHJhaW50cyBhdCBydW4gdGltZS5cbiAgZnVuY3Rpb24gVHlwZUNsYXNzKG5hbWUsIHVybCwgZGVwZW5kZW5jaWVzLCB0ZXN0KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFR5cGVDbGFzcykpIHtcbiAgICAgIHJldHVybiBuZXcgVHlwZUNsYXNzKG5hbWUsIHVybCwgZGVwZW5kZW5jaWVzLCB0ZXN0KTtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnRlc3QgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gZGVwZW5kZW5jaWVzLmV2ZXJ5KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudGVzdCh4KTsgfSkgJiYgdGVzdCh4KTtcbiAgICB9O1xuICB9XG5cbiAgVHlwZUNsYXNzWydAQHR5cGUnXSA9ICdzYW5jdHVhcnktdHlwZS1jbGFzc2VzL1R5cGVDbGFzcyc7XG5cbiAgLy8gIGRhdGEgTG9jYXRpb24gPSBDb25zdHJ1Y3RvciB8IFZhbHVlXG5cbiAgLy8gIENvbnN0cnVjdG9yIDo6IExvY2F0aW9uXG4gIHZhciBDb25zdHJ1Y3RvciA9ICdDb25zdHJ1Y3Rvcic7XG5cbiAgLy8gIFZhbHVlIDo6IExvY2F0aW9uXG4gIHZhciBWYWx1ZSA9ICdWYWx1ZSc7XG5cbiAgLy8gIF9mdW5jUGF0aCA6OiAoQm9vbGVhbiwgQXJyYXkgU3RyaW5nLCBhKSAtPiBOdWxsYWJsZSBGdW5jdGlvblxuICBmdW5jdGlvbiBfZnVuY1BhdGgoYWxsb3dJbmhlcml0ZWRQcm9wcywgcGF0aCwgX3gpIHtcbiAgICB2YXIgeCA9IF94O1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHBhdGgubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgICAgdmFyIGsgPSBwYXRoW2lkeF07XG4gICAgICBpZiAoeCA9PSBudWxsIHx8ICEoYWxsb3dJbmhlcml0ZWRQcm9wcyB8fCBoYXMoaywgeCkpKSByZXR1cm4gbnVsbDtcbiAgICAgIHggPSB4W2tdO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgPyB4IDogbnVsbDtcbiAgfVxuXG4gIC8vICBmdW5jUGF0aCA6OiAoQXJyYXkgU3RyaW5nLCBhKSAtPiBOdWxsYWJsZSBGdW5jdGlvblxuICBmdW5jdGlvbiBmdW5jUGF0aChwYXRoLCB4KSB7XG4gICAgcmV0dXJuIF9mdW5jUGF0aCh0cnVlLCBwYXRoLCB4KTtcbiAgfVxuXG4gIC8vICBpbXBsUGF0aCA6OiBBcnJheSBTdHJpbmcgLT4gTnVsbGFibGUgRnVuY3Rpb25cbiAgZnVuY3Rpb24gaW1wbFBhdGgocGF0aCkge1xuICAgIHJldHVybiBfZnVuY1BhdGgoZmFsc2UsIHBhdGgsIGltcGxlbWVudGF0aW9ucyk7XG4gIH1cblxuICAvLyAgZnVuY3Rpb25OYW1lIDo6IEZ1bmN0aW9uIC0+IFN0cmluZ1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaGFzKCduYW1lJywgZnVuY3Rpb24gZigpIHt9KSA/XG4gICAgZnVuY3Rpb24gZnVuY3Rpb25OYW1lKGYpIHsgcmV0dXJuIGYubmFtZTsgfSA6XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbk5hbWUoZikge1xuICAgICAgdmFyIG1hdGNoID0gL2Z1bmN0aW9uIChcXHcqKS8uZXhlYyhmKTtcbiAgICAgIHJldHVybiBtYXRjaCA9PSBudWxsID8gJycgOiBtYXRjaFsxXTtcbiAgICB9O1xuXG4gIC8vICAkIDo6IChTdHJpbmcsIEFycmF5IFR5cGVDbGFzcywgU3RyTWFwIChBcnJheSBMb2NhdGlvbikpIC0+IFR5cGVDbGFzc1xuICBmdW5jdGlvbiAkKF9uYW1lLCBkZXBlbmRlbmNpZXMsIHJlcXVpcmVtZW50cykge1xuICAgIGZ1bmN0aW9uIGdldEJvdW5kTWV0aG9kKF9uYW1lKSB7XG4gICAgICB2YXIgbmFtZSA9ICdmYW50YXN5LWxhbmQvJyArIF9uYW1lO1xuICAgICAgcmV0dXJuIHJlcXVpcmVtZW50c1tfbmFtZV0gPT09IENvbnN0cnVjdG9yID9cbiAgICAgICAgZnVuY3Rpb24odHlwZVJlcCkge1xuICAgICAgICAgIHZhciBmID0gZnVuY1BhdGgoW25hbWVdLCB0eXBlUmVwKTtcbiAgICAgICAgICByZXR1cm4gZiA9PSBudWxsICYmIHR5cGVvZiB0eXBlUmVwID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIGltcGxQYXRoKFtmdW5jdGlvbk5hbWUodHlwZVJlcCksIG5hbWVdKSA6XG4gICAgICAgICAgICBmO1xuICAgICAgICB9IDpcbiAgICAgICAgZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHZhciBpc1Byb3RvdHlwZSA9IHggIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguY29uc3RydWN0b3IgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguY29uc3RydWN0b3IucHJvdG90eXBlID09PSB4O1xuICAgICAgICAgIHZhciBtID0gbnVsbDtcbiAgICAgICAgICBpZiAoIWlzUHJvdG90eXBlKSBtID0gZnVuY1BhdGgoW25hbWVdLCB4KTtcbiAgICAgICAgICBpZiAobSA9PSBudWxsKSAgICBtID0gaW1wbFBhdGgoW3R5cGUoeCksICdwcm90b3R5cGUnLCBuYW1lXSk7XG4gICAgICAgICAgcmV0dXJuIG0gJiYgbS5iaW5kKHgpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciB2ZXJzaW9uID0gJzcuMS4xJzsgIC8vIHVwZGF0ZWQgcHJvZ3JhbW1hdGljYWxseVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVxdWlyZW1lbnRzKTtcblxuICAgIHZhciB0eXBlQ2xhc3MgPSBUeXBlQ2xhc3MoXG4gICAgICAnc2FuY3R1YXJ5LXR5cGUtY2xhc3Nlcy8nICsgX25hbWUsXG4gICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3NhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzL3RyZWUvdicgKyB2ZXJzaW9uXG4gICAgICAgICsgJyMnICsgX25hbWUsXG4gICAgICBkZXBlbmRlbmNpZXMsXG4gICAgICBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBrZXlzLmV2ZXJ5KGZ1bmN0aW9uKF9uYW1lKSB7XG4gICAgICAgICAgdmFyIGFyZyA9IHJlcXVpcmVtZW50c1tfbmFtZV0gPT09IENvbnN0cnVjdG9yID8geC5jb25zdHJ1Y3RvciA6IHg7XG4gICAgICAgICAgcmV0dXJuIGdldEJvdW5kTWV0aG9kKF9uYW1lKShhcmcpICE9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG5cbiAgICB0eXBlQ2xhc3MubWV0aG9kcyA9IGtleXMucmVkdWNlKGZ1bmN0aW9uKG1ldGhvZHMsIF9uYW1lKSB7XG4gICAgICBtZXRob2RzW19uYW1lXSA9IGdldEJvdW5kTWV0aG9kKF9uYW1lKTtcbiAgICAgIHJldHVybiBtZXRob2RzO1xuICAgIH0sIHt9KTtcblxuICAgIHJldHVybiB0eXBlQ2xhc3M7XG4gIH1cblxuICAvLyMgU2V0b2lkIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbU2V0b2lkXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gU2V0b2lkLnRlc3QobnVsbClcbiAgLy8uIHRydWVcbiAgLy8uIGBgYFxuICB2YXIgU2V0b2lkID0gJCgnU2V0b2lkJywgW10sIHtlcXVhbHM6IFZhbHVlfSk7XG5cbiAgLy8jIE9yZCA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW09yZF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IE9yZC50ZXN0KDApXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBPcmQudGVzdChNYXRoLnNxcnQpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBPcmQgPSAkKCdPcmQnLCBbU2V0b2lkXSwge2x0ZTogVmFsdWV9KTtcblxuICAvLyMgU2VtaWdyb3Vwb2lkIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbU2VtaWdyb3Vwb2lkXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gU2VtaWdyb3Vwb2lkLnRlc3QoTWF0aC5zcXJ0KVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gU2VtaWdyb3Vwb2lkLnRlc3QoMClcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIFNlbWlncm91cG9pZCA9ICQoJ1NlbWlncm91cG9pZCcsIFtdLCB7Y29tcG9zZTogVmFsdWV9KTtcblxuICAvLyMgQ2F0ZWdvcnkgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtDYXRlZ29yeV1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IENhdGVnb3J5LnRlc3QoTWF0aC5zcXJ0KVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gQ2F0ZWdvcnkudGVzdCgwKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgQ2F0ZWdvcnkgPSAkKCdDYXRlZ29yeScsIFtTZW1pZ3JvdXBvaWRdLCB7aWQ6IENvbnN0cnVjdG9yfSk7XG5cbiAgLy8jIFNlbWlncm91cCA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW1NlbWlncm91cF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFNlbWlncm91cC50ZXN0KCcnKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gU2VtaWdyb3VwLnRlc3QoMClcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIFNlbWlncm91cCA9ICQoJ1NlbWlncm91cCcsIFtdLCB7Y29uY2F0OiBWYWx1ZX0pO1xuXG4gIC8vIyBNb25vaWQgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtNb25vaWRdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBNb25vaWQudGVzdCgnJylcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IE1vbm9pZC50ZXN0KDApXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBNb25vaWQgPSAkKCdNb25vaWQnLCBbU2VtaWdyb3VwXSwge2VtcHR5OiBDb25zdHJ1Y3Rvcn0pO1xuXG4gIC8vIyBHcm91cCA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0dyb3VwXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gR3JvdXAudGVzdChTdW0oMCkpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBHcm91cC50ZXN0KCcnKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgR3JvdXAgPSAkKCdHcm91cCcsIFtNb25vaWRdLCB7aW52ZXJ0OiBWYWx1ZX0pO1xuXG4gIC8vIyBGdW5jdG9yIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbRnVuY3Rvcl1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IEZ1bmN0b3IudGVzdChbXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IEZ1bmN0b3IudGVzdCgnJylcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIEZ1bmN0b3IgPSAkKCdGdW5jdG9yJywgW10sIHttYXA6IFZhbHVlfSk7XG5cbiAgLy8jIEJpZnVuY3RvciA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0JpZnVuY3Rvcl1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IEJpZnVuY3Rvci50ZXN0KFR1cGxlKCdmb28nLCA2NCkpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBCaWZ1bmN0b3IudGVzdChbXSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIEJpZnVuY3RvciA9ICQoJ0JpZnVuY3RvcicsIFtGdW5jdG9yXSwge2JpbWFwOiBWYWx1ZX0pO1xuXG4gIC8vIyBQcm9mdW5jdG9yIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbUHJvZnVuY3Rvcl1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFByb2Z1bmN0b3IudGVzdChNYXRoLnNxcnQpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBQcm9mdW5jdG9yLnRlc3QoW10pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBQcm9mdW5jdG9yID0gJCgnUHJvZnVuY3RvcicsIFtGdW5jdG9yXSwge3Byb21hcDogVmFsdWV9KTtcblxuICAvLyMgQXBwbHkgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtBcHBseV1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IEFwcGx5LnRlc3QoW10pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBBcHBseS50ZXN0KCcnKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgQXBwbHkgPSAkKCdBcHBseScsIFtGdW5jdG9yXSwge2FwOiBWYWx1ZX0pO1xuXG4gIC8vIyBBcHBsaWNhdGl2ZSA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0FwcGxpY2F0aXZlXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQXBwbGljYXRpdmUudGVzdChbXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IEFwcGxpY2F0aXZlLnRlc3Qoe30pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBBcHBsaWNhdGl2ZSA9ICQoJ0FwcGxpY2F0aXZlJywgW0FwcGx5XSwge29mOiBDb25zdHJ1Y3Rvcn0pO1xuXG4gIC8vIyBDaGFpbiA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0NoYWluXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQ2hhaW4udGVzdChbXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IENoYWluLnRlc3Qoe30pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBDaGFpbiA9ICQoJ0NoYWluJywgW0FwcGx5XSwge2NoYWluOiBWYWx1ZX0pO1xuXG4gIC8vIyBDaGFpblJlYyA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0NoYWluUmVjXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQ2hhaW5SZWMudGVzdChbXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IENoYWluUmVjLnRlc3Qoe30pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBDaGFpblJlYyA9ICQoJ0NoYWluUmVjJywgW0NoYWluXSwge2NoYWluUmVjOiBDb25zdHJ1Y3Rvcn0pO1xuXG4gIC8vIyBNb25hZCA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW01vbmFkXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gTW9uYWQudGVzdChbXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IE1vbmFkLnRlc3Qoe30pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBNb25hZCA9ICQoJ01vbmFkJywgW0FwcGxpY2F0aXZlLCBDaGFpbl0sIHt9KTtcblxuICAvLyMgQWx0IDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbQWx0XVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQWx0LnRlc3Qoe30pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBBbHQudGVzdCgnJylcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIEFsdCA9ICQoJ0FsdCcsIFtGdW5jdG9yXSwge2FsdDogVmFsdWV9KTtcblxuICAvLyMgUGx1cyA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW1BsdXNdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBQbHVzLnRlc3Qoe30pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBQbHVzLnRlc3QoJycpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBQbHVzID0gJCgnUGx1cycsIFtBbHRdLCB7emVybzogQ29uc3RydWN0b3J9KTtcblxuICAvLyMgQWx0ZXJuYXRpdmUgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtBbHRlcm5hdGl2ZV1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IEFsdGVybmF0aXZlLnRlc3QoW10pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBBbHRlcm5hdGl2ZS50ZXN0KHt9KVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgQWx0ZXJuYXRpdmUgPSAkKCdBbHRlcm5hdGl2ZScsIFtBcHBsaWNhdGl2ZSwgUGx1c10sIHt9KTtcblxuICAvLyMgRm9sZGFibGUgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtGb2xkYWJsZV1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IEZvbGRhYmxlLnRlc3Qoe30pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBGb2xkYWJsZS50ZXN0KCcnKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgRm9sZGFibGUgPSAkKCdGb2xkYWJsZScsIFtdLCB7cmVkdWNlOiBWYWx1ZX0pO1xuXG4gIC8vIyBUcmF2ZXJzYWJsZSA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW1RyYXZlcnNhYmxlXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gVHJhdmVyc2FibGUudGVzdChbXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFRyYXZlcnNhYmxlLnRlc3QoJycpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBUcmF2ZXJzYWJsZSA9ICQoJ1RyYXZlcnNhYmxlJywgW0Z1bmN0b3IsIEZvbGRhYmxlXSwge3RyYXZlcnNlOiBWYWx1ZX0pO1xuXG4gIC8vIyBFeHRlbmQgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtFeHRlbmRdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBFeHRlbmQudGVzdChbXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IEV4dGVuZC50ZXN0KHt9KVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgRXh0ZW5kID0gJCgnRXh0ZW5kJywgW0Z1bmN0b3JdLCB7ZXh0ZW5kOiBWYWx1ZX0pO1xuXG4gIC8vIyBDb21vbmFkIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbQ29tb25hZF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IENvbW9uYWQudGVzdChJZGVudGl0eSgwKSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IENvbW9uYWQudGVzdChbXSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIENvbW9uYWQgPSAkKCdDb21vbmFkJywgW0V4dGVuZF0sIHtleHRyYWN0OiBWYWx1ZX0pO1xuXG4gIC8vIyBDb250cmF2YXJpYW50IDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbQ29udHJhdmFyaWFudF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IENvbnRyYXZhcmlhbnQudGVzdChNYXRoLnNxcnQpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBDb250cmF2YXJpYW50LnRlc3QoW10pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBDb250cmF2YXJpYW50ID0gJCgnQ29udHJhdmFyaWFudCcsIFtdLCB7Y29udHJhbWFwOiBWYWx1ZX0pO1xuXG4gIC8vICBOdWxsJHByb3RvdHlwZSR0b1N0cmluZyA6OiBOdWxsIH4+ICgpIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBOdWxsJHByb3RvdHlwZSR0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG5cbiAgLy8gIE51bGwkcHJvdG90eXBlJGVxdWFscyA6OiBOdWxsIH4+IE51bGwgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBOdWxsJHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vICBOdWxsJHByb3RvdHlwZSRsdGUgOjogTnVsbCB+PiBOdWxsIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gTnVsbCRwcm90b3R5cGUkbHRlKG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyAgVW5kZWZpbmVkJHByb3RvdHlwZSR0b1N0cmluZyA6OiBVbmRlZmluZWQgfj4gKCkgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIFVuZGVmaW5lZCRwcm90b3R5cGUkdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICB9XG5cbiAgLy8gIFVuZGVmaW5lZCRwcm90b3R5cGUkZXF1YWxzIDo6IFVuZGVmaW5lZCB+PiBVbmRlZmluZWQgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBVbmRlZmluZWQkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gIFVuZGVmaW5lZCRwcm90b3R5cGUkbHRlIDo6IFVuZGVmaW5lZCB+PiBVbmRlZmluZWQgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBVbmRlZmluZWQkcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gIEJvb2xlYW4kcHJvdG90eXBlJHRvU3RyaW5nIDo6IEJvb2xlYW4gfj4gKCkgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIEJvb2xlYW4kcHJvdG90eXBlJHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcyA9PT0gJ29iamVjdCcgP1xuICAgICAgJ25ldyBCb29sZWFuKCcgKyB0b1N0cmluZyh0aGlzLnZhbHVlT2YoKSkgKyAnKScgOlxuICAgICAgdGhpcy50b1N0cmluZygpO1xuICB9XG5cbiAgLy8gIEJvb2xlYW4kcHJvdG90eXBlJGVxdWFscyA6OiBCb29sZWFuIH4+IEJvb2xlYW4gLT4gQm9vbGVhblxuICBmdW5jdGlvbiBCb29sZWFuJHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMgPT09ICdvYmplY3QnID9cbiAgICAgIGVxdWFscyh0aGlzLnZhbHVlT2YoKSwgb3RoZXIudmFsdWVPZigpKSA6XG4gICAgICB0aGlzID09PSBvdGhlcjtcbiAgfVxuXG4gIC8vICBCb29sZWFuJHByb3RvdHlwZSRsdGUgOjogQm9vbGVhbiB+PiBCb29sZWFuIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gQm9vbGVhbiRwcm90b3R5cGUkbHRlKG90aGVyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzID09PSAnb2JqZWN0JyA/XG4gICAgICBsdGUodGhpcy52YWx1ZU9mKCksIG90aGVyLnZhbHVlT2YoKSkgOlxuICAgICAgdGhpcyA9PT0gZmFsc2UgfHwgb3RoZXIgPT09IHRydWU7XG4gIH1cblxuICAvLyAgTnVtYmVyJHByb3RvdHlwZSR0b1N0cmluZyA6OiBOdW1iZXIgfj4gKCkgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIE51bWJlciRwcm90b3R5cGUkdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzID09PSAnb2JqZWN0JyA/XG4gICAgICAnbmV3IE51bWJlcignICsgdG9TdHJpbmcodGhpcy52YWx1ZU9mKCkpICsgJyknIDpcbiAgICAgIDEgLyB0aGlzID09PSAtSW5maW5pdHkgPyAnLTAnIDogdGhpcy50b1N0cmluZygxMCk7XG4gIH1cblxuICAvLyAgTnVtYmVyJHByb3RvdHlwZSRlcXVhbHMgOjogTnVtYmVyIH4+IE51bWJlciAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIE51bWJlciRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzID09PSAnb2JqZWN0JyA/XG4gICAgICBlcXVhbHModGhpcy52YWx1ZU9mKCksIG90aGVyLnZhbHVlT2YoKSkgOlxuICAgICAgaXNOYU4odGhpcykgJiYgaXNOYU4ob3RoZXIpIHx8IHRoaXMgPT09IG90aGVyO1xuICB9XG5cbiAgLy8gIE51bWJlciRwcm90b3R5cGUkbHRlIDo6IE51bWJlciB+PiBOdW1iZXIgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBOdW1iZXIkcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcyA9PT0gJ29iamVjdCcgP1xuICAgICAgbHRlKHRoaXMudmFsdWVPZigpLCBvdGhlci52YWx1ZU9mKCkpIDpcbiAgICAgIGlzTmFOKHRoaXMpICYmIGlzTmFOKG90aGVyKSB8fCB0aGlzIDw9IG90aGVyO1xuICB9XG5cbiAgLy8gIERhdGUkcHJvdG90eXBlJHRvU3RyaW5nIDo6IERhdGUgfj4gKCkgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIERhdGUkcHJvdG90eXBlJHRvU3RyaW5nKCkge1xuICAgIHZhciB4ID0gaXNOYU4odGhpcy52YWx1ZU9mKCkpID8gTmFOIDogdGhpcy50b0lTT1N0cmluZygpO1xuICAgIHJldHVybiAnbmV3IERhdGUoJyArIHRvU3RyaW5nKHgpICsgJyknO1xuICB9XG5cbiAgLy8gIERhdGUkcHJvdG90eXBlJGVxdWFscyA6OiBEYXRlIH4+IERhdGUgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBEYXRlJHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gZXF1YWxzKHRoaXMudmFsdWVPZigpLCBvdGhlci52YWx1ZU9mKCkpO1xuICB9XG5cbiAgLy8gIERhdGUkcHJvdG90eXBlJGx0ZSA6OiBEYXRlIH4+IERhdGUgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBEYXRlJHByb3RvdHlwZSRsdGUob3RoZXIpIHtcbiAgICByZXR1cm4gbHRlKHRoaXMudmFsdWVPZigpLCBvdGhlci52YWx1ZU9mKCkpO1xuICB9XG5cbiAgLy8gIFJlZ0V4cCRwcm90b3R5cGUkZXF1YWxzIDo6IFJlZ0V4cCB+PiBSZWdFeHAgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBSZWdFeHAkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBvdGhlci5zb3VyY2UgPT09IHRoaXMuc291cmNlICYmXG4gICAgICAgICAgIG90aGVyLmdsb2JhbCA9PT0gdGhpcy5nbG9iYWwgJiZcbiAgICAgICAgICAgb3RoZXIuaWdub3JlQ2FzZSA9PT0gdGhpcy5pZ25vcmVDYXNlICYmXG4gICAgICAgICAgIG90aGVyLm11bHRpbGluZSA9PT0gdGhpcy5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgb3RoZXIuc3RpY2t5ID09PSB0aGlzLnN0aWNreSAmJlxuICAgICAgICAgICBvdGhlci51bmljb2RlID09PSB0aGlzLnVuaWNvZGU7XG4gIH1cblxuICAvLyAgU3RyaW5nJGVtcHR5IDo6ICgpIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBTdHJpbmckZW1wdHkoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLy8gIFN0cmluZyRwcm90b3R5cGUkdG9TdHJpbmcgOjogU3RyaW5nIH4+ICgpIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBTdHJpbmckcHJvdG90eXBlJHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcyA9PT0gJ29iamVjdCcgP1xuICAgICAgJ25ldyBTdHJpbmcoJyArIHRvU3RyaW5nKHRoaXMudmFsdWVPZigpKSArICcpJyA6XG4gICAgICBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgfVxuXG4gIC8vICBTdHJpbmckcHJvdG90eXBlJGVxdWFscyA6OiBTdHJpbmcgfj4gU3RyaW5nIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gU3RyaW5nJHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMgPT09ICdvYmplY3QnID9cbiAgICAgIGVxdWFscyh0aGlzLnZhbHVlT2YoKSwgb3RoZXIudmFsdWVPZigpKSA6XG4gICAgICB0aGlzID09PSBvdGhlcjtcbiAgfVxuXG4gIC8vICBTdHJpbmckcHJvdG90eXBlJGx0ZSA6OiBTdHJpbmcgfj4gU3RyaW5nIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gU3RyaW5nJHByb3RvdHlwZSRsdGUob3RoZXIpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMgPT09ICdvYmplY3QnID9cbiAgICAgIGx0ZSh0aGlzLnZhbHVlT2YoKSwgb3RoZXIudmFsdWVPZigpKSA6XG4gICAgICB0aGlzIDw9IG90aGVyO1xuICB9XG5cbiAgLy8gIFN0cmluZyRwcm90b3R5cGUkY29uY2F0IDo6IFN0cmluZyB+PiBTdHJpbmcgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIFN0cmluZyRwcm90b3R5cGUkY29uY2F0KG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMgKyBvdGhlcjtcbiAgfVxuXG4gIC8vICBBcnJheSRlbXB0eSA6OiAoKSAtPiBBcnJheSBhXG4gIGZ1bmN0aW9uIEFycmF5JGVtcHR5KCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vICBBcnJheSRvZiA6OiBhIC0+IEFycmF5IGFcbiAgZnVuY3Rpb24gQXJyYXkkb2YoeCkge1xuICAgIHJldHVybiBbeF07XG4gIH1cblxuICAvLyAgQXJyYXkkY2hhaW5SZWMgOjogKChhIC0+IGMsIGIgLT4gYywgYSkgLT4gQXJyYXkgYywgYSkgLT4gQXJyYXkgYlxuICBmdW5jdGlvbiBBcnJheSRjaGFpblJlYyhmLCB4KSB7XG4gICAgdmFyICR0b2RvID0gW3hdO1xuICAgIHZhciAkZG9uZSA9IFtdO1xuICAgIHdoaWxlICgkdG9kby5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgeHMgPSBmKGl0ZXJhdGlvbk5leHQsIGl0ZXJhdGlvbkRvbmUsICR0b2RvLnNoaWZ0KCkpO1xuICAgICAgdmFyICRtb3JlID0gW107XG4gICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCB4cy5sZW5ndGg7IGlkeCArPSAxKSB7XG4gICAgICAgICh4c1tpZHhdLmRvbmUgPyAkZG9uZSA6ICRtb3JlKS5wdXNoKHhzW2lkeF0udmFsdWUpO1xuICAgICAgfVxuICAgICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoJHRvZG8sICRtb3JlKTtcbiAgICB9XG4gICAgcmV0dXJuICRkb25lO1xuICB9XG5cbiAgLy8gIEFycmF5JHplcm8gOjogKCkgLT4gQXJyYXkgYVxuICBmdW5jdGlvbiBBcnJheSR6ZXJvKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vICBBcnJheSRwcm90b3R5cGUkdG9TdHJpbmcgOjogQXJyYXkgYSB+PiAoKSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJHRvU3RyaW5nKCkge1xuICAgIHZhciByZXBycyA9IHRoaXMubWFwKHRvU3RyaW5nKTtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpLnNvcnQoKTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBrZXlzLmxlbmd0aDsgaWR4ICs9IDEpIHtcbiAgICAgIHZhciBrID0ga2V5c1tpZHhdO1xuICAgICAgaWYgKCEvXlxcZCskLy50ZXN0KGspKSB7XG4gICAgICAgIHJlcHJzLnB1c2godG9TdHJpbmcoaykgKyAnOiAnICsgdG9TdHJpbmcodGhpc1trXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ1snICsgcmVwcnMuam9pbignLCAnKSArICddJztcbiAgfVxuXG4gIC8vICBBcnJheSRwcm90b3R5cGUkZXF1YWxzIDo6IEFycmF5IGEgfj4gQXJyYXkgYSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIEFycmF5JHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAob3RoZXIubGVuZ3RoICE9PSB0aGlzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHRoaXMubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgICAgaWYgKCFlcXVhbHModGhpc1tpZHhdLCBvdGhlcltpZHhdKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vICBBcnJheSRwcm90b3R5cGUkbHRlIDo6IEFycmF5IGEgfj4gQXJyYXkgYSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIEFycmF5JHByb3RvdHlwZSRsdGUob3RoZXIpIHtcbiAgICBmb3IgKHZhciBpZHggPSAwOyB0cnVlOyBpZHggKz0gMSkge1xuICAgICAgaWYgKGlkeCA9PT0gdGhpcy5sZW5ndGgpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKGlkeCA9PT0gb3RoZXIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIWVxdWFscyh0aGlzW2lkeF0sIG90aGVyW2lkeF0pKSByZXR1cm4gbHRlKHRoaXNbaWR4XSwgb3RoZXJbaWR4XSk7XG4gICAgfVxuICB9XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSRjb25jYXQgOjogQXJyYXkgYSB+PiBBcnJheSBhIC0+IEFycmF5IGFcbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJGNvbmNhdChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbmNhdChvdGhlcik7XG4gIH1cblxuICAvLyAgQXJyYXkkcHJvdG90eXBlJG1hcCA6OiBBcnJheSBhIH4+IChhIC0+IGIpIC0+IEFycmF5IGJcbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJG1hcChmKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGYoeCk7IH0pO1xuICB9XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSRhcCA6OiBBcnJheSBhIH4+IEFycmF5IChhIC0+IGIpIC0+IEFycmF5IGJcbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJGFwKGZzKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGZzLmxlbmd0aDsgaWR4ICs9IDEpIHtcbiAgICAgIGZvciAodmFyIGlkeDIgPSAwOyBpZHgyIDwgdGhpcy5sZW5ndGg7IGlkeDIgKz0gMSkge1xuICAgICAgICByZXN1bHQucHVzaChmc1tpZHhdKHRoaXNbaWR4Ml0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vICBBcnJheSRwcm90b3R5cGUkY2hhaW4gOjogQXJyYXkgYSB+PiAoYSAtPiBBcnJheSBiKSAtPiBBcnJheSBiXG4gIGZ1bmN0aW9uIEFycmF5JHByb3RvdHlwZSRjaGFpbihmKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih4KSB7IEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdCwgZih4KSk7IH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyAgQXJyYXkkcHJvdG90eXBlJGFsdCA6OiBBcnJheSBhIH4+IEFycmF5IGEgLT4gQXJyYXkgYVxuICB2YXIgQXJyYXkkcHJvdG90eXBlJGFsdCA9IEFycmF5JHByb3RvdHlwZSRjb25jYXQ7XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSRyZWR1Y2UgOjogQXJyYXkgYSB+PiAoKGIsIGEpIC0+IGIsIGIpIC0+IGJcbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJHJlZHVjZShmLCBpbml0aWFsKSB7XG4gICAgcmV0dXJuIHRoaXMucmVkdWNlKGZ1bmN0aW9uKGFjYywgeCkgeyByZXR1cm4gZihhY2MsIHgpOyB9LCBpbml0aWFsKTtcbiAgfVxuXG4gIC8vICBBcnJheSRwcm90b3R5cGUkdHJhdmVyc2UgOjogQXBwbGljYXRpdmUgZiA9PiBBcnJheSBhIH4+IChUeXBlUmVwIGYsIGEgLT4gZiBiKSAtPiBmIChBcnJheSBiKVxuICBmdW5jdGlvbiBBcnJheSRwcm90b3R5cGUkdHJhdmVyc2UodHlwZVJlcCwgZikge1xuICAgIHZhciB4cyA9IHRoaXM7XG4gICAgZnVuY3Rpb24gZ28oaWR4LCBuKSB7XG4gICAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gb2YodHlwZVJlcCwgW10pO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBsaWZ0MihwYWlyLCBmKHhzW2lkeF0pLCBmKHhzW2lkeCArIDFdKSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmFyIG0gPSBNYXRoLmZsb29yKG4gLyA0KSAqIDI7XG4gICAgICAgICAgcmV0dXJuIGxpZnQyKGNvbmNhdF8sIGdvKGlkeCwgbSksIGdvKGlkeCArIG0sIG4gLSBtKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxlbmd0aCAlIDIgPT09IDEgP1xuICAgICAgbGlmdDIoY29uY2F0XywgbWFwKEFycmF5JG9mLCBmKHRoaXNbMF0pKSwgZ28oMSwgdGhpcy5sZW5ndGggLSAxKSkgOlxuICAgICAgZ28oMCwgdGhpcy5sZW5ndGgpO1xuICB9XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSRleHRlbmQgOjogQXJyYXkgYSB+PiAoQXJyYXkgYSAtPiBiKSAtPiBBcnJheSBiXG4gIGZ1bmN0aW9uIEFycmF5JHByb3RvdHlwZSRleHRlbmQoZikge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihfLCBpZHgsIHhzKSB7IHJldHVybiBmKHhzLnNsaWNlKGlkeCkpOyB9KTtcbiAgfVxuXG4gIC8vICBBcmd1bWVudHMkcHJvdG90eXBlJHRvU3RyaW5nIDo6IEFyZ3VtZW50cyB+PiBTdHJpbmdcbiAgZnVuY3Rpb24gQXJndW1lbnRzJHByb3RvdHlwZSR0b1N0cmluZygpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCh0aGlzLCB0b1N0cmluZykuam9pbignLCAnKTtcbiAgICByZXR1cm4gJyhmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oJyArIGFyZ3MgKyAnKSknO1xuICB9XG5cbiAgLy8gIEFyZ3VtZW50cyRwcm90b3R5cGUkZXF1YWxzIDo6IEFyZ3VtZW50cyB+PiBBcmd1bWVudHMgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBBcmd1bWVudHMkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBBcnJheSRwcm90b3R5cGUkZXF1YWxzLmNhbGwodGhpcywgb3RoZXIpO1xuICB9XG5cbiAgLy8gIEFyZ3VtZW50cyRwcm90b3R5cGUkbHRlIDo6IEFyZ3VtZW50cyB+PiBBcmd1bWVudHMgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBBcmd1bWVudHMkcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIHJldHVybiBBcnJheSRwcm90b3R5cGUkbHRlLmNhbGwodGhpcywgb3RoZXIpO1xuICB9XG5cbiAgLy8gIEVycm9yJHByb3RvdHlwZSR0b1N0cmluZyA6OiBFcnJvciB+PiAoKSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gRXJyb3IkcHJvdG90eXBlJHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnbmV3ICcgKyB0aGlzLm5hbWUgKyAnKCcgKyB0b1N0cmluZyh0aGlzLm1lc3NhZ2UpICsgJyknO1xuICB9XG5cbiAgLy8gIEVycm9yJHByb3RvdHlwZSRlcXVhbHMgOjogRXJyb3Igfj4gRXJyb3IgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBFcnJvciRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIGVxdWFscyh0aGlzLm5hbWUsIG90aGVyLm5hbWUpICYmXG4gICAgICAgICAgIGVxdWFscyh0aGlzLm1lc3NhZ2UsIG90aGVyLm1lc3NhZ2UpO1xuICB9XG5cbiAgLy8gIE9iamVjdCRlbXB0eSA6OiAoKSAtPiBTdHJNYXAgYVxuICBmdW5jdGlvbiBPYmplY3QkZW1wdHkoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLy8gIE9iamVjdCR6ZXJvIDo6ICgpIC0+IFN0ck1hcCBhXG4gIGZ1bmN0aW9uIE9iamVjdCR6ZXJvKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8vICBPYmplY3QkcHJvdG90eXBlJHRvU3RyaW5nIDo6IFN0ck1hcCBhIH4+ICgpIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBPYmplY3QkcHJvdG90eXBlJHRvU3RyaW5nKCkge1xuICAgIHZhciByZXBycyA9IFtdO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcykuc29ydCgpO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGtleXMubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgICAgdmFyIGsgPSBrZXlzW2lkeF07XG4gICAgICByZXBycy5wdXNoKHRvU3RyaW5nKGspICsgJzogJyArIHRvU3RyaW5nKHRoaXNba10pKTtcbiAgICB9XG4gICAgcmV0dXJuICd7JyArIHJlcHJzLmpvaW4oJywgJykgKyAnfSc7XG4gIH1cblxuICAvLyAgT2JqZWN0JHByb3RvdHlwZSRlcXVhbHMgOjogU3RyTWFwIGEgfj4gU3RyTWFwIGEgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBPYmplY3QkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpLnNvcnQoKTtcbiAgICByZXR1cm4gZXF1YWxzKGtleXMsIE9iamVjdC5rZXlzKG90aGVyKS5zb3J0KCkpICYmXG4gICAgICAgICAgIGtleXMuZXZlcnkoZnVuY3Rpb24oaykgeyByZXR1cm4gZXF1YWxzKHNlbGZba10sIG90aGVyW2tdKTsgfSk7XG4gIH1cblxuICAvLyAgT2JqZWN0JHByb3RvdHlwZSRsdGUgOjogU3RyTWFwIGEgfj4gU3RyTWFwIGEgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBPYmplY3QkcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIHZhciB0aGVzZUtleXMgPSBPYmplY3Qua2V5cyh0aGlzKS5zb3J0KCk7XG4gICAgdmFyIG90aGVyS2V5cyA9IE9iamVjdC5rZXlzKG90aGVyKS5zb3J0KCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh0aGVzZUtleXMubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChvdGhlcktleXMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgayA9IHRoZXNlS2V5cy5zaGlmdCgpO1xuICAgICAgdmFyIHogPSBvdGhlcktleXMuc2hpZnQoKTtcbiAgICAgIGlmIChrIDwgeikgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoayA+IHopIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghZXF1YWxzKHRoaXNba10sIG90aGVyW2tdKSkgcmV0dXJuIGx0ZSh0aGlzW2tdLCBvdGhlcltrXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gIE9iamVjdCRwcm90b3R5cGUkY29uY2F0IDo6IFN0ck1hcCBhIH4+IFN0ck1hcCBhIC0+IFN0ck1hcCBhXG4gIGZ1bmN0aW9uIE9iamVjdCRwcm90b3R5cGUkY29uY2F0KG90aGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZ1bmN0aW9uIGFzc2lnbihrKSB7IHJlc3VsdFtrXSA9IHRoaXNba107IH1cbiAgICBmb3JFYWNoS2V5KHRoaXMsIGFzc2lnbik7XG4gICAgZm9yRWFjaEtleShvdGhlciwgYXNzaWduKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gIE9iamVjdCRwcm90b3R5cGUkbWFwIDo6IFN0ck1hcCBhIH4+IChhIC0+IGIpIC0+IFN0ck1hcCBiXG4gIGZ1bmN0aW9uIE9iamVjdCRwcm90b3R5cGUkbWFwKGYpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yRWFjaEtleSh0aGlzLCBmdW5jdGlvbihrKSB7IHJlc3VsdFtrXSA9IGYodGhpc1trXSk7IH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyAgT2JqZWN0JHByb3RvdHlwZSRhcCA6OiBTdHJNYXAgYSB+PiBTdHJNYXAgKGEgLT4gYikgLT4gU3RyTWFwIGJcbiAgZnVuY3Rpb24gT2JqZWN0JHByb3RvdHlwZSRhcChvdGhlcikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3JFYWNoS2V5KHRoaXMsIGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChoYXMoaywgb3RoZXIpKSByZXN1bHRba10gPSBvdGhlcltrXSh0aGlzW2tdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gIE9iamVjdCRwcm90b3R5cGUkYWx0IDo6IFN0ck1hcCBhIH4+IFN0ck1hcCBhIC0+IFN0ck1hcCBhXG4gIHZhciBPYmplY3QkcHJvdG90eXBlJGFsdCA9IE9iamVjdCRwcm90b3R5cGUkY29uY2F0O1xuXG4gIC8vICBPYmplY3QkcHJvdG90eXBlJHJlZHVjZSA6OiBTdHJNYXAgYSB+PiAoKGIsIGEpIC0+IGIsIGIpIC0+IGJcbiAgZnVuY3Rpb24gT2JqZWN0JHByb3RvdHlwZSRyZWR1Y2UoZiwgaW5pdGlhbCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmdW5jdGlvbiByZWR1Y2VyKGFjYywgaykgeyByZXR1cm4gZihhY2MsIHNlbGZba10pOyB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMpLnNvcnQoKS5yZWR1Y2UocmVkdWNlciwgaW5pdGlhbCk7XG4gIH1cblxuICAvLyAgT2JqZWN0JHByb3RvdHlwZSR0cmF2ZXJzZSA6OiBBcHBsaWNhdGl2ZSBmID0+IFN0ck1hcCBhIH4+IChUeXBlUmVwIGYsIGEgLT4gZiBiKSAtPiBmIChTdHJNYXAgYilcbiAgZnVuY3Rpb24gT2JqZWN0JHByb3RvdHlwZSR0cmF2ZXJzZSh0eXBlUmVwLCBmKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzKS5yZWR1Y2UoZnVuY3Rpb24oYXBwbGljYXRpdmUsIGspIHtcbiAgICAgIGZ1bmN0aW9uIHNldChvKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdmFyIHNpbmdsZXRvbiA9IHt9OyBzaW5nbGV0b25ba10gPSB2O1xuICAgICAgICAgIHJldHVybiBPYmplY3QkcHJvdG90eXBlJGNvbmNhdC5jYWxsKG8sIHNpbmdsZXRvbik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbGlmdDIoc2V0LCBhcHBsaWNhdGl2ZSwgZihzZWxmW2tdKSk7XG4gICAgfSwgb2YodHlwZVJlcCwge30pKTtcbiAgfVxuXG4gIC8vICBGdW5jdGlvbiRpZCA6OiAoKSAtPiBhIC0+IGFcbiAgZnVuY3Rpb24gRnVuY3Rpb24kaWQoKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJG9mIDo6IGIgLT4gKGEgLT4gYilcbiAgZnVuY3Rpb24gRnVuY3Rpb24kb2YoeCkge1xuICAgIHJldHVybiBmdW5jdGlvbihfKSB7IHJldHVybiB4OyB9O1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJGNoYWluUmVjIDo6ICgoYSAtPiBjLCBiIC0+IGMsIGEpIC0+ICh6IC0+IGMpLCBhKSAtPiAoeiAtPiBiKVxuICBmdW5jdGlvbiBGdW5jdGlvbiRjaGFpblJlYyhmLCB4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEpIHtcbiAgICAgIHZhciBzdGVwID0gaXRlcmF0aW9uTmV4dCh4KTtcbiAgICAgIHdoaWxlICghc3RlcC5kb25lKSB7XG4gICAgICAgIHN0ZXAgPSBmKGl0ZXJhdGlvbk5leHQsIGl0ZXJhdGlvbkRvbmUsIHN0ZXAudmFsdWUpKGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0ZXAudmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIC8vICBGdW5jdGlvbiRwcm90b3R5cGUkZXF1YWxzIDo6IEZ1bmN0aW9uIH4+IEZ1bmN0aW9uIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gRnVuY3Rpb24kcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBvdGhlciA9PT0gdGhpcztcbiAgfVxuXG4gIC8vICBGdW5jdGlvbiRwcm90b3R5cGUkY29tcG9zZSA6OiAoYSAtPiBiKSB+PiAoYiAtPiBjKSAtPiAoYSAtPiBjKVxuICBmdW5jdGlvbiBGdW5jdGlvbiRwcm90b3R5cGUkY29tcG9zZShvdGhlcikge1xuICAgIHZhciBzZW1pZ3JvdXBvaWQgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiBvdGhlcihzZW1pZ3JvdXBvaWQoeCkpOyB9O1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJHByb3RvdHlwZSRtYXAgOjogKGEgLT4gYikgfj4gKGIgLT4gYykgLT4gKGEgLT4gYylcbiAgZnVuY3Rpb24gRnVuY3Rpb24kcHJvdG90eXBlJG1hcChmKSB7XG4gICAgdmFyIGZ1bmN0b3IgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiBmKGZ1bmN0b3IoeCkpOyB9O1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJHByb3RvdHlwZSRwcm9tYXAgOjogKGIgLT4gYykgfj4gKGEgLT4gYiwgYyAtPiBkKSAtPiAoYSAtPiBkKVxuICBmdW5jdGlvbiBGdW5jdGlvbiRwcm90b3R5cGUkcHJvbWFwKGYsIGcpIHtcbiAgICB2YXIgcHJvZnVuY3RvciA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGcocHJvZnVuY3RvcihmKHgpKSk7IH07XG4gIH1cblxuICAvLyAgRnVuY3Rpb24kcHJvdG90eXBlJGFwIDo6IChhIC0+IGIpIH4+IChhIC0+IGIgLT4gYykgLT4gKGEgLT4gYylcbiAgZnVuY3Rpb24gRnVuY3Rpb24kcHJvdG90eXBlJGFwKGYpIHtcbiAgICB2YXIgYXBwbHkgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiBmKHgpKGFwcGx5KHgpKTsgfTtcbiAgfVxuXG4gIC8vICBGdW5jdGlvbiRwcm90b3R5cGUkY2hhaW4gOjogKGEgLT4gYikgfj4gKGIgLT4gYSAtPiBjKSAtPiAoYSAtPiBjKVxuICBmdW5jdGlvbiBGdW5jdGlvbiRwcm90b3R5cGUkY2hhaW4oZikge1xuICAgIHZhciBjaGFpbiA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGYoY2hhaW4oeCkpKHgpOyB9O1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJHByb3RvdHlwZSRjb250cmFtYXAgOjogKGIgLT4gYykgfj4gKGEgLT4gYikgLT4gKGEgLT4gYylcbiAgZnVuY3Rpb24gRnVuY3Rpb24kcHJvdG90eXBlJGNvbnRyYW1hcChmKSB7XG4gICAgdmFyIGNvbnRyYXZhcmlhbnQgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiBjb250cmF2YXJpYW50KGYoeCkpOyB9O1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgdmFyIGltcGxlbWVudGF0aW9ucyA9IHtcbiAgICBOdWxsOiB7XG4gICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgdG9TdHJpbmc6ICAgICAgICAgICAgICAgICAgIE51bGwkcHJvdG90eXBlJHRvU3RyaW5nLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgTnVsbCRwcm90b3R5cGUkZXF1YWxzLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2x0ZSc6ICAgICAgICAgTnVsbCRwcm90b3R5cGUkbHRlXG4gICAgICB9XG4gICAgfSxcbiAgICBVbmRlZmluZWQ6IHtcbiAgICAgIHByb3RvdHlwZToge1xuICAgICAgICB0b1N0cmluZzogICAgICAgICAgICAgICAgICAgVW5kZWZpbmVkJHByb3RvdHlwZSR0b1N0cmluZyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnOiAgICAgIFVuZGVmaW5lZCRwcm90b3R5cGUkZXF1YWxzLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2x0ZSc6ICAgICAgICAgVW5kZWZpbmVkJHByb3RvdHlwZSRsdGVcbiAgICAgIH1cbiAgICB9LFxuICAgIEJvb2xlYW46IHtcbiAgICAgIHByb3RvdHlwZToge1xuICAgICAgICB0b1N0cmluZzogICAgICAgICAgICAgICAgICAgQm9vbGVhbiRwcm90b3R5cGUkdG9TdHJpbmcsXG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBCb29sZWFuJHByb3RvdHlwZSRlcXVhbHMsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbHRlJzogICAgICAgICBCb29sZWFuJHByb3RvdHlwZSRsdGVcbiAgICAgIH1cbiAgICB9LFxuICAgIE51bWJlcjoge1xuICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgIHRvU3RyaW5nOiAgICAgICAgICAgICAgICAgICBOdW1iZXIkcHJvdG90eXBlJHRvU3RyaW5nLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgTnVtYmVyJHByb3RvdHlwZSRlcXVhbHMsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbHRlJzogICAgICAgICBOdW1iZXIkcHJvdG90eXBlJGx0ZVxuICAgICAgfVxuICAgIH0sXG4gICAgRGF0ZToge1xuICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgIHRvU3RyaW5nOiAgICAgICAgICAgICAgICAgICBEYXRlJHByb3RvdHlwZSR0b1N0cmluZyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnOiAgICAgIERhdGUkcHJvdG90eXBlJGVxdWFscyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9sdGUnOiAgICAgICAgIERhdGUkcHJvdG90eXBlJGx0ZVxuICAgICAgfVxuICAgIH0sXG4gICAgUmVnRXhwOiB7XG4gICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnOiAgICAgIFJlZ0V4cCRwcm90b3R5cGUkZXF1YWxzXG4gICAgICB9XG4gICAgfSxcbiAgICBTdHJpbmc6IHtcbiAgICAgICdmYW50YXN5LWxhbmQvZW1wdHknOiAgICAgICAgIFN0cmluZyRlbXB0eSxcbiAgICAgIHByb3RvdHlwZToge1xuICAgICAgICB0b1N0cmluZzogICAgICAgICAgICAgICAgICAgU3RyaW5nJHByb3RvdHlwZSR0b1N0cmluZyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnOiAgICAgIFN0cmluZyRwcm90b3R5cGUkZXF1YWxzLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2x0ZSc6ICAgICAgICAgU3RyaW5nJHByb3RvdHlwZSRsdGUsXG4gICAgICAgICdmYW50YXN5LWxhbmQvY29uY2F0JzogICAgICBTdHJpbmckcHJvdG90eXBlJGNvbmNhdFxuICAgICAgfVxuICAgIH0sXG4gICAgQXJyYXk6IHtcbiAgICAgICdmYW50YXN5LWxhbmQvZW1wdHknOiAgICAgICAgIEFycmF5JGVtcHR5LFxuICAgICAgJ2ZhbnRhc3ktbGFuZC9vZic6ICAgICAgICAgICAgQXJyYXkkb2YsXG4gICAgICAnZmFudGFzeS1sYW5kL2NoYWluUmVjJzogICAgICBBcnJheSRjaGFpblJlYyxcbiAgICAgICdmYW50YXN5LWxhbmQvemVybyc6ICAgICAgICAgIEFycmF5JHplcm8sXG4gICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgdG9TdHJpbmc6ICAgICAgICAgICAgICAgICAgIEFycmF5JHByb3RvdHlwZSR0b1N0cmluZyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnOiAgICAgIEFycmF5JHByb3RvdHlwZSRlcXVhbHMsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbHRlJzogICAgICAgICBBcnJheSRwcm90b3R5cGUkbHRlLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2NvbmNhdCc6ICAgICAgQXJyYXkkcHJvdG90eXBlJGNvbmNhdCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9tYXAnOiAgICAgICAgIEFycmF5JHByb3RvdHlwZSRtYXAsXG4gICAgICAgICdmYW50YXN5LWxhbmQvYXAnOiAgICAgICAgICBBcnJheSRwcm90b3R5cGUkYXAsXG4gICAgICAgICdmYW50YXN5LWxhbmQvY2hhaW4nOiAgICAgICBBcnJheSRwcm90b3R5cGUkY2hhaW4sXG4gICAgICAgICdmYW50YXN5LWxhbmQvYWx0JzogICAgICAgICBBcnJheSRwcm90b3R5cGUkYWx0LFxuICAgICAgICAnZmFudGFzeS1sYW5kL3JlZHVjZSc6ICAgICAgQXJyYXkkcHJvdG90eXBlJHJlZHVjZSxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC90cmF2ZXJzZSc6ICAgIEFycmF5JHByb3RvdHlwZSR0cmF2ZXJzZSxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9leHRlbmQnOiAgICAgIEFycmF5JHByb3RvdHlwZSRleHRlbmRcbiAgICAgIH1cbiAgICB9LFxuICAgIEFyZ3VtZW50czoge1xuICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgIHRvU3RyaW5nOiAgICAgICAgICAgICAgICAgICBBcmd1bWVudHMkcHJvdG90eXBlJHRvU3RyaW5nLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgQXJndW1lbnRzJHByb3RvdHlwZSRlcXVhbHMsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbHRlJzogICAgICAgICBBcmd1bWVudHMkcHJvdG90eXBlJGx0ZVxuICAgICAgfVxuICAgIH0sXG4gICAgRXJyb3I6IHtcbiAgICAgIHByb3RvdHlwZToge1xuICAgICAgICB0b1N0cmluZzogICAgICAgICAgICAgICAgICAgRXJyb3IkcHJvdG90eXBlJHRvU3RyaW5nLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgRXJyb3IkcHJvdG90eXBlJGVxdWFsc1xuICAgICAgfVxuICAgIH0sXG4gICAgT2JqZWN0OiB7XG4gICAgICAnZmFudGFzeS1sYW5kL2VtcHR5JzogICAgICAgICBPYmplY3QkZW1wdHksXG4gICAgICAnZmFudGFzeS1sYW5kL3plcm8nOiAgICAgICAgICBPYmplY3QkemVybyxcbiAgICAgIHByb3RvdHlwZToge1xuICAgICAgICB0b1N0cmluZzogICAgICAgICAgICAgICAgICAgT2JqZWN0JHByb3RvdHlwZSR0b1N0cmluZyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnOiAgICAgIE9iamVjdCRwcm90b3R5cGUkZXF1YWxzLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2x0ZSc6ICAgICAgICAgT2JqZWN0JHByb3RvdHlwZSRsdGUsXG4gICAgICAgICdmYW50YXN5LWxhbmQvY29uY2F0JzogICAgICBPYmplY3QkcHJvdG90eXBlJGNvbmNhdCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9tYXAnOiAgICAgICAgIE9iamVjdCRwcm90b3R5cGUkbWFwLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2FwJzogICAgICAgICAgT2JqZWN0JHByb3RvdHlwZSRhcCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9hbHQnOiAgICAgICAgIE9iamVjdCRwcm90b3R5cGUkYWx0LFxuICAgICAgICAnZmFudGFzeS1sYW5kL3JlZHVjZSc6ICAgICAgT2JqZWN0JHByb3RvdHlwZSRyZWR1Y2UsXG4gICAgICAgICdmYW50YXN5LWxhbmQvdHJhdmVyc2UnOiAgICBPYmplY3QkcHJvdG90eXBlJHRyYXZlcnNlXG4gICAgICB9XG4gICAgfSxcbiAgICBGdW5jdGlvbjoge1xuICAgICAgJ2ZhbnRhc3ktbGFuZC9pZCc6ICAgICAgICAgICAgRnVuY3Rpb24kaWQsXG4gICAgICAnZmFudGFzeS1sYW5kL29mJzogICAgICAgICAgICBGdW5jdGlvbiRvZixcbiAgICAgICdmYW50YXN5LWxhbmQvY2hhaW5SZWMnOiAgICAgIEZ1bmN0aW9uJGNoYWluUmVjLFxuICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBGdW5jdGlvbiRwcm90b3R5cGUkZXF1YWxzLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2NvbXBvc2UnOiAgICAgRnVuY3Rpb24kcHJvdG90eXBlJGNvbXBvc2UsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbWFwJzogICAgICAgICBGdW5jdGlvbiRwcm90b3R5cGUkbWFwLFxuICAgICAgICAnZmFudGFzeS1sYW5kL3Byb21hcCc6ICAgICAgRnVuY3Rpb24kcHJvdG90eXBlJHByb21hcCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9hcCc6ICAgICAgICAgIEZ1bmN0aW9uJHByb3RvdHlwZSRhcCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9jaGFpbic6ICAgICAgIEZ1bmN0aW9uJHByb3RvdHlwZSRjaGFpbixcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9jb250cmFtYXAnOiAgIEZ1bmN0aW9uJHByb3RvdHlwZSRjb250cmFtYXBcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cblxuICAvLyMgdG9TdHJpbmcgOjogYSAtPiBTdHJpbmdcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGEgdXNlZnVsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBpdHMgYXJndW1lbnQuXG4gIC8vLlxuICAvLy4gRGlzcGF0Y2hlcyB0byB0aGUgYXJndW1lbnQncyBgdG9TdHJpbmdgIG1ldGhvZCBpZiBhcHByb3ByaWF0ZS5cbiAgLy8uXG4gIC8vLiBXaGVyZSBwcmFjdGljYWwsIGBlcXVhbHMoZXZhbCh0b1N0cmluZyh4KSksIHgpID0gdHJ1ZWAuXG4gIC8vLlxuICAvLy4gYHRvU3RyaW5nYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nIGJ1aWx0LWluIHR5cGVzOlxuICAvLy4gTnVsbCwgVW5kZWZpbmVkLCBCb29sZWFuLCBOdW1iZXIsIERhdGUsIFN0cmluZywgQXJyYXksIEFyZ3VtZW50cywgRXJyb3IsXG4gIC8vLiBhbmQgT2JqZWN0LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gdG9TdHJpbmcoLTApXG4gIC8vLiAnLTAnXG4gIC8vLlxuICAvLy4gPiB0b1N0cmluZyhbJ2ZvbycsICdiYXInLCAnYmF6J10pXG4gIC8vLiAnW1wiZm9vXCIsIFwiYmFyXCIsIFwiYmF6XCJdJ1xuICAvLy5cbiAgLy8uID4gdG9TdHJpbmcoe3g6IDEsIHk6IDIsIHo6IDN9KVxuICAvLy4gJ3tcInhcIjogMSwgXCJ5XCI6IDIsIFwielwiOiAzfSdcbiAgLy8uXG4gIC8vLiA+IHRvU3RyaW5nKENvbnMoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKSlcbiAgLy8uICdDb25zKDEsIENvbnMoMiwgQ29ucygzLCBOaWwpKSknXG4gIC8vLiBgYGBcbiAgdmFyIHRvU3RyaW5nID0gKGZ1bmN0aW9uKCkge1xuICAgIC8vICAkc2VlbiA6OiBBcnJheSBBbnlcbiAgICB2YXIgJHNlZW4gPSBbXTtcblxuICAgIGZ1bmN0aW9uIGNhbGwobWV0aG9kLCB4KSB7XG4gICAgICAkc2Vlbi5wdXNoKHgpO1xuICAgICAgdHJ5IHsgcmV0dXJuIG1ldGhvZC5jYWxsKHgpOyB9IGZpbmFsbHkgeyAkc2Vlbi5wb3AoKTsgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiB0b1N0cmluZyh4KSB7XG4gICAgICBpZiAoJHNlZW4uaW5kZXhPZih4KSA+PSAwKSByZXR1cm4gJzxDaXJjdWxhcj4nO1xuXG4gICAgICB2YXIgeFR5cGUgPSB0eXBlKHgpO1xuICAgICAgaWYgKHhUeXBlID09PSAnT2JqZWN0Jykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkgeyByZXN1bHQgPSBjYWxsKHgudG9TdHJpbmcsIHgpOyB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCAmJiByZXN1bHQgIT09ICdbb2JqZWN0IE9iamVjdF0nKSByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FsbChpbXBsUGF0aChbeFR5cGUsICdwcm90b3R5cGUnLCAndG9TdHJpbmcnXSkgfHwgeC50b1N0cmluZywgeCk7XG4gICAgfTtcbiAgfSgpKTtcblxuICAvLyMgZXF1YWxzIDo6IChhLCBiKSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gUmV0dXJucyBgdHJ1ZWAgaWYgaXRzIGFyZ3VtZW50cyBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhbmQgZXF1YWwgYWNjb3JkaW5nXG4gIC8vLiB0byB0aGUgdHlwZSdzIFtgZmFudGFzeS1sYW5kL2VxdWFsc2BdW10gbWV0aG9kOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2VxdWFsc2AgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IE51bGwsIFVuZGVmaW5lZCwgQm9vbGVhbiwgTnVtYmVyLCBEYXRlLCBSZWdFeHAsIFN0cmluZyxcbiAgLy8uIEFycmF5LCBBcmd1bWVudHMsIEVycm9yLCBPYmplY3QsIGFuZCBGdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBUaGUgYWxnb3JpdGhtIHN1cHBvcnRzIGNpcmN1bGFyIGRhdGEgc3RydWN0dXJlcy4gVHdvIGFycmF5cyBhcmUgZXF1YWxcbiAgLy8uIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBpbmRleCBwYXRocyBhbmQgZm9yIGVhY2ggcGF0aCBoYXZlIGVxdWFsIHZhbHVlcy5cbiAgLy8uIFR3byBhcnJheXMgd2hpY2ggcmVwcmVzZW50IGBbMSwgWzEsIFsxLCBbMSwgWzEsIC4uLl1dXV1dYCwgZm9yIGV4YW1wbGUsXG4gIC8vLiBhcmUgZXF1YWwgZXZlbiBpZiB0aGVpciBpbnRlcm5hbCBzdHJ1Y3R1cmVzIGRpZmZlci4gVHdvIG9iamVjdHMgYXJlIGVxdWFsXG4gIC8vLiBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgcHJvcGVydHkgcGF0aHMgYW5kIGZvciBlYWNoIHBhdGggaGF2ZSBlcXVhbCB2YWx1ZXMuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBlcXVhbHMoMCwgLTApXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBlcXVhbHMoTmFOLCBOYU4pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBlcXVhbHMoQ29ucygnZm9vJywgQ29ucygnYmFyJywgTmlsKSksIENvbnMoJ2ZvbycsIENvbnMoJ2JhcicsIE5pbCkpKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gZXF1YWxzKENvbnMoJ2ZvbycsIENvbnMoJ2JhcicsIE5pbCkpLCBDb25zKCdiYXInLCBDb25zKCdmb28nLCBOaWwpKSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIGVxdWFscyA9IChmdW5jdGlvbigpIHtcbiAgICAvLyAgJHBhaXJzIDo6IEFycmF5IChQYWlyIEFueSBBbnkpXG4gICAgdmFyICRwYWlycyA9IFtdO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGVxdWFscyh4LCB5KSB7XG4gICAgICBpZiAoIXNhbWVUeXBlKHgsIHkpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vICBUaGlzIGFsZ29yaXRobSBmb3IgY29tcGFyaW5nIGNpcmN1bGFyIGRhdGEgc3RydWN0dXJlcyB3YXNcbiAgICAgIC8vICBzdWdnZXN0ZWQgaW4gPGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQwNjIyNzk0LzMxMjc4NT4uXG4gICAgICBpZiAoJHBhaXJzLnNvbWUoZnVuY3Rpb24ocCkgeyByZXR1cm4gcFswXSA9PT0geCAmJiBwWzFdID09PSB5OyB9KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgJHBhaXJzLnB1c2goW3gsIHldKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBTZXRvaWQudGVzdCh4KSAmJiBTZXRvaWQudGVzdCh5KSAmJiBTZXRvaWQubWV0aG9kcy5lcXVhbHMoeCkoeSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAkcGFpcnMucG9wKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSgpKTtcblxuICAvLyMgbHQgOjogKGEsIGIpIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBpZiBpdHMgYXJndW1lbnRzIGFyZSBvZiB0aGUgc2FtZSB0eXBlIGFuZCB0aGUgZmlyc3QgaXNcbiAgLy8uIGxlc3MgdGhhbiB0aGUgc2Vjb25kIGFjY29yZGluZyB0byB0aGUgdHlwZSdzIFtgZmFudGFzeS1sYW5kL2x0ZWBdW11cbiAgLy8uIG1ldGhvZDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BsdGVgXSgjbHRlKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGd0YF0oI2d0KSBhbmQgW2BndGVgXSgjZ3RlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGx0KDAsIDApXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gbHQoMCwgMSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IGx0KDEsIDApXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGx0KHgsIHkpIHtcbiAgICByZXR1cm4gc2FtZVR5cGUoeCwgeSkgJiYgIWx0ZSh5LCB4KTtcbiAgfVxuXG4gIC8vIyBsdGUgOjogKGEsIGIpIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBpZiBpdHMgYXJndW1lbnRzIGFyZSBvZiB0aGUgc2FtZSB0eXBlIGFuZCB0aGUgZmlyc3RcbiAgLy8uIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kIGFjY29yZGluZyB0byB0aGUgdHlwZSdzXG4gIC8vLiBbYGZhbnRhc3ktbGFuZC9sdGVgXVtdIG1ldGhvZDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9sdGVgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBOdWxsLCBVbmRlZmluZWQsIEJvb2xlYW4sIE51bWJlciwgRGF0ZSwgU3RyaW5nLCBBcnJheSxcbiAgLy8uIEFyZ3VtZW50cywgYW5kIE9iamVjdC5cbiAgLy8uXG4gIC8vLiBUaGUgYWxnb3JpdGhtIHN1cHBvcnRzIGNpcmN1bGFyIGRhdGEgc3RydWN0dXJlcyBpbiB0aGUgc2FtZSBtYW5uZXIgYXNcbiAgLy8uIFtgZXF1YWxzYF0oI2VxdWFscykuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BsdGBdKCNsdCksIFtgZ3RgXSgjZ3QpLCBhbmQgW2BndGVgXSgjZ3RlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGx0ZSgwLCAwKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gbHRlKDAsIDEpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBsdGUoMSwgMClcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIGx0ZSA9IChmdW5jdGlvbigpIHtcbiAgICAvLyAgJHBhaXJzIDo6IEFycmF5IChQYWlyIEFueSBBbnkpXG4gICAgdmFyICRwYWlycyA9IFtdO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGx0ZSh4LCB5KSB7XG4gICAgICBpZiAoIXNhbWVUeXBlKHgsIHkpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vICBUaGlzIGFsZ29yaXRobSBmb3IgY29tcGFyaW5nIGNpcmN1bGFyIGRhdGEgc3RydWN0dXJlcyB3YXNcbiAgICAgIC8vICBzdWdnZXN0ZWQgaW4gPGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQwNjIyNzk0LzMxMjc4NT4uXG4gICAgICBpZiAoJHBhaXJzLnNvbWUoZnVuY3Rpb24ocCkgeyByZXR1cm4gcFswXSA9PT0geCAmJiBwWzFdID09PSB5OyB9KSkge1xuICAgICAgICByZXR1cm4gZXF1YWxzKHgsIHkpO1xuICAgICAgfVxuXG4gICAgICAkcGFpcnMucHVzaChbeCwgeV0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIE9yZC50ZXN0KHgpICYmIE9yZC50ZXN0KHkpICYmIE9yZC5tZXRob2RzLmx0ZSh4KSh5KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICRwYWlycy5wb3AoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KCkpO1xuXG4gIC8vIyBndCA6OiAoYSwgYikgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIGlmIGl0cyBhcmd1bWVudHMgYXJlIG9mIHRoZSBzYW1lIHR5cGUgYW5kIHRoZSBmaXJzdCBpc1xuICAvLy4gZ3JlYXRlciB0aGFuIHRoZSBzZWNvbmQgYWNjb3JkaW5nIHRvIHRoZSB0eXBlJ3MgW2BmYW50YXN5LWxhbmQvbHRlYF1bXVxuICAvLy4gbWV0aG9kOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGx0ZWBdKCNsdGUpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbHRgXSgjbHQpIGFuZCBbYGd0ZWBdKCNndGUpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZ3QoMCwgMClcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBndCgwLCAxKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IGd0KDEsIDApXG4gIC8vLiB0cnVlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZ3QoeCwgeSkge1xuICAgIHJldHVybiBsdCh5LCB4KTtcbiAgfVxuXG4gIC8vIyBndGUgOjogKGEsIGIpIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBpZiBpdHMgYXJndW1lbnRzIGFyZSBvZiB0aGUgc2FtZSB0eXBlIGFuZCB0aGUgZmlyc3RcbiAgLy8uIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kIGFjY29yZGluZyB0byB0aGUgdHlwZSdzXG4gIC8vLiBbYGZhbnRhc3ktbGFuZC9sdGVgXVtdIG1ldGhvZDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BsdGVgXSgjbHRlKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGx0YF0oI2x0KSBhbmQgW2BndGBdKCNndCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBndGUoMCwgMClcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IGd0ZSgwLCAxKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IGd0ZSgxLCAwKVxuICAvLy4gdHJ1ZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGd0ZSh4LCB5KSB7XG4gICAgcmV0dXJuIGx0ZSh5LCB4KTtcbiAgfVxuXG4gIC8vIyBtaW4gOjogT3JkIGEgPT4gKGEsIGEpIC0+IGFcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSBzbWFsbGVyIG9mIGl0cyB0d28gYXJndW1lbnRzLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgbHRlYF0oI2x0ZSkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BtYXhgXSgjbWF4KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IG1pbigxMCwgMilcbiAgLy8uIDJcbiAgLy8uXG4gIC8vLiA+IG1pbihuZXcgRGF0ZSgnMTk5OS0xMi0zMScpLCBuZXcgRGF0ZSgnMjAwMC0wMS0wMScpKVxuICAvLy4gbmV3IERhdGUoJzE5OTktMTItMzEnKVxuICAvLy5cbiAgLy8uID4gbWluKCcxMCcsICcyJylcbiAgLy8uICcxMCdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBtaW4oeCwgeSkge1xuICAgIHJldHVybiBsdGUoeCwgeSkgPyB4IDogeTtcbiAgfVxuXG4gIC8vIyBtYXggOjogT3JkIGEgPT4gKGEsIGEpIC0+IGFcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSBsYXJnZXIgb2YgaXRzIHR3byBhcmd1bWVudHMuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BsdGVgXSgjbHRlKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYG1pbmBdKCNtaW4pLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gbWF4KDEwLCAyKVxuICAvLy4gMTBcbiAgLy8uXG4gIC8vLiA+IG1heChuZXcgRGF0ZSgnMTk5OS0xMi0zMScpLCBuZXcgRGF0ZSgnMjAwMC0wMS0wMScpKVxuICAvLy4gbmV3IERhdGUoJzIwMDAtMDEtMDEnKVxuICAvLy5cbiAgLy8uID4gbWF4KCcxMCcsICcyJylcbiAgLy8uICcyJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG1heCh4LCB5KSB7XG4gICAgcmV0dXJuIGx0ZSh4LCB5KSA/IHkgOiB4O1xuICB9XG5cbiAgLy8jIGNvbXBvc2UgOjogU2VtaWdyb3Vwb2lkIGMgPT4gKGMgaiBrLCBjIGkgaikgLT4gYyBpIGtcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9jb21wb3NlYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2NvbXBvc2VgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBGdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGNvbXBvc2UoTWF0aC5zcXJ0LCB4ID0+IHggKyAxKSg5OSlcbiAgLy8uIDEwXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gY29tcG9zZSh4LCB5KSB7XG4gICAgcmV0dXJuIFNlbWlncm91cG9pZC5tZXRob2RzLmNvbXBvc2UoeSkoeCk7XG4gIH1cblxuICAvLyMgaWQgOjogQ2F0ZWdvcnkgYyA9PiBUeXBlUmVwIGMgLT4gY1xuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2lkYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2lkYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogRnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBpZChGdW5jdGlvbikoJ2ZvbycpXG4gIC8vLiAnZm9vJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGlkKHR5cGVSZXApIHtcbiAgICByZXR1cm4gQ2F0ZWdvcnkubWV0aG9kcy5pZCh0eXBlUmVwKSgpO1xuICB9XG5cbiAgLy8jIGNvbmNhdCA6OiBTZW1pZ3JvdXAgYSA9PiAoYSwgYSkgLT4gYVxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2NvbmNhdGBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9jb25jYXRgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBTdHJpbmcsIEFycmF5LCBhbmQgT2JqZWN0LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gY29uY2F0KCdhYmMnLCAnZGVmJylcbiAgLy8uICdhYmNkZWYnXG4gIC8vLlxuICAvLy4gPiBjb25jYXQoWzEsIDIsIDNdLCBbNCwgNSwgNl0pXG4gIC8vLiBbMSwgMiwgMywgNCwgNSwgNl1cbiAgLy8uXG4gIC8vLiA+IGNvbmNhdCh7eDogMSwgeTogMn0sIHt5OiAzLCB6OiA0fSlcbiAgLy8uIHt4OiAxLCB5OiAzLCB6OiA0fVxuICAvLy5cbiAgLy8uID4gY29uY2F0KENvbnMoJ2ZvbycsIENvbnMoJ2JhcicsIENvbnMoJ2JheicsIE5pbCkpKSwgQ29ucygncXV1eCcsIE5pbCkpXG4gIC8vLiBDb25zKCdmb28nLCBDb25zKCdiYXInLCBDb25zKCdiYXonLCBDb25zKCdxdXV4JywgTmlsKSkpKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGNvbmNhdCh4LCB5KSB7XG4gICAgcmV0dXJuIFNlbWlncm91cC5tZXRob2RzLmNvbmNhdCh4KSh5KTtcbiAgfVxuXG4gIC8vIyBlbXB0eSA6OiBNb25vaWQgbSA9PiBUeXBlUmVwIG0gLT4gbVxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2VtcHR5YF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2VtcHR5YCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogU3RyaW5nLCBBcnJheSwgYW5kIE9iamVjdC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGVtcHR5KFN0cmluZylcbiAgLy8uICcnXG4gIC8vLlxuICAvLy4gPiBlbXB0eShBcnJheSlcbiAgLy8uIFtdXG4gIC8vLlxuICAvLy4gPiBlbXB0eShPYmplY3QpXG4gIC8vLiB7fVxuICAvLy5cbiAgLy8uID4gZW1wdHkoTGlzdClcbiAgLy8uIE5pbFxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGVtcHR5KHR5cGVSZXApIHtcbiAgICByZXR1cm4gTW9ub2lkLm1ldGhvZHMuZW1wdHkodHlwZVJlcCkoKTtcbiAgfVxuXG4gIC8vIyBpbnZlcnQgOjogR3JvdXAgZyA9PiBnIC0+IGdcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9pbnZlcnRgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uIGludmVydChTdW0oNSkpXG4gIC8vLiBTdW0oLTUpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gaW52ZXJ0KGdyb3VwKSB7XG4gICAgcmV0dXJuIEdyb3VwLm1ldGhvZHMuaW52ZXJ0KGdyb3VwKSgpO1xuICB9XG5cbiAgLy8jIG1hcCA6OiBGdW5jdG9yIGYgPT4gKGEgLT4gYiwgZiBhKSAtPiBmIGJcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9tYXBgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvbWFwYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogQXJyYXksIE9iamVjdCwgYW5kIEZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gbWFwKE1hdGguc3FydCwgWzEsIDQsIDldKVxuICAvLy4gWzEsIDIsIDNdXG4gIC8vLlxuICAvLy4gPiBtYXAoTWF0aC5zcXJ0LCB7eDogMSwgeTogNCwgejogOX0pXG4gIC8vLiB7eDogMSwgeTogMiwgejogM31cbiAgLy8uXG4gIC8vLiA+IG1hcChNYXRoLnNxcnQsIHMgPT4gcy5sZW5ndGgpKCdTYW5jdHVhcnknKVxuICAvLy4gM1xuICAvLy5cbiAgLy8uID4gbWFwKE1hdGguc3FydCwgVHVwbGUoJ2ZvbycsIDY0KSlcbiAgLy8uIFR1cGxlKCdmb28nLCA4KVxuICAvLy5cbiAgLy8uID4gbWFwKE1hdGguc3FydCwgTmlsKVxuICAvLy4gTmlsXG4gIC8vLlxuICAvLy4gPiBtYXAoTWF0aC5zcXJ0LCBDb25zKDEsIENvbnMoNCwgQ29ucyg5LCBOaWwpKSkpXG4gIC8vLiBDb25zKDEsIENvbnMoMiwgQ29ucygzLCBOaWwpKSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBtYXAoZiwgZnVuY3Rvcikge1xuICAgIHJldHVybiBGdW5jdG9yLm1ldGhvZHMubWFwKGZ1bmN0b3IpKGYpO1xuICB9XG5cbiAgLy8jIGJpbWFwIDo6IEJpZnVuY3RvciBmID0+IChhIC0+IGIsIGMgLT4gZCwgZiBhIGMpIC0+IGYgYiBkXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvYmltYXBgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gYmltYXAocyA9PiBzLnRvVXBwZXJDYXNlKCksIE1hdGguc3FydCwgVHVwbGUoJ2ZvbycsIDY0KSlcbiAgLy8uIFR1cGxlKCdGT08nLCA4KVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGJpbWFwKGYsIGcsIGJpZnVuY3Rvcikge1xuICAgIHJldHVybiBCaWZ1bmN0b3IubWV0aG9kcy5iaW1hcChiaWZ1bmN0b3IpKGYsIGcpO1xuICB9XG5cbiAgLy8jIHByb21hcCA6OiBQcm9mdW5jdG9yIHAgPT4gKGEgLT4gYiwgYyAtPiBkLCBwIGIgYykgLT4gcCBhIGRcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9wcm9tYXBgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvcHJvbWFwYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogRnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBwcm9tYXAoTWF0aC5hYnMsIHggPT4geCArIDEsIE1hdGguc3FydCkoLTEwMClcbiAgLy8uIDExXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcHJvbWFwKGYsIGcsIHByb2Z1bmN0b3IpIHtcbiAgICByZXR1cm4gUHJvZnVuY3Rvci5tZXRob2RzLnByb21hcChwcm9mdW5jdG9yKShmLCBnKTtcbiAgfVxuXG4gIC8vIyBhcCA6OiBBcHBseSBmID0+IChmIChhIC0+IGIpLCBmIGEpIC0+IGYgYlxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2FwYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2FwYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogQXJyYXksIE9iamVjdCwgYW5kIEZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gYXAoW01hdGguc3FydCwgeCA9PiB4ICogeF0sIFsxLCA0LCA5LCAxNiwgMjVdKVxuICAvLy4gWzEsIDIsIDMsIDQsIDUsIDEsIDE2LCA4MSwgMjU2LCA2MjVdXG4gIC8vLlxuICAvLy4gPiBhcCh7YTogTWF0aC5zcXJ0LCBiOiB4ID0+IHggKiB4fSwge2E6IDE2LCBiOiAxMCwgYzogMX0pXG4gIC8vLiB7YTogNCwgYjogMTAwfVxuICAvLy5cbiAgLy8uID4gYXAocyA9PiBuID0+IHMuc2xpY2UoMCwgbiksIHMgPT4gTWF0aC5jZWlsKHMubGVuZ3RoIC8gMikpKCdIYXNrZWxsJylcbiAgLy8uICdIYXNrJ1xuICAvLy5cbiAgLy8uID4gYXAoSWRlbnRpdHkoTWF0aC5zcXJ0KSwgSWRlbnRpdHkoNjQpKVxuICAvLy4gSWRlbnRpdHkoOClcbiAgLy8uXG4gIC8vLiA+IGFwKENvbnMoTWF0aC5zcXJ0LCBDb25zKHggPT4geCAqIHgsIE5pbCkpLCBDb25zKDE2LCBDb25zKDEwMCwgTmlsKSkpXG4gIC8vLiBDb25zKDQsIENvbnMoMTAsIENvbnMoMjU2LCBDb25zKDEwMDAwLCBOaWwpKSkpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gYXAoYXBwbHlGLCBhcHBseVgpIHtcbiAgICByZXR1cm4gQXBwbHkubWV0aG9kcy5hcChhcHBseVgpKGFwcGx5Rik7XG4gIH1cblxuICAvLyMgbGlmdDIgOjogQXBwbHkgZiA9PiAoYSAtPiBiIC0+IGMsIGYgYSwgZiBiKSAtPiBmIGNcbiAgLy8uXG4gIC8vLiBMaWZ0cyBgYSAtPiBiIC0+IGNgIHRvIGBBcHBseSBmID0+IGYgYSAtPiBmIGIgLT4gZiBjYCBhbmQgcmV0dXJucyB0aGVcbiAgLy8uIHJlc3VsdCBvZiBhcHBseWluZyB0aGlzIHRvIHRoZSBnaXZlbiBhcmd1bWVudHMuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BtYXBgXSgjbWFwKSBhbmQgW2BhcGBdKCNhcCkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BsaWZ0M2BdKCNsaWZ0MykuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBsaWZ0Mih4ID0+IHkgPT4gTWF0aC5wb3coeCwgeSksIFsxMF0sIFsxLCAyLCAzXSlcbiAgLy8uIFsxMCwgMTAwLCAxMDAwXVxuICAvLy5cbiAgLy8uID4gbGlmdDIoeCA9PiB5ID0+IE1hdGgucG93KHgsIHkpLCBJZGVudGl0eSgxMCksIElkZW50aXR5KDMpKVxuICAvLy4gSWRlbnRpdHkoMTAwMClcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBsaWZ0MihmLCB4LCB5KSB7XG4gICAgcmV0dXJuIGFwKG1hcChmLCB4KSwgeSk7XG4gIH1cblxuICAvLyMgbGlmdDMgOjogQXBwbHkgZiA9PiAoYSAtPiBiIC0+IGMgLT4gZCwgZiBhLCBmIGIsIGYgYykgLT4gZiBkXG4gIC8vLlxuICAvLy4gTGlmdHMgYGEgLT4gYiAtPiBjIC0+IGRgIHRvIGBBcHBseSBmID0+IGYgYSAtPiBmIGIgLT4gZiBjIC0+IGYgZGAgYW5kXG4gIC8vLiByZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhpcyB0byB0aGUgZ2l2ZW4gYXJndW1lbnRzLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgbWFwYF0oI21hcCkgYW5kIFtgYXBgXSgjYXApLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbGlmdDJgXSgjbGlmdDIpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gbGlmdDMoeCA9PiB5ID0+IHogPT4geCArIHogKyB5LCBbJzwnXSwgWyc+J10sIFsnZm9vJywgJ2JhcicsICdiYXonXSlcbiAgLy8uIFsnPGZvbz4nLCAnPGJhcj4nLCAnPGJhej4nXVxuICAvLy5cbiAgLy8uID4gbGlmdDMoeCA9PiB5ID0+IHogPT4geCArIHogKyB5LCBJZGVudGl0eSgnPCcpLCBJZGVudGl0eSgnPicpLCBJZGVudGl0eSgnYmF6JykpXG4gIC8vLiBJZGVudGl0eSgnPGJhej4nKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGxpZnQzKGYsIHgsIHksIHopIHtcbiAgICByZXR1cm4gYXAoYXAobWFwKGYsIHgpLCB5KSwgeik7XG4gIH1cblxuICAvLyMgYXBGaXJzdCA6OiBBcHBseSBmID0+IChmIGEsIGYgYikgLT4gZiBhXG4gIC8vLlxuICAvLy4gQ29tYmluZXMgdHdvIGVmZmVjdGZ1bCBhY3Rpb25zLCBrZWVwaW5nIG9ubHkgdGhlIHJlc3VsdCBvZiB0aGUgZmlyc3QuXG4gIC8vLiBFcXVpdmFsZW50IHRvIEhhc2tlbGwncyBgKDwqKWAgZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BsaWZ0MmBdKCNsaWZ0MikuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BhcFNlY29uZGBdKCNhcFNlY29uZCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBhcEZpcnN0KFsxLCAyXSwgWzMsIDRdKVxuICAvLy4gWzEsIDEsIDIsIDJdXG4gIC8vLlxuICAvLy4gPiBhcEZpcnN0KElkZW50aXR5KDEpLCBJZGVudGl0eSgyKSlcbiAgLy8uIElkZW50aXR5KDEpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gYXBGaXJzdCh4LCB5KSB7XG4gICAgcmV0dXJuIGxpZnQyKGNvbnN0YW50LCB4LCB5KTtcbiAgfVxuXG4gIC8vIyBhcFNlY29uZCA6OiBBcHBseSBmID0+IChmIGEsIGYgYikgLT4gZiBiXG4gIC8vLlxuICAvLy4gQ29tYmluZXMgdHdvIGVmZmVjdGZ1bCBhY3Rpb25zLCBrZWVwaW5nIG9ubHkgdGhlIHJlc3VsdCBvZiB0aGUgc2Vjb25kLlxuICAvLy4gRXF1aXZhbGVudCB0byBIYXNrZWxsJ3MgYCgqPilgIGZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgbGlmdDJgXSgjbGlmdDIpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgYXBGaXJzdGBdKCNhcEZpcnN0KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGFwU2Vjb25kKFsxLCAyXSwgWzMsIDRdKVxuICAvLy4gWzMsIDQsIDMsIDRdXG4gIC8vLlxuICAvLy4gPiBhcFNlY29uZChJZGVudGl0eSgxKSwgSWRlbnRpdHkoMikpXG4gIC8vLiBJZGVudGl0eSgyKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGFwU2Vjb25kKHgsIHkpIHtcbiAgICByZXR1cm4gbGlmdDIoY29uc3RhbnQoaWRlbnRpdHkpLCB4LCB5KTtcbiAgfVxuXG4gIC8vIyBvZiA6OiBBcHBsaWNhdGl2ZSBmID0+IChUeXBlUmVwIGYsIGEpIC0+IGYgYVxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL29mYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL29mYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogQXJyYXkgYW5kIEZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gb2YoQXJyYXksIDQyKVxuICAvLy4gWzQyXVxuICAvLy5cbiAgLy8uID4gb2YoRnVuY3Rpb24sIDQyKShudWxsKVxuICAvLy4gNDJcbiAgLy8uXG4gIC8vLiA+IG9mKExpc3QsIDQyKVxuICAvLy4gQ29ucyg0MiwgTmlsKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG9mKHR5cGVSZXAsIHgpIHtcbiAgICByZXR1cm4gQXBwbGljYXRpdmUubWV0aG9kcy5vZih0eXBlUmVwKSh4KTtcbiAgfVxuXG4gIC8vIyBhcHBlbmQgOjogKEFwcGxpY2F0aXZlIGYsIFNlbWlncm91cCAoZiBhKSkgPT4gKGEsIGYgYSkgLT4gZiBhXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFwcGVuZGluZyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHNlY29uZC5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGNvbmNhdGBdKCNjb25jYXQpIGFuZCBbYG9mYF0oI29mKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHByZXBlbmRgXSgjcHJlcGVuZCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBhcHBlbmQoMywgWzEsIDJdKVxuICAvLy4gWzEsIDIsIDNdXG4gIC8vLlxuICAvLy4gPiBhcHBlbmQoMywgQ29ucygxLCBDb25zKDIsIE5pbCkpKVxuICAvLy4gQ29ucygxLCBDb25zKDIsIENvbnMoMywgTmlsKSkpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gYXBwZW5kKHgsIHhzKSB7XG4gICAgcmV0dXJuIGNvbmNhdCh4cywgb2YoeHMuY29uc3RydWN0b3IsIHgpKTtcbiAgfVxuXG4gIC8vIyBwcmVwZW5kIDo6IChBcHBsaWNhdGl2ZSBmLCBTZW1pZ3JvdXAgKGYgYSkpID0+IChhLCBmIGEpIC0+IGYgYVxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIHJlc3VsdCBvZiBwcmVwZW5kaW5nIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgc2Vjb25kLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgY29uY2F0YF0oI2NvbmNhdCkgYW5kIFtgb2ZgXSgjb2YpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgYXBwZW5kYF0oI2FwcGVuZCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBwcmVwZW5kKDEsIFsyLCAzXSlcbiAgLy8uIFsxLCAyLCAzXVxuICAvLy5cbiAgLy8uID4gcHJlcGVuZCgxLCBDb25zKDIsIENvbnMoMywgTmlsKSkpXG4gIC8vLiBDb25zKDEsIENvbnMoMiwgQ29ucygzLCBOaWwpKSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBwcmVwZW5kKHgsIHhzKSB7XG4gICAgcmV0dXJuIGNvbmNhdChvZih4cy5jb25zdHJ1Y3RvciwgeCksIHhzKTtcbiAgfVxuXG4gIC8vIyBjaGFpbiA6OiBDaGFpbiBtID0+IChhIC0+IG0gYiwgbSBhKSAtPiBtIGJcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9jaGFpbmBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9jaGFpbmAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEFycmF5IGFuZCBGdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGNoYWluKHggPT4gW3gsIHhdLCBbMSwgMiwgM10pXG4gIC8vLiBbMSwgMSwgMiwgMiwgMywgM11cbiAgLy8uXG4gIC8vLiA+IGNoYWluKHggPT4geCAlIDIgPT0gMSA/IG9mKExpc3QsIHgpIDogTmlsLCBDb25zKDEsIENvbnMoMiwgQ29ucygzLCBOaWwpKSkpXG4gIC8vLiBDb25zKDEsIENvbnMoMywgTmlsKSlcbiAgLy8uXG4gIC8vLiA+IGNoYWluKG4gPT4gcyA9PiBzLnNsaWNlKDAsIG4pLCBzID0+IE1hdGguY2VpbChzLmxlbmd0aCAvIDIpKSgnSGFza2VsbCcpXG4gIC8vLiAnSGFzaydcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBjaGFpbihmLCBjaGFpbl8pIHtcbiAgICByZXR1cm4gQ2hhaW4ubWV0aG9kcy5jaGFpbihjaGFpbl8pKGYpO1xuICB9XG5cbiAgLy8jIGpvaW4gOjogQ2hhaW4gbSA9PiBtIChtIGEpIC0+IG0gYVxuICAvLy5cbiAgLy8uIFJlbW92ZXMgb25lIGxldmVsIG9mIG5lc3RpbmcgZnJvbSBhIG5lc3RlZCBtb25hZGljIHN0cnVjdHVyZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGNoYWluYF0oI2NoYWluKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGpvaW4oW1sxXSwgWzJdLCBbM11dKVxuICAvLy4gWzEsIDIsIDNdXG4gIC8vLlxuICAvLy4gPiBqb2luKFtbWzEsIDIsIDNdXV0pXG4gIC8vLiBbWzEsIDIsIDNdXVxuICAvLy5cbiAgLy8uID4gam9pbihJZGVudGl0eShJZGVudGl0eSgxKSkpXG4gIC8vLiBJZGVudGl0eSgxKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGpvaW4oY2hhaW5fKSB7XG4gICAgcmV0dXJuIGNoYWluKGlkZW50aXR5LCBjaGFpbl8pO1xuICB9XG5cbiAgLy8jIGNoYWluUmVjIDo6IENoYWluUmVjIG0gPT4gKFR5cGVSZXAgbSwgKGEgLT4gYywgYiAtPiBjLCBhKSAtPiBtIGMsIGEpIC0+IG0gYlxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2NoYWluUmVjYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2NoYWluUmVjYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogQXJyYXkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBjaGFpblJlYyhcbiAgLy8uIC4gICBBcnJheSxcbiAgLy8uIC4gICAobmV4dCwgZG9uZSwgcykgPT4gcy5sZW5ndGggPT0gMiA/IFtzICsgJyEnLCBzICsgJz8nXS5tYXAoZG9uZSlcbiAgLy8uIC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFtzICsgJ28nLCBzICsgJ24nXS5tYXAobmV4dCksXG4gIC8vLiAuICAgJydcbiAgLy8uIC4gKVxuICAvLy4gWydvbyEnLCAnb28/JywgJ29uIScsICdvbj8nLCAnbm8hJywgJ25vPycsICdubiEnLCAnbm4/J11cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBjaGFpblJlYyh0eXBlUmVwLCBmLCB4KSB7XG4gICAgcmV0dXJuIENoYWluUmVjLm1ldGhvZHMuY2hhaW5SZWModHlwZVJlcCkoZiwgeCk7XG4gIH1cblxuICAvLyMgZmlsdGVyIDo6IChBcHBsaWNhdGl2ZSBmLCBGb2xkYWJsZSBmLCBNb25vaWQgKGYgYSkpID0+IChhIC0+IEJvb2xlYW4sIGYgYSkgLT4gZiBhXG4gIC8vLlxuICAvLy4gRmlsdGVycyBpdHMgc2Vjb25kIGFyZ3VtZW50IGluIGFjY29yZGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gcHJlZGljYXRlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgY29uY2F0YF0oI2NvbmNhdCksIFtgZW1wdHlgXSgjZW1wdHkpLFxuICAvLy4gW2BvZmBdKCNvZiksIGFuZCBbYHJlZHVjZWBdKCNyZWR1Y2UpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZmlsdGVyTWBdKCNmaWx0ZXJNKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGZpbHRlcih4ID0+IHggJSAyID09IDEsIFsxLCAyLCAzXSlcbiAgLy8uIFsxLCAzXVxuICAvLy5cbiAgLy8uID4gZmlsdGVyKHggPT4geCAlIDIgPT0gMSwgQ29ucygxLCBDb25zKDIsIENvbnMoMywgTmlsKSkpKVxuICAvLy4gQ29ucygxLCBDb25zKDMsIE5pbCkpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZmlsdGVyKHByZWQsIG0pIHtcbiAgICAvLyAgRmFzdCBwYXRoIGZvciBhcnJheXMuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobSkpIHJldHVybiBtLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiBwcmVkKHgpOyB9KTtcbiAgICB2YXIgTSA9IG0uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIHJlZHVjZShmdW5jdGlvbihtLCB4KSB7IHJldHVybiBwcmVkKHgpID8gY29uY2F0KG0sIG9mKE0sIHgpKSA6IG07IH0sXG4gICAgICAgICAgICAgICAgICBlbXB0eShNKSxcbiAgICAgICAgICAgICAgICAgIG0pO1xuICB9XG5cbiAgLy8jIGZpbHRlck0gOjogKEFsdGVybmF0aXZlIG0sIE1vbmFkIG0pID0+IChhIC0+IEJvb2xlYW4sIG0gYSkgLT4gbSBhXG4gIC8vLlxuICAvLy4gRmlsdGVycyBpdHMgc2Vjb25kIGFyZ3VtZW50IGluIGFjY29yZGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gcHJlZGljYXRlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgb2ZgXSgjb2YpLCBbYGNoYWluYF0oI2NoYWluKSwgYW5kXG4gIC8vLiBbYHplcm9gXSgjemVybykuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BmaWx0ZXJgXSgjZmlsdGVyKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGZpbHRlck0oeCA9PiB4ICUgMiA9PSAxLCBbMSwgMiwgM10pXG4gIC8vLiBbMSwgM11cbiAgLy8uXG4gIC8vLiA+IGZpbHRlck0oeCA9PiB4ICUgMiA9PSAxLCBDb25zKDEsIENvbnMoMiwgQ29ucygzLCBOaWwpKSkpXG4gIC8vLiBDb25zKDEsIENvbnMoMywgTmlsKSlcbiAgLy8uXG4gIC8vLiA+IGZpbHRlck0oeCA9PiB4ICUgMiA9PSAxLCBOb3RoaW5nKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gZmlsdGVyTSh4ID0+IHggJSAyID09IDEsIEp1c3QoMCkpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBmaWx0ZXJNKHggPT4geCAlIDIgPT0gMSwgSnVzdCgxKSlcbiAgLy8uIEp1c3QoMSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBmaWx0ZXJNKHByZWQsIG0pIHtcbiAgICB2YXIgTSA9IG0uY29uc3RydWN0b3I7XG4gICAgdmFyIHogPSB6ZXJvKE0pO1xuICAgIHJldHVybiBjaGFpbihmdW5jdGlvbih4KSB7IHJldHVybiBwcmVkKHgpID8gb2YoTSwgeCkgOiB6OyB9LCBtKTtcbiAgfVxuXG4gIC8vIyBhbHQgOjogQWx0IGYgPT4gKGYgYSwgZiBhKSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9hbHRgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvYWx0YCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogQXJyYXkgYW5kIE9iamVjdC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGFsdChbMSwgMiwgM10sIFs0LCA1LCA2XSlcbiAgLy8uIFsxLCAyLCAzLCA0LCA1LCA2XVxuICAvLy5cbiAgLy8uID4gYWx0KE5vdGhpbmcsIE5vdGhpbmcpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBhbHQoTm90aGluZywgSnVzdCgxKSlcbiAgLy8uIEp1c3QoMSlcbiAgLy8uXG4gIC8vLiA+IGFsdChKdXN0KDIpLCBKdXN0KDMpKVxuICAvLy4gSnVzdCgyKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGFsdCh4LCB5KSB7XG4gICAgcmV0dXJuIEFsdC5tZXRob2RzLmFsdCh4KSh5KTtcbiAgfVxuXG4gIC8vIyB6ZXJvIDo6IFBsdXMgZiA9PiBUeXBlUmVwIGYgLT4gZiBhXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvemVyb2BdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC96ZXJvYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogQXJyYXkgYW5kIE9iamVjdC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHplcm8oQXJyYXkpXG4gIC8vLiBbXVxuICAvLy5cbiAgLy8uID4gemVybyhPYmplY3QpXG4gIC8vLiB7fVxuICAvLy5cbiAgLy8uID4gemVybyhNYXliZSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiB6ZXJvKHR5cGVSZXApIHtcbiAgICByZXR1cm4gUGx1cy5tZXRob2RzLnplcm8odHlwZVJlcCkoKTtcbiAgfVxuXG4gIC8vIyByZWR1Y2UgOjogRm9sZGFibGUgZiA9PiAoKGIsIGEpIC0+IGIsIGIsIGYgYSkgLT4gYlxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL3JlZHVjZWBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9yZWR1Y2VgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBBcnJheSBhbmQgT2JqZWN0LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gcmVkdWNlKCh4cywgeCkgPT4gW3hdLmNvbmNhdCh4cyksIFtdLCBbMSwgMiwgM10pXG4gIC8vLiBbMywgMiwgMV1cbiAgLy8uXG4gIC8vLiA+IHJlZHVjZShjb25jYXQsICcnLCBDb25zKCdmb28nLCBDb25zKCdiYXInLCBDb25zKCdiYXonLCBOaWwpKSkpXG4gIC8vLiAnZm9vYmFyYmF6J1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHJlZHVjZShmLCB4LCBmb2xkYWJsZSkge1xuICAgIHJldHVybiBGb2xkYWJsZS5tZXRob2RzLnJlZHVjZShmb2xkYWJsZSkoZiwgeCk7XG4gIH1cblxuICAvLyMgc2l6ZSA6OiBGb2xkYWJsZSBmID0+IGYgYSAtPiBJbnRlZ2VyXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBzdHJ1Y3R1cmUuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2ByZWR1Y2VgXSgjcmVkdWNlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHNpemUoW10pXG4gIC8vLiAwXG4gIC8vLlxuICAvLy4gPiBzaXplKFsnZm9vJywgJ2JhcicsICdiYXonXSlcbiAgLy8uIDNcbiAgLy8uXG4gIC8vLiA+IHNpemUoTmlsKVxuICAvLy4gMFxuICAvLy5cbiAgLy8uID4gc2l6ZShDb25zKCdmb28nLCBDb25zKCdiYXInLCBDb25zKCdiYXonLCBOaWwpKSkpXG4gIC8vLiAzXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gc2l6ZShmb2xkYWJsZSkge1xuICAgIC8vICBGYXN0IHBhdGggZm9yIGFycmF5cy5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShmb2xkYWJsZSkpIHJldHVybiBmb2xkYWJsZS5sZW5ndGg7XG4gICAgcmV0dXJuIHJlZHVjZShmdW5jdGlvbihuLCBfKSB7IHJldHVybiBuICsgMTsgfSwgMCwgZm9sZGFibGUpO1xuICB9XG5cbiAgLy8jIGVsZW0gOjogKFNldG9pZCBhLCBGb2xkYWJsZSBmKSA9PiAoYSwgZiBhKSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gVGFrZXMgYSB2YWx1ZSBhbmQgYSBzdHJ1Y3R1cmUgYW5kIHJldHVybnMgYHRydWVgIGlmIHRoZVxuICAvLy4gdmFsdWUgaXMgYW4gZWxlbWVudCBvZiB0aGUgc3RydWN0dXJlOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGVxdWFsc2BdKCNlcXVhbHMpIGFuZFxuICAvLy4gW2ByZWR1Y2VgXSgjcmVkdWNlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGVsZW0oJ2MnLCBbJ2EnLCAnYicsICdjJ10pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBlbGVtKCd4JywgWydhJywgJ2InLCAnYyddKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IGVsZW0oMywge3g6IDEsIHk6IDIsIHo6IDN9KVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gZWxlbSg4LCB7eDogMSwgeTogMiwgejogM30pXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gZWxlbSgwLCBKdXN0KDApKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gZWxlbSgwLCBKdXN0KDEpKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IGVsZW0oMCwgTm90aGluZylcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZWxlbSh4LCBmb2xkYWJsZSkge1xuICAgIHJldHVybiByZWR1Y2UoZnVuY3Rpb24oYiwgeSkgeyByZXR1cm4gYiB8fCBlcXVhbHMoeCwgeSk7IH0sXG4gICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIGZvbGRhYmxlKTtcbiAgfVxuXG4gIC8vIyByZXZlcnNlIDo6IChBcHBsaWNhdGl2ZSBmLCBGb2xkYWJsZSBmLCBNb25vaWQgKGYgYSkpID0+IGYgYSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBSZXZlcnNlcyB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHN0cnVjdHVyZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGNvbmNhdGBdKCNjb25jYXQpLCBbYGVtcHR5YF0oI2VtcHR5KSxcbiAgLy8uIFtgb2ZgXSgjb2YpLCBhbmQgW2ByZWR1Y2VgXSgjcmVkdWNlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHJldmVyc2UoWzEsIDIsIDNdKVxuICAvLy4gWzMsIDIsIDFdXG4gIC8vLlxuICAvLy4gPiByZXZlcnNlKENvbnMoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKSlcbiAgLy8uIENvbnMoMywgQ29ucygyLCBDb25zKDEsIE5pbCkpKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHJldmVyc2UoZm9sZGFibGUpIHtcbiAgICAvLyAgRmFzdCBwYXRoIGZvciBhcnJheXMuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm9sZGFibGUpKSByZXR1cm4gZm9sZGFibGUuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgdmFyIEYgPSBmb2xkYWJsZS5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gcmVkdWNlKGZ1bmN0aW9uKHhzLCB4KSB7IHJldHVybiBjb25jYXQob2YoRiwgeCksIHhzKTsgfSxcbiAgICAgICAgICAgICAgICAgIGVtcHR5KEYpLFxuICAgICAgICAgICAgICAgICAgZm9sZGFibGUpO1xuICB9XG5cbiAgLy8jIHNvcnQgOjogKE9yZCBhLCBBcHBsaWNhdGl2ZSBmLCBGb2xkYWJsZSBmLCBNb25vaWQgKGYgYSkpID0+IGYgYSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBQZXJmb3JtcyBhIFtzdGFibGUgc29ydF1bXSBvZiB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHN0cnVjdHVyZSxcbiAgLy8uIHVzaW5nIFtgbHRlYF0oI2x0ZSkgZm9yIGNvbXBhcmlzb25zLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgbHRlYF0oI2x0ZSksIFtgY29uY2F0YF0oI2NvbmNhdCksXG4gIC8vLiBbYGVtcHR5YF0oI2VtcHR5KSwgW2BvZmBdKCNvZiksIGFuZCBbYHJlZHVjZWBdKCNyZWR1Y2UpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgc29ydEJ5YF0oI3NvcnRCeSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBzb3J0KFsnZm9vJywgJ2JhcicsICdiYXonXSlcbiAgLy8uIFsnYmFyJywgJ2JheicsICdmb28nXVxuICAvLy5cbiAgLy8uID4gc29ydChbSnVzdCgyKSwgTm90aGluZywgSnVzdCgxKV0pXG4gIC8vLiBbTm90aGluZywgSnVzdCgxKSwgSnVzdCgyKV1cbiAgLy8uXG4gIC8vLiA+IHNvcnQoQ29ucygnZm9vJywgQ29ucygnYmFyJywgQ29ucygnYmF6JywgTmlsKSkpKVxuICAvLy4gQ29ucygnYmFyJywgQ29ucygnYmF6JywgQ29ucygnZm9vJywgTmlsKSkpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gc29ydChmb2xkYWJsZSkge1xuICAgIHJldHVybiBzb3J0QnkoaWRlbnRpdHksIGZvbGRhYmxlKTtcbiAgfVxuXG4gIC8vIyBzb3J0QnkgOjogKE9yZCBiLCBBcHBsaWNhdGl2ZSBmLCBGb2xkYWJsZSBmLCBNb25vaWQgKGYgYSkpID0+IChhIC0+IGIsIGYgYSkgLT4gZiBhXG4gIC8vLlxuICAvLy4gUGVyZm9ybXMgYSBbc3RhYmxlIHNvcnRdW10gb2YgdGhlIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBzdHJ1Y3R1cmUsXG4gIC8vLiB1c2luZyBbYGx0ZWBdKCNsdGUpIHRvIGNvbXBhcmUgdGhlIHZhbHVlcyBwcm9kdWNlZCBieSBhcHBseWluZyB0aGVcbiAgLy8uIGdpdmVuIGZ1bmN0aW9uIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgc3RydWN0dXJlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgbHRlYF0oI2x0ZSksIFtgY29uY2F0YF0oI2NvbmNhdCksXG4gIC8vLiBbYGVtcHR5YF0oI2VtcHR5KSwgW2BvZmBdKCNvZiksIGFuZCBbYHJlZHVjZWBdKCNyZWR1Y2UpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgc29ydGBdKCNzb3J0KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHNvcnRCeShzID0+IHMubGVuZ3RoLCBbJ3JlZCcsICdncmVlbicsICdibHVlJ10pXG4gIC8vLiBbJ3JlZCcsICdibHVlJywgJ2dyZWVuJ11cbiAgLy8uXG4gIC8vLiA+IHNvcnRCeShzID0+IHMubGVuZ3RoLCBbJ2JsYWNrJywgJ3doaXRlJ10pXG4gIC8vLiBbJ2JsYWNrJywgJ3doaXRlJ11cbiAgLy8uXG4gIC8vLiA+IHNvcnRCeShzID0+IHMubGVuZ3RoLCBbJ3doaXRlJywgJ2JsYWNrJ10pXG4gIC8vLiBbJ3doaXRlJywgJ2JsYWNrJ11cbiAgLy8uXG4gIC8vLiA+IHNvcnRCeShzID0+IHMubGVuZ3RoLCBDb25zKCdyZWQnLCBDb25zKCdncmVlbicsIENvbnMoJ2JsdWUnLCBOaWwpKSkpXG4gIC8vLiBDb25zKCdyZWQnLCBDb25zKCdibHVlJywgQ29ucygnZ3JlZW4nLCBOaWwpKSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBzb3J0QnkoZiwgZm9sZGFibGUpIHtcbiAgICB2YXIgcnMgPSByZWR1Y2UoZnVuY3Rpb24oeHMsIHgpIHtcbiAgICAgIHZhciBmeCA9IGYoeCk7XG4gICAgICB2YXIgbG93ZXIgPSAwO1xuICAgICAgdmFyIHVwcGVyID0geHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxvd2VyIDwgdXBwZXIpIHtcbiAgICAgICAgdmFyIGlkeCA9IE1hdGguZmxvb3IoKGxvd2VyICsgdXBwZXIpIC8gMik7XG4gICAgICAgIGlmIChsdGUoeHNbaWR4XS5meCwgZngpKSBsb3dlciA9IGlkeCArIDE7IGVsc2UgdXBwZXIgPSBpZHg7XG4gICAgICB9XG4gICAgICB4cy5zcGxpY2UobG93ZXIsIDAsIHt4OiB4LCBmeDogZnh9KTtcbiAgICAgIHJldHVybiB4cztcbiAgICB9LCBbXSwgZm9sZGFibGUpO1xuXG4gICAgdmFyIEYgPSBmb2xkYWJsZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcmVzdWx0ID0gZW1wdHkoRik7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgcnMubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgICAgcmVzdWx0ID0gY29uY2F0KHJlc3VsdCwgb2YoRiwgcnNbaWR4XS54KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyMgdGFrZVdoaWxlIDo6IChBcHBsaWNhdGl2ZSBmLCBGb2xkYWJsZSBmLCBNb25vaWQgKGYgYSkpID0+IChhIC0+IEJvb2xlYW4sIGYgYSkgLT4gZiBhXG4gIC8vLlxuICAvLy4gRGlzY2FyZHMgdGhlIGZpcnN0IGlubmVyIHZhbHVlIHdoaWNoIGRvZXMgbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZSwgYW5kXG4gIC8vLiBhbGwgc3Vic2VxdWVudCBpbm5lciB2YWx1ZXMuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2Bjb25jYXRgXSgjY29uY2F0KSwgW2BlbXB0eWBdKCNlbXB0eSksXG4gIC8vLiBbYG9mYF0oI29mKSwgYW5kIFtgcmVkdWNlYF0oI3JlZHVjZSkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2Bkcm9wV2hpbGVgXSgjZHJvcFdoaWxlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHRha2VXaGlsZShzID0+IC94Ly50ZXN0KHMpLCBbJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5J10pXG4gIC8vLiBbJ3h5JywgJ3h6JywgJ3l4J11cbiAgLy8uXG4gIC8vLiA+IHRha2VXaGlsZShzID0+IC95Ly50ZXN0KHMpLCBbJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5J10pXG4gIC8vLiBbJ3h5J11cbiAgLy8uXG4gIC8vLiA+IHRha2VXaGlsZShzID0+IC96Ly50ZXN0KHMpLCBbJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5J10pXG4gIC8vLiBbXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHRha2VXaGlsZShwcmVkLCBmb2xkYWJsZSkge1xuICAgIHZhciB0YWtlID0gdHJ1ZTtcbiAgICByZXR1cm4gZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHRha2UgPSB0YWtlICYmIHByZWQoeCk7IH0sIGZvbGRhYmxlKTtcbiAgfVxuXG4gIC8vIyBkcm9wV2hpbGUgOjogKEFwcGxpY2F0aXZlIGYsIEZvbGRhYmxlIGYsIE1vbm9pZCAoZiBhKSkgPT4gKGEgLT4gQm9vbGVhbiwgZiBhKSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBSZXRhaW5zIHRoZSBmaXJzdCBpbm5lciB2YWx1ZSB3aGljaCBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUsIGFuZFxuICAvLy4gYWxsIHN1YnNlcXVlbnQgaW5uZXIgdmFsdWVzLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgY29uY2F0YF0oI2NvbmNhdCksIFtgZW1wdHlgXSgjZW1wdHkpLFxuICAvLy4gW2BvZmBdKCNvZiksIGFuZCBbYHJlZHVjZWBdKCNyZWR1Y2UpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgdGFrZVdoaWxlYF0oI3Rha2VXaGlsZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBkcm9wV2hpbGUocyA9PiAveC8udGVzdChzKSwgWyd4eScsICd4eicsICd5eCcsICd5eicsICd6eCcsICd6eSddKVxuICAvLy4gWyd5eicsICd6eCcsICd6eSddXG4gIC8vLlxuICAvLy4gPiBkcm9wV2hpbGUocyA9PiAveS8udGVzdChzKSwgWyd4eScsICd4eicsICd5eCcsICd5eicsICd6eCcsICd6eSddKVxuICAvLy4gWyd4eicsICd5eCcsICd5eicsICd6eCcsICd6eSddXG4gIC8vLlxuICAvLy4gPiBkcm9wV2hpbGUocyA9PiAvei8udGVzdChzKSwgWyd4eScsICd4eicsICd5eCcsICd5eicsICd6eCcsICd6eSddKVxuICAvLy4gWyd4eScsICd4eicsICd5eCcsICd5eicsICd6eCcsICd6eSddXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZHJvcFdoaWxlKHByZWQsIGZvbGRhYmxlKSB7XG4gICAgdmFyIHRha2UgPSBmYWxzZTtcbiAgICByZXR1cm4gZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHRha2UgPSB0YWtlIHx8ICFwcmVkKHgpOyB9LCBmb2xkYWJsZSk7XG4gIH1cblxuICAvLyMgdHJhdmVyc2UgOjogKEFwcGxpY2F0aXZlIGYsIFRyYXZlcnNhYmxlIHQpID0+IChUeXBlUmVwIGYsIGEgLT4gZiBiLCB0IGEpIC0+IGYgKHQgYilcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC90cmF2ZXJzZWBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC90cmF2ZXJzZWAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEFycmF5IGFuZCBPYmplY3QuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BzZXF1ZW5jZWBdKCNzZXF1ZW5jZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiB0cmF2ZXJzZShBcnJheSwgeCA9PiB4LCBbWzEsIDIsIDNdLCBbNCwgNV1dKVxuICAvLy4gW1sxLCA0XSwgWzEsIDVdLCBbMiwgNF0sIFsyLCA1XSwgWzMsIDRdLCBbMywgNV1dXG4gIC8vLlxuICAvLy4gPiB0cmF2ZXJzZShJZGVudGl0eSwgeCA9PiBJZGVudGl0eSh4ICsgMSksIFsxLCAyLCAzXSlcbiAgLy8uIElkZW50aXR5KFsyLCAzLCA0XSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiB0cmF2ZXJzZSh0eXBlUmVwLCBmLCB0cmF2ZXJzYWJsZSkge1xuICAgIHJldHVybiBUcmF2ZXJzYWJsZS5tZXRob2RzLnRyYXZlcnNlKHRyYXZlcnNhYmxlKSh0eXBlUmVwLCBmKTtcbiAgfVxuXG4gIC8vIyBzZXF1ZW5jZSA6OiAoQXBwbGljYXRpdmUgZiwgVHJhdmVyc2FibGUgdCkgPT4gKFR5cGVSZXAgZiwgdCAoZiBhKSkgLT4gZiAodCBhKVxuICAvLy5cbiAgLy8uIEludmVydHMgdGhlIGdpdmVuIGB0IChmIGEpYCB0byBwcm9kdWNlIGFuIGBmICh0IGEpYC5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYHRyYXZlcnNlYF0oI3RyYXZlcnNlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHNlcXVlbmNlKEFycmF5LCBJZGVudGl0eShbMSwgMiwgM10pKVxuICAvLy4gW0lkZW50aXR5KDEpLCBJZGVudGl0eSgyKSwgSWRlbnRpdHkoMyldXG4gIC8vLlxuICAvLy4gPiBzZXF1ZW5jZShJZGVudGl0eSwgW0lkZW50aXR5KDEpLCBJZGVudGl0eSgyKSwgSWRlbnRpdHkoMyldKVxuICAvLy4gSWRlbnRpdHkoWzEsIDIsIDNdKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHNlcXVlbmNlKHR5cGVSZXAsIHRyYXZlcnNhYmxlKSB7XG4gICAgcmV0dXJuIHRyYXZlcnNlKHR5cGVSZXAsIGlkZW50aXR5LCB0cmF2ZXJzYWJsZSk7XG4gIH1cblxuICAvLyMgZXh0ZW5kIDo6IEV4dGVuZCB3ID0+ICh3IGEgLT4gYiwgdyBhKSAtPiB3IGJcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9leHRlbmRgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvZXh0ZW5kYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogQXJyYXkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBleHRlbmQoc3MgPT4gc3Muam9pbignJyksIFsneCcsICd5JywgJ3onXSlcbiAgLy8uIFsneHl6JywgJ3l6JywgJ3onXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGV4dGVuZChmLCBleHRlbmRfKSB7XG4gICAgcmV0dXJuIEV4dGVuZC5tZXRob2RzLmV4dGVuZChleHRlbmRfKShmKTtcbiAgfVxuXG4gIC8vIyBleHRyYWN0IDo6IENvbW9uYWQgdyA9PiB3IGEgLT4gYVxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2V4dHJhY3RgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZXh0cmFjdChJZGVudGl0eSg0MikpXG4gIC8vLiA0MlxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGV4dHJhY3QoY29tb25hZCkge1xuICAgIHJldHVybiBDb21vbmFkLm1ldGhvZHMuZXh0cmFjdChjb21vbmFkKSgpO1xuICB9XG5cbiAgLy8jIGNvbnRyYW1hcCA6OiBDb250cmF2YXJpYW50IGYgPT4gKGIgLT4gYSwgZiBhKSAtPiBmIGJcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9jb250cmFtYXBgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvY29udHJhbWFwYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogRnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBjb250cmFtYXAocyA9PiBzLmxlbmd0aCwgTWF0aC5zcXJ0KSgnU2FuY3R1YXJ5JylcbiAgLy8uIDNcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBjb250cmFtYXAoZiwgY29udHJhdmFyaWFudCkge1xuICAgIHJldHVybiBDb250cmF2YXJpYW50Lm1ldGhvZHMuY29udHJhbWFwKGNvbnRyYXZhcmlhbnQpKGYpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBUeXBlQ2xhc3M6IFR5cGVDbGFzcyxcbiAgICBTZXRvaWQ6IFNldG9pZCxcbiAgICBPcmQ6IE9yZCxcbiAgICBTZW1pZ3JvdXBvaWQ6IFNlbWlncm91cG9pZCxcbiAgICBDYXRlZ29yeTogQ2F0ZWdvcnksXG4gICAgU2VtaWdyb3VwOiBTZW1pZ3JvdXAsXG4gICAgTW9ub2lkOiBNb25vaWQsXG4gICAgR3JvdXA6IEdyb3VwLFxuICAgIEZ1bmN0b3I6IEZ1bmN0b3IsXG4gICAgQmlmdW5jdG9yOiBCaWZ1bmN0b3IsXG4gICAgUHJvZnVuY3RvcjogUHJvZnVuY3RvcixcbiAgICBBcHBseTogQXBwbHksXG4gICAgQXBwbGljYXRpdmU6IEFwcGxpY2F0aXZlLFxuICAgIENoYWluOiBDaGFpbixcbiAgICBDaGFpblJlYzogQ2hhaW5SZWMsXG4gICAgTW9uYWQ6IE1vbmFkLFxuICAgIEFsdDogQWx0LFxuICAgIFBsdXM6IFBsdXMsXG4gICAgQWx0ZXJuYXRpdmU6IEFsdGVybmF0aXZlLFxuICAgIEZvbGRhYmxlOiBGb2xkYWJsZSxcbiAgICBUcmF2ZXJzYWJsZTogVHJhdmVyc2FibGUsXG4gICAgRXh0ZW5kOiBFeHRlbmQsXG4gICAgQ29tb25hZDogQ29tb25hZCxcbiAgICBDb250cmF2YXJpYW50OiBDb250cmF2YXJpYW50LFxuICAgIHRvU3RyaW5nOiB0b1N0cmluZyxcbiAgICBlcXVhbHM6IGVxdWFscyxcbiAgICBsdDogbHQsXG4gICAgbHRlOiBsdGUsXG4gICAgZ3Q6IGd0LFxuICAgIGd0ZTogZ3RlLFxuICAgIG1pbjogbWluLFxuICAgIG1heDogbWF4LFxuICAgIGNvbXBvc2U6IGNvbXBvc2UsXG4gICAgaWQ6IGlkLFxuICAgIGNvbmNhdDogY29uY2F0LFxuICAgIGVtcHR5OiBlbXB0eSxcbiAgICBpbnZlcnQ6IGludmVydCxcbiAgICBtYXA6IG1hcCxcbiAgICBiaW1hcDogYmltYXAsXG4gICAgcHJvbWFwOiBwcm9tYXAsXG4gICAgYXA6IGFwLFxuICAgIGxpZnQyOiBsaWZ0MixcbiAgICBsaWZ0MzogbGlmdDMsXG4gICAgYXBGaXJzdDogYXBGaXJzdCxcbiAgICBhcFNlY29uZDogYXBTZWNvbmQsXG4gICAgb2Y6IG9mLFxuICAgIGFwcGVuZDogYXBwZW5kLFxuICAgIHByZXBlbmQ6IHByZXBlbmQsXG4gICAgY2hhaW46IGNoYWluLFxuICAgIGpvaW46IGpvaW4sXG4gICAgY2hhaW5SZWM6IGNoYWluUmVjLFxuICAgIGZpbHRlcjogZmlsdGVyLFxuICAgIGZpbHRlck06IGZpbHRlck0sXG4gICAgYWx0OiBhbHQsXG4gICAgemVybzogemVybyxcbiAgICByZWR1Y2U6IHJlZHVjZSxcbiAgICBzaXplOiBzaXplLFxuICAgIGVsZW06IGVsZW0sXG4gICAgcmV2ZXJzZTogcmV2ZXJzZSxcbiAgICBzb3J0OiBzb3J0LFxuICAgIHNvcnRCeTogc29ydEJ5LFxuICAgIHRha2VXaGlsZTogdGFrZVdoaWxlLFxuICAgIGRyb3BXaGlsZTogZHJvcFdoaWxlLFxuICAgIHRyYXZlcnNlOiB0cmF2ZXJzZSxcbiAgICBzZXF1ZW5jZTogc2VxdWVuY2UsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgZXh0cmFjdDogZXh0cmFjdCxcbiAgICBjb250cmFtYXA6IGNvbnRyYW1hcFxuICB9O1xuXG59KSk7XG5cbi8vLiBbQWx0XTogICAgICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhbHRcbi8vLiBbQWx0ZXJuYXRpdmVdOiAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhbHRlcm5hdGl2ZVxuLy8uIFtBcHBsaWNhdGl2ZV06ICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FwcGxpY2F0aXZlXG4vLy4gW0FwcGx5XTogICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYXBwbHlcbi8vLiBbQmlmdW5jdG9yXTogICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNiaWZ1bmN0b3Jcbi8vLiBbQ2F0ZWdvcnldOiAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjYXRlZ29yeVxuLy8uIFtDaGFpbl06ICAgICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NoYWluXG4vLy4gW0NoYWluUmVjXTogICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjY2hhaW5yZWNcbi8vLiBbQ29tb25hZF06ICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjb21vbmFkXG4vLy4gW0NvbnRyYXZhcmlhbnRdOiAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjY29udHJhdmFyaWFudFxuLy8uIFtFeHRlbmRdOiAgICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2V4dGVuZFxuLy8uIFtGTF06ICAgICAgICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kXG4vLy4gW0ZvbGRhYmxlXTogICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZm9sZGFibGVcbi8vLiBbRnVuY3Rvcl06ICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNmdW5jdG9yXG4vLy4gW0dyb3VwXTogICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZ3JvdXBcbi8vLiBbTW9uYWRdOiAgICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNtb25hZFxuLy8uIFtNb25vaWRdOiAgICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI21vbm9pZFxuLy8uIFtPcmRdOiAgICAgICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI29yZFxuLy8uIFtQbHVzXTogICAgICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3BsdXNcbi8vLiBbUHJvZnVuY3Rvcl06ICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNwcm9mdW5jdG9yXG4vLy4gW1NlbWlncm91cF06ICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjc2VtaWdyb3VwXG4vLy4gW1NlbWlncm91cG9pZF06ICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjc2VtaWdyb3Vwb2lkXG4vLy4gW1NldG9pZF06ICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjc2V0b2lkXG4vLy4gW1RyYXZlcnNhYmxlXTogICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjdHJhdmVyc2FibGVcbi8vLiBbYGZhbnRhc3ktbGFuZC9hbHRgXTogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhbHQtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvYXBgXTogICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYXAtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvYmltYXBgXTogICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYmltYXAtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvY2hhaW5gXTogICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjY2hhaW4tbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvY2hhaW5SZWNgXTogIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjY2hhaW5yZWMtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvY29tcG9zZWBdOiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjY29tcG9zZS1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9jb25jYXRgXTogICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjb25jYXQtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvY29udHJhbWFwYF06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjY29udHJhbWFwLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2VtcHR5YF06ICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2VtcHR5LW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2VxdWFsc2BdOiAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2VxdWFscy1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9leHRlbmRgXTogICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNleHRlbmQtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvZXh0cmFjdGBdOiAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZXh0cmFjdC1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9pZGBdOiAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNpZC1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9pbnZlcnRgXTogICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNpbnZlcnQtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvbHRlYF06ICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjbHRlLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL21hcGBdOiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI21hcC1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9vZmBdOiAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNvZi1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9wcm9tYXBgXTogICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNwcm9tYXAtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvcmVkdWNlYF06ICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjcmVkdWNlLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL3RyYXZlcnNlYF06ICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3RyYXZlcnNlLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL3plcm9gXTogICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3plcm8tbWV0aG9kXG4vLy4gW3N0YWJsZSBzb3J0XTogICAgICAgICAgICAgIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NvcnRpbmdfYWxnb3JpdGhtI1N0YWJpbGl0eVxuLy8uIFt0eXBlLWNsYXNzZXNdOiAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vc2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS1kZWYjdHlwZS1jbGFzc2VzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zYW5jdHVhcnktZGVmL25vZGVfbW9kdWxlcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n        @@@@@@@            @@@@@@@         @@\n      @@       @@        @@       @@      @@@\n    @@   @@@ @@  @@    @@   @@@ @@  @@   @@@@@@ @@   @@@  @@ @@@      @@@@\n   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@   @@\n   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@@@@@@\n   @@  @@   @@@  @@   @@  @@   @@@  @@    @@@   @@   @@@  @@@   @@  @@@\n    @@   @@@ @@@@@     @@   @@@ @@@@@      @@@    @@@ @@  @@@@@@      @@@@@\n      @@                 @@                           @@  @@\n        @@@@@@@            @@@@@@@               @@@@@    @@\n                                                          */\n//. # sanctuary-type-identifiers\n//.\n//. A type is a set of values. Boolean, for example, is the type comprising\n//. `true` and `false`. A value may be a member of multiple types (`42` is a\n//. member of Number, PositiveNumber, Integer, and many other types).\n//.\n//. In certain situations it is useful to divide JavaScript values into\n//. non-overlapping types. The language provides two constructs for this\n//. purpose: the [`typeof`][1] operator and [`Object.prototype.toString`][2].\n//. Each has pros and cons, but neither supports user-defined types.\n//.\n//. This package specifies an [algorithm][3] for deriving a _type identifier_\n//. from any JavaScript value, and exports an implementation of the algorithm.\n//. Authors of algebraic data types may follow this specification in order to\n//. make their data types compatible with the algorithm.\n//.\n//. ### Algorithm\n//.\n//. 1.  Take any JavaScript value `x`.\n//.\n//. 2.  If `x` is `null` or `undefined`, go to step 6.\n//.\n//. 3.  If `x.constructor` evaluates to `null` or `undefined`, go to step 6.\n//.\n//. 4.  If `x.constructor.prototype === x`, go to step 6. This check prevents a\n//.     prototype object from being considered a member of its associated type.\n//.\n//. 5.  If `typeof x.constructor['@@type']` evaluates to `'string'`, return\n//.     the value of `x.constructor['@@type']`.\n//.\n//. 6.  Return the [`Object.prototype.toString`][2] representation of `x`\n//.     without the leading `'[object '` and trailing `']'`.\n//.\n//. ### Compatibility\n//.\n//. For an algebraic data type to be compatible with the [algorithm][3]:\n//.\n//.   - every member of the type must have a `constructor` property pointing\n//.     to an object known as the _type representative_;\n//.\n//.   - the type representative must have a `@@type` property; and\n//.\n//.   - the type representative's `@@type` property (the _type identifier_)\n//.     must be a string primitive, ideally `'<npm-package-name>/<type-name>'`.\n//.\n//. For example:\n//.\n//. ```javascript\n//. //  Identity :: a -> Identity a\n//. function Identity(x) {\n//.   if (!(this instanceof Identity)) return new Identity(x);\n//.   this.value = x;\n//. }\n//.\n//. Identity['@@type'] = 'my-package/Identity';\n//. ```\n//.\n//. Note that by using a constructor function the `constructor` property is set\n//. implicitly for each value created. Constructor functions are convenient for\n//. this reason, but are not required. This definition is also valid:\n//.\n//. ```javascript\n//. //  IdentityTypeRep :: TypeRep Identity\n//. var IdentityTypeRep = {\n//.   '@@type': 'my-package/Identity'\n//. };\n//.\n//. //  Identity :: a -> Identity a\n//. function Identity(x) {\n//.   return {constructor: IdentityTypeRep, value: x};\n//. }\n//. ```\n//.\n//. ### Usage\n//.\n//. ```javascript\n//. var Identity = require('my-package').Identity;\n//. var type = require('sanctuary-type-identifiers');\n//.\n//. type(null);         // => 'Null'\n//. type(true);         // => 'Boolean'\n//. type([1, 2, 3]);    // => 'Array'\n//. type(Identity);     // => 'Function'\n//. type(Identity(0));  // => 'my-package/Identity'\n//. ```\n//.\n//.\n//. [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\n//. [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n//. [3]: #algorithm\n\n(function(f) {\n\n  'use strict';\n\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f();\n  } else if (\"function\" === 'function' && __webpack_require__(0) != null) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {\n    self.sanctuaryTypeIdentifiers = f();\n  }\n\n}(function() {\n\n  'use strict';\n\n  //  $$type :: String\n  var $$type = '@@type';\n\n  //  type :: Any -> String\n  function type(x) {\n    return x != null &&\n           x.constructor != null &&\n           x.constructor.prototype !== x &&\n           typeof x.constructor[$$type] === 'string' ?\n      x.constructor[$$type] :\n      Object.prototype.toString.call(x).slice('[object '.length, -']'.length);\n  }\n\n  return type;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5LWRlZi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5LXR5cGUtY2xhc3Nlcy9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMvaW5kZXguanM/MWMwYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICAgICAgICBAQEBAQEBAICAgICAgICAgICAgQEBAQEBAQCAgICAgICAgIEBAXG4gICAgICBAQCAgICAgICBAQCAgICAgICAgQEAgICAgICAgQEAgICAgICBAQEBcbiAgICBAQCAgIEBAQCBAQCAgQEAgICAgQEAgICBAQEAgQEAgIEBAICAgQEBAQEBAIEBAICAgQEBAICBAQCBAQEAgICAgICBAQEBAXG4gICBAQCAgQEAgICBAQEAgICBAQCAgQEAgIEBAICAgQEBAICAgQEAgICBAQEAgICBAQCAgIEBAQCAgQEBAICAgQEAgIEBAQCAgIEBAXG4gICBAQCAgQEAgICBAQEAgICBAQCAgQEAgIEBAICAgQEBAICAgQEAgICBAQEAgICBAQCAgIEBAQCAgQEBAICAgQEAgIEBAQEBAQEBAXG4gICBAQCAgQEAgICBAQEAgIEBAICAgQEAgIEBAICAgQEBAICBAQCAgICBAQEAgICBAQCAgIEBAQCAgQEBAICAgQEAgIEBAQFxuICAgIEBAICAgQEBAIEBAQEBAICAgICBAQCAgIEBAQCBAQEBAQCAgICAgIEBAQCAgICBAQEAgQEAgIEBAQEBAQCAgICAgIEBAQEBAXG4gICAgICBAQCAgICAgICAgICAgICAgICAgQEAgICAgICAgICAgICAgICAgICAgICAgICAgICBAQCAgQEBcbiAgICAgICAgQEBAQEBAQCAgICAgICAgICAgIEBAQEBAQEAgICAgICAgICAgICAgICBAQEBAQCAgICBAQFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vLy4gIyBzYW5jdHVhcnktdHlwZS1pZGVudGlmaWVyc1xuLy8uXG4vLy4gQSB0eXBlIGlzIGEgc2V0IG9mIHZhbHVlcy4gQm9vbGVhbiwgZm9yIGV4YW1wbGUsIGlzIHRoZSB0eXBlIGNvbXByaXNpbmdcbi8vLiBgdHJ1ZWAgYW5kIGBmYWxzZWAuIEEgdmFsdWUgbWF5IGJlIGEgbWVtYmVyIG9mIG11bHRpcGxlIHR5cGVzIChgNDJgIGlzIGFcbi8vLiBtZW1iZXIgb2YgTnVtYmVyLCBQb3NpdGl2ZU51bWJlciwgSW50ZWdlciwgYW5kIG1hbnkgb3RoZXIgdHlwZXMpLlxuLy8uXG4vLy4gSW4gY2VydGFpbiBzaXR1YXRpb25zIGl0IGlzIHVzZWZ1bCB0byBkaXZpZGUgSmF2YVNjcmlwdCB2YWx1ZXMgaW50b1xuLy8uIG5vbi1vdmVybGFwcGluZyB0eXBlcy4gVGhlIGxhbmd1YWdlIHByb3ZpZGVzIHR3byBjb25zdHJ1Y3RzIGZvciB0aGlzXG4vLy4gcHVycG9zZTogdGhlIFtgdHlwZW9mYF1bMV0gb3BlcmF0b3IgYW5kIFtgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2BdWzJdLlxuLy8uIEVhY2ggaGFzIHByb3MgYW5kIGNvbnMsIGJ1dCBuZWl0aGVyIHN1cHBvcnRzIHVzZXItZGVmaW5lZCB0eXBlcy5cbi8vLlxuLy8uIFRoaXMgcGFja2FnZSBzcGVjaWZpZXMgYW4gW2FsZ29yaXRobV1bM10gZm9yIGRlcml2aW5nIGEgX3R5cGUgaWRlbnRpZmllcl9cbi8vLiBmcm9tIGFueSBKYXZhU2NyaXB0IHZhbHVlLCBhbmQgZXhwb3J0cyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYWxnb3JpdGhtLlxuLy8uIEF1dGhvcnMgb2YgYWxnZWJyYWljIGRhdGEgdHlwZXMgbWF5IGZvbGxvdyB0aGlzIHNwZWNpZmljYXRpb24gaW4gb3JkZXIgdG9cbi8vLiBtYWtlIHRoZWlyIGRhdGEgdHlwZXMgY29tcGF0aWJsZSB3aXRoIHRoZSBhbGdvcml0aG0uXG4vLy5cbi8vLiAjIyMgQWxnb3JpdGhtXG4vLy5cbi8vLiAxLiAgVGFrZSBhbnkgSmF2YVNjcmlwdCB2YWx1ZSBgeGAuXG4vLy5cbi8vLiAyLiAgSWYgYHhgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgZ28gdG8gc3RlcCA2LlxuLy8uXG4vLy4gMy4gIElmIGB4LmNvbnN0cnVjdG9yYCBldmFsdWF0ZXMgdG8gYG51bGxgIG9yIGB1bmRlZmluZWRgLCBnbyB0byBzdGVwIDYuXG4vLy5cbi8vLiA0LiAgSWYgYHguY29uc3RydWN0b3IucHJvdG90eXBlID09PSB4YCwgZ28gdG8gc3RlcCA2LiBUaGlzIGNoZWNrIHByZXZlbnRzIGFcbi8vLiAgICAgcHJvdG90eXBlIG9iamVjdCBmcm9tIGJlaW5nIGNvbnNpZGVyZWQgYSBtZW1iZXIgb2YgaXRzIGFzc29jaWF0ZWQgdHlwZS5cbi8vLlxuLy8uIDUuICBJZiBgdHlwZW9mIHguY29uc3RydWN0b3JbJ0BAdHlwZSddYCBldmFsdWF0ZXMgdG8gYCdzdHJpbmcnYCwgcmV0dXJuXG4vLy4gICAgIHRoZSB2YWx1ZSBvZiBgeC5jb25zdHJ1Y3RvclsnQEB0eXBlJ11gLlxuLy8uXG4vLy4gNi4gIFJldHVybiB0aGUgW2BPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYF1bMl0gcmVwcmVzZW50YXRpb24gb2YgYHhgXG4vLy4gICAgIHdpdGhvdXQgdGhlIGxlYWRpbmcgYCdbb2JqZWN0ICdgIGFuZCB0cmFpbGluZyBgJ10nYC5cbi8vLlxuLy8uICMjIyBDb21wYXRpYmlsaXR5XG4vLy5cbi8vLiBGb3IgYW4gYWxnZWJyYWljIGRhdGEgdHlwZSB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlIFthbGdvcml0aG1dWzNdOlxuLy8uXG4vLy4gICAtIGV2ZXJ5IG1lbWJlciBvZiB0aGUgdHlwZSBtdXN0IGhhdmUgYSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHBvaW50aW5nXG4vLy4gICAgIHRvIGFuIG9iamVjdCBrbm93biBhcyB0aGUgX3R5cGUgcmVwcmVzZW50YXRpdmVfO1xuLy8uXG4vLy4gICAtIHRoZSB0eXBlIHJlcHJlc2VudGF0aXZlIG11c3QgaGF2ZSBhIGBAQHR5cGVgIHByb3BlcnR5OyBhbmRcbi8vLlxuLy8uICAgLSB0aGUgdHlwZSByZXByZXNlbnRhdGl2ZSdzIGBAQHR5cGVgIHByb3BlcnR5ICh0aGUgX3R5cGUgaWRlbnRpZmllcl8pXG4vLy4gICAgIG11c3QgYmUgYSBzdHJpbmcgcHJpbWl0aXZlLCBpZGVhbGx5IGAnPG5wbS1wYWNrYWdlLW5hbWU+Lzx0eXBlLW5hbWU+J2AuXG4vLy5cbi8vLiBGb3IgZXhhbXBsZTpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiAvLyAgSWRlbnRpdHkgOjogYSAtPiBJZGVudGl0eSBhXG4vLy4gZnVuY3Rpb24gSWRlbnRpdHkoeCkge1xuLy8uICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIElkZW50aXR5KSkgcmV0dXJuIG5ldyBJZGVudGl0eSh4KTtcbi8vLiAgIHRoaXMudmFsdWUgPSB4O1xuLy8uIH1cbi8vLlxuLy8uIElkZW50aXR5WydAQHR5cGUnXSA9ICdteS1wYWNrYWdlL0lkZW50aXR5Jztcbi8vLiBgYGBcbi8vLlxuLy8uIE5vdGUgdGhhdCBieSB1c2luZyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGlzIHNldFxuLy8uIGltcGxpY2l0bHkgZm9yIGVhY2ggdmFsdWUgY3JlYXRlZC4gQ29uc3RydWN0b3IgZnVuY3Rpb25zIGFyZSBjb252ZW5pZW50IGZvclxuLy8uIHRoaXMgcmVhc29uLCBidXQgYXJlIG5vdCByZXF1aXJlZC4gVGhpcyBkZWZpbml0aW9uIGlzIGFsc28gdmFsaWQ6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gLy8gIElkZW50aXR5VHlwZVJlcCA6OiBUeXBlUmVwIElkZW50aXR5XG4vLy4gdmFyIElkZW50aXR5VHlwZVJlcCA9IHtcbi8vLiAgICdAQHR5cGUnOiAnbXktcGFja2FnZS9JZGVudGl0eSdcbi8vLiB9O1xuLy8uXG4vLy4gLy8gIElkZW50aXR5IDo6IGEgLT4gSWRlbnRpdHkgYVxuLy8uIGZ1bmN0aW9uIElkZW50aXR5KHgpIHtcbi8vLiAgIHJldHVybiB7Y29uc3RydWN0b3I6IElkZW50aXR5VHlwZVJlcCwgdmFsdWU6IHh9O1xuLy8uIH1cbi8vLiBgYGBcbi8vLlxuLy8uICMjIyBVc2FnZVxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIHZhciBJZGVudGl0eSA9IHJlcXVpcmUoJ215LXBhY2thZ2UnKS5JZGVudGl0eTtcbi8vLiB2YXIgdHlwZSA9IHJlcXVpcmUoJ3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzJyk7XG4vLy5cbi8vLiB0eXBlKG51bGwpOyAgICAgICAgIC8vID0+ICdOdWxsJ1xuLy8uIHR5cGUodHJ1ZSk7ICAgICAgICAgLy8gPT4gJ0Jvb2xlYW4nXG4vLy4gdHlwZShbMSwgMiwgM10pOyAgICAvLyA9PiAnQXJyYXknXG4vLy4gdHlwZShJZGVudGl0eSk7ICAgICAvLyA9PiAnRnVuY3Rpb24nXG4vLy4gdHlwZShJZGVudGl0eSgwKSk7ICAvLyA9PiAnbXktcGFja2FnZS9JZGVudGl0eSdcbi8vLiBgYGBcbi8vLlxuLy8uXG4vLy4gWzFdOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvdHlwZW9mXG4vLy4gWzJdOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvdG9TdHJpbmdcbi8vLiBbM106ICNhbGdvcml0aG1cblxuKGZ1bmN0aW9uKGYpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGYoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgIT0gbnVsbCkge1xuICAgIGRlZmluZShbXSwgZik7XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5zYW5jdHVhcnlUeXBlSWRlbnRpZmllcnMgPSBmKCk7XG4gIH1cblxufShmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gICQkdHlwZSA6OiBTdHJpbmdcbiAgdmFyICQkdHlwZSA9ICdAQHR5cGUnO1xuXG4gIC8vICB0eXBlIDo6IEFueSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gdHlwZSh4KSB7XG4gICAgcmV0dXJuIHggIT0gbnVsbCAmJlxuICAgICAgICAgICB4LmNvbnN0cnVjdG9yICE9IG51bGwgJiZcbiAgICAgICAgICAgeC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgIT09IHggJiZcbiAgICAgICAgICAgdHlwZW9mIHguY29uc3RydWN0b3JbJCR0eXBlXSA9PT0gJ3N0cmluZycgP1xuICAgICAgeC5jb25zdHJ1Y3RvclskJHR5cGVdIDpcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KS5zbGljZSgnW29iamVjdCAnLmxlbmd0aCwgLSddJy5sZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIHR5cGU7XG5cbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NhbmN0dWFyeS1kZWYvbm9kZV9tb2R1bGVzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMvbm9kZV9tb2R1bGVzL3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n             ############                  #\n            ############                  ###\n                  #####                  #####\n                #####      ####################\n              #####       ######################\n            #####                     ###########\n          #####         ######################\n        #####          ####################\n      #####                        #####\n     ############                 ###\n    ############                 */\n\n//. # sanctuary-type-classes\n//.\n//. The [Fantasy Land Specification][FL] \"specifies interoperability of common\n//. algebraic structures\" by defining a number of type classes. For each type\n//. class, it states laws which every member of a type must obey in order for\n//. the type to be a member of the type class. In order for the Maybe type to\n//. be considered a [Functor][], for example, every `Maybe a` value must have\n//. a `fantasy-land/map` method which obeys the identity and composition laws.\n//.\n//. This project provides:\n//.\n//.   - [`TypeClass`](#TypeClass), a function for defining type classes;\n//.   - one `TypeClass` value for each Fantasy Land type class;\n//.   - lawful Fantasy Land methods for JavaScript's built-in types;\n//.   - one function for each Fantasy Land method; and\n//.   - several functions derived from these functions.\n//.\n//. ## Type-class hierarchy\n//.\n/* eslint-disable max-len */\n//. <pre>\n//.  Setoid   Semigroupoid  Semigroup   Foldable        Functor      Contravariant\n//. (equals)    (compose)    (concat)   (reduce)         (map)        (contramap)\n//.     |           |           |           \\         / | | | | \\\n//.     |           |           |            \\       /  | | | |  \\\n//.     |           |           |             \\     /   | | | |   \\\n//.     |           |           |              \\   /    | | | |    \\\n//.     |           |           |               \\ /     | | | |     \\\n//.    Ord      Category     Monoid         Traversable | | | |      \\\n//.   (lte)       (id)       (empty)        (traverse)  / | | \\       \\\n//.                             |                      /  | |  \\       \\\n//.                             |                     /   / \\   \\       \\\n//.                             |             Profunctor /   \\ Bifunctor \\\n//.                             |              (promap) /     \\ (bimap)   \\\n//.                             |                      /       \\           \\\n//.                           Group                   /         \\           \\\n//.                          (invert)               Alt        Apply      Extend\n//.                                                (alt)        (ap)     (extend)\n//.                                                 /           / \\           \\\n//.                                                /           /   \\           \\\n//.                                               /           /     \\           \\\n//.                                              /           /       \\           \\\n//.                                             /           /         \\           \\\n//.                                           Plus    Applicative    Chain      Comonad\n//.                                          (zero)       (of)      (chain)    (extract)\n//.                                             \\         / \\         / \\\n//.                                              \\       /   \\       /   \\\n//.                                               \\     /     \\     /     \\\n//.                                                \\   /       \\   /       \\\n//.                                                 \\ /         \\ /         \\\n//.                                             Alternative    Monad     ChainRec\n//.                                                                     (chainRec)\n//. </pre>\n/* eslint-enable max-len */\n//.\n//. ## API\n\n(function(f) {\n\n  'use strict';\n\n  /* istanbul ignore else */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f(__webpack_require__(16));\n  } else if (\"function\" === 'function' && __webpack_require__(0) != null) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(16)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {\n    self.sanctuaryTypeClasses = f(self.sanctuaryTypeIdentifiers);\n  }\n\n}(function(type) {\n\n  'use strict';\n\n  //  concat_ :: Array a -> Array a -> Array a\n  function concat_(xs) {\n    return function(ys) {\n      return xs.concat(ys);\n    };\n  }\n\n  //  constant :: a -> b -> a\n  function constant(x) {\n    return function(y) {\n      return x;\n    };\n  }\n\n  //  forEachKey :: (StrMap a, StrMap a ~> String -> Undefined) -> Undefined\n  function forEachKey(strMap, f) {\n    Object.keys(strMap).forEach(f, strMap);\n  }\n\n  //  has :: (String, Object) -> Boolean\n  function has(k, o) {\n    return Object.prototype.hasOwnProperty.call(o, k);\n  }\n\n  //  identity :: a -> a\n  function identity(x) { return x; }\n\n  //  pair :: a -> b -> Pair a b\n  function pair(x) {\n    return function(y) {\n      return [x, y];\n    };\n  }\n\n  //  sameType :: (a, b) -> Boolean\n  function sameType(x, y) {\n    return typeof x === typeof y && type(x) === type(y);\n  }\n\n  //  type Iteration a = { value :: a, done :: Boolean }\n\n  //  iterationNext :: a -> Iteration a\n  function iterationNext(x) { return {value: x, done: false}; }\n\n  //  iterationDone :: a -> Iteration a\n  function iterationDone(x) { return {value: x, done: true}; }\n\n  //# TypeClass :: (String, String, Array TypeClass, a -> Boolean) -> TypeClass\n  //.\n  //. The arguments are:\n  //.\n  //.   - the name of the type class, prefixed by its npm package name;\n  //.   - the documentation URL of the type class;\n  //.   - an array of dependencies; and\n  //.   - a predicate which accepts any JavaScript value and returns `true`\n  //.     if the value satisfies the requirements of the type class; `false`\n  //.     otherwise.\n  //.\n  //. Example:\n  //.\n  //. ```javascript\n  //. //    hasMethod :: String -> a -> Boolean\n  //. const hasMethod = name => x => x != null && typeof x[name] == 'function';\n  //.\n  //. //    Foo :: TypeClass\n  //. const Foo = Z.TypeClass(\n  //.   'my-package/Foo',\n  //.   'http://example.com/my-package#Foo',\n  //.   [],\n  //.   hasMethod('foo')\n  //. );\n  //.\n  //. //    Bar :: TypeClass\n  //. const Bar = Z.TypeClass(\n  //.   'my-package/Bar',\n  //.   'http://example.com/my-package#Bar',\n  //.   [Foo],\n  //.   hasMethod('bar')\n  //. );\n  //. ```\n  //.\n  //. Types whose values have a `foo` method are members of the Foo type class.\n  //. Members of the Foo type class whose values have a `bar` method are also\n  //. members of the Bar type class.\n  //.\n  //. Each `TypeClass` value has a `test` field: a function which accepts\n  //. any JavaScript value and returns `true` if the value satisfies the\n  //. type class's predicate and the predicates of all the type class's\n  //. dependencies; `false` otherwise.\n  //.\n  //. `TypeClass` values may be used with [sanctuary-def][type-classes]\n  //. to define parametrically polymorphic functions which verify their\n  //. type-class constraints at run time.\n  function TypeClass(name, url, dependencies, test) {\n    if (!(this instanceof TypeClass)) {\n      return new TypeClass(name, url, dependencies, test);\n    }\n    this.name = name;\n    this.url = url;\n    this.test = function(x) {\n      return dependencies.every(function(d) { return d.test(x); }) && test(x);\n    };\n  }\n\n  TypeClass['@@type'] = 'sanctuary-type-classes/TypeClass';\n\n  //  data Location = Constructor | Value\n\n  //  Constructor :: Location\n  var Constructor = 'Constructor';\n\n  //  Value :: Location\n  var Value = 'Value';\n\n  //  _funcPath :: (Boolean, Array String, a) -> Nullable Function\n  function _funcPath(allowInheritedProps, path, _x) {\n    var x = _x;\n    for (var idx = 0; idx < path.length; idx += 1) {\n      var k = path[idx];\n      if (x == null || !(allowInheritedProps || has(k, x))) return null;\n      x = x[k];\n    }\n    return typeof x === 'function' ? x : null;\n  }\n\n  //  funcPath :: (Array String, a) -> Nullable Function\n  function funcPath(path, x) {\n    return _funcPath(true, path, x);\n  }\n\n  //  implPath :: Array String -> Nullable Function\n  function implPath(path) {\n    return _funcPath(false, path, implementations);\n  }\n\n  //  functionName :: Function -> String\n  var functionName = has('name', function f() {}) ?\n    function functionName(f) { return f.name; } :\n    /* istanbul ignore next */\n    function functionName(f) {\n      var match = /function (\\w*)/.exec(f);\n      return match == null ? '' : match[1];\n    };\n\n  //  $ :: (String, Array TypeClass, StrMap (Array Location)) -> TypeClass\n  function $(_name, dependencies, requirements) {\n    function getBoundMethod(_name) {\n      var name = 'fantasy-land/' + _name;\n      return requirements[_name] === Constructor ?\n        function(typeRep) {\n          var f = funcPath([name], typeRep);\n          return f == null && typeof typeRep === 'function' ?\n            implPath([functionName(typeRep), name]) :\n            f;\n        } :\n        function(x) {\n          var isPrototype = x != null &&\n                            x.constructor != null &&\n                            x.constructor.prototype === x;\n          var m = null;\n          if (!isPrototype) m = funcPath([name], x);\n          if (m == null)    m = implPath([type(x), 'prototype', name]);\n          return m && m.bind(x);\n        };\n    }\n\n    var version = '7.1.1';  // updated programmatically\n    var keys = Object.keys(requirements);\n\n    var typeClass = TypeClass(\n      'sanctuary-type-classes/' + _name,\n      'https://github.com/sanctuary-js/sanctuary-type-classes/tree/v' + version\n        + '#' + _name,\n      dependencies,\n      function(x) {\n        return keys.every(function(_name) {\n          var arg = requirements[_name] === Constructor ? x.constructor : x;\n          return getBoundMethod(_name)(arg) != null;\n        });\n      }\n    );\n\n    typeClass.methods = keys.reduce(function(methods, _name) {\n      methods[_name] = getBoundMethod(_name);\n      return methods;\n    }, {});\n\n    return typeClass;\n  }\n\n  //# Setoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Setoid][].\n  //.\n  //. ```javascript\n  //. > Setoid.test(null)\n  //. true\n  //. ```\n  var Setoid = $('Setoid', [], {equals: Value});\n\n  //# Ord :: TypeClass\n  //.\n  //. `TypeClass` value for [Ord][].\n  //.\n  //. ```javascript\n  //. > Ord.test(0)\n  //. true\n  //.\n  //. > Ord.test(Math.sqrt)\n  //. false\n  //. ```\n  var Ord = $('Ord', [Setoid], {lte: Value});\n\n  //# Semigroupoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Semigroupoid][].\n  //.\n  //. ```javascript\n  //. > Semigroupoid.test(Math.sqrt)\n  //. true\n  //.\n  //. > Semigroupoid.test(0)\n  //. false\n  //. ```\n  var Semigroupoid = $('Semigroupoid', [], {compose: Value});\n\n  //# Category :: TypeClass\n  //.\n  //. `TypeClass` value for [Category][].\n  //.\n  //. ```javascript\n  //. > Category.test(Math.sqrt)\n  //. true\n  //.\n  //. > Category.test(0)\n  //. false\n  //. ```\n  var Category = $('Category', [Semigroupoid], {id: Constructor});\n\n  //# Semigroup :: TypeClass\n  //.\n  //. `TypeClass` value for [Semigroup][].\n  //.\n  //. ```javascript\n  //. > Semigroup.test('')\n  //. true\n  //.\n  //. > Semigroup.test(0)\n  //. false\n  //. ```\n  var Semigroup = $('Semigroup', [], {concat: Value});\n\n  //# Monoid :: TypeClass\n  //.\n  //. `TypeClass` value for [Monoid][].\n  //.\n  //. ```javascript\n  //. > Monoid.test('')\n  //. true\n  //.\n  //. > Monoid.test(0)\n  //. false\n  //. ```\n  var Monoid = $('Monoid', [Semigroup], {empty: Constructor});\n\n  //# Group :: TypeClass\n  //.\n  //. `TypeClass` value for [Group][].\n  //.\n  //. ```javascript\n  //. > Group.test(Sum(0))\n  //. true\n  //.\n  //. > Group.test('')\n  //. false\n  //. ```\n  var Group = $('Group', [Monoid], {invert: Value});\n\n  //# Functor :: TypeClass\n  //.\n  //. `TypeClass` value for [Functor][].\n  //.\n  //. ```javascript\n  //. > Functor.test([])\n  //. true\n  //.\n  //. > Functor.test('')\n  //. false\n  //. ```\n  var Functor = $('Functor', [], {map: Value});\n\n  //# Bifunctor :: TypeClass\n  //.\n  //. `TypeClass` value for [Bifunctor][].\n  //.\n  //. ```javascript\n  //. > Bifunctor.test(Tuple('foo', 64))\n  //. true\n  //.\n  //. > Bifunctor.test([])\n  //. false\n  //. ```\n  var Bifunctor = $('Bifunctor', [Functor], {bimap: Value});\n\n  //# Profunctor :: TypeClass\n  //.\n  //. `TypeClass` value for [Profunctor][].\n  //.\n  //. ```javascript\n  //. > Profunctor.test(Math.sqrt)\n  //. true\n  //.\n  //. > Profunctor.test([])\n  //. false\n  //. ```\n  var Profunctor = $('Profunctor', [Functor], {promap: Value});\n\n  //# Apply :: TypeClass\n  //.\n  //. `TypeClass` value for [Apply][].\n  //.\n  //. ```javascript\n  //. > Apply.test([])\n  //. true\n  //.\n  //. > Apply.test('')\n  //. false\n  //. ```\n  var Apply = $('Apply', [Functor], {ap: Value});\n\n  //# Applicative :: TypeClass\n  //.\n  //. `TypeClass` value for [Applicative][].\n  //.\n  //. ```javascript\n  //. > Applicative.test([])\n  //. true\n  //.\n  //. > Applicative.test({})\n  //. false\n  //. ```\n  var Applicative = $('Applicative', [Apply], {of: Constructor});\n\n  //# Chain :: TypeClass\n  //.\n  //. `TypeClass` value for [Chain][].\n  //.\n  //. ```javascript\n  //. > Chain.test([])\n  //. true\n  //.\n  //. > Chain.test({})\n  //. false\n  //. ```\n  var Chain = $('Chain', [Apply], {chain: Value});\n\n  //# ChainRec :: TypeClass\n  //.\n  //. `TypeClass` value for [ChainRec][].\n  //.\n  //. ```javascript\n  //. > ChainRec.test([])\n  //. true\n  //.\n  //. > ChainRec.test({})\n  //. false\n  //. ```\n  var ChainRec = $('ChainRec', [Chain], {chainRec: Constructor});\n\n  //# Monad :: TypeClass\n  //.\n  //. `TypeClass` value for [Monad][].\n  //.\n  //. ```javascript\n  //. > Monad.test([])\n  //. true\n  //.\n  //. > Monad.test({})\n  //. false\n  //. ```\n  var Monad = $('Monad', [Applicative, Chain], {});\n\n  //# Alt :: TypeClass\n  //.\n  //. `TypeClass` value for [Alt][].\n  //.\n  //. ```javascript\n  //. > Alt.test({})\n  //. true\n  //.\n  //. > Alt.test('')\n  //. false\n  //. ```\n  var Alt = $('Alt', [Functor], {alt: Value});\n\n  //# Plus :: TypeClass\n  //.\n  //. `TypeClass` value for [Plus][].\n  //.\n  //. ```javascript\n  //. > Plus.test({})\n  //. true\n  //.\n  //. > Plus.test('')\n  //. false\n  //. ```\n  var Plus = $('Plus', [Alt], {zero: Constructor});\n\n  //# Alternative :: TypeClass\n  //.\n  //. `TypeClass` value for [Alternative][].\n  //.\n  //. ```javascript\n  //. > Alternative.test([])\n  //. true\n  //.\n  //. > Alternative.test({})\n  //. false\n  //. ```\n  var Alternative = $('Alternative', [Applicative, Plus], {});\n\n  //# Foldable :: TypeClass\n  //.\n  //. `TypeClass` value for [Foldable][].\n  //.\n  //. ```javascript\n  //. > Foldable.test({})\n  //. true\n  //.\n  //. > Foldable.test('')\n  //. false\n  //. ```\n  var Foldable = $('Foldable', [], {reduce: Value});\n\n  //# Traversable :: TypeClass\n  //.\n  //. `TypeClass` value for [Traversable][].\n  //.\n  //. ```javascript\n  //. > Traversable.test([])\n  //. true\n  //.\n  //. > Traversable.test('')\n  //. false\n  //. ```\n  var Traversable = $('Traversable', [Functor, Foldable], {traverse: Value});\n\n  //# Extend :: TypeClass\n  //.\n  //. `TypeClass` value for [Extend][].\n  //.\n  //. ```javascript\n  //. > Extend.test([])\n  //. true\n  //.\n  //. > Extend.test({})\n  //. false\n  //. ```\n  var Extend = $('Extend', [Functor], {extend: Value});\n\n  //# Comonad :: TypeClass\n  //.\n  //. `TypeClass` value for [Comonad][].\n  //.\n  //. ```javascript\n  //. > Comonad.test(Identity(0))\n  //. true\n  //.\n  //. > Comonad.test([])\n  //. false\n  //. ```\n  var Comonad = $('Comonad', [Extend], {extract: Value});\n\n  //# Contravariant :: TypeClass\n  //.\n  //. `TypeClass` value for [Contravariant][].\n  //.\n  //. ```javascript\n  //. > Contravariant.test(Math.sqrt)\n  //. true\n  //.\n  //. > Contravariant.test([])\n  //. false\n  //. ```\n  var Contravariant = $('Contravariant', [], {contramap: Value});\n\n  //  Null$prototype$toString :: Null ~> () -> String\n  function Null$prototype$toString() {\n    return 'null';\n  }\n\n  //  Null$prototype$equals :: Null ~> Null -> Boolean\n  function Null$prototype$equals(other) {\n    return true;\n  }\n\n  //  Null$prototype$lte :: Null ~> Null -> Boolean\n  function Null$prototype$lte(other) {\n    return true;\n  }\n\n  //  Undefined$prototype$toString :: Undefined ~> () -> String\n  function Undefined$prototype$toString() {\n    return 'undefined';\n  }\n\n  //  Undefined$prototype$equals :: Undefined ~> Undefined -> Boolean\n  function Undefined$prototype$equals(other) {\n    return true;\n  }\n\n  //  Undefined$prototype$lte :: Undefined ~> Undefined -> Boolean\n  function Undefined$prototype$lte(other) {\n    return true;\n  }\n\n  //  Boolean$prototype$toString :: Boolean ~> () -> String\n  function Boolean$prototype$toString() {\n    return typeof this === 'object' ?\n      'new Boolean(' + toString(this.valueOf()) + ')' :\n      this.toString();\n  }\n\n  //  Boolean$prototype$equals :: Boolean ~> Boolean -> Boolean\n  function Boolean$prototype$equals(other) {\n    return typeof this === 'object' ?\n      equals(this.valueOf(), other.valueOf()) :\n      this === other;\n  }\n\n  //  Boolean$prototype$lte :: Boolean ~> Boolean -> Boolean\n  function Boolean$prototype$lte(other) {\n    return typeof this === 'object' ?\n      lte(this.valueOf(), other.valueOf()) :\n      this === false || other === true;\n  }\n\n  //  Number$prototype$toString :: Number ~> () -> String\n  function Number$prototype$toString() {\n    return typeof this === 'object' ?\n      'new Number(' + toString(this.valueOf()) + ')' :\n      1 / this === -Infinity ? '-0' : this.toString(10);\n  }\n\n  //  Number$prototype$equals :: Number ~> Number -> Boolean\n  function Number$prototype$equals(other) {\n    return typeof this === 'object' ?\n      equals(this.valueOf(), other.valueOf()) :\n      isNaN(this) && isNaN(other) || this === other;\n  }\n\n  //  Number$prototype$lte :: Number ~> Number -> Boolean\n  function Number$prototype$lte(other) {\n    return typeof this === 'object' ?\n      lte(this.valueOf(), other.valueOf()) :\n      isNaN(this) && isNaN(other) || this <= other;\n  }\n\n  //  Date$prototype$toString :: Date ~> () -> String\n  function Date$prototype$toString() {\n    var x = isNaN(this.valueOf()) ? NaN : this.toISOString();\n    return 'new Date(' + toString(x) + ')';\n  }\n\n  //  Date$prototype$equals :: Date ~> Date -> Boolean\n  function Date$prototype$equals(other) {\n    return equals(this.valueOf(), other.valueOf());\n  }\n\n  //  Date$prototype$lte :: Date ~> Date -> Boolean\n  function Date$prototype$lte(other) {\n    return lte(this.valueOf(), other.valueOf());\n  }\n\n  //  RegExp$prototype$equals :: RegExp ~> RegExp -> Boolean\n  function RegExp$prototype$equals(other) {\n    return other.source === this.source &&\n           other.global === this.global &&\n           other.ignoreCase === this.ignoreCase &&\n           other.multiline === this.multiline &&\n           other.sticky === this.sticky &&\n           other.unicode === this.unicode;\n  }\n\n  //  String$empty :: () -> String\n  function String$empty() {\n    return '';\n  }\n\n  //  String$prototype$toString :: String ~> () -> String\n  function String$prototype$toString() {\n    return typeof this === 'object' ?\n      'new String(' + toString(this.valueOf()) + ')' :\n      JSON.stringify(this);\n  }\n\n  //  String$prototype$equals :: String ~> String -> Boolean\n  function String$prototype$equals(other) {\n    return typeof this === 'object' ?\n      equals(this.valueOf(), other.valueOf()) :\n      this === other;\n  }\n\n  //  String$prototype$lte :: String ~> String -> Boolean\n  function String$prototype$lte(other) {\n    return typeof this === 'object' ?\n      lte(this.valueOf(), other.valueOf()) :\n      this <= other;\n  }\n\n  //  String$prototype$concat :: String ~> String -> String\n  function String$prototype$concat(other) {\n    return this + other;\n  }\n\n  //  Array$empty :: () -> Array a\n  function Array$empty() {\n    return [];\n  }\n\n  //  Array$of :: a -> Array a\n  function Array$of(x) {\n    return [x];\n  }\n\n  //  Array$chainRec :: ((a -> c, b -> c, a) -> Array c, a) -> Array b\n  function Array$chainRec(f, x) {\n    var $todo = [x];\n    var $done = [];\n    while ($todo.length > 0) {\n      var xs = f(iterationNext, iterationDone, $todo.shift());\n      var $more = [];\n      for (var idx = 0; idx < xs.length; idx += 1) {\n        (xs[idx].done ? $done : $more).push(xs[idx].value);\n      }\n      Array.prototype.unshift.apply($todo, $more);\n    }\n    return $done;\n  }\n\n  //  Array$zero :: () -> Array a\n  function Array$zero() {\n    return [];\n  }\n\n  //  Array$prototype$toString :: Array a ~> () -> String\n  function Array$prototype$toString() {\n    var reprs = this.map(toString);\n    var keys = Object.keys(this).sort();\n    for (var idx = 0; idx < keys.length; idx += 1) {\n      var k = keys[idx];\n      if (!/^\\d+$/.test(k)) {\n        reprs.push(toString(k) + ': ' + toString(this[k]));\n      }\n    }\n    return '[' + reprs.join(', ') + ']';\n  }\n\n  //  Array$prototype$equals :: Array a ~> Array a -> Boolean\n  function Array$prototype$equals(other) {\n    if (other.length !== this.length) return false;\n    for (var idx = 0; idx < this.length; idx += 1) {\n      if (!equals(this[idx], other[idx])) return false;\n    }\n    return true;\n  }\n\n  //  Array$prototype$lte :: Array a ~> Array a -> Boolean\n  function Array$prototype$lte(other) {\n    for (var idx = 0; true; idx += 1) {\n      if (idx === this.length) return true;\n      if (idx === other.length) return false;\n      if (!equals(this[idx], other[idx])) return lte(this[idx], other[idx]);\n    }\n  }\n\n  //  Array$prototype$concat :: Array a ~> Array a -> Array a\n  function Array$prototype$concat(other) {\n    return this.concat(other);\n  }\n\n  //  Array$prototype$map :: Array a ~> (a -> b) -> Array b\n  function Array$prototype$map(f) {\n    return this.map(function(x) { return f(x); });\n  }\n\n  //  Array$prototype$ap :: Array a ~> Array (a -> b) -> Array b\n  function Array$prototype$ap(fs) {\n    var result = [];\n    for (var idx = 0; idx < fs.length; idx += 1) {\n      for (var idx2 = 0; idx2 < this.length; idx2 += 1) {\n        result.push(fs[idx](this[idx2]));\n      }\n    }\n    return result;\n  }\n\n  //  Array$prototype$chain :: Array a ~> (a -> Array b) -> Array b\n  function Array$prototype$chain(f) {\n    var result = [];\n    this.forEach(function(x) { Array.prototype.push.apply(result, f(x)); });\n    return result;\n  }\n\n  //  Array$prototype$alt :: Array a ~> Array a -> Array a\n  var Array$prototype$alt = Array$prototype$concat;\n\n  //  Array$prototype$reduce :: Array a ~> ((b, a) -> b, b) -> b\n  function Array$prototype$reduce(f, initial) {\n    return this.reduce(function(acc, x) { return f(acc, x); }, initial);\n  }\n\n  //  Array$prototype$traverse :: Applicative f => Array a ~> (TypeRep f, a -> f b) -> f (Array b)\n  function Array$prototype$traverse(typeRep, f) {\n    var xs = this;\n    function go(idx, n) {\n      switch (n) {\n        case 0: return of(typeRep, []);\n        case 2: return lift2(pair, f(xs[idx]), f(xs[idx + 1]));\n        default:\n          var m = Math.floor(n / 4) * 2;\n          return lift2(concat_, go(idx, m), go(idx + m, n - m));\n      }\n    }\n    return this.length % 2 === 1 ?\n      lift2(concat_, map(Array$of, f(this[0])), go(1, this.length - 1)) :\n      go(0, this.length);\n  }\n\n  //  Array$prototype$extend :: Array a ~> (Array a -> b) -> Array b\n  function Array$prototype$extend(f) {\n    return this.map(function(_, idx, xs) { return f(xs.slice(idx)); });\n  }\n\n  //  Arguments$prototype$toString :: Arguments ~> String\n  function Arguments$prototype$toString() {\n    var args = Array.prototype.map.call(this, toString).join(', ');\n    return '(function () { return arguments; }(' + args + '))';\n  }\n\n  //  Arguments$prototype$equals :: Arguments ~> Arguments -> Boolean\n  function Arguments$prototype$equals(other) {\n    return Array$prototype$equals.call(this, other);\n  }\n\n  //  Arguments$prototype$lte :: Arguments ~> Arguments -> Boolean\n  function Arguments$prototype$lte(other) {\n    return Array$prototype$lte.call(this, other);\n  }\n\n  //  Error$prototype$toString :: Error ~> () -> String\n  function Error$prototype$toString() {\n    return 'new ' + this.name + '(' + toString(this.message) + ')';\n  }\n\n  //  Error$prototype$equals :: Error ~> Error -> Boolean\n  function Error$prototype$equals(other) {\n    return equals(this.name, other.name) &&\n           equals(this.message, other.message);\n  }\n\n  //  Object$empty :: () -> StrMap a\n  function Object$empty() {\n    return {};\n  }\n\n  //  Object$zero :: () -> StrMap a\n  function Object$zero() {\n    return {};\n  }\n\n  //  Object$prototype$toString :: StrMap a ~> () -> String\n  function Object$prototype$toString() {\n    var reprs = [];\n    var keys = Object.keys(this).sort();\n    for (var idx = 0; idx < keys.length; idx += 1) {\n      var k = keys[idx];\n      reprs.push(toString(k) + ': ' + toString(this[k]));\n    }\n    return '{' + reprs.join(', ') + '}';\n  }\n\n  //  Object$prototype$equals :: StrMap a ~> StrMap a -> Boolean\n  function Object$prototype$equals(other) {\n    var self = this;\n    var keys = Object.keys(this).sort();\n    return equals(keys, Object.keys(other).sort()) &&\n           keys.every(function(k) { return equals(self[k], other[k]); });\n  }\n\n  //  Object$prototype$lte :: StrMap a ~> StrMap a -> Boolean\n  function Object$prototype$lte(other) {\n    var theseKeys = Object.keys(this).sort();\n    var otherKeys = Object.keys(other).sort();\n    while (true) {\n      if (theseKeys.length === 0) return true;\n      if (otherKeys.length === 0) return false;\n      var k = theseKeys.shift();\n      var z = otherKeys.shift();\n      if (k < z) return true;\n      if (k > z) return false;\n      if (!equals(this[k], other[k])) return lte(this[k], other[k]);\n    }\n  }\n\n  //  Object$prototype$concat :: StrMap a ~> StrMap a -> StrMap a\n  function Object$prototype$concat(other) {\n    var result = {};\n    function assign(k) { result[k] = this[k]; }\n    forEachKey(this, assign);\n    forEachKey(other, assign);\n    return result;\n  }\n\n  //  Object$prototype$map :: StrMap a ~> (a -> b) -> StrMap b\n  function Object$prototype$map(f) {\n    var result = {};\n    forEachKey(this, function(k) { result[k] = f(this[k]); });\n    return result;\n  }\n\n  //  Object$prototype$ap :: StrMap a ~> StrMap (a -> b) -> StrMap b\n  function Object$prototype$ap(other) {\n    var result = {};\n    forEachKey(this, function(k) {\n      if (has(k, other)) result[k] = other[k](this[k]);\n    });\n    return result;\n  }\n\n  //  Object$prototype$alt :: StrMap a ~> StrMap a -> StrMap a\n  var Object$prototype$alt = Object$prototype$concat;\n\n  //  Object$prototype$reduce :: StrMap a ~> ((b, a) -> b, b) -> b\n  function Object$prototype$reduce(f, initial) {\n    var self = this;\n    function reducer(acc, k) { return f(acc, self[k]); }\n    return Object.keys(this).sort().reduce(reducer, initial);\n  }\n\n  //  Object$prototype$traverse :: Applicative f => StrMap a ~> (TypeRep f, a -> f b) -> f (StrMap b)\n  function Object$prototype$traverse(typeRep, f) {\n    var self = this;\n    return Object.keys(this).reduce(function(applicative, k) {\n      function set(o) {\n        return function(v) {\n          var singleton = {}; singleton[k] = v;\n          return Object$prototype$concat.call(o, singleton);\n        };\n      }\n      return lift2(set, applicative, f(self[k]));\n    }, of(typeRep, {}));\n  }\n\n  //  Function$id :: () -> a -> a\n  function Function$id() {\n    return identity;\n  }\n\n  //  Function$of :: b -> (a -> b)\n  function Function$of(x) {\n    return function(_) { return x; };\n  }\n\n  //  Function$chainRec :: ((a -> c, b -> c, a) -> (z -> c), a) -> (z -> b)\n  function Function$chainRec(f, x) {\n    return function(a) {\n      var step = iterationNext(x);\n      while (!step.done) {\n        step = f(iterationNext, iterationDone, step.value)(a);\n      }\n      return step.value;\n    };\n  }\n\n  //  Function$prototype$equals :: Function ~> Function -> Boolean\n  function Function$prototype$equals(other) {\n    return other === this;\n  }\n\n  //  Function$prototype$compose :: (a -> b) ~> (b -> c) -> (a -> c)\n  function Function$prototype$compose(other) {\n    var semigroupoid = this;\n    return function(x) { return other(semigroupoid(x)); };\n  }\n\n  //  Function$prototype$map :: (a -> b) ~> (b -> c) -> (a -> c)\n  function Function$prototype$map(f) {\n    var functor = this;\n    return function(x) { return f(functor(x)); };\n  }\n\n  //  Function$prototype$promap :: (b -> c) ~> (a -> b, c -> d) -> (a -> d)\n  function Function$prototype$promap(f, g) {\n    var profunctor = this;\n    return function(x) { return g(profunctor(f(x))); };\n  }\n\n  //  Function$prototype$ap :: (a -> b) ~> (a -> b -> c) -> (a -> c)\n  function Function$prototype$ap(f) {\n    var apply = this;\n    return function(x) { return f(x)(apply(x)); };\n  }\n\n  //  Function$prototype$chain :: (a -> b) ~> (b -> a -> c) -> (a -> c)\n  function Function$prototype$chain(f) {\n    var chain = this;\n    return function(x) { return f(chain(x))(x); };\n  }\n\n  //  Function$prototype$contramap :: (b -> c) ~> (a -> b) -> (a -> c)\n  function Function$prototype$contramap(f) {\n    var contravariant = this;\n    return function(x) { return contravariant(f(x)); };\n  }\n\n  /* eslint-disable key-spacing */\n  var implementations = {\n    Null: {\n      prototype: {\n        toString:                   Null$prototype$toString,\n        'fantasy-land/equals':      Null$prototype$equals,\n        'fantasy-land/lte':         Null$prototype$lte\n      }\n    },\n    Undefined: {\n      prototype: {\n        toString:                   Undefined$prototype$toString,\n        'fantasy-land/equals':      Undefined$prototype$equals,\n        'fantasy-land/lte':         Undefined$prototype$lte\n      }\n    },\n    Boolean: {\n      prototype: {\n        toString:                   Boolean$prototype$toString,\n        'fantasy-land/equals':      Boolean$prototype$equals,\n        'fantasy-land/lte':         Boolean$prototype$lte\n      }\n    },\n    Number: {\n      prototype: {\n        toString:                   Number$prototype$toString,\n        'fantasy-land/equals':      Number$prototype$equals,\n        'fantasy-land/lte':         Number$prototype$lte\n      }\n    },\n    Date: {\n      prototype: {\n        toString:                   Date$prototype$toString,\n        'fantasy-land/equals':      Date$prototype$equals,\n        'fantasy-land/lte':         Date$prototype$lte\n      }\n    },\n    RegExp: {\n      prototype: {\n        'fantasy-land/equals':      RegExp$prototype$equals\n      }\n    },\n    String: {\n      'fantasy-land/empty':         String$empty,\n      prototype: {\n        toString:                   String$prototype$toString,\n        'fantasy-land/equals':      String$prototype$equals,\n        'fantasy-land/lte':         String$prototype$lte,\n        'fantasy-land/concat':      String$prototype$concat\n      }\n    },\n    Array: {\n      'fantasy-land/empty':         Array$empty,\n      'fantasy-land/of':            Array$of,\n      'fantasy-land/chainRec':      Array$chainRec,\n      'fantasy-land/zero':          Array$zero,\n      prototype: {\n        toString:                   Array$prototype$toString,\n        'fantasy-land/equals':      Array$prototype$equals,\n        'fantasy-land/lte':         Array$prototype$lte,\n        'fantasy-land/concat':      Array$prototype$concat,\n        'fantasy-land/map':         Array$prototype$map,\n        'fantasy-land/ap':          Array$prototype$ap,\n        'fantasy-land/chain':       Array$prototype$chain,\n        'fantasy-land/alt':         Array$prototype$alt,\n        'fantasy-land/reduce':      Array$prototype$reduce,\n        'fantasy-land/traverse':    Array$prototype$traverse,\n        'fantasy-land/extend':      Array$prototype$extend\n      }\n    },\n    Arguments: {\n      prototype: {\n        toString:                   Arguments$prototype$toString,\n        'fantasy-land/equals':      Arguments$prototype$equals,\n        'fantasy-land/lte':         Arguments$prototype$lte\n      }\n    },\n    Error: {\n      prototype: {\n        toString:                   Error$prototype$toString,\n        'fantasy-land/equals':      Error$prototype$equals\n      }\n    },\n    Object: {\n      'fantasy-land/empty':         Object$empty,\n      'fantasy-land/zero':          Object$zero,\n      prototype: {\n        toString:                   Object$prototype$toString,\n        'fantasy-land/equals':      Object$prototype$equals,\n        'fantasy-land/lte':         Object$prototype$lte,\n        'fantasy-land/concat':      Object$prototype$concat,\n        'fantasy-land/map':         Object$prototype$map,\n        'fantasy-land/ap':          Object$prototype$ap,\n        'fantasy-land/alt':         Object$prototype$alt,\n        'fantasy-land/reduce':      Object$prototype$reduce,\n        'fantasy-land/traverse':    Object$prototype$traverse\n      }\n    },\n    Function: {\n      'fantasy-land/id':            Function$id,\n      'fantasy-land/of':            Function$of,\n      'fantasy-land/chainRec':      Function$chainRec,\n      prototype: {\n        'fantasy-land/equals':      Function$prototype$equals,\n        'fantasy-land/compose':     Function$prototype$compose,\n        'fantasy-land/map':         Function$prototype$map,\n        'fantasy-land/promap':      Function$prototype$promap,\n        'fantasy-land/ap':          Function$prototype$ap,\n        'fantasy-land/chain':       Function$prototype$chain,\n        'fantasy-land/contramap':   Function$prototype$contramap\n      }\n    }\n  };\n  /* eslint-enable key-spacing */\n\n  //# toString :: a -> String\n  //.\n  //. Returns a useful string representation of its argument.\n  //.\n  //. Dispatches to the argument's `toString` method if appropriate.\n  //.\n  //. Where practical, `equals(eval(toString(x)), x) = true`.\n  //.\n  //. `toString` implementations are provided for the following built-in types:\n  //. Null, Undefined, Boolean, Number, Date, String, Array, Arguments, Error,\n  //. and Object.\n  //.\n  //. ```javascript\n  //. > toString(-0)\n  //. '-0'\n  //.\n  //. > toString(['foo', 'bar', 'baz'])\n  //. '[\"foo\", \"bar\", \"baz\"]'\n  //.\n  //. > toString({x: 1, y: 2, z: 3})\n  //. '{\"x\": 1, \"y\": 2, \"z\": 3}'\n  //.\n  //. > toString(Cons(1, Cons(2, Cons(3, Nil))))\n  //. 'Cons(1, Cons(2, Cons(3, Nil)))'\n  //. ```\n  var toString = (function() {\n    //  $seen :: Array Any\n    var $seen = [];\n\n    function call(method, x) {\n      $seen.push(x);\n      try { return method.call(x); } finally { $seen.pop(); }\n    }\n\n    return function toString(x) {\n      if ($seen.indexOf(x) >= 0) return '<Circular>';\n\n      var xType = type(x);\n      if (xType === 'Object') {\n        var result;\n        try { result = call(x.toString, x); } catch (err) {}\n        if (result != null && result !== '[object Object]') return result;\n      }\n\n      return call(implPath([xType, 'prototype', 'toString']) || x.toString, x);\n    };\n  }());\n\n  //# equals :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and equal according\n  //. to the type's [`fantasy-land/equals`][] method; `false` otherwise.\n  //.\n  //. `fantasy-land/equals` implementations are provided for the following\n  //. built-in types: Null, Undefined, Boolean, Number, Date, RegExp, String,\n  //. Array, Arguments, Error, Object, and Function.\n  //.\n  //. The algorithm supports circular data structures. Two arrays are equal\n  //. if they have the same index paths and for each path have equal values.\n  //. Two arrays which represent `[1, [1, [1, [1, [1, ...]]]]]`, for example,\n  //. are equal even if their internal structures differ. Two objects are equal\n  //. if they have the same property paths and for each path have equal values.\n  //.\n  //. ```javascript\n  //. > equals(0, -0)\n  //. true\n  //.\n  //. > equals(NaN, NaN)\n  //. true\n  //.\n  //. > equals(Cons('foo', Cons('bar', Nil)), Cons('foo', Cons('bar', Nil)))\n  //. true\n  //.\n  //. > equals(Cons('foo', Cons('bar', Nil)), Cons('bar', Cons('foo', Nil)))\n  //. false\n  //. ```\n  var equals = (function() {\n    //  $pairs :: Array (Pair Any Any)\n    var $pairs = [];\n\n    return function equals(x, y) {\n      if (!sameType(x, y)) return false;\n\n      //  This algorithm for comparing circular data structures was\n      //  suggested in <http://stackoverflow.com/a/40622794/312785>.\n      if ($pairs.some(function(p) { return p[0] === x && p[1] === y; })) {\n        return true;\n      }\n\n      $pairs.push([x, y]);\n      try {\n        return Setoid.test(x) && Setoid.test(y) && Setoid.methods.equals(x)(y);\n      } finally {\n        $pairs.pop();\n      }\n    };\n  }());\n\n  //# lt :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first is\n  //. less than the second according to the type's [`fantasy-land/lte`][]\n  //. method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`gt`](#gt) and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > lt(0, 0)\n  //. false\n  //.\n  //. > lt(0, 1)\n  //. true\n  //.\n  //. > lt(1, 0)\n  //. false\n  //. ```\n  function lt(x, y) {\n    return sameType(x, y) && !lte(y, x);\n  }\n\n  //# lte :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first\n  //. is less than or equal to the second according to the type's\n  //. [`fantasy-land/lte`][] method; `false` otherwise.\n  //.\n  //. `fantasy-land/lte` implementations are provided for the following\n  //. built-in types: Null, Undefined, Boolean, Number, Date, String, Array,\n  //. Arguments, and Object.\n  //.\n  //. The algorithm supports circular data structures in the same manner as\n  //. [`equals`](#equals).\n  //.\n  //. See also [`lt`](#lt), [`gt`](#gt), and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > lte(0, 0)\n  //. true\n  //.\n  //. > lte(0, 1)\n  //. true\n  //.\n  //. > lte(1, 0)\n  //. false\n  //. ```\n  var lte = (function() {\n    //  $pairs :: Array (Pair Any Any)\n    var $pairs = [];\n\n    return function lte(x, y) {\n      if (!sameType(x, y)) return false;\n\n      //  This algorithm for comparing circular data structures was\n      //  suggested in <http://stackoverflow.com/a/40622794/312785>.\n      if ($pairs.some(function(p) { return p[0] === x && p[1] === y; })) {\n        return equals(x, y);\n      }\n\n      $pairs.push([x, y]);\n      try {\n        return Ord.test(x) && Ord.test(y) && Ord.methods.lte(x)(y);\n      } finally {\n        $pairs.pop();\n      }\n    };\n  }());\n\n  //# gt :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first is\n  //. greater than the second according to the type's [`fantasy-land/lte`][]\n  //. method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`lt`](#lt) and [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > gt(0, 0)\n  //. false\n  //.\n  //. > gt(0, 1)\n  //. false\n  //.\n  //. > gt(1, 0)\n  //. true\n  //. ```\n  function gt(x, y) {\n    return lt(y, x);\n  }\n\n  //# gte :: (a, b) -> Boolean\n  //.\n  //. Returns `true` if its arguments are of the same type and the first\n  //. is greater than or equal to the second according to the type's\n  //. [`fantasy-land/lte`][] method; `false` otherwise.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`lt`](#lt) and [`gt`](#gt).\n  //.\n  //. ```javascript\n  //. > gte(0, 0)\n  //. true\n  //.\n  //. > gte(0, 1)\n  //. false\n  //.\n  //. > gte(1, 0)\n  //. true\n  //. ```\n  function gte(x, y) {\n    return lte(y, x);\n  }\n\n  //# min :: Ord a => (a, a) -> a\n  //.\n  //. Returns the smaller of its two arguments.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`max`](#max).\n  //.\n  //. ```javascript\n  //. > min(10, 2)\n  //. 2\n  //.\n  //. > min(new Date('1999-12-31'), new Date('2000-01-01'))\n  //. new Date('1999-12-31')\n  //.\n  //. > min('10', '2')\n  //. '10'\n  //. ```\n  function min(x, y) {\n    return lte(x, y) ? x : y;\n  }\n\n  //# max :: Ord a => (a, a) -> a\n  //.\n  //. Returns the larger of its two arguments.\n  //.\n  //. This function is derived from [`lte`](#lte).\n  //.\n  //. See also [`min`](#min).\n  //.\n  //. ```javascript\n  //. > max(10, 2)\n  //. 10\n  //.\n  //. > max(new Date('1999-12-31'), new Date('2000-01-01'))\n  //. new Date('2000-01-01')\n  //.\n  //. > max('10', '2')\n  //. '2'\n  //. ```\n  function max(x, y) {\n    return lte(x, y) ? y : x;\n  }\n\n  //# compose :: Semigroupoid c => (c j k, c i j) -> c i k\n  //.\n  //. Function wrapper for [`fantasy-land/compose`][].\n  //.\n  //. `fantasy-land/compose` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > compose(Math.sqrt, x => x + 1)(99)\n  //. 10\n  //. ```\n  function compose(x, y) {\n    return Semigroupoid.methods.compose(y)(x);\n  }\n\n  //# id :: Category c => TypeRep c -> c\n  //.\n  //. Function wrapper for [`fantasy-land/id`][].\n  //.\n  //. `fantasy-land/id` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > id(Function)('foo')\n  //. 'foo'\n  //. ```\n  function id(typeRep) {\n    return Category.methods.id(typeRep)();\n  }\n\n  //# concat :: Semigroup a => (a, a) -> a\n  //.\n  //. Function wrapper for [`fantasy-land/concat`][].\n  //.\n  //. `fantasy-land/concat` implementations are provided for the following\n  //. built-in types: String, Array, and Object.\n  //.\n  //. ```javascript\n  //. > concat('abc', 'def')\n  //. 'abcdef'\n  //.\n  //. > concat([1, 2, 3], [4, 5, 6])\n  //. [1, 2, 3, 4, 5, 6]\n  //.\n  //. > concat({x: 1, y: 2}, {y: 3, z: 4})\n  //. {x: 1, y: 3, z: 4}\n  //.\n  //. > concat(Cons('foo', Cons('bar', Cons('baz', Nil))), Cons('quux', Nil))\n  //. Cons('foo', Cons('bar', Cons('baz', Cons('quux', Nil))))\n  //. ```\n  function concat(x, y) {\n    return Semigroup.methods.concat(x)(y);\n  }\n\n  //# empty :: Monoid m => TypeRep m -> m\n  //.\n  //. Function wrapper for [`fantasy-land/empty`][].\n  //.\n  //. `fantasy-land/empty` implementations are provided for the following\n  //. built-in types: String, Array, and Object.\n  //.\n  //. ```javascript\n  //. > empty(String)\n  //. ''\n  //.\n  //. > empty(Array)\n  //. []\n  //.\n  //. > empty(Object)\n  //. {}\n  //.\n  //. > empty(List)\n  //. Nil\n  //. ```\n  function empty(typeRep) {\n    return Monoid.methods.empty(typeRep)();\n  }\n\n  //# invert :: Group g => g -> g\n  //.\n  //. Function wrapper for [`fantasy-land/invert`][].\n  //.\n  //. ```javascript\n  //. invert(Sum(5))\n  //. Sum(-5)\n  //. ```\n  function invert(group) {\n    return Group.methods.invert(group)();\n  }\n\n  //# map :: Functor f => (a -> b, f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/map`][].\n  //.\n  //. `fantasy-land/map` implementations are provided for the following\n  //. built-in types: Array, Object, and Function.\n  //.\n  //. ```javascript\n  //. > map(Math.sqrt, [1, 4, 9])\n  //. [1, 2, 3]\n  //.\n  //. > map(Math.sqrt, {x: 1, y: 4, z: 9})\n  //. {x: 1, y: 2, z: 3}\n  //.\n  //. > map(Math.sqrt, s => s.length)('Sanctuary')\n  //. 3\n  //.\n  //. > map(Math.sqrt, Tuple('foo', 64))\n  //. Tuple('foo', 8)\n  //.\n  //. > map(Math.sqrt, Nil)\n  //. Nil\n  //.\n  //. > map(Math.sqrt, Cons(1, Cons(4, Cons(9, Nil))))\n  //. Cons(1, Cons(2, Cons(3, Nil)))\n  //. ```\n  function map(f, functor) {\n    return Functor.methods.map(functor)(f);\n  }\n\n  //# bimap :: Bifunctor f => (a -> b, c -> d, f a c) -> f b d\n  //.\n  //. Function wrapper for [`fantasy-land/bimap`][].\n  //.\n  //. ```javascript\n  //. > bimap(s => s.toUpperCase(), Math.sqrt, Tuple('foo', 64))\n  //. Tuple('FOO', 8)\n  //. ```\n  function bimap(f, g, bifunctor) {\n    return Bifunctor.methods.bimap(bifunctor)(f, g);\n  }\n\n  //# promap :: Profunctor p => (a -> b, c -> d, p b c) -> p a d\n  //.\n  //. Function wrapper for [`fantasy-land/promap`][].\n  //.\n  //. `fantasy-land/promap` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > promap(Math.abs, x => x + 1, Math.sqrt)(-100)\n  //. 11\n  //. ```\n  function promap(f, g, profunctor) {\n    return Profunctor.methods.promap(profunctor)(f, g);\n  }\n\n  //# ap :: Apply f => (f (a -> b), f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/ap`][].\n  //.\n  //. `fantasy-land/ap` implementations are provided for the following\n  //. built-in types: Array, Object, and Function.\n  //.\n  //. ```javascript\n  //. > ap([Math.sqrt, x => x * x], [1, 4, 9, 16, 25])\n  //. [1, 2, 3, 4, 5, 1, 16, 81, 256, 625]\n  //.\n  //. > ap({a: Math.sqrt, b: x => x * x}, {a: 16, b: 10, c: 1})\n  //. {a: 4, b: 100}\n  //.\n  //. > ap(s => n => s.slice(0, n), s => Math.ceil(s.length / 2))('Haskell')\n  //. 'Hask'\n  //.\n  //. > ap(Identity(Math.sqrt), Identity(64))\n  //. Identity(8)\n  //.\n  //. > ap(Cons(Math.sqrt, Cons(x => x * x, Nil)), Cons(16, Cons(100, Nil)))\n  //. Cons(4, Cons(10, Cons(256, Cons(10000, Nil))))\n  //. ```\n  function ap(applyF, applyX) {\n    return Apply.methods.ap(applyX)(applyF);\n  }\n\n  //# lift2 :: Apply f => (a -> b -> c, f a, f b) -> f c\n  //.\n  //. Lifts `a -> b -> c` to `Apply f => f a -> f b -> f c` and returns the\n  //. result of applying this to the given arguments.\n  //.\n  //. This function is derived from [`map`](#map) and [`ap`](#ap).\n  //.\n  //. See also [`lift3`](#lift3).\n  //.\n  //. ```javascript\n  //. > lift2(x => y => Math.pow(x, y), [10], [1, 2, 3])\n  //. [10, 100, 1000]\n  //.\n  //. > lift2(x => y => Math.pow(x, y), Identity(10), Identity(3))\n  //. Identity(1000)\n  //. ```\n  function lift2(f, x, y) {\n    return ap(map(f, x), y);\n  }\n\n  //# lift3 :: Apply f => (a -> b -> c -> d, f a, f b, f c) -> f d\n  //.\n  //. Lifts `a -> b -> c -> d` to `Apply f => f a -> f b -> f c -> f d` and\n  //. returns the result of applying this to the given arguments.\n  //.\n  //. This function is derived from [`map`](#map) and [`ap`](#ap).\n  //.\n  //. See also [`lift2`](#lift2).\n  //.\n  //. ```javascript\n  //. > lift3(x => y => z => x + z + y, ['<'], ['>'], ['foo', 'bar', 'baz'])\n  //. ['<foo>', '<bar>', '<baz>']\n  //.\n  //. > lift3(x => y => z => x + z + y, Identity('<'), Identity('>'), Identity('baz'))\n  //. Identity('<baz>')\n  //. ```\n  function lift3(f, x, y, z) {\n    return ap(ap(map(f, x), y), z);\n  }\n\n  //# apFirst :: Apply f => (f a, f b) -> f a\n  //.\n  //. Combines two effectful actions, keeping only the result of the first.\n  //. Equivalent to Haskell's `(<*)` function.\n  //.\n  //. This function is derived from [`lift2`](#lift2).\n  //.\n  //. See also [`apSecond`](#apSecond).\n  //.\n  //. ```javascript\n  //. > apFirst([1, 2], [3, 4])\n  //. [1, 1, 2, 2]\n  //.\n  //. > apFirst(Identity(1), Identity(2))\n  //. Identity(1)\n  //. ```\n  function apFirst(x, y) {\n    return lift2(constant, x, y);\n  }\n\n  //# apSecond :: Apply f => (f a, f b) -> f b\n  //.\n  //. Combines two effectful actions, keeping only the result of the second.\n  //. Equivalent to Haskell's `(*>)` function.\n  //.\n  //. This function is derived from [`lift2`](#lift2).\n  //.\n  //. See also [`apFirst`](#apFirst).\n  //.\n  //. ```javascript\n  //. > apSecond([1, 2], [3, 4])\n  //. [3, 4, 3, 4]\n  //.\n  //. > apSecond(Identity(1), Identity(2))\n  //. Identity(2)\n  //. ```\n  function apSecond(x, y) {\n    return lift2(constant(identity), x, y);\n  }\n\n  //# of :: Applicative f => (TypeRep f, a) -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/of`][].\n  //.\n  //. `fantasy-land/of` implementations are provided for the following\n  //. built-in types: Array and Function.\n  //.\n  //. ```javascript\n  //. > of(Array, 42)\n  //. [42]\n  //.\n  //. > of(Function, 42)(null)\n  //. 42\n  //.\n  //. > of(List, 42)\n  //. Cons(42, Nil)\n  //. ```\n  function of(typeRep, x) {\n    return Applicative.methods.of(typeRep)(x);\n  }\n\n  //# append :: (Applicative f, Semigroup (f a)) => (a, f a) -> f a\n  //.\n  //. Returns the result of appending the first argument to the second.\n  //.\n  //. This function is derived from [`concat`](#concat) and [`of`](#of).\n  //.\n  //. See also [`prepend`](#prepend).\n  //.\n  //. ```javascript\n  //. > append(3, [1, 2])\n  //. [1, 2, 3]\n  //.\n  //. > append(3, Cons(1, Cons(2, Nil)))\n  //. Cons(1, Cons(2, Cons(3, Nil)))\n  //. ```\n  function append(x, xs) {\n    return concat(xs, of(xs.constructor, x));\n  }\n\n  //# prepend :: (Applicative f, Semigroup (f a)) => (a, f a) -> f a\n  //.\n  //. Returns the result of prepending the first argument to the second.\n  //.\n  //. This function is derived from [`concat`](#concat) and [`of`](#of).\n  //.\n  //. See also [`append`](#append).\n  //.\n  //. ```javascript\n  //. > prepend(1, [2, 3])\n  //. [1, 2, 3]\n  //.\n  //. > prepend(1, Cons(2, Cons(3, Nil)))\n  //. Cons(1, Cons(2, Cons(3, Nil)))\n  //. ```\n  function prepend(x, xs) {\n    return concat(of(xs.constructor, x), xs);\n  }\n\n  //# chain :: Chain m => (a -> m b, m a) -> m b\n  //.\n  //. Function wrapper for [`fantasy-land/chain`][].\n  //.\n  //. `fantasy-land/chain` implementations are provided for the following\n  //. built-in types: Array and Function.\n  //.\n  //. ```javascript\n  //. > chain(x => [x, x], [1, 2, 3])\n  //. [1, 1, 2, 2, 3, 3]\n  //.\n  //. > chain(x => x % 2 == 1 ? of(List, x) : Nil, Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(1, Cons(3, Nil))\n  //.\n  //. > chain(n => s => s.slice(0, n), s => Math.ceil(s.length / 2))('Haskell')\n  //. 'Hask'\n  //. ```\n  function chain(f, chain_) {\n    return Chain.methods.chain(chain_)(f);\n  }\n\n  //# join :: Chain m => m (m a) -> m a\n  //.\n  //. Removes one level of nesting from a nested monadic structure.\n  //.\n  //. This function is derived from [`chain`](#chain).\n  //.\n  //. ```javascript\n  //. > join([[1], [2], [3]])\n  //. [1, 2, 3]\n  //.\n  //. > join([[[1, 2, 3]]])\n  //. [[1, 2, 3]]\n  //.\n  //. > join(Identity(Identity(1)))\n  //. Identity(1)\n  //. ```\n  function join(chain_) {\n    return chain(identity, chain_);\n  }\n\n  //# chainRec :: ChainRec m => (TypeRep m, (a -> c, b -> c, a) -> m c, a) -> m b\n  //.\n  //. Function wrapper for [`fantasy-land/chainRec`][].\n  //.\n  //. `fantasy-land/chainRec` implementations are provided for the following\n  //. built-in types: Array.\n  //.\n  //. ```javascript\n  //. > chainRec(\n  //. .   Array,\n  //. .   (next, done, s) => s.length == 2 ? [s + '!', s + '?'].map(done)\n  //. .                                    : [s + 'o', s + 'n'].map(next),\n  //. .   ''\n  //. . )\n  //. ['oo!', 'oo?', 'on!', 'on?', 'no!', 'no?', 'nn!', 'nn?']\n  //. ```\n  function chainRec(typeRep, f, x) {\n    return ChainRec.methods.chainRec(typeRep)(f, x);\n  }\n\n  //# filter :: (Applicative f, Foldable f, Monoid (f a)) => (a -> Boolean, f a) -> f a\n  //.\n  //. Filters its second argument in accordance with the given predicate.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`filterM`](#filterM).\n  //.\n  //. ```javascript\n  //. > filter(x => x % 2 == 1, [1, 2, 3])\n  //. [1, 3]\n  //.\n  //. > filter(x => x % 2 == 1, Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(1, Cons(3, Nil))\n  //. ```\n  function filter(pred, m) {\n    //  Fast path for arrays.\n    if (Array.isArray(m)) return m.filter(function(x) { return pred(x); });\n    var M = m.constructor;\n    return reduce(function(m, x) { return pred(x) ? concat(m, of(M, x)) : m; },\n                  empty(M),\n                  m);\n  }\n\n  //# filterM :: (Alternative m, Monad m) => (a -> Boolean, m a) -> m a\n  //.\n  //. Filters its second argument in accordance with the given predicate.\n  //.\n  //. This function is derived from [`of`](#of), [`chain`](#chain), and\n  //. [`zero`](#zero).\n  //.\n  //. See also [`filter`](#filter).\n  //.\n  //. ```javascript\n  //. > filterM(x => x % 2 == 1, [1, 2, 3])\n  //. [1, 3]\n  //.\n  //. > filterM(x => x % 2 == 1, Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(1, Cons(3, Nil))\n  //.\n  //. > filterM(x => x % 2 == 1, Nothing)\n  //. Nothing\n  //.\n  //. > filterM(x => x % 2 == 1, Just(0))\n  //. Nothing\n  //.\n  //. > filterM(x => x % 2 == 1, Just(1))\n  //. Just(1)\n  //. ```\n  function filterM(pred, m) {\n    var M = m.constructor;\n    var z = zero(M);\n    return chain(function(x) { return pred(x) ? of(M, x) : z; }, m);\n  }\n\n  //# alt :: Alt f => (f a, f a) -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/alt`][].\n  //.\n  //. `fantasy-land/alt` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > alt([1, 2, 3], [4, 5, 6])\n  //. [1, 2, 3, 4, 5, 6]\n  //.\n  //. > alt(Nothing, Nothing)\n  //. Nothing\n  //.\n  //. > alt(Nothing, Just(1))\n  //. Just(1)\n  //.\n  //. > alt(Just(2), Just(3))\n  //. Just(2)\n  //. ```\n  function alt(x, y) {\n    return Alt.methods.alt(x)(y);\n  }\n\n  //# zero :: Plus f => TypeRep f -> f a\n  //.\n  //. Function wrapper for [`fantasy-land/zero`][].\n  //.\n  //. `fantasy-land/zero` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > zero(Array)\n  //. []\n  //.\n  //. > zero(Object)\n  //. {}\n  //.\n  //. > zero(Maybe)\n  //. Nothing\n  //. ```\n  function zero(typeRep) {\n    return Plus.methods.zero(typeRep)();\n  }\n\n  //# reduce :: Foldable f => ((b, a) -> b, b, f a) -> b\n  //.\n  //. Function wrapper for [`fantasy-land/reduce`][].\n  //.\n  //. `fantasy-land/reduce` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. ```javascript\n  //. > reduce((xs, x) => [x].concat(xs), [], [1, 2, 3])\n  //. [3, 2, 1]\n  //.\n  //. > reduce(concat, '', Cons('foo', Cons('bar', Cons('baz', Nil))))\n  //. 'foobarbaz'\n  //. ```\n  function reduce(f, x, foldable) {\n    return Foldable.methods.reduce(foldable)(f, x);\n  }\n\n  //# size :: Foldable f => f a -> Integer\n  //.\n  //. Returns the number of elements of the given structure.\n  //.\n  //. This function is derived from [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > size([])\n  //. 0\n  //.\n  //. > size(['foo', 'bar', 'baz'])\n  //. 3\n  //.\n  //. > size(Nil)\n  //. 0\n  //.\n  //. > size(Cons('foo', Cons('bar', Cons('baz', Nil))))\n  //. 3\n  //. ```\n  function size(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray(foldable)) return foldable.length;\n    return reduce(function(n, _) { return n + 1; }, 0, foldable);\n  }\n\n  //# elem :: (Setoid a, Foldable f) => (a, f a) -> Boolean\n  //.\n  //. Takes a value and a structure and returns `true` if the\n  //. value is an element of the structure; `false` otherwise.\n  //.\n  //. This function is derived from [`equals`](#equals) and\n  //. [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > elem('c', ['a', 'b', 'c'])\n  //. true\n  //.\n  //. > elem('x', ['a', 'b', 'c'])\n  //. false\n  //.\n  //. > elem(3, {x: 1, y: 2, z: 3})\n  //. true\n  //.\n  //. > elem(8, {x: 1, y: 2, z: 3})\n  //. false\n  //.\n  //. > elem(0, Just(0))\n  //. true\n  //.\n  //. > elem(0, Just(1))\n  //. false\n  //.\n  //. > elem(0, Nothing)\n  //. false\n  //. ```\n  function elem(x, foldable) {\n    return reduce(function(b, y) { return b || equals(x, y); },\n                  false,\n                  foldable);\n  }\n\n  //# reverse :: (Applicative f, Foldable f, Monoid (f a)) => f a -> f a\n  //.\n  //. Reverses the elements of the given structure.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. ```javascript\n  //. > reverse([1, 2, 3])\n  //. [3, 2, 1]\n  //.\n  //. > reverse(Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(3, Cons(2, Cons(1, Nil)))\n  //. ```\n  function reverse(foldable) {\n    //  Fast path for arrays.\n    if (Array.isArray(foldable)) return foldable.slice().reverse();\n    var F = foldable.constructor;\n    return reduce(function(xs, x) { return concat(of(F, x), xs); },\n                  empty(F),\n                  foldable);\n  }\n\n  //# sort :: (Ord a, Applicative f, Foldable f, Monoid (f a)) => f a -> f a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure,\n  //. using [`lte`](#lte) for comparisons.\n  //.\n  //. This function is derived from [`lte`](#lte), [`concat`](#concat),\n  //. [`empty`](#empty), [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`sortBy`](#sortBy).\n  //.\n  //. ```javascript\n  //. > sort(['foo', 'bar', 'baz'])\n  //. ['bar', 'baz', 'foo']\n  //.\n  //. > sort([Just(2), Nothing, Just(1)])\n  //. [Nothing, Just(1), Just(2)]\n  //.\n  //. > sort(Cons('foo', Cons('bar', Cons('baz', Nil))))\n  //. Cons('bar', Cons('baz', Cons('foo', Nil)))\n  //. ```\n  function sort(foldable) {\n    return sortBy(identity, foldable);\n  }\n\n  //# sortBy :: (Ord b, Applicative f, Foldable f, Monoid (f a)) => (a -> b, f a) -> f a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure,\n  //. using [`lte`](#lte) to compare the values produced by applying the\n  //. given function to each element of the structure.\n  //.\n  //. This function is derived from [`lte`](#lte), [`concat`](#concat),\n  //. [`empty`](#empty), [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`sort`](#sort).\n  //.\n  //. ```javascript\n  //. > sortBy(s => s.length, ['red', 'green', 'blue'])\n  //. ['red', 'blue', 'green']\n  //.\n  //. > sortBy(s => s.length, ['black', 'white'])\n  //. ['black', 'white']\n  //.\n  //. > sortBy(s => s.length, ['white', 'black'])\n  //. ['white', 'black']\n  //.\n  //. > sortBy(s => s.length, Cons('red', Cons('green', Cons('blue', Nil))))\n  //. Cons('red', Cons('blue', Cons('green', Nil)))\n  //. ```\n  function sortBy(f, foldable) {\n    var rs = reduce(function(xs, x) {\n      var fx = f(x);\n      var lower = 0;\n      var upper = xs.length;\n      while (lower < upper) {\n        var idx = Math.floor((lower + upper) / 2);\n        if (lte(xs[idx].fx, fx)) lower = idx + 1; else upper = idx;\n      }\n      xs.splice(lower, 0, {x: x, fx: fx});\n      return xs;\n    }, [], foldable);\n\n    var F = foldable.constructor;\n    var result = empty(F);\n    for (var idx = 0; idx < rs.length; idx += 1) {\n      result = concat(result, of(F, rs[idx].x));\n    }\n    return result;\n  }\n\n  //# takeWhile :: (Applicative f, Foldable f, Monoid (f a)) => (a -> Boolean, f a) -> f a\n  //.\n  //. Discards the first inner value which does not satisfy the predicate, and\n  //. all subsequent inner values.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`dropWhile`](#dropWhile).\n  //.\n  //. ```javascript\n  //. > takeWhile(s => /x/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xy', 'xz', 'yx']\n  //.\n  //. > takeWhile(s => /y/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xy']\n  //.\n  //. > takeWhile(s => /z/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. []\n  //. ```\n  function takeWhile(pred, foldable) {\n    var take = true;\n    return filter(function(x) { return take = take && pred(x); }, foldable);\n  }\n\n  //# dropWhile :: (Applicative f, Foldable f, Monoid (f a)) => (a -> Boolean, f a) -> f a\n  //.\n  //. Retains the first inner value which does not satisfy the predicate, and\n  //. all subsequent inner values.\n  //.\n  //. This function is derived from [`concat`](#concat), [`empty`](#empty),\n  //. [`of`](#of), and [`reduce`](#reduce).\n  //.\n  //. See also [`takeWhile`](#takeWhile).\n  //.\n  //. ```javascript\n  //. > dropWhile(s => /x/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['yz', 'zx', 'zy']\n  //.\n  //. > dropWhile(s => /y/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xz', 'yx', 'yz', 'zx', 'zy']\n  //.\n  //. > dropWhile(s => /z/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])\n  //. ['xy', 'xz', 'yx', 'yz', 'zx', 'zy']\n  //. ```\n  function dropWhile(pred, foldable) {\n    var take = false;\n    return filter(function(x) { return take = take || !pred(x); }, foldable);\n  }\n\n  //# traverse :: (Applicative f, Traversable t) => (TypeRep f, a -> f b, t a) -> f (t b)\n  //.\n  //. Function wrapper for [`fantasy-land/traverse`][].\n  //.\n  //. `fantasy-land/traverse` implementations are provided for the following\n  //. built-in types: Array and Object.\n  //.\n  //. See also [`sequence`](#sequence).\n  //.\n  //. ```javascript\n  //. > traverse(Array, x => x, [[1, 2, 3], [4, 5]])\n  //. [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]\n  //.\n  //. > traverse(Identity, x => Identity(x + 1), [1, 2, 3])\n  //. Identity([2, 3, 4])\n  //. ```\n  function traverse(typeRep, f, traversable) {\n    return Traversable.methods.traverse(traversable)(typeRep, f);\n  }\n\n  //# sequence :: (Applicative f, Traversable t) => (TypeRep f, t (f a)) -> f (t a)\n  //.\n  //. Inverts the given `t (f a)` to produce an `f (t a)`.\n  //.\n  //. This function is derived from [`traverse`](#traverse).\n  //.\n  //. ```javascript\n  //. > sequence(Array, Identity([1, 2, 3]))\n  //. [Identity(1), Identity(2), Identity(3)]\n  //.\n  //. > sequence(Identity, [Identity(1), Identity(2), Identity(3)])\n  //. Identity([1, 2, 3])\n  //. ```\n  function sequence(typeRep, traversable) {\n    return traverse(typeRep, identity, traversable);\n  }\n\n  //# extend :: Extend w => (w a -> b, w a) -> w b\n  //.\n  //. Function wrapper for [`fantasy-land/extend`][].\n  //.\n  //. `fantasy-land/extend` implementations are provided for the following\n  //. built-in types: Array.\n  //.\n  //. ```javascript\n  //. > extend(ss => ss.join(''), ['x', 'y', 'z'])\n  //. ['xyz', 'yz', 'z']\n  //. ```\n  function extend(f, extend_) {\n    return Extend.methods.extend(extend_)(f);\n  }\n\n  //# extract :: Comonad w => w a -> a\n  //.\n  //. Function wrapper for [`fantasy-land/extract`][].\n  //.\n  //. ```javascript\n  //. > extract(Identity(42))\n  //. 42\n  //. ```\n  function extract(comonad) {\n    return Comonad.methods.extract(comonad)();\n  }\n\n  //# contramap :: Contravariant f => (b -> a, f a) -> f b\n  //.\n  //. Function wrapper for [`fantasy-land/contramap`][].\n  //.\n  //. `fantasy-land/contramap` implementations are provided for the following\n  //. built-in types: Function.\n  //.\n  //. ```javascript\n  //. > contramap(s => s.length, Math.sqrt)('Sanctuary')\n  //. 3\n  //. ```\n  function contramap(f, contravariant) {\n    return Contravariant.methods.contramap(contravariant)(f);\n  }\n\n  return {\n    TypeClass: TypeClass,\n    Setoid: Setoid,\n    Ord: Ord,\n    Semigroupoid: Semigroupoid,\n    Category: Category,\n    Semigroup: Semigroup,\n    Monoid: Monoid,\n    Group: Group,\n    Functor: Functor,\n    Bifunctor: Bifunctor,\n    Profunctor: Profunctor,\n    Apply: Apply,\n    Applicative: Applicative,\n    Chain: Chain,\n    ChainRec: ChainRec,\n    Monad: Monad,\n    Alt: Alt,\n    Plus: Plus,\n    Alternative: Alternative,\n    Foldable: Foldable,\n    Traversable: Traversable,\n    Extend: Extend,\n    Comonad: Comonad,\n    Contravariant: Contravariant,\n    toString: toString,\n    equals: equals,\n    lt: lt,\n    lte: lte,\n    gt: gt,\n    gte: gte,\n    min: min,\n    max: max,\n    compose: compose,\n    id: id,\n    concat: concat,\n    empty: empty,\n    invert: invert,\n    map: map,\n    bimap: bimap,\n    promap: promap,\n    ap: ap,\n    lift2: lift2,\n    lift3: lift3,\n    apFirst: apFirst,\n    apSecond: apSecond,\n    of: of,\n    append: append,\n    prepend: prepend,\n    chain: chain,\n    join: join,\n    chainRec: chainRec,\n    filter: filter,\n    filterM: filterM,\n    alt: alt,\n    zero: zero,\n    reduce: reduce,\n    size: size,\n    elem: elem,\n    reverse: reverse,\n    sort: sort,\n    sortBy: sortBy,\n    takeWhile: takeWhile,\n    dropWhile: dropWhile,\n    traverse: traverse,\n    sequence: sequence,\n    extend: extend,\n    extract: extract,\n    contramap: contramap\n  };\n\n}));\n\n//. [Alt]:                      https://github.com/fantasyland/fantasy-land#alt\n//. [Alternative]:              https://github.com/fantasyland/fantasy-land#alternative\n//. [Applicative]:              https://github.com/fantasyland/fantasy-land#applicative\n//. [Apply]:                    https://github.com/fantasyland/fantasy-land#apply\n//. [Bifunctor]:                https://github.com/fantasyland/fantasy-land#bifunctor\n//. [Category]:                 https://github.com/fantasyland/fantasy-land#category\n//. [Chain]:                    https://github.com/fantasyland/fantasy-land#chain\n//. [ChainRec]:                 https://github.com/fantasyland/fantasy-land#chainrec\n//. [Comonad]:                  https://github.com/fantasyland/fantasy-land#comonad\n//. [Contravariant]:            https://github.com/fantasyland/fantasy-land#contravariant\n//. [Extend]:                   https://github.com/fantasyland/fantasy-land#extend\n//. [FL]:                       https://github.com/fantasyland/fantasy-land\n//. [Foldable]:                 https://github.com/fantasyland/fantasy-land#foldable\n//. [Functor]:                  https://github.com/fantasyland/fantasy-land#functor\n//. [Group]:                    https://github.com/fantasyland/fantasy-land#group\n//. [Monad]:                    https://github.com/fantasyland/fantasy-land#monad\n//. [Monoid]:                   https://github.com/fantasyland/fantasy-land#monoid\n//. [Ord]:                      https://github.com/fantasyland/fantasy-land#ord\n//. [Plus]:                     https://github.com/fantasyland/fantasy-land#plus\n//. [Profunctor]:               https://github.com/fantasyland/fantasy-land#profunctor\n//. [Semigroup]:                https://github.com/fantasyland/fantasy-land#semigroup\n//. [Semigroupoid]:             https://github.com/fantasyland/fantasy-land#semigroupoid\n//. [Setoid]:                   https://github.com/fantasyland/fantasy-land#setoid\n//. [Traversable]:              https://github.com/fantasyland/fantasy-land#traversable\n//. [`fantasy-land/alt`]:       https://github.com/fantasyland/fantasy-land#alt-method\n//. [`fantasy-land/ap`]:        https://github.com/fantasyland/fantasy-land#ap-method\n//. [`fantasy-land/bimap`]:     https://github.com/fantasyland/fantasy-land#bimap-method\n//. [`fantasy-land/chain`]:     https://github.com/fantasyland/fantasy-land#chain-method\n//. [`fantasy-land/chainRec`]:  https://github.com/fantasyland/fantasy-land#chainrec-method\n//. [`fantasy-land/compose`]:   https://github.com/fantasyland/fantasy-land#compose-method\n//. [`fantasy-land/concat`]:    https://github.com/fantasyland/fantasy-land#concat-method\n//. [`fantasy-land/contramap`]: https://github.com/fantasyland/fantasy-land#contramap-method\n//. [`fantasy-land/empty`]:     https://github.com/fantasyland/fantasy-land#empty-method\n//. [`fantasy-land/equals`]:    https://github.com/fantasyland/fantasy-land#equals-method\n//. [`fantasy-land/extend`]:    https://github.com/fantasyland/fantasy-land#extend-method\n//. [`fantasy-land/extract`]:   https://github.com/fantasyland/fantasy-land#extract-method\n//. [`fantasy-land/id`]:        https://github.com/fantasyland/fantasy-land#id-method\n//. [`fantasy-land/invert`]:    https://github.com/fantasyland/fantasy-land#invert-method\n//. [`fantasy-land/lte`]:       https://github.com/fantasyland/fantasy-land#lte-method\n//. [`fantasy-land/map`]:       https://github.com/fantasyland/fantasy-land#map-method\n//. [`fantasy-land/of`]:        https://github.com/fantasyland/fantasy-land#of-method\n//. [`fantasy-land/promap`]:    https://github.com/fantasyland/fantasy-land#promap-method\n//. [`fantasy-land/reduce`]:    https://github.com/fantasyland/fantasy-land#reduce-method\n//. [`fantasy-land/traverse`]:  https://github.com/fantasyland/fantasy-land#traverse-method\n//. [`fantasy-land/zero`]:      https://github.com/fantasyland/fantasy-land#zero-method\n//. [stable sort]:              https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\n//. [type-classes]:             https://github.com/sanctuary-js/sanctuary-def#type-classes\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5L25vZGVfbW9kdWxlcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzL2luZGV4LmpzP2U1NzEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICAgICAgICAgICAjIyMjIyMjIyMjIyMgICAgICAgICAgICAgICAgICAjXG4gICAgICAgICAgICAjIyMjIyMjIyMjIyMgICAgICAgICAgICAgICAgICAjIyNcbiAgICAgICAgICAgICAgICAgICMjIyMjICAgICAgICAgICAgICAgICAgIyMjIyNcbiAgICAgICAgICAgICAgICAjIyMjIyAgICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gICAgICAgICAgICAgICMjIyMjICAgICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbiAgICAgICAgICAgICMjIyMjICAgICAgICAgICAgICAgICAgICAgIyMjIyMjIyMjIyNcbiAgICAgICAgICAjIyMjIyAgICAgICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbiAgICAgICAgIyMjIyMgICAgICAgICAgIyMjIyMjIyMjIyMjIyMjIyMjIyNcbiAgICAgICMjIyMjICAgICAgICAgICAgICAgICAgICAgICAgIyMjIyNcbiAgICAgIyMjIyMjIyMjIyMjICAgICAgICAgICAgICAgICAjIyNcbiAgICAjIyMjIyMjIyMjIyMgICAgICAgICAgICAgICAgICovXG5cbi8vLiAjIHNhbmN0dWFyeS10eXBlLWNsYXNzZXNcbi8vLlxuLy8uIFRoZSBbRmFudGFzeSBMYW5kIFNwZWNpZmljYXRpb25dW0ZMXSBcInNwZWNpZmllcyBpbnRlcm9wZXJhYmlsaXR5IG9mIGNvbW1vblxuLy8uIGFsZ2VicmFpYyBzdHJ1Y3R1cmVzXCIgYnkgZGVmaW5pbmcgYSBudW1iZXIgb2YgdHlwZSBjbGFzc2VzLiBGb3IgZWFjaCB0eXBlXG4vLy4gY2xhc3MsIGl0IHN0YXRlcyBsYXdzIHdoaWNoIGV2ZXJ5IG1lbWJlciBvZiBhIHR5cGUgbXVzdCBvYmV5IGluIG9yZGVyIGZvclxuLy8uIHRoZSB0eXBlIHRvIGJlIGEgbWVtYmVyIG9mIHRoZSB0eXBlIGNsYXNzLiBJbiBvcmRlciBmb3IgdGhlIE1heWJlIHR5cGUgdG9cbi8vLiBiZSBjb25zaWRlcmVkIGEgW0Z1bmN0b3JdW10sIGZvciBleGFtcGxlLCBldmVyeSBgTWF5YmUgYWAgdmFsdWUgbXVzdCBoYXZlXG4vLy4gYSBgZmFudGFzeS1sYW5kL21hcGAgbWV0aG9kIHdoaWNoIG9iZXlzIHRoZSBpZGVudGl0eSBhbmQgY29tcG9zaXRpb24gbGF3cy5cbi8vLlxuLy8uIFRoaXMgcHJvamVjdCBwcm92aWRlczpcbi8vLlxuLy8uICAgLSBbYFR5cGVDbGFzc2BdKCNUeXBlQ2xhc3MpLCBhIGZ1bmN0aW9uIGZvciBkZWZpbmluZyB0eXBlIGNsYXNzZXM7XG4vLy4gICAtIG9uZSBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgZWFjaCBGYW50YXN5IExhbmQgdHlwZSBjbGFzcztcbi8vLiAgIC0gbGF3ZnVsIEZhbnRhc3kgTGFuZCBtZXRob2RzIGZvciBKYXZhU2NyaXB0J3MgYnVpbHQtaW4gdHlwZXM7XG4vLy4gICAtIG9uZSBmdW5jdGlvbiBmb3IgZWFjaCBGYW50YXN5IExhbmQgbWV0aG9kOyBhbmRcbi8vLiAgIC0gc2V2ZXJhbCBmdW5jdGlvbnMgZGVyaXZlZCBmcm9tIHRoZXNlIGZ1bmN0aW9ucy5cbi8vLlxuLy8uICMjIFR5cGUtY2xhc3MgaGllcmFyY2h5XG4vLy5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbi8vLiA8cHJlPlxuLy8uICBTZXRvaWQgICBTZW1pZ3JvdXBvaWQgIFNlbWlncm91cCAgIEZvbGRhYmxlICAgICAgICBGdW5jdG9yICAgICAgQ29udHJhdmFyaWFudFxuLy8uIChlcXVhbHMpICAgIChjb21wb3NlKSAgICAoY29uY2F0KSAgIChyZWR1Y2UpICAgICAgICAgKG1hcCkgICAgICAgIChjb250cmFtYXApXG4vLy4gICAgIHwgICAgICAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgIFxcICAgICAgICAgLyB8IHwgfCB8IFxcXG4vLy4gICAgIHwgICAgICAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICBcXCAgICAgICAvICB8IHwgfCB8ICBcXFxuLy8uICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgIFxcICAgICAvICAgfCB8IHwgfCAgIFxcXG4vLy4gICAgIHwgICAgICAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgIFxcICAgLyAgICB8IHwgfCB8ICAgIFxcXG4vLy4gICAgIHwgICAgICAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICBcXCAvICAgICB8IHwgfCB8ICAgICBcXFxuLy8uICAgIE9yZCAgICAgIENhdGVnb3J5ICAgICBNb25vaWQgICAgICAgICBUcmF2ZXJzYWJsZSB8IHwgfCB8ICAgICAgXFxcbi8vLiAgIChsdGUpICAgICAgIChpZCkgICAgICAgKGVtcHR5KSAgICAgICAgKHRyYXZlcnNlKSAgLyB8IHwgXFwgICAgICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAvICB8IHwgIFxcICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAvICAgLyBcXCAgIFxcICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgUHJvZnVuY3RvciAvICAgXFwgQmlmdW5jdG9yIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIChwcm9tYXApIC8gICAgIFxcIChiaW1hcCkgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgXFwgICAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICBHcm91cCAgICAgICAgICAgICAgICAgICAvICAgICAgICAgXFwgICAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgIChpbnZlcnQpICAgICAgICAgICAgICAgQWx0ICAgICAgICBBcHBseSAgICAgIEV4dGVuZFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFsdCkgICAgICAgIChhcCkgICAgIChleHRlbmQpXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgICAgICAgICAgLyBcXCAgICAgICAgICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgICAgIC8gICBcXCAgICAgICAgICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgICAgICAgICAgLyAgICAgXFwgICAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgICAgICAgICAgLyAgICAgICBcXCAgICAgICAgICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgICAgIC8gICAgICAgICBcXCAgICAgICAgICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQbHVzICAgIEFwcGxpY2F0aXZlICAgIENoYWluICAgICAgQ29tb25hZFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHplcm8pICAgICAgIChvZikgICAgICAoY2hhaW4pICAgIChleHRyYWN0KVxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFwgICAgICAgICAvIFxcICAgICAgICAgLyBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcICAgICAgIC8gICBcXCAgICAgICAvICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFwgICAgIC8gICAgIFxcICAgICAvICAgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFwgICAvICAgICAgIFxcICAgLyAgICAgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcIC8gICAgICAgICBcXCAvICAgICAgICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsdGVybmF0aXZlICAgIE1vbmFkICAgICBDaGFpblJlY1xuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNoYWluUmVjKVxuLy8uIDwvcHJlPlxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG4vLy5cbi8vLiAjIyBBUElcblxuKGZ1bmN0aW9uKGYpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGYocmVxdWlyZSgnc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMnKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICE9IG51bGwpIHtcbiAgICBkZWZpbmUoWydzYW5jdHVhcnktdHlwZS1pZGVudGlmaWVycyddLCBmKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnNhbmN0dWFyeVR5cGVDbGFzc2VzID0gZihzZWxmLnNhbmN0dWFyeVR5cGVJZGVudGlmaWVycyk7XG4gIH1cblxufShmdW5jdGlvbih0eXBlKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vICBjb25jYXRfIDo6IEFycmF5IGEgLT4gQXJyYXkgYSAtPiBBcnJheSBhXG4gIGZ1bmN0aW9uIGNvbmNhdF8oeHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeXMpIHtcbiAgICAgIHJldHVybiB4cy5jb25jYXQoeXMpO1xuICAgIH07XG4gIH1cblxuICAvLyAgY29uc3RhbnQgOjogYSAtPiBiIC0+IGFcbiAgZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9O1xuICB9XG5cbiAgLy8gIGZvckVhY2hLZXkgOjogKFN0ck1hcCBhLCBTdHJNYXAgYSB+PiBTdHJpbmcgLT4gVW5kZWZpbmVkKSAtPiBVbmRlZmluZWRcbiAgZnVuY3Rpb24gZm9yRWFjaEtleShzdHJNYXAsIGYpIHtcbiAgICBPYmplY3Qua2V5cyhzdHJNYXApLmZvckVhY2goZiwgc3RyTWFwKTtcbiAgfVxuXG4gIC8vICBoYXMgOjogKFN0cmluZywgT2JqZWN0KSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIGhhcyhrLCBvKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKTtcbiAgfVxuXG4gIC8vICBpZGVudGl0eSA6OiBhIC0+IGFcbiAgZnVuY3Rpb24gaWRlbnRpdHkoeCkgeyByZXR1cm4geDsgfVxuXG4gIC8vICBwYWlyIDo6IGEgLT4gYiAtPiBQYWlyIGEgYlxuICBmdW5jdGlvbiBwYWlyKHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9O1xuICB9XG5cbiAgLy8gIHNhbWVUeXBlIDo6IChhLCBiKSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIHNhbWVUeXBlKHgsIHkpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IHR5cGVvZiB5ICYmIHR5cGUoeCkgPT09IHR5cGUoeSk7XG4gIH1cblxuICAvLyAgdHlwZSBJdGVyYXRpb24gYSA9IHsgdmFsdWUgOjogYSwgZG9uZSA6OiBCb29sZWFuIH1cblxuICAvLyAgaXRlcmF0aW9uTmV4dCA6OiBhIC0+IEl0ZXJhdGlvbiBhXG4gIGZ1bmN0aW9uIGl0ZXJhdGlvbk5leHQoeCkgeyByZXR1cm4ge3ZhbHVlOiB4LCBkb25lOiBmYWxzZX07IH1cblxuICAvLyAgaXRlcmF0aW9uRG9uZSA6OiBhIC0+IEl0ZXJhdGlvbiBhXG4gIGZ1bmN0aW9uIGl0ZXJhdGlvbkRvbmUoeCkgeyByZXR1cm4ge3ZhbHVlOiB4LCBkb25lOiB0cnVlfTsgfVxuXG4gIC8vIyBUeXBlQ2xhc3MgOjogKFN0cmluZywgU3RyaW5nLCBBcnJheSBUeXBlQ2xhc3MsIGEgLT4gQm9vbGVhbikgLT4gVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gVGhlIGFyZ3VtZW50cyBhcmU6XG4gIC8vLlxuICAvLy4gICAtIHRoZSBuYW1lIG9mIHRoZSB0eXBlIGNsYXNzLCBwcmVmaXhlZCBieSBpdHMgbnBtIHBhY2thZ2UgbmFtZTtcbiAgLy8uICAgLSB0aGUgZG9jdW1lbnRhdGlvbiBVUkwgb2YgdGhlIHR5cGUgY2xhc3M7XG4gIC8vLiAgIC0gYW4gYXJyYXkgb2YgZGVwZW5kZW5jaWVzOyBhbmRcbiAgLy8uICAgLSBhIHByZWRpY2F0ZSB3aGljaCBhY2NlcHRzIGFueSBKYXZhU2NyaXB0IHZhbHVlIGFuZCByZXR1cm5zIGB0cnVlYFxuICAvLy4gICAgIGlmIHRoZSB2YWx1ZSBzYXRpc2ZpZXMgdGhlIHJlcXVpcmVtZW50cyBvZiB0aGUgdHlwZSBjbGFzczsgYGZhbHNlYFxuICAvLy4gICAgIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBFeGFtcGxlOlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uIC8vICAgIGhhc01ldGhvZCA6OiBTdHJpbmcgLT4gYSAtPiBCb29sZWFuXG4gIC8vLiBjb25zdCBoYXNNZXRob2QgPSBuYW1lID0+IHggPT4geCAhPSBudWxsICYmIHR5cGVvZiB4W25hbWVdID09ICdmdW5jdGlvbic7XG4gIC8vLlxuICAvLy4gLy8gICAgRm9vIDo6IFR5cGVDbGFzc1xuICAvLy4gY29uc3QgRm9vID0gWi5UeXBlQ2xhc3MoXG4gIC8vLiAgICdteS1wYWNrYWdlL0ZvbycsXG4gIC8vLiAgICdodHRwOi8vZXhhbXBsZS5jb20vbXktcGFja2FnZSNGb28nLFxuICAvLy4gICBbXSxcbiAgLy8uICAgaGFzTWV0aG9kKCdmb28nKVxuICAvLy4gKTtcbiAgLy8uXG4gIC8vLiAvLyAgICBCYXIgOjogVHlwZUNsYXNzXG4gIC8vLiBjb25zdCBCYXIgPSBaLlR5cGVDbGFzcyhcbiAgLy8uICAgJ215LXBhY2thZ2UvQmFyJyxcbiAgLy8uICAgJ2h0dHA6Ly9leGFtcGxlLmNvbS9teS1wYWNrYWdlI0JhcicsXG4gIC8vLiAgIFtGb29dLFxuICAvLy4gICBoYXNNZXRob2QoJ2JhcicpXG4gIC8vLiApO1xuICAvLy4gYGBgXG4gIC8vLlxuICAvLy4gVHlwZXMgd2hvc2UgdmFsdWVzIGhhdmUgYSBgZm9vYCBtZXRob2QgYXJlIG1lbWJlcnMgb2YgdGhlIEZvbyB0eXBlIGNsYXNzLlxuICAvLy4gTWVtYmVycyBvZiB0aGUgRm9vIHR5cGUgY2xhc3Mgd2hvc2UgdmFsdWVzIGhhdmUgYSBgYmFyYCBtZXRob2QgYXJlIGFsc29cbiAgLy8uIG1lbWJlcnMgb2YgdGhlIEJhciB0eXBlIGNsYXNzLlxuICAvLy5cbiAgLy8uIEVhY2ggYFR5cGVDbGFzc2AgdmFsdWUgaGFzIGEgYHRlc3RgIGZpZWxkOiBhIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdHNcbiAgLy8uIGFueSBKYXZhU2NyaXB0IHZhbHVlIGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgc2F0aXNmaWVzIHRoZVxuICAvLy4gdHlwZSBjbGFzcydzIHByZWRpY2F0ZSBhbmQgdGhlIHByZWRpY2F0ZXMgb2YgYWxsIHRoZSB0eXBlIGNsYXNzJ3NcbiAgLy8uIGRlcGVuZGVuY2llczsgYGZhbHNlYCBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWVzIG1heSBiZSB1c2VkIHdpdGggW3NhbmN0dWFyeS1kZWZdW3R5cGUtY2xhc3Nlc11cbiAgLy8uIHRvIGRlZmluZSBwYXJhbWV0cmljYWxseSBwb2x5bW9ycGhpYyBmdW5jdGlvbnMgd2hpY2ggdmVyaWZ5IHRoZWlyXG4gIC8vLiB0eXBlLWNsYXNzIGNvbnN0cmFpbnRzIGF0IHJ1biB0aW1lLlxuICBmdW5jdGlvbiBUeXBlQ2xhc3MobmFtZSwgdXJsLCBkZXBlbmRlbmNpZXMsIHRlc3QpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHlwZUNsYXNzKSkge1xuICAgICAgcmV0dXJuIG5ldyBUeXBlQ2xhc3MobmFtZSwgdXJsLCBkZXBlbmRlbmNpZXMsIHRlc3QpO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMudGVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBkZXBlbmRlbmNpZXMuZXZlcnkoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50ZXN0KHgpOyB9KSAmJiB0ZXN0KHgpO1xuICAgIH07XG4gIH1cblxuICBUeXBlQ2xhc3NbJ0BAdHlwZSddID0gJ3NhbmN0dWFyeS10eXBlLWNsYXNzZXMvVHlwZUNsYXNzJztcblxuICAvLyAgZGF0YSBMb2NhdGlvbiA9IENvbnN0cnVjdG9yIHwgVmFsdWVcblxuICAvLyAgQ29uc3RydWN0b3IgOjogTG9jYXRpb25cbiAgdmFyIENvbnN0cnVjdG9yID0gJ0NvbnN0cnVjdG9yJztcblxuICAvLyAgVmFsdWUgOjogTG9jYXRpb25cbiAgdmFyIFZhbHVlID0gJ1ZhbHVlJztcblxuICAvLyAgX2Z1bmNQYXRoIDo6IChCb29sZWFuLCBBcnJheSBTdHJpbmcsIGEpIC0+IE51bGxhYmxlIEZ1bmN0aW9uXG4gIGZ1bmN0aW9uIF9mdW5jUGF0aChhbGxvd0luaGVyaXRlZFByb3BzLCBwYXRoLCBfeCkge1xuICAgIHZhciB4ID0gX3g7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgcGF0aC5sZW5ndGg7IGlkeCArPSAxKSB7XG4gICAgICB2YXIgayA9IHBhdGhbaWR4XTtcbiAgICAgIGlmICh4ID09IG51bGwgfHwgIShhbGxvd0luaGVyaXRlZFByb3BzIHx8IGhhcyhrLCB4KSkpIHJldHVybiBudWxsO1xuICAgICAgeCA9IHhba107XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyA/IHggOiBudWxsO1xuICB9XG5cbiAgLy8gIGZ1bmNQYXRoIDo6IChBcnJheSBTdHJpbmcsIGEpIC0+IE51bGxhYmxlIEZ1bmN0aW9uXG4gIGZ1bmN0aW9uIGZ1bmNQYXRoKHBhdGgsIHgpIHtcbiAgICByZXR1cm4gX2Z1bmNQYXRoKHRydWUsIHBhdGgsIHgpO1xuICB9XG5cbiAgLy8gIGltcGxQYXRoIDo6IEFycmF5IFN0cmluZyAtPiBOdWxsYWJsZSBGdW5jdGlvblxuICBmdW5jdGlvbiBpbXBsUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIF9mdW5jUGF0aChmYWxzZSwgcGF0aCwgaW1wbGVtZW50YXRpb25zKTtcbiAgfVxuXG4gIC8vICBmdW5jdGlvbk5hbWUgOjogRnVuY3Rpb24gLT4gU3RyaW5nXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBoYXMoJ25hbWUnLCBmdW5jdGlvbiBmKCkge30pID9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbk5hbWUoZikgeyByZXR1cm4gZi5uYW1lOyB9IDpcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uTmFtZShmKSB7XG4gICAgICB2YXIgbWF0Y2ggPSAvZnVuY3Rpb24gKFxcdyopLy5leGVjKGYpO1xuICAgICAgcmV0dXJuIG1hdGNoID09IG51bGwgPyAnJyA6IG1hdGNoWzFdO1xuICAgIH07XG5cbiAgLy8gICQgOjogKFN0cmluZywgQXJyYXkgVHlwZUNsYXNzLCBTdHJNYXAgKEFycmF5IExvY2F0aW9uKSkgLT4gVHlwZUNsYXNzXG4gIGZ1bmN0aW9uICQoX25hbWUsIGRlcGVuZGVuY2llcywgcmVxdWlyZW1lbnRzKSB7XG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRNZXRob2QoX25hbWUpIHtcbiAgICAgIHZhciBuYW1lID0gJ2ZhbnRhc3ktbGFuZC8nICsgX25hbWU7XG4gICAgICByZXR1cm4gcmVxdWlyZW1lbnRzW19uYW1lXSA9PT0gQ29uc3RydWN0b3IgP1xuICAgICAgICBmdW5jdGlvbih0eXBlUmVwKSB7XG4gICAgICAgICAgdmFyIGYgPSBmdW5jUGF0aChbbmFtZV0sIHR5cGVSZXApO1xuICAgICAgICAgIHJldHVybiBmID09IG51bGwgJiYgdHlwZW9mIHR5cGVSZXAgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgaW1wbFBhdGgoW2Z1bmN0aW9uTmFtZSh0eXBlUmVwKSwgbmFtZV0pIDpcbiAgICAgICAgICAgIGY7XG4gICAgICAgIH0gOlxuICAgICAgICBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgdmFyIGlzUHJvdG90eXBlID0geCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5jb25zdHJ1Y3RvciAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHg7XG4gICAgICAgICAgdmFyIG0gPSBudWxsO1xuICAgICAgICAgIGlmICghaXNQcm90b3R5cGUpIG0gPSBmdW5jUGF0aChbbmFtZV0sIHgpO1xuICAgICAgICAgIGlmIChtID09IG51bGwpICAgIG0gPSBpbXBsUGF0aChbdHlwZSh4KSwgJ3Byb3RvdHlwZScsIG5hbWVdKTtcbiAgICAgICAgICByZXR1cm4gbSAmJiBtLmJpbmQoeCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHZlcnNpb24gPSAnNy4xLjEnOyAgLy8gdXBkYXRlZCBwcm9ncmFtbWF0aWNhbGx5XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZXF1aXJlbWVudHMpO1xuXG4gICAgdmFyIHR5cGVDbGFzcyA9IFR5cGVDbGFzcyhcbiAgICAgICdzYW5jdHVhcnktdHlwZS1jbGFzc2VzLycgKyBfbmFtZSxcbiAgICAgICdodHRwczovL2dpdGh1Yi5jb20vc2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMvdHJlZS92JyArIHZlcnNpb25cbiAgICAgICAgKyAnIycgKyBfbmFtZSxcbiAgICAgIGRlcGVuZGVuY2llcyxcbiAgICAgIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIGtleXMuZXZlcnkoZnVuY3Rpb24oX25hbWUpIHtcbiAgICAgICAgICB2YXIgYXJnID0gcmVxdWlyZW1lbnRzW19uYW1lXSA9PT0gQ29uc3RydWN0b3IgPyB4LmNvbnN0cnVjdG9yIDogeDtcbiAgICAgICAgICByZXR1cm4gZ2V0Qm91bmRNZXRob2QoX25hbWUpKGFyZykgIT0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIHR5cGVDbGFzcy5tZXRob2RzID0ga2V5cy5yZWR1Y2UoZnVuY3Rpb24obWV0aG9kcywgX25hbWUpIHtcbiAgICAgIG1ldGhvZHNbX25hbWVdID0gZ2V0Qm91bmRNZXRob2QoX25hbWUpO1xuICAgICAgcmV0dXJuIG1ldGhvZHM7XG4gICAgfSwge30pO1xuXG4gICAgcmV0dXJuIHR5cGVDbGFzcztcbiAgfVxuXG4gIC8vIyBTZXRvaWQgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtTZXRvaWRdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTZXRvaWQudGVzdChudWxsKVxuICAvLy4gdHJ1ZVxuICAvLy4gYGBgXG4gIHZhciBTZXRvaWQgPSAkKCdTZXRvaWQnLCBbXSwge2VxdWFsczogVmFsdWV9KTtcblxuICAvLyMgT3JkIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbT3JkXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gT3JkLnRlc3QoMClcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IE9yZC50ZXN0KE1hdGguc3FydClcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIE9yZCA9ICQoJ09yZCcsIFtTZXRvaWRdLCB7bHRlOiBWYWx1ZX0pO1xuXG4gIC8vIyBTZW1pZ3JvdXBvaWQgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtTZW1pZ3JvdXBvaWRdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTZW1pZ3JvdXBvaWQudGVzdChNYXRoLnNxcnQpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTZW1pZ3JvdXBvaWQudGVzdCgwKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgU2VtaWdyb3Vwb2lkID0gJCgnU2VtaWdyb3Vwb2lkJywgW10sIHtjb21wb3NlOiBWYWx1ZX0pO1xuXG4gIC8vIyBDYXRlZ29yeSA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0NhdGVnb3J5XVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQ2F0ZWdvcnkudGVzdChNYXRoLnNxcnQpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBDYXRlZ29yeS50ZXN0KDApXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBDYXRlZ29yeSA9ICQoJ0NhdGVnb3J5JywgW1NlbWlncm91cG9pZF0sIHtpZDogQ29uc3RydWN0b3J9KTtcblxuICAvLyMgU2VtaWdyb3VwIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbU2VtaWdyb3VwXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gU2VtaWdyb3VwLnRlc3QoJycpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTZW1pZ3JvdXAudGVzdCgwKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgU2VtaWdyb3VwID0gJCgnU2VtaWdyb3VwJywgW10sIHtjb25jYXQ6IFZhbHVlfSk7XG5cbiAgLy8jIE1vbm9pZCA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW01vbm9pZF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IE1vbm9pZC50ZXN0KCcnKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gTW9ub2lkLnRlc3QoMClcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIE1vbm9pZCA9ICQoJ01vbm9pZCcsIFtTZW1pZ3JvdXBdLCB7ZW1wdHk6IENvbnN0cnVjdG9yfSk7XG5cbiAgLy8jIEdyb3VwIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbR3JvdXBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBHcm91cC50ZXN0KFN1bSgwKSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IEdyb3VwLnRlc3QoJycpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBHcm91cCA9ICQoJ0dyb3VwJywgW01vbm9pZF0sIHtpbnZlcnQ6IFZhbHVlfSk7XG5cbiAgLy8jIEZ1bmN0b3IgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtGdW5jdG9yXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gRnVuY3Rvci50ZXN0KFtdKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gRnVuY3Rvci50ZXN0KCcnKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgRnVuY3RvciA9ICQoJ0Z1bmN0b3InLCBbXSwge21hcDogVmFsdWV9KTtcblxuICAvLyMgQmlmdW5jdG9yIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbQmlmdW5jdG9yXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQmlmdW5jdG9yLnRlc3QoVHVwbGUoJ2ZvbycsIDY0KSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IEJpZnVuY3Rvci50ZXN0KFtdKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgQmlmdW5jdG9yID0gJCgnQmlmdW5jdG9yJywgW0Z1bmN0b3JdLCB7YmltYXA6IFZhbHVlfSk7XG5cbiAgLy8jIFByb2Z1bmN0b3IgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtQcm9mdW5jdG9yXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUHJvZnVuY3Rvci50ZXN0KE1hdGguc3FydClcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFByb2Z1bmN0b3IudGVzdChbXSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIFByb2Z1bmN0b3IgPSAkKCdQcm9mdW5jdG9yJywgW0Z1bmN0b3JdLCB7cHJvbWFwOiBWYWx1ZX0pO1xuXG4gIC8vIyBBcHBseSA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0FwcGx5XVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQXBwbHkudGVzdChbXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IEFwcGx5LnRlc3QoJycpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBBcHBseSA9ICQoJ0FwcGx5JywgW0Z1bmN0b3JdLCB7YXA6IFZhbHVlfSk7XG5cbiAgLy8jIEFwcGxpY2F0aXZlIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbQXBwbGljYXRpdmVdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBBcHBsaWNhdGl2ZS50ZXN0KFtdKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gQXBwbGljYXRpdmUudGVzdCh7fSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIEFwcGxpY2F0aXZlID0gJCgnQXBwbGljYXRpdmUnLCBbQXBwbHldLCB7b2Y6IENvbnN0cnVjdG9yfSk7XG5cbiAgLy8jIENoYWluIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbQ2hhaW5dW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBDaGFpbi50ZXN0KFtdKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gQ2hhaW4udGVzdCh7fSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIENoYWluID0gJCgnQ2hhaW4nLCBbQXBwbHldLCB7Y2hhaW46IFZhbHVlfSk7XG5cbiAgLy8jIENoYWluUmVjIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbQ2hhaW5SZWNdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBDaGFpblJlYy50ZXN0KFtdKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gQ2hhaW5SZWMudGVzdCh7fSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIENoYWluUmVjID0gJCgnQ2hhaW5SZWMnLCBbQ2hhaW5dLCB7Y2hhaW5SZWM6IENvbnN0cnVjdG9yfSk7XG5cbiAgLy8jIE1vbmFkIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbTW9uYWRdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBNb25hZC50ZXN0KFtdKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gTW9uYWQudGVzdCh7fSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIE1vbmFkID0gJCgnTW9uYWQnLCBbQXBwbGljYXRpdmUsIENoYWluXSwge30pO1xuXG4gIC8vIyBBbHQgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtBbHRdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBBbHQudGVzdCh7fSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IEFsdC50ZXN0KCcnKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgQWx0ID0gJCgnQWx0JywgW0Z1bmN0b3JdLCB7YWx0OiBWYWx1ZX0pO1xuXG4gIC8vIyBQbHVzIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbUGx1c11bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFBsdXMudGVzdCh7fSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFBsdXMudGVzdCgnJylcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIFBsdXMgPSAkKCdQbHVzJywgW0FsdF0sIHt6ZXJvOiBDb25zdHJ1Y3Rvcn0pO1xuXG4gIC8vIyBBbHRlcm5hdGl2ZSA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0FsdGVybmF0aXZlXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQWx0ZXJuYXRpdmUudGVzdChbXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IEFsdGVybmF0aXZlLnRlc3Qoe30pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBBbHRlcm5hdGl2ZSA9ICQoJ0FsdGVybmF0aXZlJywgW0FwcGxpY2F0aXZlLCBQbHVzXSwge30pO1xuXG4gIC8vIyBGb2xkYWJsZSA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0ZvbGRhYmxlXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gRm9sZGFibGUudGVzdCh7fSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IEZvbGRhYmxlLnRlc3QoJycpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBGb2xkYWJsZSA9ICQoJ0ZvbGRhYmxlJywgW10sIHtyZWR1Y2U6IFZhbHVlfSk7XG5cbiAgLy8jIFRyYXZlcnNhYmxlIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbVHJhdmVyc2FibGVdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBUcmF2ZXJzYWJsZS50ZXN0KFtdKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gVHJhdmVyc2FibGUudGVzdCgnJylcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIFRyYXZlcnNhYmxlID0gJCgnVHJhdmVyc2FibGUnLCBbRnVuY3RvciwgRm9sZGFibGVdLCB7dHJhdmVyc2U6IFZhbHVlfSk7XG5cbiAgLy8jIEV4dGVuZCA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0V4dGVuZF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IEV4dGVuZC50ZXN0KFtdKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gRXh0ZW5kLnRlc3Qoe30pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBFeHRlbmQgPSAkKCdFeHRlbmQnLCBbRnVuY3Rvcl0sIHtleHRlbmQ6IFZhbHVlfSk7XG5cbiAgLy8jIENvbW9uYWQgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtDb21vbmFkXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQ29tb25hZC50ZXN0KElkZW50aXR5KDApKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gQ29tb25hZC50ZXN0KFtdKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgQ29tb25hZCA9ICQoJ0NvbW9uYWQnLCBbRXh0ZW5kXSwge2V4dHJhY3Q6IFZhbHVlfSk7XG5cbiAgLy8jIENvbnRyYXZhcmlhbnQgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtDb250cmF2YXJpYW50XVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQ29udHJhdmFyaWFudC50ZXN0KE1hdGguc3FydClcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IENvbnRyYXZhcmlhbnQudGVzdChbXSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIENvbnRyYXZhcmlhbnQgPSAkKCdDb250cmF2YXJpYW50JywgW10sIHtjb250cmFtYXA6IFZhbHVlfSk7XG5cbiAgLy8gIE51bGwkcHJvdG90eXBlJHRvU3RyaW5nIDo6IE51bGwgfj4gKCkgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIE51bGwkcHJvdG90eXBlJHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH1cblxuICAvLyAgTnVsbCRwcm90b3R5cGUkZXF1YWxzIDo6IE51bGwgfj4gTnVsbCAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIE51bGwkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gIE51bGwkcHJvdG90eXBlJGx0ZSA6OiBOdWxsIH4+IE51bGwgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBOdWxsJHByb3RvdHlwZSRsdGUob3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vICBVbmRlZmluZWQkcHJvdG90eXBlJHRvU3RyaW5nIDo6IFVuZGVmaW5lZCB+PiAoKSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gVW5kZWZpbmVkJHByb3RvdHlwZSR0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICAvLyAgVW5kZWZpbmVkJHByb3RvdHlwZSRlcXVhbHMgOjogVW5kZWZpbmVkIH4+IFVuZGVmaW5lZCAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIFVuZGVmaW5lZCRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyAgVW5kZWZpbmVkJHByb3RvdHlwZSRsdGUgOjogVW5kZWZpbmVkIH4+IFVuZGVmaW5lZCAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIFVuZGVmaW5lZCRwcm90b3R5cGUkbHRlKG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyAgQm9vbGVhbiRwcm90b3R5cGUkdG9TdHJpbmcgOjogQm9vbGVhbiB+PiAoKSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gQm9vbGVhbiRwcm90b3R5cGUkdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzID09PSAnb2JqZWN0JyA/XG4gICAgICAnbmV3IEJvb2xlYW4oJyArIHRvU3RyaW5nKHRoaXMudmFsdWVPZigpKSArICcpJyA6XG4gICAgICB0aGlzLnRvU3RyaW5nKCk7XG4gIH1cblxuICAvLyAgQm9vbGVhbiRwcm90b3R5cGUkZXF1YWxzIDo6IEJvb2xlYW4gfj4gQm9vbGVhbiAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIEJvb2xlYW4kcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcyA9PT0gJ29iamVjdCcgP1xuICAgICAgZXF1YWxzKHRoaXMudmFsdWVPZigpLCBvdGhlci52YWx1ZU9mKCkpIDpcbiAgICAgIHRoaXMgPT09IG90aGVyO1xuICB9XG5cbiAgLy8gIEJvb2xlYW4kcHJvdG90eXBlJGx0ZSA6OiBCb29sZWFuIH4+IEJvb2xlYW4gLT4gQm9vbGVhblxuICBmdW5jdGlvbiBCb29sZWFuJHByb3RvdHlwZSRsdGUob3RoZXIpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMgPT09ICdvYmplY3QnID9cbiAgICAgIGx0ZSh0aGlzLnZhbHVlT2YoKSwgb3RoZXIudmFsdWVPZigpKSA6XG4gICAgICB0aGlzID09PSBmYWxzZSB8fCBvdGhlciA9PT0gdHJ1ZTtcbiAgfVxuXG4gIC8vICBOdW1iZXIkcHJvdG90eXBlJHRvU3RyaW5nIDo6IE51bWJlciB+PiAoKSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gTnVtYmVyJHByb3RvdHlwZSR0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMgPT09ICdvYmplY3QnID9cbiAgICAgICduZXcgTnVtYmVyKCcgKyB0b1N0cmluZyh0aGlzLnZhbHVlT2YoKSkgKyAnKScgOlxuICAgICAgMSAvIHRoaXMgPT09IC1JbmZpbml0eSA/ICctMCcgOiB0aGlzLnRvU3RyaW5nKDEwKTtcbiAgfVxuXG4gIC8vICBOdW1iZXIkcHJvdG90eXBlJGVxdWFscyA6OiBOdW1iZXIgfj4gTnVtYmVyIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gTnVtYmVyJHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMgPT09ICdvYmplY3QnID9cbiAgICAgIGVxdWFscyh0aGlzLnZhbHVlT2YoKSwgb3RoZXIudmFsdWVPZigpKSA6XG4gICAgICBpc05hTih0aGlzKSAmJiBpc05hTihvdGhlcikgfHwgdGhpcyA9PT0gb3RoZXI7XG4gIH1cblxuICAvLyAgTnVtYmVyJHByb3RvdHlwZSRsdGUgOjogTnVtYmVyIH4+IE51bWJlciAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIE51bWJlciRwcm90b3R5cGUkbHRlKG90aGVyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzID09PSAnb2JqZWN0JyA/XG4gICAgICBsdGUodGhpcy52YWx1ZU9mKCksIG90aGVyLnZhbHVlT2YoKSkgOlxuICAgICAgaXNOYU4odGhpcykgJiYgaXNOYU4ob3RoZXIpIHx8IHRoaXMgPD0gb3RoZXI7XG4gIH1cblxuICAvLyAgRGF0ZSRwcm90b3R5cGUkdG9TdHJpbmcgOjogRGF0ZSB+PiAoKSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gRGF0ZSRwcm90b3R5cGUkdG9TdHJpbmcoKSB7XG4gICAgdmFyIHggPSBpc05hTih0aGlzLnZhbHVlT2YoKSkgPyBOYU4gOiB0aGlzLnRvSVNPU3RyaW5nKCk7XG4gICAgcmV0dXJuICduZXcgRGF0ZSgnICsgdG9TdHJpbmcoeCkgKyAnKSc7XG4gIH1cblxuICAvLyAgRGF0ZSRwcm90b3R5cGUkZXF1YWxzIDo6IERhdGUgfj4gRGF0ZSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIERhdGUkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBlcXVhbHModGhpcy52YWx1ZU9mKCksIG90aGVyLnZhbHVlT2YoKSk7XG4gIH1cblxuICAvLyAgRGF0ZSRwcm90b3R5cGUkbHRlIDo6IERhdGUgfj4gRGF0ZSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIERhdGUkcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIHJldHVybiBsdGUodGhpcy52YWx1ZU9mKCksIG90aGVyLnZhbHVlT2YoKSk7XG4gIH1cblxuICAvLyAgUmVnRXhwJHByb3RvdHlwZSRlcXVhbHMgOjogUmVnRXhwIH4+IFJlZ0V4cCAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIFJlZ0V4cCRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLnNvdXJjZSA9PT0gdGhpcy5zb3VyY2UgJiZcbiAgICAgICAgICAgb3RoZXIuZ2xvYmFsID09PSB0aGlzLmdsb2JhbCAmJlxuICAgICAgICAgICBvdGhlci5pZ25vcmVDYXNlID09PSB0aGlzLmlnbm9yZUNhc2UgJiZcbiAgICAgICAgICAgb3RoZXIubXVsdGlsaW5lID09PSB0aGlzLm11bHRpbGluZSAmJlxuICAgICAgICAgICBvdGhlci5zdGlja3kgPT09IHRoaXMuc3RpY2t5ICYmXG4gICAgICAgICAgIG90aGVyLnVuaWNvZGUgPT09IHRoaXMudW5pY29kZTtcbiAgfVxuXG4gIC8vICBTdHJpbmckZW1wdHkgOjogKCkgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIFN0cmluZyRlbXB0eSgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvLyAgU3RyaW5nJHByb3RvdHlwZSR0b1N0cmluZyA6OiBTdHJpbmcgfj4gKCkgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIFN0cmluZyRwcm90b3R5cGUkdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzID09PSAnb2JqZWN0JyA/XG4gICAgICAnbmV3IFN0cmluZygnICsgdG9TdHJpbmcodGhpcy52YWx1ZU9mKCkpICsgJyknIDpcbiAgICAgIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICB9XG5cbiAgLy8gIFN0cmluZyRwcm90b3R5cGUkZXF1YWxzIDo6IFN0cmluZyB+PiBTdHJpbmcgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBTdHJpbmckcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcyA9PT0gJ29iamVjdCcgP1xuICAgICAgZXF1YWxzKHRoaXMudmFsdWVPZigpLCBvdGhlci52YWx1ZU9mKCkpIDpcbiAgICAgIHRoaXMgPT09IG90aGVyO1xuICB9XG5cbiAgLy8gIFN0cmluZyRwcm90b3R5cGUkbHRlIDo6IFN0cmluZyB+PiBTdHJpbmcgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBTdHJpbmckcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcyA9PT0gJ29iamVjdCcgP1xuICAgICAgbHRlKHRoaXMudmFsdWVPZigpLCBvdGhlci52YWx1ZU9mKCkpIDpcbiAgICAgIHRoaXMgPD0gb3RoZXI7XG4gIH1cblxuICAvLyAgU3RyaW5nJHByb3RvdHlwZSRjb25jYXQgOjogU3RyaW5nIH4+IFN0cmluZyAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gU3RyaW5nJHByb3RvdHlwZSRjb25jYXQob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcyArIG90aGVyO1xuICB9XG5cbiAgLy8gIEFycmF5JGVtcHR5IDo6ICgpIC0+IEFycmF5IGFcbiAgZnVuY3Rpb24gQXJyYXkkZW1wdHkoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLy8gIEFycmF5JG9mIDo6IGEgLT4gQXJyYXkgYVxuICBmdW5jdGlvbiBBcnJheSRvZih4KSB7XG4gICAgcmV0dXJuIFt4XTtcbiAgfVxuXG4gIC8vICBBcnJheSRjaGFpblJlYyA6OiAoKGEgLT4gYywgYiAtPiBjLCBhKSAtPiBBcnJheSBjLCBhKSAtPiBBcnJheSBiXG4gIGZ1bmN0aW9uIEFycmF5JGNoYWluUmVjKGYsIHgpIHtcbiAgICB2YXIgJHRvZG8gPSBbeF07XG4gICAgdmFyICRkb25lID0gW107XG4gICAgd2hpbGUgKCR0b2RvLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciB4cyA9IGYoaXRlcmF0aW9uTmV4dCwgaXRlcmF0aW9uRG9uZSwgJHRvZG8uc2hpZnQoKSk7XG4gICAgICB2YXIgJG1vcmUgPSBbXTtcbiAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHhzLmxlbmd0aDsgaWR4ICs9IDEpIHtcbiAgICAgICAgKHhzW2lkeF0uZG9uZSA/ICRkb25lIDogJG1vcmUpLnB1c2goeHNbaWR4XS52YWx1ZSk7XG4gICAgICB9XG4gICAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseSgkdG9kbywgJG1vcmUpO1xuICAgIH1cbiAgICByZXR1cm4gJGRvbmU7XG4gIH1cblxuICAvLyAgQXJyYXkkemVybyA6OiAoKSAtPiBBcnJheSBhXG4gIGZ1bmN0aW9uIEFycmF5JHplcm8oKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSR0b1N0cmluZyA6OiBBcnJheSBhIH4+ICgpIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBBcnJheSRwcm90b3R5cGUkdG9TdHJpbmcoKSB7XG4gICAgdmFyIHJlcHJzID0gdGhpcy5tYXAodG9TdHJpbmcpO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcykuc29ydCgpO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGtleXMubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgICAgdmFyIGsgPSBrZXlzW2lkeF07XG4gICAgICBpZiAoIS9eXFxkKyQvLnRlc3QoaykpIHtcbiAgICAgICAgcmVwcnMucHVzaCh0b1N0cmluZyhrKSArICc6ICcgKyB0b1N0cmluZyh0aGlzW2tdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnWycgKyByZXBycy5qb2luKCcsICcpICsgJ10nO1xuICB9XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSRlcXVhbHMgOjogQXJyYXkgYSB+PiBBcnJheSBhIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIGlmIChvdGhlci5sZW5ndGggIT09IHRoaXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgdGhpcy5sZW5ndGg7IGlkeCArPSAxKSB7XG4gICAgICBpZiAoIWVxdWFscyh0aGlzW2lkeF0sIG90aGVyW2lkeF0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSRsdGUgOjogQXJyYXkgYSB+PiBBcnJheSBhIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIGZvciAodmFyIGlkeCA9IDA7IHRydWU7IGlkeCArPSAxKSB7XG4gICAgICBpZiAoaWR4ID09PSB0aGlzLmxlbmd0aCkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoaWR4ID09PSBvdGhlci5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICghZXF1YWxzKHRoaXNbaWR4XSwgb3RoZXJbaWR4XSkpIHJldHVybiBsdGUodGhpc1tpZHhdLCBvdGhlcltpZHhdKTtcbiAgICB9XG4gIH1cblxuICAvLyAgQXJyYXkkcHJvdG90eXBlJGNvbmNhdCA6OiBBcnJheSBhIH4+IEFycmF5IGEgLT4gQXJyYXkgYVxuICBmdW5jdGlvbiBBcnJheSRwcm90b3R5cGUkY29uY2F0KG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uY2F0KG90aGVyKTtcbiAgfVxuXG4gIC8vICBBcnJheSRwcm90b3R5cGUkbWFwIDo6IEFycmF5IGEgfj4gKGEgLT4gYikgLT4gQXJyYXkgYlxuICBmdW5jdGlvbiBBcnJheSRwcm90b3R5cGUkbWFwKGYpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gZih4KTsgfSk7XG4gIH1cblxuICAvLyAgQXJyYXkkcHJvdG90eXBlJGFwIDo6IEFycmF5IGEgfj4gQXJyYXkgKGEgLT4gYikgLT4gQXJyYXkgYlxuICBmdW5jdGlvbiBBcnJheSRwcm90b3R5cGUkYXAoZnMpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgZnMubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgICAgZm9yICh2YXIgaWR4MiA9IDA7IGlkeDIgPCB0aGlzLmxlbmd0aDsgaWR4MiArPSAxKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGZzW2lkeF0odGhpc1tpZHgyXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSRjaGFpbiA6OiBBcnJheSBhIH4+IChhIC0+IEFycmF5IGIpIC0+IEFycmF5IGJcbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJGNoYWluKGYpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHgpIHsgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocmVzdWx0LCBmKHgpKTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vICBBcnJheSRwcm90b3R5cGUkYWx0IDo6IEFycmF5IGEgfj4gQXJyYXkgYSAtPiBBcnJheSBhXG4gIHZhciBBcnJheSRwcm90b3R5cGUkYWx0ID0gQXJyYXkkcHJvdG90eXBlJGNvbmNhdDtcblxuICAvLyAgQXJyYXkkcHJvdG90eXBlJHJlZHVjZSA6OiBBcnJheSBhIH4+ICgoYiwgYSkgLT4gYiwgYikgLT4gYlxuICBmdW5jdGlvbiBBcnJheSRwcm90b3R5cGUkcmVkdWNlKGYsIGluaXRpYWwpIHtcbiAgICByZXR1cm4gdGhpcy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCB4KSB7IHJldHVybiBmKGFjYywgeCk7IH0sIGluaXRpYWwpO1xuICB9XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSR0cmF2ZXJzZSA6OiBBcHBsaWNhdGl2ZSBmID0+IEFycmF5IGEgfj4gKFR5cGVSZXAgZiwgYSAtPiBmIGIpIC0+IGYgKEFycmF5IGIpXG4gIGZ1bmN0aW9uIEFycmF5JHByb3RvdHlwZSR0cmF2ZXJzZSh0eXBlUmVwLCBmKSB7XG4gICAgdmFyIHhzID0gdGhpcztcbiAgICBmdW5jdGlvbiBnbyhpZHgsIG4pIHtcbiAgICAgIHN3aXRjaCAobikge1xuICAgICAgICBjYXNlIDA6IHJldHVybiBvZih0eXBlUmVwLCBbXSk7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGxpZnQyKHBhaXIsIGYoeHNbaWR4XSksIGYoeHNbaWR4ICsgMV0pKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YXIgbSA9IE1hdGguZmxvb3IobiAvIDQpICogMjtcbiAgICAgICAgICByZXR1cm4gbGlmdDIoY29uY2F0XywgZ28oaWR4LCBtKSwgZ28oaWR4ICsgbSwgbiAtIG0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoICUgMiA9PT0gMSA/XG4gICAgICBsaWZ0Mihjb25jYXRfLCBtYXAoQXJyYXkkb2YsIGYodGhpc1swXSkpLCBnbygxLCB0aGlzLmxlbmd0aCAtIDEpKSA6XG4gICAgICBnbygwLCB0aGlzLmxlbmd0aCk7XG4gIH1cblxuICAvLyAgQXJyYXkkcHJvdG90eXBlJGV4dGVuZCA6OiBBcnJheSBhIH4+IChBcnJheSBhIC0+IGIpIC0+IEFycmF5IGJcbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJGV4dGVuZChmKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKF8sIGlkeCwgeHMpIHsgcmV0dXJuIGYoeHMuc2xpY2UoaWR4KSk7IH0pO1xuICB9XG5cbiAgLy8gIEFyZ3VtZW50cyRwcm90b3R5cGUkdG9TdHJpbmcgOjogQXJndW1lbnRzIH4+IFN0cmluZ1xuICBmdW5jdGlvbiBBcmd1bWVudHMkcHJvdG90eXBlJHRvU3RyaW5nKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKHRoaXMsIHRvU3RyaW5nKS5qb2luKCcsICcpO1xuICAgIHJldHVybiAnKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgnICsgYXJncyArICcpKSc7XG4gIH1cblxuICAvLyAgQXJndW1lbnRzJHByb3RvdHlwZSRlcXVhbHMgOjogQXJndW1lbnRzIH4+IEFyZ3VtZW50cyAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIEFyZ3VtZW50cyRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIEFycmF5JHByb3RvdHlwZSRlcXVhbHMuY2FsbCh0aGlzLCBvdGhlcik7XG4gIH1cblxuICAvLyAgQXJndW1lbnRzJHByb3RvdHlwZSRsdGUgOjogQXJndW1lbnRzIH4+IEFyZ3VtZW50cyAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIEFyZ3VtZW50cyRwcm90b3R5cGUkbHRlKG90aGVyKSB7XG4gICAgcmV0dXJuIEFycmF5JHByb3RvdHlwZSRsdGUuY2FsbCh0aGlzLCBvdGhlcik7XG4gIH1cblxuICAvLyAgRXJyb3IkcHJvdG90eXBlJHRvU3RyaW5nIDo6IEVycm9yIH4+ICgpIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBFcnJvciRwcm90b3R5cGUkdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICduZXcgJyArIHRoaXMubmFtZSArICcoJyArIHRvU3RyaW5nKHRoaXMubWVzc2FnZSkgKyAnKSc7XG4gIH1cblxuICAvLyAgRXJyb3IkcHJvdG90eXBlJGVxdWFscyA6OiBFcnJvciB+PiBFcnJvciAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIEVycm9yJHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gZXF1YWxzKHRoaXMubmFtZSwgb3RoZXIubmFtZSkgJiZcbiAgICAgICAgICAgZXF1YWxzKHRoaXMubWVzc2FnZSwgb3RoZXIubWVzc2FnZSk7XG4gIH1cblxuICAvLyAgT2JqZWN0JGVtcHR5IDo6ICgpIC0+IFN0ck1hcCBhXG4gIGZ1bmN0aW9uIE9iamVjdCRlbXB0eSgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvLyAgT2JqZWN0JHplcm8gOjogKCkgLT4gU3RyTWFwIGFcbiAgZnVuY3Rpb24gT2JqZWN0JHplcm8oKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLy8gIE9iamVjdCRwcm90b3R5cGUkdG9TdHJpbmcgOjogU3RyTWFwIGEgfj4gKCkgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIE9iamVjdCRwcm90b3R5cGUkdG9TdHJpbmcoKSB7XG4gICAgdmFyIHJlcHJzID0gW107XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKS5zb3J0KCk7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwga2V5cy5sZW5ndGg7IGlkeCArPSAxKSB7XG4gICAgICB2YXIgayA9IGtleXNbaWR4XTtcbiAgICAgIHJlcHJzLnB1c2godG9TdHJpbmcoaykgKyAnOiAnICsgdG9TdHJpbmcodGhpc1trXSkpO1xuICAgIH1cbiAgICByZXR1cm4gJ3snICsgcmVwcnMuam9pbignLCAnKSArICd9JztcbiAgfVxuXG4gIC8vICBPYmplY3QkcHJvdG90eXBlJGVxdWFscyA6OiBTdHJNYXAgYSB+PiBTdHJNYXAgYSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIE9iamVjdCRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcykuc29ydCgpO1xuICAgIHJldHVybiBlcXVhbHMoa2V5cywgT2JqZWN0LmtleXMob3RoZXIpLnNvcnQoKSkgJiZcbiAgICAgICAgICAga2V5cy5ldmVyeShmdW5jdGlvbihrKSB7IHJldHVybiBlcXVhbHMoc2VsZltrXSwgb3RoZXJba10pOyB9KTtcbiAgfVxuXG4gIC8vICBPYmplY3QkcHJvdG90eXBlJGx0ZSA6OiBTdHJNYXAgYSB+PiBTdHJNYXAgYSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIE9iamVjdCRwcm90b3R5cGUkbHRlKG90aGVyKSB7XG4gICAgdmFyIHRoZXNlS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpLnNvcnQoKTtcbiAgICB2YXIgb3RoZXJLZXlzID0gT2JqZWN0LmtleXMob3RoZXIpLnNvcnQoKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHRoZXNlS2V5cy5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgaWYgKG90aGVyS2V5cy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBrID0gdGhlc2VLZXlzLnNoaWZ0KCk7XG4gICAgICB2YXIgeiA9IG90aGVyS2V5cy5zaGlmdCgpO1xuICAgICAgaWYgKGsgPCB6KSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChrID4geikgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKCFlcXVhbHModGhpc1trXSwgb3RoZXJba10pKSByZXR1cm4gbHRlKHRoaXNba10sIG90aGVyW2tdKTtcbiAgICB9XG4gIH1cblxuICAvLyAgT2JqZWN0JHByb3RvdHlwZSRjb25jYXQgOjogU3RyTWFwIGEgfj4gU3RyTWFwIGEgLT4gU3RyTWFwIGFcbiAgZnVuY3Rpb24gT2JqZWN0JHByb3RvdHlwZSRjb25jYXQob3RoZXIpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZnVuY3Rpb24gYXNzaWduKGspIHsgcmVzdWx0W2tdID0gdGhpc1trXTsgfVxuICAgIGZvckVhY2hLZXkodGhpcywgYXNzaWduKTtcbiAgICBmb3JFYWNoS2V5KG90aGVyLCBhc3NpZ24pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyAgT2JqZWN0JHByb3RvdHlwZSRtYXAgOjogU3RyTWFwIGEgfj4gKGEgLT4gYikgLT4gU3RyTWFwIGJcbiAgZnVuY3Rpb24gT2JqZWN0JHByb3RvdHlwZSRtYXAoZikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3JFYWNoS2V5KHRoaXMsIGZ1bmN0aW9uKGspIHsgcmVzdWx0W2tdID0gZih0aGlzW2tdKTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vICBPYmplY3QkcHJvdG90eXBlJGFwIDo6IFN0ck1hcCBhIH4+IFN0ck1hcCAoYSAtPiBiKSAtPiBTdHJNYXAgYlxuICBmdW5jdGlvbiBPYmplY3QkcHJvdG90eXBlJGFwKG90aGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvckVhY2hLZXkodGhpcywgZnVuY3Rpb24oaykge1xuICAgICAgaWYgKGhhcyhrLCBvdGhlcikpIHJlc3VsdFtrXSA9IG90aGVyW2tdKHRoaXNba10pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyAgT2JqZWN0JHByb3RvdHlwZSRhbHQgOjogU3RyTWFwIGEgfj4gU3RyTWFwIGEgLT4gU3RyTWFwIGFcbiAgdmFyIE9iamVjdCRwcm90b3R5cGUkYWx0ID0gT2JqZWN0JHByb3RvdHlwZSRjb25jYXQ7XG5cbiAgLy8gIE9iamVjdCRwcm90b3R5cGUkcmVkdWNlIDo6IFN0ck1hcCBhIH4+ICgoYiwgYSkgLT4gYiwgYikgLT4gYlxuICBmdW5jdGlvbiBPYmplY3QkcHJvdG90eXBlJHJlZHVjZShmLCBpbml0aWFsKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIHJlZHVjZXIoYWNjLCBrKSB7IHJldHVybiBmKGFjYywgc2VsZltrXSk7IH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcykuc29ydCgpLnJlZHVjZShyZWR1Y2VyLCBpbml0aWFsKTtcbiAgfVxuXG4gIC8vICBPYmplY3QkcHJvdG90eXBlJHRyYXZlcnNlIDo6IEFwcGxpY2F0aXZlIGYgPT4gU3RyTWFwIGEgfj4gKFR5cGVSZXAgZiwgYSAtPiBmIGIpIC0+IGYgKFN0ck1hcCBiKVxuICBmdW5jdGlvbiBPYmplY3QkcHJvdG90eXBlJHRyYXZlcnNlKHR5cGVSZXAsIGYpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMpLnJlZHVjZShmdW5jdGlvbihhcHBsaWNhdGl2ZSwgaykge1xuICAgICAgZnVuY3Rpb24gc2V0KG8pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB2YXIgc2luZ2xldG9uID0ge307IHNpbmdsZXRvbltrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdCRwcm90b3R5cGUkY29uY2F0LmNhbGwobywgc2luZ2xldG9uKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaWZ0MihzZXQsIGFwcGxpY2F0aXZlLCBmKHNlbGZba10pKTtcbiAgICB9LCBvZih0eXBlUmVwLCB7fSkpO1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJGlkIDo6ICgpIC0+IGEgLT4gYVxuICBmdW5jdGlvbiBGdW5jdGlvbiRpZCgpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cblxuICAvLyAgRnVuY3Rpb24kb2YgOjogYiAtPiAoYSAtPiBiKVxuICBmdW5jdGlvbiBGdW5jdGlvbiRvZih4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKF8pIHsgcmV0dXJuIHg7IH07XG4gIH1cblxuICAvLyAgRnVuY3Rpb24kY2hhaW5SZWMgOjogKChhIC0+IGMsIGIgLT4gYywgYSkgLT4gKHogLT4gYyksIGEpIC0+ICh6IC0+IGIpXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uJGNoYWluUmVjKGYsIHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYSkge1xuICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRpb25OZXh0KHgpO1xuICAgICAgd2hpbGUgKCFzdGVwLmRvbmUpIHtcbiAgICAgICAgc3RlcCA9IGYoaXRlcmF0aW9uTmV4dCwgaXRlcmF0aW9uRG9uZSwgc3RlcC52YWx1ZSkoYSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RlcC52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJHByb3RvdHlwZSRlcXVhbHMgOjogRnVuY3Rpb24gfj4gRnVuY3Rpb24gLT4gQm9vbGVhblxuICBmdW5jdGlvbiBGdW5jdGlvbiRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyID09PSB0aGlzO1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJHByb3RvdHlwZSRjb21wb3NlIDo6IChhIC0+IGIpIH4+IChiIC0+IGMpIC0+IChhIC0+IGMpXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uJHByb3RvdHlwZSRjb21wb3NlKG90aGVyKSB7XG4gICAgdmFyIHNlbWlncm91cG9pZCA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIG90aGVyKHNlbWlncm91cG9pZCh4KSk7IH07XG4gIH1cblxuICAvLyAgRnVuY3Rpb24kcHJvdG90eXBlJG1hcCA6OiAoYSAtPiBiKSB+PiAoYiAtPiBjKSAtPiAoYSAtPiBjKVxuICBmdW5jdGlvbiBGdW5jdGlvbiRwcm90b3R5cGUkbWFwKGYpIHtcbiAgICB2YXIgZnVuY3RvciA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGYoZnVuY3Rvcih4KSk7IH07XG4gIH1cblxuICAvLyAgRnVuY3Rpb24kcHJvdG90eXBlJHByb21hcCA6OiAoYiAtPiBjKSB+PiAoYSAtPiBiLCBjIC0+IGQpIC0+IChhIC0+IGQpXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uJHByb3RvdHlwZSRwcm9tYXAoZiwgZykge1xuICAgIHZhciBwcm9mdW5jdG9yID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gZyhwcm9mdW5jdG9yKGYoeCkpKTsgfTtcbiAgfVxuXG4gIC8vICBGdW5jdGlvbiRwcm90b3R5cGUkYXAgOjogKGEgLT4gYikgfj4gKGEgLT4gYiAtPiBjKSAtPiAoYSAtPiBjKVxuICBmdW5jdGlvbiBGdW5jdGlvbiRwcm90b3R5cGUkYXAoZikge1xuICAgIHZhciBhcHBseSA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGYoeCkoYXBwbHkoeCkpOyB9O1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJHByb3RvdHlwZSRjaGFpbiA6OiAoYSAtPiBiKSB+PiAoYiAtPiBhIC0+IGMpIC0+IChhIC0+IGMpXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uJHByb3RvdHlwZSRjaGFpbihmKSB7XG4gICAgdmFyIGNoYWluID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gZihjaGFpbih4KSkoeCk7IH07XG4gIH1cblxuICAvLyAgRnVuY3Rpb24kcHJvdG90eXBlJGNvbnRyYW1hcCA6OiAoYiAtPiBjKSB+PiAoYSAtPiBiKSAtPiAoYSAtPiBjKVxuICBmdW5jdGlvbiBGdW5jdGlvbiRwcm90b3R5cGUkY29udHJhbWFwKGYpIHtcbiAgICB2YXIgY29udHJhdmFyaWFudCA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGNvbnRyYXZhcmlhbnQoZih4KSk7IH07XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuICB2YXIgaW1wbGVtZW50YXRpb25zID0ge1xuICAgIE51bGw6IHtcbiAgICAgIHByb3RvdHlwZToge1xuICAgICAgICB0b1N0cmluZzogICAgICAgICAgICAgICAgICAgTnVsbCRwcm90b3R5cGUkdG9TdHJpbmcsXG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBOdWxsJHByb3RvdHlwZSRlcXVhbHMsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbHRlJzogICAgICAgICBOdWxsJHByb3RvdHlwZSRsdGVcbiAgICAgIH1cbiAgICB9LFxuICAgIFVuZGVmaW5lZDoge1xuICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgIHRvU3RyaW5nOiAgICAgICAgICAgICAgICAgICBVbmRlZmluZWQkcHJvdG90eXBlJHRvU3RyaW5nLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgVW5kZWZpbmVkJHByb3RvdHlwZSRlcXVhbHMsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbHRlJzogICAgICAgICBVbmRlZmluZWQkcHJvdG90eXBlJGx0ZVxuICAgICAgfVxuICAgIH0sXG4gICAgQm9vbGVhbjoge1xuICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgIHRvU3RyaW5nOiAgICAgICAgICAgICAgICAgICBCb29sZWFuJHByb3RvdHlwZSR0b1N0cmluZyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnOiAgICAgIEJvb2xlYW4kcHJvdG90eXBlJGVxdWFscyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9sdGUnOiAgICAgICAgIEJvb2xlYW4kcHJvdG90eXBlJGx0ZVxuICAgICAgfVxuICAgIH0sXG4gICAgTnVtYmVyOiB7XG4gICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgdG9TdHJpbmc6ICAgICAgICAgICAgICAgICAgIE51bWJlciRwcm90b3R5cGUkdG9TdHJpbmcsXG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBOdW1iZXIkcHJvdG90eXBlJGVxdWFscyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9sdGUnOiAgICAgICAgIE51bWJlciRwcm90b3R5cGUkbHRlXG4gICAgICB9XG4gICAgfSxcbiAgICBEYXRlOiB7XG4gICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgdG9TdHJpbmc6ICAgICAgICAgICAgICAgICAgIERhdGUkcHJvdG90eXBlJHRvU3RyaW5nLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgRGF0ZSRwcm90b3R5cGUkZXF1YWxzLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2x0ZSc6ICAgICAgICAgRGF0ZSRwcm90b3R5cGUkbHRlXG4gICAgICB9XG4gICAgfSxcbiAgICBSZWdFeHA6IHtcbiAgICAgIHByb3RvdHlwZToge1xuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgUmVnRXhwJHByb3RvdHlwZSRlcXVhbHNcbiAgICAgIH1cbiAgICB9LFxuICAgIFN0cmluZzoge1xuICAgICAgJ2ZhbnRhc3ktbGFuZC9lbXB0eSc6ICAgICAgICAgU3RyaW5nJGVtcHR5LFxuICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgIHRvU3RyaW5nOiAgICAgICAgICAgICAgICAgICBTdHJpbmckcHJvdG90eXBlJHRvU3RyaW5nLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgU3RyaW5nJHByb3RvdHlwZSRlcXVhbHMsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbHRlJzogICAgICAgICBTdHJpbmckcHJvdG90eXBlJGx0ZSxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9jb25jYXQnOiAgICAgIFN0cmluZyRwcm90b3R5cGUkY29uY2F0XG4gICAgICB9XG4gICAgfSxcbiAgICBBcnJheToge1xuICAgICAgJ2ZhbnRhc3ktbGFuZC9lbXB0eSc6ICAgICAgICAgQXJyYXkkZW1wdHksXG4gICAgICAnZmFudGFzeS1sYW5kL29mJzogICAgICAgICAgICBBcnJheSRvZixcbiAgICAgICdmYW50YXN5LWxhbmQvY2hhaW5SZWMnOiAgICAgIEFycmF5JGNoYWluUmVjLFxuICAgICAgJ2ZhbnRhc3ktbGFuZC96ZXJvJzogICAgICAgICAgQXJyYXkkemVybyxcbiAgICAgIHByb3RvdHlwZToge1xuICAgICAgICB0b1N0cmluZzogICAgICAgICAgICAgICAgICAgQXJyYXkkcHJvdG90eXBlJHRvU3RyaW5nLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgQXJyYXkkcHJvdG90eXBlJGVxdWFscyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9sdGUnOiAgICAgICAgIEFycmF5JHByb3RvdHlwZSRsdGUsXG4gICAgICAgICdmYW50YXN5LWxhbmQvY29uY2F0JzogICAgICBBcnJheSRwcm90b3R5cGUkY29uY2F0LFxuICAgICAgICAnZmFudGFzeS1sYW5kL21hcCc6ICAgICAgICAgQXJyYXkkcHJvdG90eXBlJG1hcCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9hcCc6ICAgICAgICAgIEFycmF5JHByb3RvdHlwZSRhcCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9jaGFpbic6ICAgICAgIEFycmF5JHByb3RvdHlwZSRjaGFpbixcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9hbHQnOiAgICAgICAgIEFycmF5JHByb3RvdHlwZSRhbHQsXG4gICAgICAgICdmYW50YXN5LWxhbmQvcmVkdWNlJzogICAgICBBcnJheSRwcm90b3R5cGUkcmVkdWNlLFxuICAgICAgICAnZmFudGFzeS1sYW5kL3RyYXZlcnNlJzogICAgQXJyYXkkcHJvdG90eXBlJHRyYXZlcnNlLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2V4dGVuZCc6ICAgICAgQXJyYXkkcHJvdG90eXBlJGV4dGVuZFxuICAgICAgfVxuICAgIH0sXG4gICAgQXJndW1lbnRzOiB7XG4gICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgdG9TdHJpbmc6ICAgICAgICAgICAgICAgICAgIEFyZ3VtZW50cyRwcm90b3R5cGUkdG9TdHJpbmcsXG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBBcmd1bWVudHMkcHJvdG90eXBlJGVxdWFscyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9sdGUnOiAgICAgICAgIEFyZ3VtZW50cyRwcm90b3R5cGUkbHRlXG4gICAgICB9XG4gICAgfSxcbiAgICBFcnJvcjoge1xuICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgIHRvU3RyaW5nOiAgICAgICAgICAgICAgICAgICBFcnJvciRwcm90b3R5cGUkdG9TdHJpbmcsXG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBFcnJvciRwcm90b3R5cGUkZXF1YWxzXG4gICAgICB9XG4gICAgfSxcbiAgICBPYmplY3Q6IHtcbiAgICAgICdmYW50YXN5LWxhbmQvZW1wdHknOiAgICAgICAgIE9iamVjdCRlbXB0eSxcbiAgICAgICdmYW50YXN5LWxhbmQvemVybyc6ICAgICAgICAgIE9iamVjdCR6ZXJvLFxuICAgICAgcHJvdG90eXBlOiB7XG4gICAgICAgIHRvU3RyaW5nOiAgICAgICAgICAgICAgICAgICBPYmplY3QkcHJvdG90eXBlJHRvU3RyaW5nLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgT2JqZWN0JHByb3RvdHlwZSRlcXVhbHMsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbHRlJzogICAgICAgICBPYmplY3QkcHJvdG90eXBlJGx0ZSxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9jb25jYXQnOiAgICAgIE9iamVjdCRwcm90b3R5cGUkY29uY2F0LFxuICAgICAgICAnZmFudGFzeS1sYW5kL21hcCc6ICAgICAgICAgT2JqZWN0JHByb3RvdHlwZSRtYXAsXG4gICAgICAgICdmYW50YXN5LWxhbmQvYXAnOiAgICAgICAgICBPYmplY3QkcHJvdG90eXBlJGFwLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2FsdCc6ICAgICAgICAgT2JqZWN0JHByb3RvdHlwZSRhbHQsXG4gICAgICAgICdmYW50YXN5LWxhbmQvcmVkdWNlJzogICAgICBPYmplY3QkcHJvdG90eXBlJHJlZHVjZSxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC90cmF2ZXJzZSc6ICAgIE9iamVjdCRwcm90b3R5cGUkdHJhdmVyc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIEZ1bmN0aW9uOiB7XG4gICAgICAnZmFudGFzeS1sYW5kL2lkJzogICAgICAgICAgICBGdW5jdGlvbiRpZCxcbiAgICAgICdmYW50YXN5LWxhbmQvb2YnOiAgICAgICAgICAgIEZ1bmN0aW9uJG9mLFxuICAgICAgJ2ZhbnRhc3ktbGFuZC9jaGFpblJlYyc6ICAgICAgRnVuY3Rpb24kY2hhaW5SZWMsXG4gICAgICBwcm90b3R5cGU6IHtcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnOiAgICAgIEZ1bmN0aW9uJHByb3RvdHlwZSRlcXVhbHMsXG4gICAgICAgICdmYW50YXN5LWxhbmQvY29tcG9zZSc6ICAgICBGdW5jdGlvbiRwcm90b3R5cGUkY29tcG9zZSxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9tYXAnOiAgICAgICAgIEZ1bmN0aW9uJHByb3RvdHlwZSRtYXAsXG4gICAgICAgICdmYW50YXN5LWxhbmQvcHJvbWFwJzogICAgICBGdW5jdGlvbiRwcm90b3R5cGUkcHJvbWFwLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2FwJzogICAgICAgICAgRnVuY3Rpb24kcHJvdG90eXBlJGFwLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2NoYWluJzogICAgICAgRnVuY3Rpb24kcHJvdG90eXBlJGNoYWluLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2NvbnRyYW1hcCc6ICAgRnVuY3Rpb24kcHJvdG90eXBlJGNvbnRyYW1hcFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuXG4gIC8vIyB0b1N0cmluZyA6OiBhIC0+IFN0cmluZ1xuICAvLy5cbiAgLy8uIFJldHVybnMgYSB1c2VmdWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGl0cyBhcmd1bWVudC5cbiAgLy8uXG4gIC8vLiBEaXNwYXRjaGVzIHRvIHRoZSBhcmd1bWVudCdzIGB0b1N0cmluZ2AgbWV0aG9kIGlmIGFwcHJvcHJpYXRlLlxuICAvLy5cbiAgLy8uIFdoZXJlIHByYWN0aWNhbCwgYGVxdWFscyhldmFsKHRvU3RyaW5nKHgpKSwgeCkgPSB0cnVlYC5cbiAgLy8uXG4gIC8vLiBgdG9TdHJpbmdgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmcgYnVpbHQtaW4gdHlwZXM6XG4gIC8vLiBOdWxsLCBVbmRlZmluZWQsIEJvb2xlYW4sIE51bWJlciwgRGF0ZSwgU3RyaW5nLCBBcnJheSwgQXJndW1lbnRzLCBFcnJvcixcbiAgLy8uIGFuZCBPYmplY3QuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiB0b1N0cmluZygtMClcbiAgLy8uICctMCdcbiAgLy8uXG4gIC8vLiA+IHRvU3RyaW5nKFsnZm9vJywgJ2JhcicsICdiYXonXSlcbiAgLy8uICdbXCJmb29cIiwgXCJiYXJcIiwgXCJiYXpcIl0nXG4gIC8vLlxuICAvLy4gPiB0b1N0cmluZyh7eDogMSwgeTogMiwgejogM30pXG4gIC8vLiAne1wieFwiOiAxLCBcInlcIjogMiwgXCJ6XCI6IDN9J1xuICAvLy5cbiAgLy8uID4gdG9TdHJpbmcoQ29ucygxLCBDb25zKDIsIENvbnMoMywgTmlsKSkpKVxuICAvLy4gJ0NvbnMoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKSdcbiAgLy8uIGBgYFxuICB2YXIgdG9TdHJpbmcgPSAoZnVuY3Rpb24oKSB7XG4gICAgLy8gICRzZWVuIDo6IEFycmF5IEFueVxuICAgIHZhciAkc2VlbiA9IFtdO1xuXG4gICAgZnVuY3Rpb24gY2FsbChtZXRob2QsIHgpIHtcbiAgICAgICRzZWVuLnB1c2goeCk7XG4gICAgICB0cnkgeyByZXR1cm4gbWV0aG9kLmNhbGwoeCk7IH0gZmluYWxseSB7ICRzZWVuLnBvcCgpOyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvU3RyaW5nKHgpIHtcbiAgICAgIGlmICgkc2Vlbi5pbmRleE9mKHgpID49IDApIHJldHVybiAnPENpcmN1bGFyPic7XG5cbiAgICAgIHZhciB4VHlwZSA9IHR5cGUoeCk7XG4gICAgICBpZiAoeFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7IHJlc3VsdCA9IGNhbGwoeC50b1N0cmluZywgeCk7IH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsICYmIHJlc3VsdCAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYWxsKGltcGxQYXRoKFt4VHlwZSwgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddKSB8fCB4LnRvU3RyaW5nLCB4KTtcbiAgICB9O1xuICB9KCkpO1xuXG4gIC8vIyBlcXVhbHMgOjogKGEsIGIpIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBpZiBpdHMgYXJndW1lbnRzIGFyZSBvZiB0aGUgc2FtZSB0eXBlIGFuZCBlcXVhbCBhY2NvcmRpbmdcbiAgLy8uIHRvIHRoZSB0eXBlJ3MgW2BmYW50YXN5LWxhbmQvZXF1YWxzYF1bXSBtZXRob2Q7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvZXF1YWxzYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogTnVsbCwgVW5kZWZpbmVkLCBCb29sZWFuLCBOdW1iZXIsIERhdGUsIFJlZ0V4cCwgU3RyaW5nLFxuICAvLy4gQXJyYXksIEFyZ3VtZW50cywgRXJyb3IsIE9iamVjdCwgYW5kIEZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIFRoZSBhbGdvcml0aG0gc3VwcG9ydHMgY2lyY3VsYXIgZGF0YSBzdHJ1Y3R1cmVzLiBUd28gYXJyYXlzIGFyZSBlcXVhbFxuICAvLy4gaWYgdGhleSBoYXZlIHRoZSBzYW1lIGluZGV4IHBhdGhzIGFuZCBmb3IgZWFjaCBwYXRoIGhhdmUgZXF1YWwgdmFsdWVzLlxuICAvLy4gVHdvIGFycmF5cyB3aGljaCByZXByZXNlbnQgYFsxLCBbMSwgWzEsIFsxLCBbMSwgLi4uXV1dXV1gLCBmb3IgZXhhbXBsZSxcbiAgLy8uIGFyZSBlcXVhbCBldmVuIGlmIHRoZWlyIGludGVybmFsIHN0cnVjdHVyZXMgZGlmZmVyLiBUd28gb2JqZWN0cyBhcmUgZXF1YWxcbiAgLy8uIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBwcm9wZXJ0eSBwYXRocyBhbmQgZm9yIGVhY2ggcGF0aCBoYXZlIGVxdWFsIHZhbHVlcy5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGVxdWFscygwLCAtMClcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IGVxdWFscyhOYU4sIE5hTilcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IGVxdWFscyhDb25zKCdmb28nLCBDb25zKCdiYXInLCBOaWwpKSwgQ29ucygnZm9vJywgQ29ucygnYmFyJywgTmlsKSkpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBlcXVhbHMoQ29ucygnZm9vJywgQ29ucygnYmFyJywgTmlsKSksIENvbnMoJ2JhcicsIENvbnMoJ2ZvbycsIE5pbCkpKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgZXF1YWxzID0gKGZ1bmN0aW9uKCkge1xuICAgIC8vICAkcGFpcnMgOjogQXJyYXkgKFBhaXIgQW55IEFueSlcbiAgICB2YXIgJHBhaXJzID0gW107XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZXF1YWxzKHgsIHkpIHtcbiAgICAgIGlmICghc2FtZVR5cGUoeCwgeSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gIFRoaXMgYWxnb3JpdGhtIGZvciBjb21wYXJpbmcgY2lyY3VsYXIgZGF0YSBzdHJ1Y3R1cmVzIHdhc1xuICAgICAgLy8gIHN1Z2dlc3RlZCBpbiA8aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDA2MjI3OTQvMzEyNzg1Pi5cbiAgICAgIGlmICgkcGFpcnMuc29tZShmdW5jdGlvbihwKSB7IHJldHVybiBwWzBdID09PSB4ICYmIHBbMV0gPT09IHk7IH0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAkcGFpcnMucHVzaChbeCwgeV0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFNldG9pZC50ZXN0KHgpICYmIFNldG9pZC50ZXN0KHkpICYmIFNldG9pZC5tZXRob2RzLmVxdWFscyh4KSh5KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICRwYWlycy5wb3AoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KCkpO1xuXG4gIC8vIyBsdCA6OiAoYSwgYikgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIGlmIGl0cyBhcmd1bWVudHMgYXJlIG9mIHRoZSBzYW1lIHR5cGUgYW5kIHRoZSBmaXJzdCBpc1xuICAvLy4gbGVzcyB0aGFuIHRoZSBzZWNvbmQgYWNjb3JkaW5nIHRvIHRoZSB0eXBlJ3MgW2BmYW50YXN5LWxhbmQvbHRlYF1bXVxuICAvLy4gbWV0aG9kOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGx0ZWBdKCNsdGUpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZ3RgXSgjZ3QpIGFuZCBbYGd0ZWBdKCNndGUpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gbHQoMCwgMClcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBsdCgwLCAxKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gbHQoMSwgMClcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbHQoeCwgeSkge1xuICAgIHJldHVybiBzYW1lVHlwZSh4LCB5KSAmJiAhbHRlKHksIHgpO1xuICB9XG5cbiAgLy8jIGx0ZSA6OiAoYSwgYikgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIGlmIGl0cyBhcmd1bWVudHMgYXJlIG9mIHRoZSBzYW1lIHR5cGUgYW5kIHRoZSBmaXJzdFxuICAvLy4gaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQgYWNjb3JkaW5nIHRvIHRoZSB0eXBlJ3NcbiAgLy8uIFtgZmFudGFzeS1sYW5kL2x0ZWBdW10gbWV0aG9kOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2x0ZWAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IE51bGwsIFVuZGVmaW5lZCwgQm9vbGVhbiwgTnVtYmVyLCBEYXRlLCBTdHJpbmcsIEFycmF5LFxuICAvLy4gQXJndW1lbnRzLCBhbmQgT2JqZWN0LlxuICAvLy5cbiAgLy8uIFRoZSBhbGdvcml0aG0gc3VwcG9ydHMgY2lyY3VsYXIgZGF0YSBzdHJ1Y3R1cmVzIGluIHRoZSBzYW1lIG1hbm5lciBhc1xuICAvLy4gW2BlcXVhbHNgXSgjZXF1YWxzKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGx0YF0oI2x0KSwgW2BndGBdKCNndCksIGFuZCBbYGd0ZWBdKCNndGUpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gbHRlKDAsIDApXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBsdGUoMCwgMSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IGx0ZSgxLCAwKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgbHRlID0gKGZ1bmN0aW9uKCkge1xuICAgIC8vICAkcGFpcnMgOjogQXJyYXkgKFBhaXIgQW55IEFueSlcbiAgICB2YXIgJHBhaXJzID0gW107XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbHRlKHgsIHkpIHtcbiAgICAgIGlmICghc2FtZVR5cGUoeCwgeSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gIFRoaXMgYWxnb3JpdGhtIGZvciBjb21wYXJpbmcgY2lyY3VsYXIgZGF0YSBzdHJ1Y3R1cmVzIHdhc1xuICAgICAgLy8gIHN1Z2dlc3RlZCBpbiA8aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDA2MjI3OTQvMzEyNzg1Pi5cbiAgICAgIGlmICgkcGFpcnMuc29tZShmdW5jdGlvbihwKSB7IHJldHVybiBwWzBdID09PSB4ICYmIHBbMV0gPT09IHk7IH0pKSB7XG4gICAgICAgIHJldHVybiBlcXVhbHMoeCwgeSk7XG4gICAgICB9XG5cbiAgICAgICRwYWlycy5wdXNoKFt4LCB5XSk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gT3JkLnRlc3QoeCkgJiYgT3JkLnRlc3QoeSkgJiYgT3JkLm1ldGhvZHMubHRlKHgpKHkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgJHBhaXJzLnBvcCgpO1xuICAgICAgfVxuICAgIH07XG4gIH0oKSk7XG5cbiAgLy8jIGd0IDo6IChhLCBiKSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gUmV0dXJucyBgdHJ1ZWAgaWYgaXRzIGFyZ3VtZW50cyBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhbmQgdGhlIGZpcnN0IGlzXG4gIC8vLiBncmVhdGVyIHRoYW4gdGhlIHNlY29uZCBhY2NvcmRpbmcgdG8gdGhlIHR5cGUncyBbYGZhbnRhc3ktbGFuZC9sdGVgXVtdXG4gIC8vLiBtZXRob2Q7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgbHRlYF0oI2x0ZSkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BsdGBdKCNsdCkgYW5kIFtgZ3RlYF0oI2d0ZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBndCgwLCAwKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IGd0KDAsIDEpXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gZ3QoMSwgMClcbiAgLy8uIHRydWVcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBndCh4LCB5KSB7XG4gICAgcmV0dXJuIGx0KHksIHgpO1xuICB9XG5cbiAgLy8jIGd0ZSA6OiAoYSwgYikgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIGlmIGl0cyBhcmd1bWVudHMgYXJlIG9mIHRoZSBzYW1lIHR5cGUgYW5kIHRoZSBmaXJzdFxuICAvLy4gaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQgYWNjb3JkaW5nIHRvIHRoZSB0eXBlJ3NcbiAgLy8uIFtgZmFudGFzeS1sYW5kL2x0ZWBdW10gbWV0aG9kOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGx0ZWBdKCNsdGUpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbHRgXSgjbHQpIGFuZCBbYGd0YF0oI2d0KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGd0ZSgwLCAwKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gZ3RlKDAsIDEpXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gZ3RlKDEsIDApXG4gIC8vLiB0cnVlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZ3RlKHgsIHkpIHtcbiAgICByZXR1cm4gbHRlKHksIHgpO1xuICB9XG5cbiAgLy8jIG1pbiA6OiBPcmQgYSA9PiAoYSwgYSkgLT4gYVxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIHNtYWxsZXIgb2YgaXRzIHR3byBhcmd1bWVudHMuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BsdGVgXSgjbHRlKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYG1heGBdKCNtYXgpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gbWluKDEwLCAyKVxuICAvLy4gMlxuICAvLy5cbiAgLy8uID4gbWluKG5ldyBEYXRlKCcxOTk5LTEyLTMxJyksIG5ldyBEYXRlKCcyMDAwLTAxLTAxJykpXG4gIC8vLiBuZXcgRGF0ZSgnMTk5OS0xMi0zMScpXG4gIC8vLlxuICAvLy4gPiBtaW4oJzEwJywgJzInKVxuICAvLy4gJzEwJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG1pbih4LCB5KSB7XG4gICAgcmV0dXJuIGx0ZSh4LCB5KSA/IHggOiB5O1xuICB9XG5cbiAgLy8jIG1heCA6OiBPcmQgYSA9PiAoYSwgYSkgLT4gYVxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIGxhcmdlciBvZiBpdHMgdHdvIGFyZ3VtZW50cy5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGx0ZWBdKCNsdGUpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbWluYF0oI21pbikuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBtYXgoMTAsIDIpXG4gIC8vLiAxMFxuICAvLy5cbiAgLy8uID4gbWF4KG5ldyBEYXRlKCcxOTk5LTEyLTMxJyksIG5ldyBEYXRlKCcyMDAwLTAxLTAxJykpXG4gIC8vLiBuZXcgRGF0ZSgnMjAwMC0wMS0wMScpXG4gIC8vLlxuICAvLy4gPiBtYXgoJzEwJywgJzInKVxuICAvLy4gJzInXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbWF4KHgsIHkpIHtcbiAgICByZXR1cm4gbHRlKHgsIHkpID8geSA6IHg7XG4gIH1cblxuICAvLyMgY29tcG9zZSA6OiBTZW1pZ3JvdXBvaWQgYyA9PiAoYyBqIGssIGMgaSBqKSAtPiBjIGkga1xuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2NvbXBvc2VgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvY29tcG9zZWAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gY29tcG9zZShNYXRoLnNxcnQsIHggPT4geCArIDEpKDk5KVxuICAvLy4gMTBcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBjb21wb3NlKHgsIHkpIHtcbiAgICByZXR1cm4gU2VtaWdyb3Vwb2lkLm1ldGhvZHMuY29tcG9zZSh5KSh4KTtcbiAgfVxuXG4gIC8vIyBpZCA6OiBDYXRlZ29yeSBjID0+IFR5cGVSZXAgYyAtPiBjXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvaWRgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvaWRgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBGdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGlkKEZ1bmN0aW9uKSgnZm9vJylcbiAgLy8uICdmb28nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gaWQodHlwZVJlcCkge1xuICAgIHJldHVybiBDYXRlZ29yeS5tZXRob2RzLmlkKHR5cGVSZXApKCk7XG4gIH1cblxuICAvLyMgY29uY2F0IDo6IFNlbWlncm91cCBhID0+IChhLCBhKSAtPiBhXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvY29uY2F0YF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2NvbmNhdGAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IFN0cmluZywgQXJyYXksIGFuZCBPYmplY3QuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBjb25jYXQoJ2FiYycsICdkZWYnKVxuICAvLy4gJ2FiY2RlZidcbiAgLy8uXG4gIC8vLiA+IGNvbmNhdChbMSwgMiwgM10sIFs0LCA1LCA2XSlcbiAgLy8uIFsxLCAyLCAzLCA0LCA1LCA2XVxuICAvLy5cbiAgLy8uID4gY29uY2F0KHt4OiAxLCB5OiAyfSwge3k6IDMsIHo6IDR9KVxuICAvLy4ge3g6IDEsIHk6IDMsIHo6IDR9XG4gIC8vLlxuICAvLy4gPiBjb25jYXQoQ29ucygnZm9vJywgQ29ucygnYmFyJywgQ29ucygnYmF6JywgTmlsKSkpLCBDb25zKCdxdXV4JywgTmlsKSlcbiAgLy8uIENvbnMoJ2ZvbycsIENvbnMoJ2JhcicsIENvbnMoJ2JheicsIENvbnMoJ3F1dXgnLCBOaWwpKSkpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gY29uY2F0KHgsIHkpIHtcbiAgICByZXR1cm4gU2VtaWdyb3VwLm1ldGhvZHMuY29uY2F0KHgpKHkpO1xuICB9XG5cbiAgLy8jIGVtcHR5IDo6IE1vbm9pZCBtID0+IFR5cGVSZXAgbSAtPiBtXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvZW1wdHlgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvZW1wdHlgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBTdHJpbmcsIEFycmF5LCBhbmQgT2JqZWN0LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZW1wdHkoU3RyaW5nKVxuICAvLy4gJydcbiAgLy8uXG4gIC8vLiA+IGVtcHR5KEFycmF5KVxuICAvLy4gW11cbiAgLy8uXG4gIC8vLiA+IGVtcHR5KE9iamVjdClcbiAgLy8uIHt9XG4gIC8vLlxuICAvLy4gPiBlbXB0eShMaXN0KVxuICAvLy4gTmlsXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZW1wdHkodHlwZVJlcCkge1xuICAgIHJldHVybiBNb25vaWQubWV0aG9kcy5lbXB0eSh0eXBlUmVwKSgpO1xuICB9XG5cbiAgLy8jIGludmVydCA6OiBHcm91cCBnID0+IGcgLT4gZ1xuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2ludmVydGBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gaW52ZXJ0KFN1bSg1KSlcbiAgLy8uIFN1bSgtNSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBpbnZlcnQoZ3JvdXApIHtcbiAgICByZXR1cm4gR3JvdXAubWV0aG9kcy5pbnZlcnQoZ3JvdXApKCk7XG4gIH1cblxuICAvLyMgbWFwIDo6IEZ1bmN0b3IgZiA9PiAoYSAtPiBiLCBmIGEpIC0+IGYgYlxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL21hcGBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9tYXBgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBBcnJheSwgT2JqZWN0LCBhbmQgRnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBtYXAoTWF0aC5zcXJ0LCBbMSwgNCwgOV0pXG4gIC8vLiBbMSwgMiwgM11cbiAgLy8uXG4gIC8vLiA+IG1hcChNYXRoLnNxcnQsIHt4OiAxLCB5OiA0LCB6OiA5fSlcbiAgLy8uIHt4OiAxLCB5OiAyLCB6OiAzfVxuICAvLy5cbiAgLy8uID4gbWFwKE1hdGguc3FydCwgcyA9PiBzLmxlbmd0aCkoJ1NhbmN0dWFyeScpXG4gIC8vLiAzXG4gIC8vLlxuICAvLy4gPiBtYXAoTWF0aC5zcXJ0LCBUdXBsZSgnZm9vJywgNjQpKVxuICAvLy4gVHVwbGUoJ2ZvbycsIDgpXG4gIC8vLlxuICAvLy4gPiBtYXAoTWF0aC5zcXJ0LCBOaWwpXG4gIC8vLiBOaWxcbiAgLy8uXG4gIC8vLiA+IG1hcChNYXRoLnNxcnQsIENvbnMoMSwgQ29ucyg0LCBDb25zKDksIE5pbCkpKSlcbiAgLy8uIENvbnMoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG1hcChmLCBmdW5jdG9yKSB7XG4gICAgcmV0dXJuIEZ1bmN0b3IubWV0aG9kcy5tYXAoZnVuY3RvcikoZik7XG4gIH1cblxuICAvLyMgYmltYXAgOjogQmlmdW5jdG9yIGYgPT4gKGEgLT4gYiwgYyAtPiBkLCBmIGEgYykgLT4gZiBiIGRcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9iaW1hcGBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBiaW1hcChzID0+IHMudG9VcHBlckNhc2UoKSwgTWF0aC5zcXJ0LCBUdXBsZSgnZm9vJywgNjQpKVxuICAvLy4gVHVwbGUoJ0ZPTycsIDgpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gYmltYXAoZiwgZywgYmlmdW5jdG9yKSB7XG4gICAgcmV0dXJuIEJpZnVuY3Rvci5tZXRob2RzLmJpbWFwKGJpZnVuY3RvcikoZiwgZyk7XG4gIH1cblxuICAvLyMgcHJvbWFwIDo6IFByb2Z1bmN0b3IgcCA9PiAoYSAtPiBiLCBjIC0+IGQsIHAgYiBjKSAtPiBwIGEgZFxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL3Byb21hcGBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9wcm9tYXBgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBGdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHByb21hcChNYXRoLmFicywgeCA9PiB4ICsgMSwgTWF0aC5zcXJ0KSgtMTAwKVxuICAvLy4gMTFcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBwcm9tYXAoZiwgZywgcHJvZnVuY3Rvcikge1xuICAgIHJldHVybiBQcm9mdW5jdG9yLm1ldGhvZHMucHJvbWFwKHByb2Z1bmN0b3IpKGYsIGcpO1xuICB9XG5cbiAgLy8jIGFwIDo6IEFwcGx5IGYgPT4gKGYgKGEgLT4gYiksIGYgYSkgLT4gZiBiXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvYXBgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvYXBgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBBcnJheSwgT2JqZWN0LCBhbmQgRnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBhcChbTWF0aC5zcXJ0LCB4ID0+IHggKiB4XSwgWzEsIDQsIDksIDE2LCAyNV0pXG4gIC8vLiBbMSwgMiwgMywgNCwgNSwgMSwgMTYsIDgxLCAyNTYsIDYyNV1cbiAgLy8uXG4gIC8vLiA+IGFwKHthOiBNYXRoLnNxcnQsIGI6IHggPT4geCAqIHh9LCB7YTogMTYsIGI6IDEwLCBjOiAxfSlcbiAgLy8uIHthOiA0LCBiOiAxMDB9XG4gIC8vLlxuICAvLy4gPiBhcChzID0+IG4gPT4gcy5zbGljZSgwLCBuKSwgcyA9PiBNYXRoLmNlaWwocy5sZW5ndGggLyAyKSkoJ0hhc2tlbGwnKVxuICAvLy4gJ0hhc2snXG4gIC8vLlxuICAvLy4gPiBhcChJZGVudGl0eShNYXRoLnNxcnQpLCBJZGVudGl0eSg2NCkpXG4gIC8vLiBJZGVudGl0eSg4KVxuICAvLy5cbiAgLy8uID4gYXAoQ29ucyhNYXRoLnNxcnQsIENvbnMoeCA9PiB4ICogeCwgTmlsKSksIENvbnMoMTYsIENvbnMoMTAwLCBOaWwpKSlcbiAgLy8uIENvbnMoNCwgQ29ucygxMCwgQ29ucygyNTYsIENvbnMoMTAwMDAsIE5pbCkpKSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBhcChhcHBseUYsIGFwcGx5WCkge1xuICAgIHJldHVybiBBcHBseS5tZXRob2RzLmFwKGFwcGx5WCkoYXBwbHlGKTtcbiAgfVxuXG4gIC8vIyBsaWZ0MiA6OiBBcHBseSBmID0+IChhIC0+IGIgLT4gYywgZiBhLCBmIGIpIC0+IGYgY1xuICAvLy5cbiAgLy8uIExpZnRzIGBhIC0+IGIgLT4gY2AgdG8gYEFwcGx5IGYgPT4gZiBhIC0+IGYgYiAtPiBmIGNgIGFuZCByZXR1cm5zIHRoZVxuICAvLy4gcmVzdWx0IG9mIGFwcGx5aW5nIHRoaXMgdG8gdGhlIGdpdmVuIGFyZ3VtZW50cy5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYG1hcGBdKCNtYXApIGFuZCBbYGFwYF0oI2FwKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGxpZnQzYF0oI2xpZnQzKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGxpZnQyKHggPT4geSA9PiBNYXRoLnBvdyh4LCB5KSwgWzEwXSwgWzEsIDIsIDNdKVxuICAvLy4gWzEwLCAxMDAsIDEwMDBdXG4gIC8vLlxuICAvLy4gPiBsaWZ0Mih4ID0+IHkgPT4gTWF0aC5wb3coeCwgeSksIElkZW50aXR5KDEwKSwgSWRlbnRpdHkoMykpXG4gIC8vLiBJZGVudGl0eSgxMDAwKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGxpZnQyKGYsIHgsIHkpIHtcbiAgICByZXR1cm4gYXAobWFwKGYsIHgpLCB5KTtcbiAgfVxuXG4gIC8vIyBsaWZ0MyA6OiBBcHBseSBmID0+IChhIC0+IGIgLT4gYyAtPiBkLCBmIGEsIGYgYiwgZiBjKSAtPiBmIGRcbiAgLy8uXG4gIC8vLiBMaWZ0cyBgYSAtPiBiIC0+IGMgLT4gZGAgdG8gYEFwcGx5IGYgPT4gZiBhIC0+IGYgYiAtPiBmIGMgLT4gZiBkYCBhbmRcbiAgLy8uIHJldHVybnMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGlzIHRvIHRoZSBnaXZlbiBhcmd1bWVudHMuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BtYXBgXSgjbWFwKSBhbmQgW2BhcGBdKCNhcCkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BsaWZ0MmBdKCNsaWZ0MikuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBsaWZ0Myh4ID0+IHkgPT4geiA9PiB4ICsgeiArIHksIFsnPCddLCBbJz4nXSwgWydmb28nLCAnYmFyJywgJ2JheiddKVxuICAvLy4gWyc8Zm9vPicsICc8YmFyPicsICc8YmF6PiddXG4gIC8vLlxuICAvLy4gPiBsaWZ0Myh4ID0+IHkgPT4geiA9PiB4ICsgeiArIHksIElkZW50aXR5KCc8JyksIElkZW50aXR5KCc+JyksIElkZW50aXR5KCdiYXonKSlcbiAgLy8uIElkZW50aXR5KCc8YmF6PicpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbGlmdDMoZiwgeCwgeSwgeikge1xuICAgIHJldHVybiBhcChhcChtYXAoZiwgeCksIHkpLCB6KTtcbiAgfVxuXG4gIC8vIyBhcEZpcnN0IDo6IEFwcGx5IGYgPT4gKGYgYSwgZiBiKSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBDb21iaW5lcyB0d28gZWZmZWN0ZnVsIGFjdGlvbnMsIGtlZXBpbmcgb25seSB0aGUgcmVzdWx0IG9mIHRoZSBmaXJzdC5cbiAgLy8uIEVxdWl2YWxlbnQgdG8gSGFza2VsbCdzIGAoPCopYCBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGxpZnQyYF0oI2xpZnQyKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGFwU2Vjb25kYF0oI2FwU2Vjb25kKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGFwRmlyc3QoWzEsIDJdLCBbMywgNF0pXG4gIC8vLiBbMSwgMSwgMiwgMl1cbiAgLy8uXG4gIC8vLiA+IGFwRmlyc3QoSWRlbnRpdHkoMSksIElkZW50aXR5KDIpKVxuICAvLy4gSWRlbnRpdHkoMSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBhcEZpcnN0KHgsIHkpIHtcbiAgICByZXR1cm4gbGlmdDIoY29uc3RhbnQsIHgsIHkpO1xuICB9XG5cbiAgLy8jIGFwU2Vjb25kIDo6IEFwcGx5IGYgPT4gKGYgYSwgZiBiKSAtPiBmIGJcbiAgLy8uXG4gIC8vLiBDb21iaW5lcyB0d28gZWZmZWN0ZnVsIGFjdGlvbnMsIGtlZXBpbmcgb25seSB0aGUgcmVzdWx0IG9mIHRoZSBzZWNvbmQuXG4gIC8vLiBFcXVpdmFsZW50IHRvIEhhc2tlbGwncyBgKCo+KWAgZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BsaWZ0MmBdKCNsaWZ0MikuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BhcEZpcnN0YF0oI2FwRmlyc3QpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gYXBTZWNvbmQoWzEsIDJdLCBbMywgNF0pXG4gIC8vLiBbMywgNCwgMywgNF1cbiAgLy8uXG4gIC8vLiA+IGFwU2Vjb25kKElkZW50aXR5KDEpLCBJZGVudGl0eSgyKSlcbiAgLy8uIElkZW50aXR5KDIpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gYXBTZWNvbmQoeCwgeSkge1xuICAgIHJldHVybiBsaWZ0Mihjb25zdGFudChpZGVudGl0eSksIHgsIHkpO1xuICB9XG5cbiAgLy8jIG9mIDo6IEFwcGxpY2F0aXZlIGYgPT4gKFR5cGVSZXAgZiwgYSkgLT4gZiBhXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvb2ZgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvb2ZgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBBcnJheSBhbmQgRnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBvZihBcnJheSwgNDIpXG4gIC8vLiBbNDJdXG4gIC8vLlxuICAvLy4gPiBvZihGdW5jdGlvbiwgNDIpKG51bGwpXG4gIC8vLiA0MlxuICAvLy5cbiAgLy8uID4gb2YoTGlzdCwgNDIpXG4gIC8vLiBDb25zKDQyLCBOaWwpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gb2YodHlwZVJlcCwgeCkge1xuICAgIHJldHVybiBBcHBsaWNhdGl2ZS5tZXRob2RzLm9mKHR5cGVSZXApKHgpO1xuICB9XG5cbiAgLy8jIGFwcGVuZCA6OiAoQXBwbGljYXRpdmUgZiwgU2VtaWdyb3VwIChmIGEpKSA9PiAoYSwgZiBhKSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwZW5kaW5nIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgc2Vjb25kLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgY29uY2F0YF0oI2NvbmNhdCkgYW5kIFtgb2ZgXSgjb2YpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgcHJlcGVuZGBdKCNwcmVwZW5kKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGFwcGVuZCgzLCBbMSwgMl0pXG4gIC8vLiBbMSwgMiwgM11cbiAgLy8uXG4gIC8vLiA+IGFwcGVuZCgzLCBDb25zKDEsIENvbnMoMiwgTmlsKSkpXG4gIC8vLiBDb25zKDEsIENvbnMoMiwgQ29ucygzLCBOaWwpKSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBhcHBlbmQoeCwgeHMpIHtcbiAgICByZXR1cm4gY29uY2F0KHhzLCBvZih4cy5jb25zdHJ1Y3RvciwgeCkpO1xuICB9XG5cbiAgLy8jIHByZXBlbmQgOjogKEFwcGxpY2F0aXZlIGYsIFNlbWlncm91cCAoZiBhKSkgPT4gKGEsIGYgYSkgLT4gZiBhXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHByZXBlbmRpbmcgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2Bjb25jYXRgXSgjY29uY2F0KSBhbmQgW2BvZmBdKCNvZikuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BhcHBlbmRgXSgjYXBwZW5kKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHByZXBlbmQoMSwgWzIsIDNdKVxuICAvLy4gWzEsIDIsIDNdXG4gIC8vLlxuICAvLy4gPiBwcmVwZW5kKDEsIENvbnMoMiwgQ29ucygzLCBOaWwpKSlcbiAgLy8uIENvbnMoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHByZXBlbmQoeCwgeHMpIHtcbiAgICByZXR1cm4gY29uY2F0KG9mKHhzLmNvbnN0cnVjdG9yLCB4KSwgeHMpO1xuICB9XG5cbiAgLy8jIGNoYWluIDo6IENoYWluIG0gPT4gKGEgLT4gbSBiLCBtIGEpIC0+IG0gYlxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2NoYWluYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2NoYWluYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogQXJyYXkgYW5kIEZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gY2hhaW4oeCA9PiBbeCwgeF0sIFsxLCAyLCAzXSlcbiAgLy8uIFsxLCAxLCAyLCAyLCAzLCAzXVxuICAvLy5cbiAgLy8uID4gY2hhaW4oeCA9PiB4ICUgMiA9PSAxID8gb2YoTGlzdCwgeCkgOiBOaWwsIENvbnMoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKSlcbiAgLy8uIENvbnMoMSwgQ29ucygzLCBOaWwpKVxuICAvLy5cbiAgLy8uID4gY2hhaW4obiA9PiBzID0+IHMuc2xpY2UoMCwgbiksIHMgPT4gTWF0aC5jZWlsKHMubGVuZ3RoIC8gMikpKCdIYXNrZWxsJylcbiAgLy8uICdIYXNrJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGNoYWluKGYsIGNoYWluXykge1xuICAgIHJldHVybiBDaGFpbi5tZXRob2RzLmNoYWluKGNoYWluXykoZik7XG4gIH1cblxuICAvLyMgam9pbiA6OiBDaGFpbiBtID0+IG0gKG0gYSkgLT4gbSBhXG4gIC8vLlxuICAvLy4gUmVtb3ZlcyBvbmUgbGV2ZWwgb2YgbmVzdGluZyBmcm9tIGEgbmVzdGVkIG1vbmFkaWMgc3RydWN0dXJlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgY2hhaW5gXSgjY2hhaW4pLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gam9pbihbWzFdLCBbMl0sIFszXV0pXG4gIC8vLiBbMSwgMiwgM11cbiAgLy8uXG4gIC8vLiA+IGpvaW4oW1tbMSwgMiwgM11dXSlcbiAgLy8uIFtbMSwgMiwgM11dXG4gIC8vLlxuICAvLy4gPiBqb2luKElkZW50aXR5KElkZW50aXR5KDEpKSlcbiAgLy8uIElkZW50aXR5KDEpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gam9pbihjaGFpbl8pIHtcbiAgICByZXR1cm4gY2hhaW4oaWRlbnRpdHksIGNoYWluXyk7XG4gIH1cblxuICAvLyMgY2hhaW5SZWMgOjogQ2hhaW5SZWMgbSA9PiAoVHlwZVJlcCBtLCAoYSAtPiBjLCBiIC0+IGMsIGEpIC0+IG0gYywgYSkgLT4gbSBiXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvY2hhaW5SZWNgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvY2hhaW5SZWNgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBBcnJheS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGNoYWluUmVjKFxuICAvLy4gLiAgIEFycmF5LFxuICAvLy4gLiAgIChuZXh0LCBkb25lLCBzKSA9PiBzLmxlbmd0aCA9PSAyID8gW3MgKyAnIScsIHMgKyAnPyddLm1hcChkb25lKVxuICAvLy4gLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogW3MgKyAnbycsIHMgKyAnbiddLm1hcChuZXh0KSxcbiAgLy8uIC4gICAnJ1xuICAvLy4gLiApXG4gIC8vLiBbJ29vIScsICdvbz8nLCAnb24hJywgJ29uPycsICdubyEnLCAnbm8/JywgJ25uIScsICdubj8nXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGNoYWluUmVjKHR5cGVSZXAsIGYsIHgpIHtcbiAgICByZXR1cm4gQ2hhaW5SZWMubWV0aG9kcy5jaGFpblJlYyh0eXBlUmVwKShmLCB4KTtcbiAgfVxuXG4gIC8vIyBmaWx0ZXIgOjogKEFwcGxpY2F0aXZlIGYsIEZvbGRhYmxlIGYsIE1vbm9pZCAoZiBhKSkgPT4gKGEgLT4gQm9vbGVhbiwgZiBhKSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBGaWx0ZXJzIGl0cyBzZWNvbmQgYXJndW1lbnQgaW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBnaXZlbiBwcmVkaWNhdGUuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2Bjb25jYXRgXSgjY29uY2F0KSwgW2BlbXB0eWBdKCNlbXB0eSksXG4gIC8vLiBbYG9mYF0oI29mKSwgYW5kIFtgcmVkdWNlYF0oI3JlZHVjZSkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BmaWx0ZXJNYF0oI2ZpbHRlck0pLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZmlsdGVyKHggPT4geCAlIDIgPT0gMSwgWzEsIDIsIDNdKVxuICAvLy4gWzEsIDNdXG4gIC8vLlxuICAvLy4gPiBmaWx0ZXIoeCA9PiB4ICUgMiA9PSAxLCBDb25zKDEsIENvbnMoMiwgQ29ucygzLCBOaWwpKSkpXG4gIC8vLiBDb25zKDEsIENvbnMoMywgTmlsKSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBmaWx0ZXIocHJlZCwgbSkge1xuICAgIC8vICBGYXN0IHBhdGggZm9yIGFycmF5cy5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShtKSkgcmV0dXJuIG0uZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHByZWQoeCk7IH0pO1xuICAgIHZhciBNID0gbS5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gcmVkdWNlKGZ1bmN0aW9uKG0sIHgpIHsgcmV0dXJuIHByZWQoeCkgPyBjb25jYXQobSwgb2YoTSwgeCkpIDogbTsgfSxcbiAgICAgICAgICAgICAgICAgIGVtcHR5KE0pLFxuICAgICAgICAgICAgICAgICAgbSk7XG4gIH1cblxuICAvLyMgZmlsdGVyTSA6OiAoQWx0ZXJuYXRpdmUgbSwgTW9uYWQgbSkgPT4gKGEgLT4gQm9vbGVhbiwgbSBhKSAtPiBtIGFcbiAgLy8uXG4gIC8vLiBGaWx0ZXJzIGl0cyBzZWNvbmQgYXJndW1lbnQgaW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBnaXZlbiBwcmVkaWNhdGUuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BvZmBdKCNvZiksIFtgY2hhaW5gXSgjY2hhaW4pLCBhbmRcbiAgLy8uIFtgemVyb2BdKCN6ZXJvKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGZpbHRlcmBdKCNmaWx0ZXIpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZmlsdGVyTSh4ID0+IHggJSAyID09IDEsIFsxLCAyLCAzXSlcbiAgLy8uIFsxLCAzXVxuICAvLy5cbiAgLy8uID4gZmlsdGVyTSh4ID0+IHggJSAyID09IDEsIENvbnMoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKSlcbiAgLy8uIENvbnMoMSwgQ29ucygzLCBOaWwpKVxuICAvLy5cbiAgLy8uID4gZmlsdGVyTSh4ID0+IHggJSAyID09IDEsIE5vdGhpbmcpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBmaWx0ZXJNKHggPT4geCAlIDIgPT0gMSwgSnVzdCgwKSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IGZpbHRlck0oeCA9PiB4ICUgMiA9PSAxLCBKdXN0KDEpKVxuICAvLy4gSnVzdCgxKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGZpbHRlck0ocHJlZCwgbSkge1xuICAgIHZhciBNID0gbS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgeiA9IHplcm8oTSk7XG4gICAgcmV0dXJuIGNoYWluKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHByZWQoeCkgPyBvZihNLCB4KSA6IHo7IH0sIG0pO1xuICB9XG5cbiAgLy8jIGFsdCA6OiBBbHQgZiA9PiAoZiBhLCBmIGEpIC0+IGYgYVxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2FsdGBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9hbHRgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBBcnJheSBhbmQgT2JqZWN0LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gYWx0KFsxLCAyLCAzXSwgWzQsIDUsIDZdKVxuICAvLy4gWzEsIDIsIDMsIDQsIDUsIDZdXG4gIC8vLlxuICAvLy4gPiBhbHQoTm90aGluZywgTm90aGluZylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IGFsdChOb3RoaW5nLCBKdXN0KDEpKVxuICAvLy4gSnVzdCgxKVxuICAvLy5cbiAgLy8uID4gYWx0KEp1c3QoMiksIEp1c3QoMykpXG4gIC8vLiBKdXN0KDIpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gYWx0KHgsIHkpIHtcbiAgICByZXR1cm4gQWx0Lm1ldGhvZHMuYWx0KHgpKHkpO1xuICB9XG5cbiAgLy8jIHplcm8gOjogUGx1cyBmID0+IFR5cGVSZXAgZiAtPiBmIGFcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC96ZXJvYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL3plcm9gIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBBcnJheSBhbmQgT2JqZWN0LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gemVybyhBcnJheSlcbiAgLy8uIFtdXG4gIC8vLlxuICAvLy4gPiB6ZXJvKE9iamVjdClcbiAgLy8uIHt9XG4gIC8vLlxuICAvLy4gPiB6ZXJvKE1heWJlKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHplcm8odHlwZVJlcCkge1xuICAgIHJldHVybiBQbHVzLm1ldGhvZHMuemVybyh0eXBlUmVwKSgpO1xuICB9XG5cbiAgLy8jIHJlZHVjZSA6OiBGb2xkYWJsZSBmID0+ICgoYiwgYSkgLT4gYiwgYiwgZiBhKSAtPiBiXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvcmVkdWNlYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL3JlZHVjZWAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEFycmF5IGFuZCBPYmplY3QuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiByZWR1Y2UoKHhzLCB4KSA9PiBbeF0uY29uY2F0KHhzKSwgW10sIFsxLCAyLCAzXSlcbiAgLy8uIFszLCAyLCAxXVxuICAvLy5cbiAgLy8uID4gcmVkdWNlKGNvbmNhdCwgJycsIENvbnMoJ2ZvbycsIENvbnMoJ2JhcicsIENvbnMoJ2JheicsIE5pbCkpKSlcbiAgLy8uICdmb29iYXJiYXonXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcmVkdWNlKGYsIHgsIGZvbGRhYmxlKSB7XG4gICAgcmV0dXJuIEZvbGRhYmxlLm1ldGhvZHMucmVkdWNlKGZvbGRhYmxlKShmLCB4KTtcbiAgfVxuXG4gIC8vIyBzaXplIDo6IEZvbGRhYmxlIGYgPT4gZiBhIC0+IEludGVnZXJcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHN0cnVjdHVyZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYHJlZHVjZWBdKCNyZWR1Y2UpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gc2l6ZShbXSlcbiAgLy8uIDBcbiAgLy8uXG4gIC8vLiA+IHNpemUoWydmb28nLCAnYmFyJywgJ2JheiddKVxuICAvLy4gM1xuICAvLy5cbiAgLy8uID4gc2l6ZShOaWwpXG4gIC8vLiAwXG4gIC8vLlxuICAvLy4gPiBzaXplKENvbnMoJ2ZvbycsIENvbnMoJ2JhcicsIENvbnMoJ2JheicsIE5pbCkpKSlcbiAgLy8uIDNcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBzaXplKGZvbGRhYmxlKSB7XG4gICAgLy8gIEZhc3QgcGF0aCBmb3IgYXJyYXlzLlxuICAgIGlmIChBcnJheS5pc0FycmF5KGZvbGRhYmxlKSkgcmV0dXJuIGZvbGRhYmxlLmxlbmd0aDtcbiAgICByZXR1cm4gcmVkdWNlKGZ1bmN0aW9uKG4sIF8pIHsgcmV0dXJuIG4gKyAxOyB9LCAwLCBmb2xkYWJsZSk7XG4gIH1cblxuICAvLyMgZWxlbSA6OiAoU2V0b2lkIGEsIEZvbGRhYmxlIGYpID0+IChhLCBmIGEpIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHZhbHVlIGFuZCBhIHN0cnVjdHVyZSBhbmQgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlXG4gIC8vLiB2YWx1ZSBpcyBhbiBlbGVtZW50IG9mIHRoZSBzdHJ1Y3R1cmU7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgZXF1YWxzYF0oI2VxdWFscykgYW5kXG4gIC8vLiBbYHJlZHVjZWBdKCNyZWR1Y2UpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZWxlbSgnYycsIFsnYScsICdiJywgJ2MnXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IGVsZW0oJ3gnLCBbJ2EnLCAnYicsICdjJ10pXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gZWxlbSgzLCB7eDogMSwgeTogMiwgejogM30pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBlbGVtKDgsIHt4OiAxLCB5OiAyLCB6OiAzfSlcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBlbGVtKDAsIEp1c3QoMCkpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBlbGVtKDAsIEp1c3QoMSkpXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gZWxlbSgwLCBOb3RoaW5nKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBlbGVtKHgsIGZvbGRhYmxlKSB7XG4gICAgcmV0dXJuIHJlZHVjZShmdW5jdGlvbihiLCB5KSB7IHJldHVybiBiIHx8IGVxdWFscyh4LCB5KTsgfSxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgZm9sZGFibGUpO1xuICB9XG5cbiAgLy8jIHJldmVyc2UgOjogKEFwcGxpY2F0aXZlIGYsIEZvbGRhYmxlIGYsIE1vbm9pZCAoZiBhKSkgPT4gZiBhIC0+IGYgYVxuICAvLy5cbiAgLy8uIFJldmVyc2VzIHRoZSBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gc3RydWN0dXJlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgY29uY2F0YF0oI2NvbmNhdCksIFtgZW1wdHlgXSgjZW1wdHkpLFxuICAvLy4gW2BvZmBdKCNvZiksIGFuZCBbYHJlZHVjZWBdKCNyZWR1Y2UpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gcmV2ZXJzZShbMSwgMiwgM10pXG4gIC8vLiBbMywgMiwgMV1cbiAgLy8uXG4gIC8vLiA+IHJldmVyc2UoQ29ucygxLCBDb25zKDIsIENvbnMoMywgTmlsKSkpKVxuICAvLy4gQ29ucygzLCBDb25zKDIsIENvbnMoMSwgTmlsKSkpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcmV2ZXJzZShmb2xkYWJsZSkge1xuICAgIC8vICBGYXN0IHBhdGggZm9yIGFycmF5cy5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShmb2xkYWJsZSkpIHJldHVybiBmb2xkYWJsZS5zbGljZSgpLnJldmVyc2UoKTtcbiAgICB2YXIgRiA9IGZvbGRhYmxlLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiByZWR1Y2UoZnVuY3Rpb24oeHMsIHgpIHsgcmV0dXJuIGNvbmNhdChvZihGLCB4KSwgeHMpOyB9LFxuICAgICAgICAgICAgICAgICAgZW1wdHkoRiksXG4gICAgICAgICAgICAgICAgICBmb2xkYWJsZSk7XG4gIH1cblxuICAvLyMgc29ydCA6OiAoT3JkIGEsIEFwcGxpY2F0aXZlIGYsIEZvbGRhYmxlIGYsIE1vbm9pZCAoZiBhKSkgPT4gZiBhIC0+IGYgYVxuICAvLy5cbiAgLy8uIFBlcmZvcm1zIGEgW3N0YWJsZSBzb3J0XVtdIG9mIHRoZSBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gc3RydWN0dXJlLFxuICAvLy4gdXNpbmcgW2BsdGVgXSgjbHRlKSBmb3IgY29tcGFyaXNvbnMuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BsdGVgXSgjbHRlKSwgW2Bjb25jYXRgXSgjY29uY2F0KSxcbiAgLy8uIFtgZW1wdHlgXSgjZW1wdHkpLCBbYG9mYF0oI29mKSwgYW5kIFtgcmVkdWNlYF0oI3JlZHVjZSkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2Bzb3J0QnlgXSgjc29ydEJ5KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHNvcnQoWydmb28nLCAnYmFyJywgJ2JheiddKVxuICAvLy4gWydiYXInLCAnYmF6JywgJ2ZvbyddXG4gIC8vLlxuICAvLy4gPiBzb3J0KFtKdXN0KDIpLCBOb3RoaW5nLCBKdXN0KDEpXSlcbiAgLy8uIFtOb3RoaW5nLCBKdXN0KDEpLCBKdXN0KDIpXVxuICAvLy5cbiAgLy8uID4gc29ydChDb25zKCdmb28nLCBDb25zKCdiYXInLCBDb25zKCdiYXonLCBOaWwpKSkpXG4gIC8vLiBDb25zKCdiYXInLCBDb25zKCdiYXonLCBDb25zKCdmb28nLCBOaWwpKSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBzb3J0KGZvbGRhYmxlKSB7XG4gICAgcmV0dXJuIHNvcnRCeShpZGVudGl0eSwgZm9sZGFibGUpO1xuICB9XG5cbiAgLy8jIHNvcnRCeSA6OiAoT3JkIGIsIEFwcGxpY2F0aXZlIGYsIEZvbGRhYmxlIGYsIE1vbm9pZCAoZiBhKSkgPT4gKGEgLT4gYiwgZiBhKSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBQZXJmb3JtcyBhIFtzdGFibGUgc29ydF1bXSBvZiB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHN0cnVjdHVyZSxcbiAgLy8uIHVzaW5nIFtgbHRlYF0oI2x0ZSkgdG8gY29tcGFyZSB0aGUgdmFsdWVzIHByb2R1Y2VkIGJ5IGFwcGx5aW5nIHRoZVxuICAvLy4gZ2l2ZW4gZnVuY3Rpb24gdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBzdHJ1Y3R1cmUuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BsdGVgXSgjbHRlKSwgW2Bjb25jYXRgXSgjY29uY2F0KSxcbiAgLy8uIFtgZW1wdHlgXSgjZW1wdHkpLCBbYG9mYF0oI29mKSwgYW5kIFtgcmVkdWNlYF0oI3JlZHVjZSkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2Bzb3J0YF0oI3NvcnQpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gc29ydEJ5KHMgPT4gcy5sZW5ndGgsIFsncmVkJywgJ2dyZWVuJywgJ2JsdWUnXSlcbiAgLy8uIFsncmVkJywgJ2JsdWUnLCAnZ3JlZW4nXVxuICAvLy5cbiAgLy8uID4gc29ydEJ5KHMgPT4gcy5sZW5ndGgsIFsnYmxhY2snLCAnd2hpdGUnXSlcbiAgLy8uIFsnYmxhY2snLCAnd2hpdGUnXVxuICAvLy5cbiAgLy8uID4gc29ydEJ5KHMgPT4gcy5sZW5ndGgsIFsnd2hpdGUnLCAnYmxhY2snXSlcbiAgLy8uIFsnd2hpdGUnLCAnYmxhY2snXVxuICAvLy5cbiAgLy8uID4gc29ydEJ5KHMgPT4gcy5sZW5ndGgsIENvbnMoJ3JlZCcsIENvbnMoJ2dyZWVuJywgQ29ucygnYmx1ZScsIE5pbCkpKSlcbiAgLy8uIENvbnMoJ3JlZCcsIENvbnMoJ2JsdWUnLCBDb25zKCdncmVlbicsIE5pbCkpKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHNvcnRCeShmLCBmb2xkYWJsZSkge1xuICAgIHZhciBycyA9IHJlZHVjZShmdW5jdGlvbih4cywgeCkge1xuICAgICAgdmFyIGZ4ID0gZih4KTtcbiAgICAgIHZhciBsb3dlciA9IDA7XG4gICAgICB2YXIgdXBwZXIgPSB4cy5sZW5ndGg7XG4gICAgICB3aGlsZSAobG93ZXIgPCB1cHBlcikge1xuICAgICAgICB2YXIgaWR4ID0gTWF0aC5mbG9vcigobG93ZXIgKyB1cHBlcikgLyAyKTtcbiAgICAgICAgaWYgKGx0ZSh4c1tpZHhdLmZ4LCBmeCkpIGxvd2VyID0gaWR4ICsgMTsgZWxzZSB1cHBlciA9IGlkeDtcbiAgICAgIH1cbiAgICAgIHhzLnNwbGljZShsb3dlciwgMCwge3g6IHgsIGZ4OiBmeH0pO1xuICAgICAgcmV0dXJuIHhzO1xuICAgIH0sIFtdLCBmb2xkYWJsZSk7XG5cbiAgICB2YXIgRiA9IGZvbGRhYmxlLmNvbnN0cnVjdG9yO1xuICAgIHZhciByZXN1bHQgPSBlbXB0eShGKTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBycy5sZW5ndGg7IGlkeCArPSAxKSB7XG4gICAgICByZXN1bHQgPSBjb25jYXQocmVzdWx0LCBvZihGLCByc1tpZHhdLngpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIyB0YWtlV2hpbGUgOjogKEFwcGxpY2F0aXZlIGYsIEZvbGRhYmxlIGYsIE1vbm9pZCAoZiBhKSkgPT4gKGEgLT4gQm9vbGVhbiwgZiBhKSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBEaXNjYXJkcyB0aGUgZmlyc3QgaW5uZXIgdmFsdWUgd2hpY2ggZG9lcyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLCBhbmRcbiAgLy8uIGFsbCBzdWJzZXF1ZW50IGlubmVyIHZhbHVlcy5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGNvbmNhdGBdKCNjb25jYXQpLCBbYGVtcHR5YF0oI2VtcHR5KSxcbiAgLy8uIFtgb2ZgXSgjb2YpLCBhbmQgW2ByZWR1Y2VgXSgjcmVkdWNlKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGRyb3BXaGlsZWBdKCNkcm9wV2hpbGUpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gdGFrZVdoaWxlKHMgPT4gL3gvLnRlc3QocyksIFsneHknLCAneHonLCAneXgnLCAneXonLCAnengnLCAnenknXSlcbiAgLy8uIFsneHknLCAneHonLCAneXgnXVxuICAvLy5cbiAgLy8uID4gdGFrZVdoaWxlKHMgPT4gL3kvLnRlc3QocyksIFsneHknLCAneHonLCAneXgnLCAneXonLCAnengnLCAnenknXSlcbiAgLy8uIFsneHknXVxuICAvLy5cbiAgLy8uID4gdGFrZVdoaWxlKHMgPT4gL3ovLnRlc3QocyksIFsneHknLCAneHonLCAneXgnLCAneXonLCAnengnLCAnenknXSlcbiAgLy8uIFtdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gdGFrZVdoaWxlKHByZWQsIGZvbGRhYmxlKSB7XG4gICAgdmFyIHRha2UgPSB0cnVlO1xuICAgIHJldHVybiBmaWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4gdGFrZSA9IHRha2UgJiYgcHJlZCh4KTsgfSwgZm9sZGFibGUpO1xuICB9XG5cbiAgLy8jIGRyb3BXaGlsZSA6OiAoQXBwbGljYXRpdmUgZiwgRm9sZGFibGUgZiwgTW9ub2lkIChmIGEpKSA9PiAoYSAtPiBCb29sZWFuLCBmIGEpIC0+IGYgYVxuICAvLy5cbiAgLy8uIFJldGFpbnMgdGhlIGZpcnN0IGlubmVyIHZhbHVlIHdoaWNoIGRvZXMgbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZSwgYW5kXG4gIC8vLiBhbGwgc3Vic2VxdWVudCBpbm5lciB2YWx1ZXMuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2Bjb25jYXRgXSgjY29uY2F0KSwgW2BlbXB0eWBdKCNlbXB0eSksXG4gIC8vLiBbYG9mYF0oI29mKSwgYW5kIFtgcmVkdWNlYF0oI3JlZHVjZSkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2B0YWtlV2hpbGVgXSgjdGFrZVdoaWxlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGRyb3BXaGlsZShzID0+IC94Ly50ZXN0KHMpLCBbJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5J10pXG4gIC8vLiBbJ3l6JywgJ3p4JywgJ3p5J11cbiAgLy8uXG4gIC8vLiA+IGRyb3BXaGlsZShzID0+IC95Ly50ZXN0KHMpLCBbJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5J10pXG4gIC8vLiBbJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5J11cbiAgLy8uXG4gIC8vLiA+IGRyb3BXaGlsZShzID0+IC96Ly50ZXN0KHMpLCBbJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5J10pXG4gIC8vLiBbJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5J11cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBkcm9wV2hpbGUocHJlZCwgZm9sZGFibGUpIHtcbiAgICB2YXIgdGFrZSA9IGZhbHNlO1xuICAgIHJldHVybiBmaWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4gdGFrZSA9IHRha2UgfHwgIXByZWQoeCk7IH0sIGZvbGRhYmxlKTtcbiAgfVxuXG4gIC8vIyB0cmF2ZXJzZSA6OiAoQXBwbGljYXRpdmUgZiwgVHJhdmVyc2FibGUgdCkgPT4gKFR5cGVSZXAgZiwgYSAtPiBmIGIsIHQgYSkgLT4gZiAodCBiKVxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL3RyYXZlcnNlYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL3RyYXZlcnNlYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogQXJyYXkgYW5kIE9iamVjdC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHNlcXVlbmNlYF0oI3NlcXVlbmNlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHRyYXZlcnNlKEFycmF5LCB4ID0+IHgsIFtbMSwgMiwgM10sIFs0LCA1XV0pXG4gIC8vLiBbWzEsIDRdLCBbMSwgNV0sIFsyLCA0XSwgWzIsIDVdLCBbMywgNF0sIFszLCA1XV1cbiAgLy8uXG4gIC8vLiA+IHRyYXZlcnNlKElkZW50aXR5LCB4ID0+IElkZW50aXR5KHggKyAxKSwgWzEsIDIsIDNdKVxuICAvLy4gSWRlbnRpdHkoWzIsIDMsIDRdKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHRyYXZlcnNlKHR5cGVSZXAsIGYsIHRyYXZlcnNhYmxlKSB7XG4gICAgcmV0dXJuIFRyYXZlcnNhYmxlLm1ldGhvZHMudHJhdmVyc2UodHJhdmVyc2FibGUpKHR5cGVSZXAsIGYpO1xuICB9XG5cbiAgLy8jIHNlcXVlbmNlIDo6IChBcHBsaWNhdGl2ZSBmLCBUcmF2ZXJzYWJsZSB0KSA9PiAoVHlwZVJlcCBmLCB0IChmIGEpKSAtPiBmICh0IGEpXG4gIC8vLlxuICAvLy4gSW52ZXJ0cyB0aGUgZ2l2ZW4gYHQgKGYgYSlgIHRvIHByb2R1Y2UgYW4gYGYgKHQgYSlgLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgdHJhdmVyc2VgXSgjdHJhdmVyc2UpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gc2VxdWVuY2UoQXJyYXksIElkZW50aXR5KFsxLCAyLCAzXSkpXG4gIC8vLiBbSWRlbnRpdHkoMSksIElkZW50aXR5KDIpLCBJZGVudGl0eSgzKV1cbiAgLy8uXG4gIC8vLiA+IHNlcXVlbmNlKElkZW50aXR5LCBbSWRlbnRpdHkoMSksIElkZW50aXR5KDIpLCBJZGVudGl0eSgzKV0pXG4gIC8vLiBJZGVudGl0eShbMSwgMiwgM10pXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gc2VxdWVuY2UodHlwZVJlcCwgdHJhdmVyc2FibGUpIHtcbiAgICByZXR1cm4gdHJhdmVyc2UodHlwZVJlcCwgaWRlbnRpdHksIHRyYXZlcnNhYmxlKTtcbiAgfVxuXG4gIC8vIyBleHRlbmQgOjogRXh0ZW5kIHcgPT4gKHcgYSAtPiBiLCB3IGEpIC0+IHcgYlxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2V4dGVuZGBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9leHRlbmRgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBBcnJheS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGV4dGVuZChzcyA9PiBzcy5qb2luKCcnKSwgWyd4JywgJ3knLCAneiddKVxuICAvLy4gWyd4eXonLCAneXonLCAneiddXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZXh0ZW5kKGYsIGV4dGVuZF8pIHtcbiAgICByZXR1cm4gRXh0ZW5kLm1ldGhvZHMuZXh0ZW5kKGV4dGVuZF8pKGYpO1xuICB9XG5cbiAgLy8jIGV4dHJhY3QgOjogQ29tb25hZCB3ID0+IHcgYSAtPiBhXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvZXh0cmFjdGBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBleHRyYWN0KElkZW50aXR5KDQyKSlcbiAgLy8uIDQyXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZXh0cmFjdChjb21vbmFkKSB7XG4gICAgcmV0dXJuIENvbW9uYWQubWV0aG9kcy5leHRyYWN0KGNvbW9uYWQpKCk7XG4gIH1cblxuICAvLyMgY29udHJhbWFwIDo6IENvbnRyYXZhcmlhbnQgZiA9PiAoYiAtPiBhLCBmIGEpIC0+IGYgYlxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2NvbnRyYW1hcGBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9jb250cmFtYXBgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBGdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGNvbnRyYW1hcChzID0+IHMubGVuZ3RoLCBNYXRoLnNxcnQpKCdTYW5jdHVhcnknKVxuICAvLy4gM1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGNvbnRyYW1hcChmLCBjb250cmF2YXJpYW50KSB7XG4gICAgcmV0dXJuIENvbnRyYXZhcmlhbnQubWV0aG9kcy5jb250cmFtYXAoY29udHJhdmFyaWFudCkoZik7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIFR5cGVDbGFzczogVHlwZUNsYXNzLFxuICAgIFNldG9pZDogU2V0b2lkLFxuICAgIE9yZDogT3JkLFxuICAgIFNlbWlncm91cG9pZDogU2VtaWdyb3Vwb2lkLFxuICAgIENhdGVnb3J5OiBDYXRlZ29yeSxcbiAgICBTZW1pZ3JvdXA6IFNlbWlncm91cCxcbiAgICBNb25vaWQ6IE1vbm9pZCxcbiAgICBHcm91cDogR3JvdXAsXG4gICAgRnVuY3RvcjogRnVuY3RvcixcbiAgICBCaWZ1bmN0b3I6IEJpZnVuY3RvcixcbiAgICBQcm9mdW5jdG9yOiBQcm9mdW5jdG9yLFxuICAgIEFwcGx5OiBBcHBseSxcbiAgICBBcHBsaWNhdGl2ZTogQXBwbGljYXRpdmUsXG4gICAgQ2hhaW46IENoYWluLFxuICAgIENoYWluUmVjOiBDaGFpblJlYyxcbiAgICBNb25hZDogTW9uYWQsXG4gICAgQWx0OiBBbHQsXG4gICAgUGx1czogUGx1cyxcbiAgICBBbHRlcm5hdGl2ZTogQWx0ZXJuYXRpdmUsXG4gICAgRm9sZGFibGU6IEZvbGRhYmxlLFxuICAgIFRyYXZlcnNhYmxlOiBUcmF2ZXJzYWJsZSxcbiAgICBFeHRlbmQ6IEV4dGVuZCxcbiAgICBDb21vbmFkOiBDb21vbmFkLFxuICAgIENvbnRyYXZhcmlhbnQ6IENvbnRyYXZhcmlhbnQsXG4gICAgdG9TdHJpbmc6IHRvU3RyaW5nLFxuICAgIGVxdWFsczogZXF1YWxzLFxuICAgIGx0OiBsdCxcbiAgICBsdGU6IGx0ZSxcbiAgICBndDogZ3QsXG4gICAgZ3RlOiBndGUsXG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXgsXG4gICAgY29tcG9zZTogY29tcG9zZSxcbiAgICBpZDogaWQsXG4gICAgY29uY2F0OiBjb25jYXQsXG4gICAgZW1wdHk6IGVtcHR5LFxuICAgIGludmVydDogaW52ZXJ0LFxuICAgIG1hcDogbWFwLFxuICAgIGJpbWFwOiBiaW1hcCxcbiAgICBwcm9tYXA6IHByb21hcCxcbiAgICBhcDogYXAsXG4gICAgbGlmdDI6IGxpZnQyLFxuICAgIGxpZnQzOiBsaWZ0MyxcbiAgICBhcEZpcnN0OiBhcEZpcnN0LFxuICAgIGFwU2Vjb25kOiBhcFNlY29uZCxcbiAgICBvZjogb2YsXG4gICAgYXBwZW5kOiBhcHBlbmQsXG4gICAgcHJlcGVuZDogcHJlcGVuZCxcbiAgICBjaGFpbjogY2hhaW4sXG4gICAgam9pbjogam9pbixcbiAgICBjaGFpblJlYzogY2hhaW5SZWMsXG4gICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgZmlsdGVyTTogZmlsdGVyTSxcbiAgICBhbHQ6IGFsdCxcbiAgICB6ZXJvOiB6ZXJvLFxuICAgIHJlZHVjZTogcmVkdWNlLFxuICAgIHNpemU6IHNpemUsXG4gICAgZWxlbTogZWxlbSxcbiAgICByZXZlcnNlOiByZXZlcnNlLFxuICAgIHNvcnQ6IHNvcnQsXG4gICAgc29ydEJ5OiBzb3J0QnksXG4gICAgdGFrZVdoaWxlOiB0YWtlV2hpbGUsXG4gICAgZHJvcFdoaWxlOiBkcm9wV2hpbGUsXG4gICAgdHJhdmVyc2U6IHRyYXZlcnNlLFxuICAgIHNlcXVlbmNlOiBzZXF1ZW5jZSxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBleHRyYWN0OiBleHRyYWN0LFxuICAgIGNvbnRyYW1hcDogY29udHJhbWFwXG4gIH07XG5cbn0pKTtcblxuLy8uIFtBbHRdOiAgICAgICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FsdFxuLy8uIFtBbHRlcm5hdGl2ZV06ICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FsdGVybmF0aXZlXG4vLy4gW0FwcGxpY2F0aXZlXTogICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYXBwbGljYXRpdmVcbi8vLiBbQXBwbHldOiAgICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhcHBseVxuLy8uIFtCaWZ1bmN0b3JdOiAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2JpZnVuY3RvclxuLy8uIFtDYXRlZ29yeV06ICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NhdGVnb3J5XG4vLy4gW0NoYWluXTogICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjY2hhaW5cbi8vLiBbQ2hhaW5SZWNdOiAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjaGFpbnJlY1xuLy8uIFtDb21vbmFkXTogICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NvbW9uYWRcbi8vLiBbQ29udHJhdmFyaWFudF06ICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjb250cmF2YXJpYW50XG4vLy4gW0V4dGVuZF06ICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZXh0ZW5kXG4vLy4gW0ZMXTogICAgICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmRcbi8vLiBbRm9sZGFibGVdOiAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNmb2xkYWJsZVxuLy8uIFtGdW5jdG9yXTogICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2Z1bmN0b3Jcbi8vLiBbR3JvdXBdOiAgICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNncm91cFxuLy8uIFtNb25hZF06ICAgICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI21vbmFkXG4vLy4gW01vbm9pZF06ICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjbW9ub2lkXG4vLy4gW09yZF06ICAgICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjb3JkXG4vLy4gW1BsdXNdOiAgICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjcGx1c1xuLy8uIFtQcm9mdW5jdG9yXTogICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3Byb2Z1bmN0b3Jcbi8vLiBbU2VtaWdyb3VwXTogICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNzZW1pZ3JvdXBcbi8vLiBbU2VtaWdyb3Vwb2lkXTogICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNzZW1pZ3JvdXBvaWRcbi8vLiBbU2V0b2lkXTogICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNzZXRvaWRcbi8vLiBbVHJhdmVyc2FibGVdOiAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCN0cmF2ZXJzYWJsZVxuLy8uIFtgZmFudGFzeS1sYW5kL2FsdGBdOiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FsdC1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9hcGBdOiAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhcC1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9iaW1hcGBdOiAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNiaW1hcC1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9jaGFpbmBdOiAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjaGFpbi1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9jaGFpblJlY2BdOiAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjaGFpbnJlYy1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9jb21wb3NlYF06ICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjb21wb3NlLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2NvbmNhdGBdOiAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NvbmNhdC1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9jb250cmFtYXBgXTogaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjb250cmFtYXAtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvZW1wdHlgXTogICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZW1wdHktbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvZXF1YWxzYF06ICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZXF1YWxzLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2V4dGVuZGBdOiAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2V4dGVuZC1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9leHRyYWN0YF06ICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNleHRyYWN0LW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2lkYF06ICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2lkLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2ludmVydGBdOiAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2ludmVydC1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9sdGVgXTogICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNsdGUtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvbWFwYF06ICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjbWFwLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL29mYF06ICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI29mLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL3Byb21hcGBdOiAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3Byb21hcC1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9yZWR1Y2VgXTogICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNyZWR1Y2UtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvdHJhdmVyc2VgXTogIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjdHJhdmVyc2UtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvemVyb2BdOiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjemVyby1tZXRob2Rcbi8vLiBbc3RhYmxlIHNvcnRdOiAgICAgICAgICAgICAgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU29ydGluZ19hbGdvcml0aG0jU3RhYmlsaXR5XG4vLy4gW3R5cGUtY2xhc3Nlc106ICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW5jdHVhcnktanMvc2FuY3R1YXJ5LWRlZiN0eXBlLWNsYXNzZXNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NhbmN0dWFyeS9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5LXR5cGUtY2xhc3Nlcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n        @@@@@@@            @@@@@@@         @@\n      @@       @@        @@       @@      @@@\n    @@   @@@ @@  @@    @@   @@@ @@  @@   @@@@@@ @@   @@@  @@ @@@      @@@@\n   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@   @@\n   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@@@@@@\n   @@  @@   @@@  @@   @@  @@   @@@  @@    @@@   @@   @@@  @@@   @@  @@@\n    @@   @@@ @@@@@     @@   @@@ @@@@@      @@@    @@@ @@  @@@@@@      @@@@@\n      @@                 @@                           @@  @@\n        @@@@@@@            @@@@@@@               @@@@@    @@\n                                                          */\n//. # sanctuary-type-identifiers\n//.\n//. A type is a set of values. Boolean, for example, is the type comprising\n//. `true` and `false`. A value may be a member of multiple types (`42` is a\n//. member of Number, PositiveNumber, Integer, and many other types).\n//.\n//. In certain situations it is useful to divide JavaScript values into\n//. non-overlapping types. The language provides two constructs for this\n//. purpose: the [`typeof`][1] operator and [`Object.prototype.toString`][2].\n//. Each has pros and cons, but neither supports user-defined types.\n//.\n//. This package specifies an [algorithm][3] for deriving a _type identifier_\n//. from any JavaScript value, and exports an implementation of the algorithm.\n//. Authors of algebraic data types may follow this specification in order to\n//. make their data types compatible with the algorithm.\n//.\n//. ### Algorithm\n//.\n//. 1.  Take any JavaScript value `x`.\n//.\n//. 2.  If `x` is `null` or `undefined`, go to step 6.\n//.\n//. 3.  If `x.constructor` evaluates to `null` or `undefined`, go to step 6.\n//.\n//. 4.  If `x.constructor.prototype === x`, go to step 6. This check prevents a\n//.     prototype object from being considered a member of its associated type.\n//.\n//. 5.  If `typeof x.constructor['@@type']` evaluates to `'string'`, return\n//.     the value of `x.constructor['@@type']`.\n//.\n//. 6.  Return the [`Object.prototype.toString`][2] representation of `x`\n//.     without the leading `'[object '` and trailing `']'`.\n//.\n//. ### Compatibility\n//.\n//. For an algebraic data type to be compatible with the [algorithm][3]:\n//.\n//.   - every member of the type must have a `constructor` property pointing\n//.     to an object known as the _type representative_;\n//.\n//.   - the type representative must have a `@@type` property; and\n//.\n//.   - the type representative's `@@type` property (the _type identifier_)\n//.     must be a string primitive, ideally `'<npm-package-name>/<type-name>'`.\n//.\n//. For example:\n//.\n//. ```javascript\n//. //  Identity :: a -> Identity a\n//. function Identity(x) {\n//.   if (!(this instanceof Identity)) return new Identity(x);\n//.   this.value = x;\n//. }\n//.\n//. Identity['@@type'] = 'my-package/Identity';\n//. ```\n//.\n//. Note that by using a constructor function the `constructor` property is set\n//. implicitly for each value created. Constructor functions are convenient for\n//. this reason, but are not required. This definition is also valid:\n//.\n//. ```javascript\n//. //  IdentityTypeRep :: TypeRep Identity\n//. var IdentityTypeRep = {\n//.   '@@type': 'my-package/Identity'\n//. };\n//.\n//. //  Identity :: a -> Identity a\n//. function Identity(x) {\n//.   return {constructor: IdentityTypeRep, value: x};\n//. }\n//. ```\n//.\n//. ### Usage\n//.\n//. ```javascript\n//. var Identity = require('my-package').Identity;\n//. var type = require('sanctuary-type-identifiers');\n//.\n//. type(null);         // => 'Null'\n//. type(true);         // => 'Boolean'\n//. type([1, 2, 3]);    // => 'Array'\n//. type(Identity);     // => 'Function'\n//. type(Identity(0));  // => 'my-package/Identity'\n//. ```\n//.\n//.\n//. [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof\n//. [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n//. [3]: #algorithm\n\n(function(f) {\n\n  'use strict';\n\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f();\n  } else if (\"function\" === 'function' && __webpack_require__(0) != null) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {\n    self.sanctuaryTypeIdentifiers = f();\n  }\n\n}(function() {\n\n  'use strict';\n\n  //  $$type :: String\n  var $$type = '@@type';\n\n  //  type :: Any -> String\n  function type(x) {\n    return x != null &&\n           x.constructor != null &&\n           x.constructor.prototype !== x &&\n           typeof x.constructor[$$type] === 'string' ?\n      x.constructor[$$type] :\n      Object.prototype.toString.call(x).slice('[object '.length, -']'.length);\n  }\n\n  return type;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5L25vZGVfbW9kdWxlcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzL25vZGVfbW9kdWxlcy9zYW5jdHVhcnktdHlwZS1pZGVudGlmaWVycy9pbmRleC5qcz8zMTM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gICAgICAgIEBAQEBAQEAgICAgICAgICAgICBAQEBAQEBAICAgICAgICAgQEBcbiAgICAgIEBAICAgICAgIEBAICAgICAgICBAQCAgICAgICBAQCAgICAgIEBAQFxuICAgIEBAICAgQEBAIEBAICBAQCAgICBAQCAgIEBAQCBAQCAgQEAgICBAQEBAQEAgQEAgICBAQEAgIEBAIEBAQCAgICAgIEBAQEBcbiAgIEBAICBAQCAgIEBAQCAgIEBAICBAQCAgQEAgICBAQEAgICBAQCAgIEBAQCAgIEBAICAgQEBAICBAQEAgICBAQCAgQEBAICAgQEBcbiAgIEBAICBAQCAgIEBAQCAgIEBAICBAQCAgQEAgICBAQEAgICBAQCAgIEBAQCAgIEBAICAgQEBAICBAQEAgICBAQCAgQEBAQEBAQEBcbiAgIEBAICBAQCAgIEBAQCAgQEAgICBAQCAgQEAgICBAQEAgIEBAICAgIEBAQCAgIEBAICAgQEBAICBAQEAgICBAQCAgQEBAXG4gICAgQEAgICBAQEAgQEBAQEAgICAgIEBAICAgQEBAIEBAQEBAICAgICAgQEBAICAgIEBAQCBAQCAgQEBAQEBAICAgICAgQEBAQEBcbiAgICAgIEBAICAgICAgICAgICAgICAgICBAQCAgICAgICAgICAgICAgICAgICAgICAgICAgIEBAICBAQFxuICAgICAgICBAQEBAQEBAICAgICAgICAgICAgQEBAQEBAQCAgICAgICAgICAgICAgIEBAQEBAICAgIEBAXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8vLiAjIHNhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzXG4vLy5cbi8vLiBBIHR5cGUgaXMgYSBzZXQgb2YgdmFsdWVzLiBCb29sZWFuLCBmb3IgZXhhbXBsZSwgaXMgdGhlIHR5cGUgY29tcHJpc2luZ1xuLy8uIGB0cnVlYCBhbmQgYGZhbHNlYC4gQSB2YWx1ZSBtYXkgYmUgYSBtZW1iZXIgb2YgbXVsdGlwbGUgdHlwZXMgKGA0MmAgaXMgYVxuLy8uIG1lbWJlciBvZiBOdW1iZXIsIFBvc2l0aXZlTnVtYmVyLCBJbnRlZ2VyLCBhbmQgbWFueSBvdGhlciB0eXBlcykuXG4vLy5cbi8vLiBJbiBjZXJ0YWluIHNpdHVhdGlvbnMgaXQgaXMgdXNlZnVsIHRvIGRpdmlkZSBKYXZhU2NyaXB0IHZhbHVlcyBpbnRvXG4vLy4gbm9uLW92ZXJsYXBwaW5nIHR5cGVzLiBUaGUgbGFuZ3VhZ2UgcHJvdmlkZXMgdHdvIGNvbnN0cnVjdHMgZm9yIHRoaXNcbi8vLiBwdXJwb3NlOiB0aGUgW2B0eXBlb2ZgXVsxXSBvcGVyYXRvciBhbmQgW2BPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYF1bMl0uXG4vLy4gRWFjaCBoYXMgcHJvcyBhbmQgY29ucywgYnV0IG5laXRoZXIgc3VwcG9ydHMgdXNlci1kZWZpbmVkIHR5cGVzLlxuLy8uXG4vLy4gVGhpcyBwYWNrYWdlIHNwZWNpZmllcyBhbiBbYWxnb3JpdGhtXVszXSBmb3IgZGVyaXZpbmcgYSBfdHlwZSBpZGVudGlmaWVyX1xuLy8uIGZyb20gYW55IEphdmFTY3JpcHQgdmFsdWUsIGFuZCBleHBvcnRzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBhbGdvcml0aG0uXG4vLy4gQXV0aG9ycyBvZiBhbGdlYnJhaWMgZGF0YSB0eXBlcyBtYXkgZm9sbG93IHRoaXMgc3BlY2lmaWNhdGlvbiBpbiBvcmRlciB0b1xuLy8uIG1ha2UgdGhlaXIgZGF0YSB0eXBlcyBjb21wYXRpYmxlIHdpdGggdGhlIGFsZ29yaXRobS5cbi8vLlxuLy8uICMjIyBBbGdvcml0aG1cbi8vLlxuLy8uIDEuICBUYWtlIGFueSBKYXZhU2NyaXB0IHZhbHVlIGB4YC5cbi8vLlxuLy8uIDIuICBJZiBgeGAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLCBnbyB0byBzdGVwIDYuXG4vLy5cbi8vLiAzLiAgSWYgYHguY29uc3RydWN0b3JgIGV2YWx1YXRlcyB0byBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsIGdvIHRvIHN0ZXAgNi5cbi8vLlxuLy8uIDQuICBJZiBgeC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHhgLCBnbyB0byBzdGVwIDYuIFRoaXMgY2hlY2sgcHJldmVudHMgYVxuLy8uICAgICBwcm90b3R5cGUgb2JqZWN0IGZyb20gYmVpbmcgY29uc2lkZXJlZCBhIG1lbWJlciBvZiBpdHMgYXNzb2NpYXRlZCB0eXBlLlxuLy8uXG4vLy4gNS4gIElmIGB0eXBlb2YgeC5jb25zdHJ1Y3RvclsnQEB0eXBlJ11gIGV2YWx1YXRlcyB0byBgJ3N0cmluZydgLCByZXR1cm5cbi8vLiAgICAgdGhlIHZhbHVlIG9mIGB4LmNvbnN0cnVjdG9yWydAQHR5cGUnXWAuXG4vLy5cbi8vLiA2LiAgUmV0dXJuIHRoZSBbYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXVsyXSByZXByZXNlbnRhdGlvbiBvZiBgeGBcbi8vLiAgICAgd2l0aG91dCB0aGUgbGVhZGluZyBgJ1tvYmplY3QgJ2AgYW5kIHRyYWlsaW5nIGAnXSdgLlxuLy8uXG4vLy4gIyMjIENvbXBhdGliaWxpdHlcbi8vLlxuLy8uIEZvciBhbiBhbGdlYnJhaWMgZGF0YSB0eXBlIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgW2FsZ29yaXRobV1bM106XG4vLy5cbi8vLiAgIC0gZXZlcnkgbWVtYmVyIG9mIHRoZSB0eXBlIG11c3QgaGF2ZSBhIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgcG9pbnRpbmdcbi8vLiAgICAgdG8gYW4gb2JqZWN0IGtub3duIGFzIHRoZSBfdHlwZSByZXByZXNlbnRhdGl2ZV87XG4vLy5cbi8vLiAgIC0gdGhlIHR5cGUgcmVwcmVzZW50YXRpdmUgbXVzdCBoYXZlIGEgYEBAdHlwZWAgcHJvcGVydHk7IGFuZFxuLy8uXG4vLy4gICAtIHRoZSB0eXBlIHJlcHJlc2VudGF0aXZlJ3MgYEBAdHlwZWAgcHJvcGVydHkgKHRoZSBfdHlwZSBpZGVudGlmaWVyXylcbi8vLiAgICAgbXVzdCBiZSBhIHN0cmluZyBwcmltaXRpdmUsIGlkZWFsbHkgYCc8bnBtLXBhY2thZ2UtbmFtZT4vPHR5cGUtbmFtZT4nYC5cbi8vLlxuLy8uIEZvciBleGFtcGxlOlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIC8vICBJZGVudGl0eSA6OiBhIC0+IElkZW50aXR5IGFcbi8vLiBmdW5jdGlvbiBJZGVudGl0eSh4KSB7XG4vLy4gICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSWRlbnRpdHkpKSByZXR1cm4gbmV3IElkZW50aXR5KHgpO1xuLy8uICAgdGhpcy52YWx1ZSA9IHg7XG4vLy4gfVxuLy8uXG4vLy4gSWRlbnRpdHlbJ0BAdHlwZSddID0gJ215LXBhY2thZ2UvSWRlbnRpdHknO1xuLy8uIGBgYFxuLy8uXG4vLy4gTm90ZSB0aGF0IGJ5IHVzaW5nIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgaXMgc2V0XG4vLy4gaW1wbGljaXRseSBmb3IgZWFjaCB2YWx1ZSBjcmVhdGVkLiBDb25zdHJ1Y3RvciBmdW5jdGlvbnMgYXJlIGNvbnZlbmllbnQgZm9yXG4vLy4gdGhpcyByZWFzb24sIGJ1dCBhcmUgbm90IHJlcXVpcmVkLiBUaGlzIGRlZmluaXRpb24gaXMgYWxzbyB2YWxpZDpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiAvLyAgSWRlbnRpdHlUeXBlUmVwIDo6IFR5cGVSZXAgSWRlbnRpdHlcbi8vLiB2YXIgSWRlbnRpdHlUeXBlUmVwID0ge1xuLy8uICAgJ0BAdHlwZSc6ICdteS1wYWNrYWdlL0lkZW50aXR5J1xuLy8uIH07XG4vLy5cbi8vLiAvLyAgSWRlbnRpdHkgOjogYSAtPiBJZGVudGl0eSBhXG4vLy4gZnVuY3Rpb24gSWRlbnRpdHkoeCkge1xuLy8uICAgcmV0dXJuIHtjb25zdHJ1Y3RvcjogSWRlbnRpdHlUeXBlUmVwLCB2YWx1ZTogeH07XG4vLy4gfVxuLy8uIGBgYFxuLy8uXG4vLy4gIyMjIFVzYWdlXG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gdmFyIElkZW50aXR5ID0gcmVxdWlyZSgnbXktcGFja2FnZScpLklkZW50aXR5O1xuLy8uIHZhciB0eXBlID0gcmVxdWlyZSgnc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMnKTtcbi8vLlxuLy8uIHR5cGUobnVsbCk7ICAgICAgICAgLy8gPT4gJ051bGwnXG4vLy4gdHlwZSh0cnVlKTsgICAgICAgICAvLyA9PiAnQm9vbGVhbidcbi8vLiB0eXBlKFsxLCAyLCAzXSk7ICAgIC8vID0+ICdBcnJheSdcbi8vLiB0eXBlKElkZW50aXR5KTsgICAgIC8vID0+ICdGdW5jdGlvbidcbi8vLiB0eXBlKElkZW50aXR5KDApKTsgIC8vID0+ICdteS1wYWNrYWdlL0lkZW50aXR5J1xuLy8uIGBgYFxuLy8uXG4vLy5cbi8vLiBbMV06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy90eXBlb2Zcbi8vLiBbMl06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC90b1N0cmluZ1xuLy8uIFszXTogI2FsZ29yaXRobVxuXG4oZnVuY3Rpb24oZikge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZigpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCAhPSBudWxsKSB7XG4gICAgZGVmaW5lKFtdLCBmKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnNhbmN0dWFyeVR5cGVJZGVudGlmaWVycyA9IGYoKTtcbiAgfVxuXG59KGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyAgJCR0eXBlIDo6IFN0cmluZ1xuICB2YXIgJCR0eXBlID0gJ0BAdHlwZSc7XG5cbiAgLy8gIHR5cGUgOjogQW55IC0+IFN0cmluZ1xuICBmdW5jdGlvbiB0eXBlKHgpIHtcbiAgICByZXR1cm4geCAhPSBudWxsICYmXG4gICAgICAgICAgIHguY29uc3RydWN0b3IgIT0gbnVsbCAmJlxuICAgICAgICAgICB4LmNvbnN0cnVjdG9yLnByb3RvdHlwZSAhPT0geCAmJlxuICAgICAgICAgICB0eXBlb2YgeC5jb25zdHJ1Y3RvclskJHR5cGVdID09PSAnc3RyaW5nJyA/XG4gICAgICB4LmNvbnN0cnVjdG9yWyQkdHlwZV0gOlxuICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpLnNsaWNlKCdbb2JqZWN0ICcubGVuZ3RoLCAtJ10nLmxlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gdHlwZTtcblxufSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5L25vZGVfbW9kdWxlcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzL25vZGVfbW9kdWxlcy9zYW5jdHVhcnktdHlwZS1pZGVudGlmaWVycy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n");

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"adjustHue\", function() { return curriedAdjustHue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"animation\", function() { return animation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"backgroundImages\", function() { return backgroundImages; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"backgrounds\", function() { return backgrounds; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"borderColor\", function() { return borderColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"borderRadius\", function() { return borderRadius; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"borderStyle\", function() { return borderStyle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"borderWidth\", function() { return borderWidth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buttons\", function() { return buttons; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clearFix\", function() { return clearFix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"complement\", function() { return complement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"darken\", function() { return curriedDarken; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"desaturate\", function() { return curriedDesaturate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"directionalProperty\", function() { return directionalProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ellipsis\", function() { return ellipsis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"em\", function() { return em; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fontFace\", function() { return fontFace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLuminance\", function() { return getLuminance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"grayscale\", function() { return grayscale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hideText\", function() { return hideText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hideVisually\", function() { return hideVisually; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hiDPI\", function() { return hiDPI; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hsl\", function() { return hsl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hsla\", function() { return hsla; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lighten\", function() { return curriedLighten; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"margin\", function() { return margin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mix\", function() { return curriedMix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"modularScale\", function() { return modularScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"opacify\", function() { return curriedOpacify; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"padding\", function() { return padding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseToHsl\", function() { return parseToHsl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseToRgb\", function() { return parseToRgb; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"placeholder\", function() { return placeholder; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"position\", function() { return position; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"radialGradient\", function() { return radialGradient; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"readableColor\", function() { return curriedReadableColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rem\", function() { return rem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"retinaImage\", function() { return retinaImage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rgb\", function() { return rgb; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rgba\", function() { return rgba; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"saturate\", function() { return curriedSaturate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"selection\", function() { return selection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setHue\", function() { return curriedSetHue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setLightness\", function() { return curriedSetLightness; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setSaturation\", function() { return curriedSetSaturation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shade\", function() { return curriedShade; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"size\", function() { return size; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stripUnit\", function() { return stripUnit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"textInputs\", function() { return textInputs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"timingFunctions\", function() { return timingFunctions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tint\", function() { return curriedTint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toColorString\", function() { return toColorString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transitions\", function() { return transitions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transparentize\", function() { return curriedTransparentize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"triangle\", function() { return triangle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wordWrap\", function() { return wordWrap; });\n//      \n\n// @private\nfunction capitalizeString(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\n//      \nvar positionMap = ['Top', 'Right', 'Bottom', 'Left'];\n\nfunction generateProperty(property, position) {\n  if (!property) return position.toLowerCase();\n  var splitProperty = property.split('-');\n  if (splitProperty.length > 1) {\n    splitProperty.splice(1, 0, position);\n    return splitProperty.reduce(function (acc, val) {\n      return '' + acc + capitalizeString(val);\n    });\n  }\n  var joinedProperty = property.replace(/([a-z])([A-Z])/g, '$1' + position + '$2');\n  return property === joinedProperty ? '' + property + position : joinedProperty;\n}\n\nfunction generateStyles(property, valuesWithDefaults) {\n  var styles = {};\n  for (var i = 0; i < valuesWithDefaults.length; i += 1) {\n    if (valuesWithDefaults[i] || valuesWithDefaults[i] === 0) {\n      styles[generateProperty(property, positionMap[i])] = valuesWithDefaults[i];\n    }\n  }\n  return styles;\n}\n\n/**\n * A helper that enables shorthand for direction based properties. It accepts a property (hyphenated or camelCased) and up to four values that map to top, right, bottom, and left, respectively. You can optionally pass an empty string to get only the directional values as properties. You can also optionally pass a null argument for a directional value to ignore it.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...directionalProperty('padding', '12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${directionalProperty('padding', '12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'paddingTop': '12px',\n *   'paddingRight': '24px',\n *   'paddingBottom': '36px',\n *   'paddingLeft': '48px'\n * }\n */\n\nfunction directionalProperty(property) {\n  for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    values[_key - 1] = arguments[_key];\n  }\n\n  //  prettier-ignore\n  var firstValue = values[0],\n      _values$ = values[1],\n      secondValue = _values$ === undefined ? firstValue : _values$,\n      _values$2 = values[2],\n      thirdValue = _values$2 === undefined ? firstValue : _values$2,\n      _values$3 = values[3],\n      fourthValue = _values$3 === undefined ? secondValue : _values$3;\n\n  var valuesWithDefaults = [firstValue, secondValue, thirdValue, fourthValue];\n  return generateStyles(property, valuesWithDefaults);\n}\n\n//      \n\n/**\n * Check if a string ends with something\n * @private\n */\nvar endsWith = function (string, suffix) {\n  return string.substr(-suffix.length) === suffix;\n};\n\n//      \n\n/**\n * Strip the unit from a given CSS value, returning just the number. (or the original value if an invalid string was passed)\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   '--dimension': stripUnit('100px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   --dimension: ${stripUnit('100px')}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   '--dimension': 100\n * }\n */\n\nfunction stripUnit(value) {\n  var unitlessValue = parseFloat(value);\n  if (isNaN(unitlessValue)) return value;\n  return unitlessValue;\n}\n\n//      \n\n/**\n * Factory function that creates pixel-to-x converters\n * @private\n */\nvar pxtoFactory = function pxtoFactory(to) {\n  return function (pxval) {\n    var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '16px';\n\n    var newPxval = pxval;\n    var newBase = base;\n    if (typeof pxval === 'string') {\n      if (!endsWith(pxval, 'px')) {\n        throw new Error('Expected a string ending in \"px\" or a number passed as the first argument to ' + to + '(), got \"' + pxval + '\" instead.');\n      }\n      newPxval = stripUnit(pxval);\n    }\n\n    if (typeof base === 'string') {\n      if (!endsWith(base, 'px')) {\n        throw new Error('Expected a string ending in \"px\" or a number passed as the second argument to ' + to + '(), got \"' + base + '\" instead.');\n      }\n      newBase = stripUnit(base);\n    }\n\n    if (typeof newPxval === 'string') {\n      throw new Error('Passed invalid pixel value (\"' + pxval + '\") to ' + to + '(), please pass a value like \"12px\" or 12.');\n    }\n\n    if (typeof newBase === 'string') {\n      throw new Error('Passed invalid base value (\"' + base + '\") to ' + to + '(), please pass a value like \"12px\" or 12.');\n    }\n\n    return '' + newPxval / newBase + to;\n  };\n};\n\n//      \n/**\n * Convert pixel value to ems. The default base value is 16px, but can be changed by passing a\n * second argument to the function.\n * @function\n * @param {string|number} pxval\n * @param {string|number} [base='16px']\n * @example\n * // Styles as object usage\n * const styles = {\n *   'height': em('16px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   height: ${em('16px')}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'height': '1em'\n * }\n */\n\nvar em = /*#__PURE__*/pxtoFactory('em');\n\n//      \n\nvar ratioNames = {\n  minorSecond: 1.067,\n  majorSecond: 1.125,\n  minorThird: 1.2,\n  majorThird: 1.25,\n  perfectFourth: 1.333,\n  augFourth: 1.414,\n  perfectFifth: 1.5,\n  minorSixth: 1.6,\n  goldenSection: 1.618,\n  majorSixth: 1.667,\n  minorSeventh: 1.778,\n  majorSeventh: 1.875,\n  octave: 2,\n  majorTenth: 2.5,\n  majorEleventh: 2.667,\n  majorTwelfth: 3,\n  doubleOctave: 4\n};\n\n/** */\n\n/**\n * Establish consistent measurements and spacial relationships throughout your projects by incrementing up or down a defined scale. We provide a list of commonly used scales as pre-defined variables, see below.\n * @example\n * // Styles as object usage\n * const styles = {\n *    // Increment two steps up the default scale\n *   'fontSize': modularScale(2)\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *    // Increment two steps up the default scale\n *   fontSize: ${modularScale(2)}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'fontSize': '1.77689em'\n * }\n */\nfunction modularScale(steps) {\n  var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '1em';\n  var ratio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'perfectFourth';\n\n  if (typeof steps !== 'number') {\n    throw new Error('Please provide a number of steps to the modularScale helper.');\n  }\n  if (typeof ratio === 'string' && !ratioNames[ratio]) {\n    throw new Error('Please pass a number or one of the predefined scales to the modularScale helper as the ratio.');\n  }\n\n  var realBase = typeof base === 'string' ? stripUnit(base) : base;\n  var realRatio = typeof ratio === 'string' ? ratioNames[ratio] : ratio;\n\n  if (typeof realBase === 'string') {\n    throw new Error('Invalid value passed as base to modularScale, expected number or em string but got \"' + base + '\"');\n  }\n\n  return realBase * Math.pow(realRatio, steps) + 'em';\n}\n\n//      \n\n/**\n * Convert pixel value to rems. The default base value is 16px, but can be changed by passing a\n * second argument to the function.\n * @function\n * @param {string|number} pxval\n * @param {string|number} [base='16px']\n * @example\n * // Styles as object usage\n * const styles = {\n *   'height': rem('16px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   height: ${rem('16px')}\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   'height': '1rem'\n * }\n */\n\nvar rem = /*#__PURE__*/pxtoFactory('rem');\n\n//      \n\n/**\n * CSS to contain a float (credit to CSSMojo).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *    ...clearFix(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${clearFix()}\n * `\n *\n * // CSS as JS Output\n *\n * '&::after': {\n *   'clear': 'both',\n *   'content': '\"\"',\n *   'display': 'table'\n * }\n */\n\nfunction clearFix() {\n  var _ref;\n\n  var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '&';\n\n  var pseudoSelector = parent + '::after';\n  return _ref = {}, _ref[pseudoSelector] = {\n    clear: 'both',\n    content: '\"\"',\n    display: 'table'\n  }, _ref;\n}\n\n//      \n\n/**\n * CSS to represent truncated text with an ellipsis.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...ellipsis('250px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${ellipsis('250px')}\n * `\n *\n * // CSS as JS Output\n *\n * div: {\n *   'display': 'inline-block',\n *   'maxWidth': '250px',\n *   'overflow': 'hidden',\n *   'textOverflow': 'ellipsis',\n *   'whiteSpace': 'nowrap',\n *   'wordWrap': 'normal'\n * }\n */\n\nfunction ellipsis() {\n  var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '100%';\n\n  return {\n    display: 'inline-block',\n    maxWidth: width,\n    overflow: 'hidden',\n    textOverflow: 'ellipsis',\n    whiteSpace: 'nowrap',\n    wordWrap: 'normal'\n  };\n}\n\n//      \n\n/** */\n\nfunction generateFileReferences(fontFilePath, fileFormats) {\n  var fileFontReferences = fileFormats.map(function (format) {\n    return 'url(\"' + fontFilePath + '.' + format + '\")';\n  });\n  return fileFontReferences.join(', ');\n}\n\nfunction generateLocalReferences(localFonts) {\n  var localFontReferences = localFonts.map(function (font) {\n    return 'local(\"' + font + '\")';\n  });\n  return localFontReferences.join(', ');\n}\n\nfunction generateSources(fontFilePath, localFonts, fileFormats) {\n  var fontReferences = [];\n  if (localFonts) fontReferences.push(generateLocalReferences(localFonts));\n  if (fontFilePath) {\n    fontReferences.push(generateFileReferences(fontFilePath, fileFormats));\n  }\n  return fontReferences.join(', ');\n}\n\n/**\n * CSS for a @font-face declaration.\n *\n * @example\n * // Styles as object basic usage\n * const styles = {\n *    ...fontFace({\n *      'fontFamily': 'Sans-Pro'\n *      'fontFilePath': 'path/to/file'\n *    })\n * }\n *\n * // styled-components basic usage\n * injectGlobal`${\n *   fontFace({\n *     'fontFamily': 'Sans-Pro'\n *     'fontFilePath': 'path/to/file'\n *   }\n * )}`\n *\n * // CSS as JS Output\n *\n * '@font-face': {\n *   'fontFamily': 'Sans-Pro',\n *   'src': 'url(\"path/to/file.eot\"), url(\"path/to/file.woff2\"), url(\"path/to/file.woff\"), url(\"path/to/file.ttf\"), url(\"path/to/file.svg\")',\n * }\n */\n\nfunction fontFace(_ref) {\n  var fontFamily = _ref.fontFamily,\n      fontFilePath = _ref.fontFilePath,\n      fontStretch = _ref.fontStretch,\n      fontStyle = _ref.fontStyle,\n      fontVariant = _ref.fontVariant,\n      fontWeight = _ref.fontWeight,\n      _ref$fileFormats = _ref.fileFormats,\n      fileFormats = _ref$fileFormats === undefined ? ['eot', 'woff2', 'woff', 'ttf', 'svg'] : _ref$fileFormats,\n      localFonts = _ref.localFonts,\n      unicodeRange = _ref.unicodeRange;\n\n  // Error Handling\n  if (!fontFamily) throw new Error('fontFace expects a name of a font-family.');\n  if (!fontFilePath && !localFonts) {\n    throw new Error('fontFace expects either the path to the font file(s) or a name of a local copy.');\n  }\n  if (localFonts && !Array.isArray(localFonts)) {\n    throw new Error('fontFace expects localFonts to be an array.');\n  }\n  if (!Array.isArray(fileFormats)) {\n    throw new Error('fontFace expects fileFormats to be an array.');\n  }\n\n  var fontFaceDeclaration = {\n    '@font-face': {\n      fontFamily: fontFamily,\n      src: generateSources(fontFilePath, localFonts, fileFormats),\n      unicodeRange: unicodeRange,\n      fontStretch: fontStretch,\n      fontStyle: fontStyle,\n      fontVariant: fontVariant,\n      fontWeight: fontWeight\n    }\n  };\n\n  // Removes undefined fields for cleaner css object.\n  return JSON.parse(JSON.stringify(fontFaceDeclaration));\n}\n\n//      \n\n/**\n * CSS to hide text to show a background image in a SEO-friendly way.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'backgroundImage': 'url(logo.png)',\n *   ...hideText(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   backgroundImage: url(logo.png);\n *   ${hideText()};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'backgroundImage': 'url(logo.png)',\n *   'textIndent': '101%',\n *   'overflow': 'hidden',\n *   'whiteSpace': 'nowrap',\n * }\n */\n\nfunction hideText() {\n  return {\n    textIndent: '101%',\n    overflow: 'hidden',\n    whiteSpace: 'nowrap'\n  };\n}\n\n//      \n\n/**\n * CSS to hide content visually but remain accessible to screen readers.\n * from [HTML5 Boilerplate](https://github.com/h5bp/html5-boilerplate/blob/9a176f57af1cfe8ec70300da4621fb9b07e5fa31/src/css/main.css#L121)\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...hideVisually(),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${hideVisually()};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'border': '0',\n *   'clip': 'rect(0 0 0 0)',\n *   'clipPath': 'inset(50%)',\n *   'height': '1px',\n *   'margin': '-1px',\n *   'overflow': 'hidden',\n *   'padding': '0',\n *   'position': 'absolute',\n *   'whiteSpace': 'nowrap',\n *   'width': '1px',\n * }\n */\n\nfunction hideVisually() {\n  return {\n    border: '0',\n    clip: 'rect(0 0 0 0)',\n    clipPath: 'inset(50%)',\n    height: '1px',\n    margin: '-1px',\n    overflow: 'hidden',\n    padding: '0',\n    position: 'absolute',\n    whiteSpace: 'nowrap',\n    width: '1px'\n  };\n}\n\n//      \n\n/**\n * Generates a media query to target HiDPI devices.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *  [hiDPI(1.5)]: {\n *    width: 200px;\n *  }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${hiDPI(1.5)} {\n *     width: 200px;\n *   }\n * `\n *\n * // CSS as JS Output\n *\n * '@media only screen and (-webkit-min-device-pixel-ratio: 1.5),\n *  only screen and (min--moz-device-pixel-ratio: 1.5),\n *  only screen and (-o-min-device-pixel-ratio: 1.5/1),\n *  only screen and (min-resolution: 144dpi),\n *  only screen and (min-resolution: 1.5dppx)': {\n *   'width': '200px',\n * }\n */\n\nfunction hiDPI() {\n  var ratio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.3;\n\n  return \"\\n    @media only screen and (-webkit-min-device-pixel-ratio: \" + ratio + \"),\\n    only screen and (min--moz-device-pixel-ratio: \" + ratio + \"),\\n    only screen and (-o-min-device-pixel-ratio: \" + ratio + \"/1),\\n    only screen and (min-resolution: \" + Math.round(ratio * 96) + \"dpi),\\n    only screen and (min-resolution: \" + ratio + \"dppx)\\n  \";\n}\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar taggedTemplateLiteralLoose = function (strings, raw) {\n  strings.raw = raw;\n  return strings;\n};\n\nvar _opinionatedRules;\nvar _abbrTitle;\nvar _unopinionatedRules;\n\n//      \nvar opinionatedRules = (_opinionatedRules = {\n  html: {\n    fontFamily: 'sans-serif'\n  },\n\n  body: {\n    margin: '0'\n  }\n\n}, _opinionatedRules['a:active,\\n  a:hover'] = {\n  outlineWidth: '0'\n}, _opinionatedRules['button,\\n  input,\\n  optgroup,\\n  select,\\n  textarea'] = {\n  fontFamily: 'sans-serif',\n  fontSize: '100%',\n  lineHeight: '1.15'\n}, _opinionatedRules);\n\nvar unopinionatedRules = (_unopinionatedRules = {\n  html: {\n    lineHeight: '1.15',\n    textSizeAdjust: '100%'\n  }\n\n}, _unopinionatedRules['article,\\n  aside,\\n  footer,\\n  header,\\n  nav,\\n  section'] = {\n  display: 'block'\n}, _unopinionatedRules.h1 = {\n  fontSize: '2em',\n  margin: '0.67em 0'\n}, _unopinionatedRules['figcaption,\\n  figure,\\n  main'] = {\n  display: 'block'\n}, _unopinionatedRules.figure = {\n  margin: '1em 40px'\n}, _unopinionatedRules.hr = {\n  boxSizing: 'content-box',\n  height: '0',\n  overflow: 'visible'\n}, _unopinionatedRules.pre = {\n  fontFamily: 'monospace, monospace',\n  fontSize: '1em'\n}, _unopinionatedRules.a = {\n  'background-color': 'transparent',\n  '-webkit-text-decoration-skip': 'objects'\n}, _unopinionatedRules['abbr[title]'] = (_abbrTitle = {\n  borderBottom: 'none',\n  textDecoration: 'underline'\n}, _abbrTitle['textDecoration'] = 'underline dotted', _abbrTitle), _unopinionatedRules['b,\\n  strong'] = {\n  fontWeight: 'inherit'\n}, _unopinionatedRules['code,\\n  kbd,\\n  samp'] = {\n  fontFamily: 'monospace, monospace',\n  fontSize: '1em'\n}, _unopinionatedRules.dfn = {\n  fontStyle: 'italic'\n}, _unopinionatedRules.mark = {\n  backgroundColor: '#ff0',\n  color: '#000'\n}, _unopinionatedRules.small = {\n  fontSize: '80%'\n}, _unopinionatedRules['sub,\\n  sup'] = {\n  fontSize: '75%',\n  lineHeight: '0',\n  position: 'relative',\n  verticalAlign: 'baseline'\n}, _unopinionatedRules.sub = {\n  bottom: '-0.25em'\n}, _unopinionatedRules.sup = {\n  top: '-0.5em'\n}, _unopinionatedRules['audio,\\n  video'] = {\n  display: 'inline-block'\n}, _unopinionatedRules['audio:not([controls])'] = {\n  display: 'none',\n  height: '0'\n}, _unopinionatedRules.img = {\n  borderStyle: 'none'\n}, _unopinionatedRules['svg:not(:root)'] = {\n  overflow: 'hidden'\n}, _unopinionatedRules['button,\\n  input,\\n  optgroup,\\n  select,\\n  textarea'] = {\n  margin: '0'\n}, _unopinionatedRules['button,\\n  input'] = {\n  overflow: 'visible'\n}, _unopinionatedRules['button,\\n  select'] = {\n  textTransform: 'none'\n}, _unopinionatedRules['button,\\n  html [type=\"button\"],\\n  [type=\"reset\"],\\n  [type=\"submit\"]'] = {\n  '-webkit-appearance': 'button'\n}, _unopinionatedRules['button::-moz-focus-inner,\\n  [type=\"button\"]::-moz-focus-inner,\\n  [type=\"reset\"]::-moz-focus-inner,\\n  [type=\"submit\"]::-moz-focus-inner'] = {\n  borderStyle: 'none',\n  padding: '0'\n}, _unopinionatedRules['button:-moz-focusring,\\n  [type=\"button\"]:-moz-focusring,\\n  [type=\"reset\"]:-moz-focusring,\\n  [type=\"submit\"]:-moz-focusring'] = {\n  outline: '1px dotted ButtonText'\n}, _unopinionatedRules.fieldset = {\n  border: '1px solid #c0c0c0',\n  margin: '0 2px',\n  padding: '0.35em 0.625em 0.75em'\n}, _unopinionatedRules.legend = {\n  boxSizing: 'border-box',\n  color: 'inherit',\n  display: 'table',\n  maxWidth: '100%',\n  padding: '0',\n  whiteSpace: 'normal'\n}, _unopinionatedRules.progress = {\n  display: 'inline-block',\n  verticalAlign: 'baseline'\n}, _unopinionatedRules.textarea = {\n  overflow: 'auto'\n}, _unopinionatedRules['[type=\"checkbox\"],\\n  [type=\"radio\"]'] = {\n  boxSizing: 'border-box',\n  padding: '0'\n}, _unopinionatedRules['[type=\"number\"]::-webkit-inner-spin-button,\\n  [type=\"number\"]::-webkit-outer-spin-button'] = {\n  height: 'auto'\n}, _unopinionatedRules['[type=\"search\"]'] = {\n  '-webkit-appearance': 'textfield',\n  outlineOffset: '-2px'\n}, _unopinionatedRules['[type=\"search\"]::-webkit-search-cancel-button,\\n  [type=\"search\"]::-webkit-search-decoration'] = {\n  '-webkit-appearance': 'none'\n}, _unopinionatedRules['::-webkit-file-upload-button'] = {\n  '-webkit-appearance': 'button',\n  font: 'inherit'\n}, _unopinionatedRules['details,\\n  menu'] = {\n  display: 'block'\n}, _unopinionatedRules.summary = {\n  display: 'list-item'\n}, _unopinionatedRules.canvas = {\n  display: 'inline-block'\n}, _unopinionatedRules.template = {\n  display: 'none'\n}, _unopinionatedRules['[hidden]'] = {\n  display: 'none'\n}, _unopinionatedRules);\n\nfunction mergeRules(baseRules, additionalRules) {\n  var mergedRules = _extends({}, baseRules);\n  Object.keys(additionalRules).forEach(function (key) {\n    if (mergedRules[key]) {\n      mergedRules[key] = _extends({}, mergedRules[key], additionalRules[key]);\n    } else {\n      mergedRules[key] = _extends({}, additionalRules[key]);\n    }\n  });\n  return mergedRules;\n}\n\n/**\n * CSS to normalize abnormalities across browsers (normalize.css v5.0.0 | MIT License | github.com/necolas/normalize.css)\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *    ...normalize(),\n * }\n *\n * // styled-components usage\n * injectGlobal`${normalize()}`\n *\n * // CSS as JS Output\n *\n * html {\n *   fontFamily: 'sans-serif',\n *   lineHeight: 1.15,\n *   textSizeAdjust: 100%,\n * } ...\n */\nfunction normalize(excludeOpinionated) {\n  if (excludeOpinionated) return unopinionatedRules;\n  return mergeRules(unopinionatedRules, opinionatedRules);\n}\n\n//      \n\n/**\n * CSS to style the placeholder pseudo-element.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...placeholder({'color': 'blue'})\n * }\n *\n * // styled-components usage\n * const div = styled.input`\n *    ${placeholder({'color': 'blue'})}\n * `\n *\n * // CSS as JS Output\n *\n * 'input': {\n *   '&:-moz-placeholder': {\n *     'color': 'blue',\n *   },\n *   '&:-ms-input-placeholder': {\n *     'color': 'blue',\n *   },\n *   '&::-moz-placeholder': {\n *     'color': 'blue',\n *   },\n *   '&::-webkit-input-placeholder': {\n *     'color': 'blue',\n *   },\n * },\n */\n\nfunction placeholder(styles) {\n  var _ref;\n\n  var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '&';\n\n  return _ref = {}, _ref[parent + '::-webkit-input-placeholder'] = _extends({}, styles), _ref[parent + ':-moz-placeholder'] = _extends({}, styles), _ref[parent + '::-moz-placeholder'] = _extends({}, styles), _ref[parent + ':-ms-input-placeholder'] = _extends({}, styles), _ref;\n}\n\nvar _templateObject = /*#__PURE__*/ taggedTemplateLiteralLoose(['radial-gradient(', '', '', '', ')'], ['radial-gradient(', '', '', '', ')']);\n\n//      \n\n/** */\n\nfunction parseFallback(colorStops) {\n  return colorStops[0].split(' ')[0];\n}\n\nfunction constructGradientValue(literals) {\n  var template = '';\n  for (var i = 0; i < literals.length; i += 1) {\n    template += literals[i];\n    // Adds leading coma if properties preceed color-stops\n    if (i === 3 && (arguments.length <= i + 1 ? undefined : arguments[i + 1]) && ((arguments.length <= 1 ? undefined : arguments[1]) || (arguments.length <= 2 ? undefined : arguments[2]) || (arguments.length <= 3 ? undefined : arguments[3]))) {\n      template = template.slice(0, -1);\n      template += ', ' + (arguments.length <= i + 1 ? undefined : arguments[i + 1]);\n      // No trailing space if color-stops is the only param provided\n    } else if (i === 3 && (arguments.length <= i + 1 ? undefined : arguments[i + 1]) && !(arguments.length <= 1 ? undefined : arguments[1]) && !(arguments.length <= 2 ? undefined : arguments[2]) && !(arguments.length <= 3 ? undefined : arguments[3])) {\n      template += '' + (arguments.length <= i + 1 ? undefined : arguments[i + 1]);\n      // Only adds substitution if it is defined\n    } else if (arguments.length <= i + 1 ? undefined : arguments[i + 1]) {\n      template += (arguments.length <= i + 1 ? undefined : arguments[i + 1]) + ' ';\n    }\n  }\n  return template.trim();\n}\n\n/**\n * CSS for declaring a radial gradient, including a fallback background-color. The fallback is either the first color-stop or an explicitly passed fallback color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...radialGradient({\n *     colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n *     extent: 'farthest-corner at 45px 45px',\n *     position: 'center',\n *     shape: 'ellipse',\n *   })\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${radialGradient({\n *     colorStops: ['#00FFFF 0%', 'rgba(0, 0, 255, 0) 50%', '#0000FF 95%'],\n *     extent: 'farthest-corner at 45px 45px',\n *     position: 'center',\n *     shape: 'ellipse',\n *   })}\n *`\n *\n * // CSS as JS Output\n *\n * div: {\n *   'backgroundColor': '#00FFFF',\n *   'backgroundImage': 'radial-gradient(center ellipse farthest-corner at 45px 45px, #00FFFF 0%, rgba(0, 0, 255, 0) 50%, #0000FF 95%)',\n * }\n */\n\nfunction radialGradient(_ref) {\n  var colorStops = _ref.colorStops,\n      extent = _ref.extent,\n      fallback = _ref.fallback,\n      position = _ref.position,\n      shape = _ref.shape;\n\n  if (!colorStops || colorStops.length < 2) {\n    throw new Error('radialGradient requries at least 2 color-stops to properly render.');\n  }\n  return {\n    backgroundColor: fallback || parseFallback(colorStops),\n    backgroundImage: constructGradientValue(_templateObject, position, shape, extent, colorStops.join(', '))\n  };\n}\n\n//      \n\n/**\n * A helper to generate a retina background image and non-retina\n * background image. The retina background image will output to a HiDPI media query. The mixin uses\n * a _2x.png filename suffix by default.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *  ...retinaImage('my-img')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${retinaImage('my-img')}\n * `\n *\n * // CSS as JS Output\n * div {\n *   backgroundImage: 'url(my-img.png)',\n *   '@media only screen and (-webkit-min-device-pixel-ratio: 1.3),\n *    only screen and (min--moz-device-pixel-ratio: 1.3),\n *    only screen and (-o-min-device-pixel-ratio: 1.3/1),\n *    only screen and (min-resolution: 144dpi),\n *    only screen and (min-resolution: 1.5dppx)': {\n *     backgroundImage: 'url(my-img_2x.png)',\n *   }\n * }\n */\nfunction retinaImage(filename, backgroundSize) {\n  var extension = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'png';\n\n  var _ref;\n\n  var retinaFilename = arguments[3];\n  var retinaSuffix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '_2x';\n\n  if (!filename) {\n    throw new Error('Please supply a filename to retinaImage() as the first argument.');\n  }\n  // Replace the dot at the beginning of the passed extension if one exists\n  var ext = extension.replace(/^\\./, '');\n  var rFilename = retinaFilename ? retinaFilename + '.' + ext : '' + filename + retinaSuffix + '.' + ext;\n\n  return _ref = {\n    backgroundImage: 'url(' + filename + '.' + ext + ')'\n  }, _ref[hiDPI()] = {\n    backgroundImage: 'url(' + rFilename + ')',\n    backgroundSize: backgroundSize\n  }, _ref;\n}\n\n//      \n\n/**\n * CSS to style the selection pseudo-element.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...selection({\n *     'backgroundColor': 'blue'\n *   }, 'section')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${selection({'backgroundColor': 'blue'}, 'section')}\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'section::-moz-selection': {\n *     'backgroundColor':'blue',\n *   },\n *   'section::selection': {\n *     'backgroundColor': 'blue',\n *   }\n * }\n */\n\nfunction selection(styles) {\n  var _ref;\n\n  var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  return _ref = {}, _ref[parent + '::-moz-selection'] = _extends({}, styles), _ref[parent + '::selection'] = _extends({}, styles), _ref;\n}\n\n//      \n\n/* eslint-disable key-spacing */\nvar functionsMap = {\n  easeInBack: 'cubic-bezier(0.600, -0.280, 0.735, 0.045)',\n  easeInCirc: 'cubic-bezier(0.600,  0.040, 0.980, 0.335)',\n  easeInCubic: 'cubic-bezier(0.550,  0.055, 0.675, 0.190)',\n  easeInExpo: 'cubic-bezier(0.950,  0.050, 0.795, 0.035)',\n  easeInQuad: 'cubic-bezier(0.550,  0.085, 0.680, 0.530)',\n  easeInQuart: 'cubic-bezier(0.895,  0.030, 0.685, 0.220)',\n  easeInQuint: 'cubic-bezier(0.755,  0.050, 0.855, 0.060)',\n  easeInSine: 'cubic-bezier(0.470,  0.000, 0.745, 0.715)',\n\n  easeOutBack: 'cubic-bezier(0.175,  0.885, 0.320, 1.275)',\n  easeOutCubic: 'cubic-bezier(0.215,  0.610, 0.355, 1.000)',\n  easeOutCirc: 'cubic-bezier(0.075,  0.820, 0.165, 1.000)',\n  easeOutExpo: 'cubic-bezier(0.190,  1.000, 0.220, 1.000)',\n  easeOutQuad: 'cubic-bezier(0.250,  0.460, 0.450, 0.940)',\n  easeOutQuart: 'cubic-bezier(0.165,  0.840, 0.440, 1.000)',\n  easeOutQuint: 'cubic-bezier(0.230,  1.000, 0.320, 1.000)',\n  easeOutSine: 'cubic-bezier(0.390,  0.575, 0.565, 1.000)',\n\n  easeInOutBack: 'cubic-bezier(0.680, -0.550, 0.265, 1.550)',\n  easeInOutCirc: 'cubic-bezier(0.785,  0.135, 0.150, 0.860)',\n  easeInOutCubic: 'cubic-bezier(0.645,  0.045, 0.355, 1.000)',\n  easeInOutExpo: 'cubic-bezier(1.000,  0.000, 0.000, 1.000)',\n  easeInOutQuad: 'cubic-bezier(0.455,  0.030, 0.515, 0.955)',\n  easeInOutQuart: 'cubic-bezier(0.770,  0.000, 0.175, 1.000)',\n  easeInOutQuint: 'cubic-bezier(0.860,  0.000, 0.070, 1.000)',\n  easeInOutSine: 'cubic-bezier(0.445,  0.050, 0.550, 0.950)'\n};\n/* eslint-enable key-spacing */\n\n/** */\n\n/**\n * String to represent common easing functions as demonstrated here: (github.com/jaukia/easie).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   'transitionTimingFunction': timingFunctions('easeInQuad')\n * }\n *\n * // styled-components usage\n *  const div = styled.div`\n *   transitionTimingFunction: ${timingFunctions('easeInQuad')};\n * `\n *\n * // CSS as JS Output\n *\n * 'div': {\n *   'transitionTimingFunction': 'cubic-bezier(0.550,  0.085, 0.680, 0.530)',\n * }\n */\n\nfunction timingFunctions(timingFunction) {\n  return functionsMap[timingFunction];\n}\n\n//      \n\n/** */\n\nvar getBorderWidth = function getBorderWidth(pointingDirection, height, width) {\n  switch (pointingDirection) {\n    case 'top':\n      return '0 ' + width / 2 + 'px ' + height + 'px ' + width / 2 + 'px';\n    case 'left':\n      return height / 2 + 'px ' + width + 'px ' + height / 2 + 'px 0';\n    case 'bottom':\n      return height + 'px ' + width / 2 + 'px 0 ' + width / 2 + 'px';\n    case 'right':\n      return height / 2 + 'px 0 ' + height / 2 + 'px ' + width + 'px';\n\n    default:\n      throw new Error(\"Passed invalid argument to triangle, please pass correct poitingDirection e.g. 'right'.\");\n  }\n};\n\n// needed for border-color\nvar reverseDirection = {\n  left: 'Right',\n  right: 'Left',\n  top: 'Bottom',\n  bottom: 'Top'\n};\n\n/**\n * CSS to represent triangle with any pointing direction with an optional background color. Accepts number or px values for height and width.\n *\n * @example\n * // Styles as object usage\n *\n * const styles = {\n *   ...triangle({ pointingDirection: 'right', width: '100px', height: '100px', foregroundColor: 'red' })\n * }\n *\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${triangle({ pointingDirection: 'right', width: '100px', height: '100px', foregroundColor: 'red' })}\n *\n *\n * // CSS as JS Output\n *\n * div: {\n *  'borderColor': 'transparent',\n *  'borderLeftColor': 'red !important',\n *  'borderStyle': 'solid',\n *  'borderWidth': '50px 0 50px 100px',\n *  'height': '0',\n *  'width': '0',\n * }\n */\n\nfunction triangle(_ref) {\n  var _ref2;\n\n  var pointingDirection = _ref.pointingDirection,\n      height = _ref.height,\n      width = _ref.width,\n      foregroundColor = _ref.foregroundColor,\n      _ref$backgroundColor = _ref.backgroundColor,\n      backgroundColor = _ref$backgroundColor === undefined ? 'transparent' : _ref$backgroundColor;\n\n  var unitlessHeight = parseFloat(height);\n  var unitlessWidth = parseFloat(width);\n  if (isNaN(unitlessHeight) || isNaN(unitlessWidth)) {\n    throw new Error('Passed an invalid value to `height` or `width`. Please provide a pixel based unit');\n  }\n\n  return _ref2 = {\n    borderColor: backgroundColor,\n    width: '0',\n    height: '0',\n    borderWidth: getBorderWidth(pointingDirection, unitlessHeight, unitlessWidth),\n    borderStyle: 'solid'\n  }, _ref2['border' + reverseDirection[pointingDirection] + 'Color'] = foregroundColor + ' !important', _ref2;\n}\n\n//      \n\n/**\n * Provides an easy way to change the `wordWrap` property.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...wordWrap('break-word')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${wordWrap('break-word')}\n * `\n *\n * // CSS as JS Output\n *\n * const styles = {\n *   overflowWrap: 'break-word',\n *   wordWrap: 'break-word',\n *   wordBreak: 'break-all',\n * }\n */\n\nfunction wordWrap() {\n  var wrap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'break-word';\n\n  var wordBreak = wrap === 'break-word' ? 'break-all' : wrap;\n  return {\n    overflowWrap: wrap,\n    wordWrap: wrap,\n    wordBreak: wordBreak\n  };\n}\n\n//      \n\n\nfunction colorToInt(color) {\n  return Math.round(color * 255);\n}\n\nfunction convertToInt(red, green, blue) {\n  return colorToInt(red) + \",\" + colorToInt(green) + \",\" + colorToInt(blue);\n}\n\nfunction hslToRgb(hue, saturation, lightness) {\n  var convert = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : convertToInt;\n\n  if (saturation === 0) {\n    // achromatic\n    return convert(lightness, lightness, lightness);\n  }\n\n  // formular from https://en.wikipedia.org/wiki/HSL_and_HSV\n  var huePrime = hue % 360 / 60;\n  var chroma = (1 - Math.abs(2 * lightness - 1)) * saturation;\n  var secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));\n\n  var red = 0;\n  var green = 0;\n  var blue = 0;\n\n  if (huePrime >= 0 && huePrime < 1) {\n    red = chroma;\n    green = secondComponent;\n  } else if (huePrime >= 1 && huePrime < 2) {\n    red = secondComponent;\n    green = chroma;\n  } else if (huePrime >= 2 && huePrime < 3) {\n    green = chroma;\n    blue = secondComponent;\n  } else if (huePrime >= 3 && huePrime < 4) {\n    green = secondComponent;\n    blue = chroma;\n  } else if (huePrime >= 4 && huePrime < 5) {\n    red = secondComponent;\n    blue = chroma;\n  } else if (huePrime >= 5 && huePrime < 6) {\n    red = chroma;\n    blue = secondComponent;\n  }\n\n  var lightnessModification = lightness - chroma / 2;\n  var finalRed = red + lightnessModification;\n  var finalGreen = green + lightnessModification;\n  var finalBlue = blue + lightnessModification;\n  return convert(finalRed, finalGreen, finalBlue);\n}\n\n//      \nvar namedColorMap = {\n  aliceblue: 'f0f8ff',\n  antiquewhite: 'faebd7',\n  aqua: '00ffff',\n  aquamarine: '7fffd4',\n  azure: 'f0ffff',\n  beige: 'f5f5dc',\n  bisque: 'ffe4c4',\n  black: '000',\n  blanchedalmond: 'ffebcd',\n  blue: '0000ff',\n  blueviolet: '8a2be2',\n  brown: 'a52a2a',\n  burlywood: 'deb887',\n  cadetblue: '5f9ea0',\n  chartreuse: '7fff00',\n  chocolate: 'd2691e',\n  coral: 'ff7f50',\n  cornflowerblue: '6495ed',\n  cornsilk: 'fff8dc',\n  crimson: 'dc143c',\n  cyan: '00ffff',\n  darkblue: '00008b',\n  darkcyan: '008b8b',\n  darkgoldenrod: 'b8860b',\n  darkgray: 'a9a9a9',\n  darkgreen: '006400',\n  darkgrey: 'a9a9a9',\n  darkkhaki: 'bdb76b',\n  darkmagenta: '8b008b',\n  darkolivegreen: '556b2f',\n  darkorange: 'ff8c00',\n  darkorchid: '9932cc',\n  darkred: '8b0000',\n  darksalmon: 'e9967a',\n  darkseagreen: '8fbc8f',\n  darkslateblue: '483d8b',\n  darkslategray: '2f4f4f',\n  darkslategrey: '2f4f4f',\n  darkturquoise: '00ced1',\n  darkviolet: '9400d3',\n  deeppink: 'ff1493',\n  deepskyblue: '00bfff',\n  dimgray: '696969',\n  dimgrey: '696969',\n  dodgerblue: '1e90ff',\n  firebrick: 'b22222',\n  floralwhite: 'fffaf0',\n  forestgreen: '228b22',\n  fuchsia: 'ff00ff',\n  gainsboro: 'dcdcdc',\n  ghostwhite: 'f8f8ff',\n  gold: 'ffd700',\n  goldenrod: 'daa520',\n  gray: '808080',\n  green: '008000',\n  greenyellow: 'adff2f',\n  grey: '808080',\n  honeydew: 'f0fff0',\n  hotpink: 'ff69b4',\n  indianred: 'cd5c5c',\n  indigo: '4b0082',\n  ivory: 'fffff0',\n  khaki: 'f0e68c',\n  lavender: 'e6e6fa',\n  lavenderblush: 'fff0f5',\n  lawngreen: '7cfc00',\n  lemonchiffon: 'fffacd',\n  lightblue: 'add8e6',\n  lightcoral: 'f08080',\n  lightcyan: 'e0ffff',\n  lightgoldenrodyellow: 'fafad2',\n  lightgray: 'd3d3d3',\n  lightgreen: '90ee90',\n  lightgrey: 'd3d3d3',\n  lightpink: 'ffb6c1',\n  lightsalmon: 'ffa07a',\n  lightseagreen: '20b2aa',\n  lightskyblue: '87cefa',\n  lightslategray: '789',\n  lightslategrey: '789',\n  lightsteelblue: 'b0c4de',\n  lightyellow: 'ffffe0',\n  lime: '0f0',\n  limegreen: '32cd32',\n  linen: 'faf0e6',\n  magenta: 'f0f',\n  maroon: '800000',\n  mediumaquamarine: '66cdaa',\n  mediumblue: '0000cd',\n  mediumorchid: 'ba55d3',\n  mediumpurple: '9370db',\n  mediumseagreen: '3cb371',\n  mediumslateblue: '7b68ee',\n  mediumspringgreen: '00fa9a',\n  mediumturquoise: '48d1cc',\n  mediumvioletred: 'c71585',\n  midnightblue: '191970',\n  mintcream: 'f5fffa',\n  mistyrose: 'ffe4e1',\n  moccasin: 'ffe4b5',\n  navajowhite: 'ffdead',\n  navy: '000080',\n  oldlace: 'fdf5e6',\n  olive: '808000',\n  olivedrab: '6b8e23',\n  orange: 'ffa500',\n  orangered: 'ff4500',\n  orchid: 'da70d6',\n  palegoldenrod: 'eee8aa',\n  palegreen: '98fb98',\n  paleturquoise: 'afeeee',\n  palevioletred: 'db7093',\n  papayawhip: 'ffefd5',\n  peachpuff: 'ffdab9',\n  peru: 'cd853f',\n  pink: 'ffc0cb',\n  plum: 'dda0dd',\n  powderblue: 'b0e0e6',\n  purple: '800080',\n  rebeccapurple: '639',\n  red: 'f00',\n  rosybrown: 'bc8f8f',\n  royalblue: '4169e1',\n  saddlebrown: '8b4513',\n  salmon: 'fa8072',\n  sandybrown: 'f4a460',\n  seagreen: '2e8b57',\n  seashell: 'fff5ee',\n  sienna: 'a0522d',\n  silver: 'c0c0c0',\n  skyblue: '87ceeb',\n  slateblue: '6a5acd',\n  slategray: '708090',\n  slategrey: '708090',\n  snow: 'fffafa',\n  springgreen: '00ff7f',\n  steelblue: '4682b4',\n  tan: 'd2b48c',\n  teal: '008080',\n  thistle: 'd8bfd8',\n  tomato: 'ff6347',\n  turquoise: '40e0d0',\n  violet: 'ee82ee',\n  wheat: 'f5deb3',\n  white: 'fff',\n  whitesmoke: 'f5f5f5',\n  yellow: 'ff0',\n  yellowgreen: '9acd32'\n};\n\n/**\n * Checks if a string is a CSS named color and returns its equivalent hex value, otherwise returns the original color.\n * @private\n */\nfunction nameToHex(color) {\n  if (typeof color !== 'string') return color;\n  var normalizedColorName = color.toLowerCase();\n  return namedColorMap[normalizedColorName] ? '#' + namedColorMap[normalizedColorName] : color;\n}\n\n//      \nvar hexRegex = /^#[a-fA-F0-9]{6}$/;\nvar reducedHexRegex = /^#[a-fA-F0-9]{3}$/;\nvar rgbRegex = /^rgb\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)$/;\nvar rgbaRegex = /^rgba\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*([-+]?[0-9]*[.]?[0-9]+)\\s*\\)$/;\nvar hslRegex = /^hsl\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})%\\s*,\\s*(\\d{1,3})%\\s*\\)$/;\nvar hslaRegex = /^hsla\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})%\\s*,\\s*(\\d{1,3})%\\s*,\\s*([-+]?[0-9]*[.]?[0-9]+)\\s*\\)$/;\n\n/**\n * Returns an RgbColor or RgbaColor object. This utility function is only useful\n * if want to extract a color component. With the color util `toColorString` you\n * can convert a RgbColor or RgbaColor object back to a string.\n *\n * @example\n * // Assigns `{ red: 255, green: 0, blue: 0 }` to color1\n * const color1 = 'rgb(255, 0, 0)';\n * // Assigns `{ red: 92, green: 102, blue: 112, alpha: 0.75 }` to color2\n * const color2 = 'hsla(210, 10%, 40%, 0.75)';\n */\nfunction parseToRgb(color) {\n  if (typeof color !== 'string') {\n    throw new Error('Passed an incorrect argument to a color function, please pass a string representation of a color.');\n  }\n  var normalizedColor = nameToHex(color);\n  if (normalizedColor.match(hexRegex)) {\n    return {\n      red: parseInt('' + normalizedColor[1] + normalizedColor[2], 16),\n      green: parseInt('' + normalizedColor[3] + normalizedColor[4], 16),\n      blue: parseInt('' + normalizedColor[5] + normalizedColor[6], 16)\n    };\n  }\n  if (normalizedColor.match(reducedHexRegex)) {\n    return {\n      red: parseInt('' + normalizedColor[1] + normalizedColor[1], 16),\n      green: parseInt('' + normalizedColor[2] + normalizedColor[2], 16),\n      blue: parseInt('' + normalizedColor[3] + normalizedColor[3], 16)\n    };\n  }\n  var rgbMatched = rgbRegex.exec(normalizedColor);\n  if (rgbMatched) {\n    return {\n      red: parseInt('' + rgbMatched[1], 10),\n      green: parseInt('' + rgbMatched[2], 10),\n      blue: parseInt('' + rgbMatched[3], 10)\n    };\n  }\n  var rgbaMatched = rgbaRegex.exec(normalizedColor);\n  if (rgbaMatched) {\n    return {\n      red: parseInt('' + rgbaMatched[1], 10),\n      green: parseInt('' + rgbaMatched[2], 10),\n      blue: parseInt('' + rgbaMatched[3], 10),\n      alpha: parseFloat('' + rgbaMatched[4])\n    };\n  }\n  var hslMatched = hslRegex.exec(normalizedColor);\n  if (hslMatched) {\n    var hue = parseInt('' + hslMatched[1], 10);\n    var saturation = parseInt('' + hslMatched[2], 10) / 100;\n    var lightness = parseInt('' + hslMatched[3], 10) / 100;\n    var rgbColorString = 'rgb(' + hslToRgb(hue, saturation, lightness) + ')';\n    var hslRgbMatched = rgbRegex.exec(rgbColorString);\n    return {\n      red: parseInt('' + hslRgbMatched[1], 10),\n      green: parseInt('' + hslRgbMatched[2], 10),\n      blue: parseInt('' + hslRgbMatched[3], 10)\n    };\n  }\n  var hslaMatched = hslaRegex.exec(normalizedColor);\n  if (hslaMatched) {\n    var _hue = parseInt('' + hslaMatched[1], 10);\n    var _saturation = parseInt('' + hslaMatched[2], 10) / 100;\n    var _lightness = parseInt('' + hslaMatched[3], 10) / 100;\n    var _rgbColorString = 'rgb(' + hslToRgb(_hue, _saturation, _lightness) + ')';\n    var _hslRgbMatched = rgbRegex.exec(_rgbColorString);\n    return {\n      red: parseInt('' + _hslRgbMatched[1], 10),\n      green: parseInt('' + _hslRgbMatched[2], 10),\n      blue: parseInt('' + _hslRgbMatched[3], 10),\n      alpha: parseFloat('' + hslaMatched[4])\n    };\n  }\n  throw new Error(\"Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\");\n}\n\n//      \n\n\nfunction rgbToHsl(color) {\n  // make sure rgb are contained in a set of [0, 255]\n  var red = color.red / 255;\n  var green = color.green / 255;\n  var blue = color.blue / 255;\n\n  var max = Math.max(red, green, blue);\n  var min = Math.min(red, green, blue);\n  var lightness = (max + min) / 2;\n\n  if (max === min) {\n    // achromatic\n    if (color.alpha !== undefined) {\n      return { hue: 0, saturation: 0, lightness: lightness, alpha: color.alpha };\n    } else {\n      return { hue: 0, saturation: 0, lightness: lightness };\n    }\n  }\n\n  var hue = void 0;\n  var delta = max - min;\n  var saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);\n  switch (max) {\n    case red:\n      hue = (green - blue) / delta + (green < blue ? 6 : 0);\n      break;\n    case green:\n      hue = (blue - red) / delta + 2;\n      break;\n    default:\n      // blue case\n      hue = (red - green) / delta + 4;\n      break;\n  }\n\n  hue *= 60;\n  if (color.alpha !== undefined) {\n    return { hue: hue, saturation: saturation, lightness: lightness, alpha: color.alpha };\n  }\n  return { hue: hue, saturation: saturation, lightness: lightness };\n}\n\n//      \n\n/**\n * Returns an HslColor or HslaColor object. This utility function is only useful\n * if want to extract a color component. With the color util `toColorString` you\n * can convert a HslColor or HslaColor object back to a string.\n *\n * @example\n * // Assigns `{ red: 255, green: 0, blue: 0 }` to color1\n * const color1 = 'rgb(255, 0, 0)';\n * // Assigns `{ red: 92, green: 102, blue: 112, alpha: 0.75 }` to color2\n * const color2 = 'hsla(210, 10%, 40%, 0.75)';\n */\nfunction parseToHsl(color) {\n  // Note: At a later stage we can optimize this function as right now a hsl\n  // color would be parsed converted to rgb values and converted back to hsl.\n  return rgbToHsl(parseToRgb(color));\n}\n\n//      \n\n/**\n * Reduces hex values if possible e.g. #ff8866 to #f86\n * @private\n */\nvar reduceHexValue = function reduceHexValue(value) {\n  if (value.length === 7 && value[1] === value[2] && value[3] === value[4] && value[5] === value[6]) {\n    return \"#\" + value[1] + value[3] + value[5];\n  }\n  return value;\n};\n\n//      \nfunction numberToHex(value) {\n  var hex = value.toString(16);\n  return hex.length === 1 ? \"0\" + hex : hex;\n}\n\n//      \n\n/**\n * Returns a string value for the color. The returned result is the smallest possible hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgb(255, 205, 100),\n *   background: rgb({ red: 255, green: 205, blue: 100 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgb(255, 205, 100)};\n *   background: ${rgb({ red: 255, green: 205, blue: 100 })};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#ffcd64\";\n *   background: \"#ffcd64\";\n * }\n */\nfunction rgb(value, green, blue) {\n  if (typeof value === 'number' && typeof green === 'number' && typeof blue === 'number') {\n    return reduceHexValue('#' + numberToHex(value) + numberToHex(green) + numberToHex(blue));\n  } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && green === undefined && blue === undefined) {\n    return reduceHexValue('#' + numberToHex(value.red) + numberToHex(value.green) + numberToHex(value.blue));\n  }\n\n  throw new Error('Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).');\n}\n\n//      \n\n/**\n * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.\n *\n * Can also be used to fade a color by passing a hex value or named CSS color along with an alpha value.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: rgba(255, 205, 100, 0.7),\n *   background: rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 }),\n *   background: rgba(255, 205, 100, 1),\n *   background: rgba('#ffffff', 0.4),\n *   background: rgba('black', 0.7),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${rgba(255, 205, 100, 0.7)};\n *   background: ${rgba({ red: 255, green: 205, blue: 100, alpha: 0.7 })};\n *   background: ${rgba(255, 205, 100, 1)};\n *   background: ${rgba('#ffffff', 0.4)};\n *   background: ${rgba('black', 0.7)};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(255,205,100,0.7)\";\n *   background: \"rgba(255,205,100,0.7)\";\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,255,255,0.4)\";\n *   background: \"rgba(0,0,0,0.7)\";\n * }\n */\nfunction rgba(firstValue, secondValue, thirdValue, fourthValue) {\n  if (typeof firstValue === 'string' && typeof secondValue === 'number') {\n    var rgbValue = parseToRgb(firstValue);\n    return 'rgba(' + rgbValue.red + ',' + rgbValue.green + ',' + rgbValue.blue + ',' + secondValue + ')';\n  } else if (typeof firstValue === 'number' && typeof secondValue === 'number' && typeof thirdValue === 'number' && typeof fourthValue === 'number') {\n    return fourthValue >= 1 ? rgb(firstValue, secondValue, thirdValue) : 'rgba(' + firstValue + ',' + secondValue + ',' + thirdValue + ',' + fourthValue + ')';\n  } else if ((typeof firstValue === 'undefined' ? 'undefined' : _typeof(firstValue)) === 'object' && secondValue === undefined && thirdValue === undefined && fourthValue === undefined) {\n    return firstValue.alpha >= 1 ? rgb(firstValue.red, firstValue.green, firstValue.blue) : 'rgba(' + firstValue.red + ',' + firstValue.green + ',' + firstValue.blue + ',' + firstValue.alpha + ')';\n  }\n\n  throw new Error('Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).');\n}\n\n//      \nfunction colorToHex(color) {\n  return numberToHex(Math.round(color * 255));\n}\n\nfunction convertToHex(red, green, blue) {\n  return reduceHexValue('#' + colorToHex(red) + colorToHex(green) + colorToHex(blue));\n}\n\nfunction hslToHex(hue, saturation, lightness) {\n  return hslToRgb(hue, saturation, lightness, convertToHex);\n}\n\n//      \n\n/**\n * Returns a string value for the color. The returned result is the smallest possible hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hsl(359, 0.75, 0.4),\n *   background: hsl({ hue: 360, saturation: 0.75, lightness: 0.4 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hsl(359, 0.75, 0.4)};\n *   background: ${hsl({ hue: 360, saturation: 0.75, lightness: 0.4 })};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#b3191c\";\n *   background: \"#b3191c\";\n * }\n */\nfunction hsl(value, saturation, lightness) {\n  if (typeof value === 'number' && typeof saturation === 'number' && typeof lightness === 'number') {\n    return hslToHex(value, saturation, lightness);\n  } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && saturation === undefined && lightness === undefined) {\n    return hslToHex(value.hue, value.saturation, value.lightness);\n  }\n\n  throw new Error('Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).');\n}\n\n//      \n\n/**\n * Returns a string value for the color. The returned result is the smallest possible rgba or hex notation.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: hsla(359, 0.75, 0.4, 0.7),\n *   background: hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 }),\n *   background: hsla(359, 0.75, 0.4, 1),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${hsla(359, 0.75, 0.4, 0.7)};\n *   background: ${hsla({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0,7 })};\n *   background: ${hsla(359, 0.75, 0.4, 1)};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(179,25,28,0.7)\";\n *   background: \"rgba(179,25,28,0.7)\";\n *   background: \"#b3191c\";\n * }\n */\nfunction hsla(value, saturation, lightness, alpha) {\n  if (typeof value === 'number' && typeof saturation === 'number' && typeof lightness === 'number' && typeof alpha === 'number') {\n    return alpha >= 1 ? hslToHex(value, saturation, lightness) : 'rgba(' + hslToRgb(value, saturation, lightness) + ',' + alpha + ')';\n  } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && saturation === undefined && lightness === undefined && alpha === undefined) {\n    return value.alpha >= 1 ? hslToHex(value.hue, value.saturation, value.lightness) : 'rgba(' + hslToRgb(value.hue, value.saturation, value.lightness) + ',' + value.alpha + ')';\n  }\n\n  throw new Error('Passed invalid arguments to hsla, please pass multiple numbers e.g. hsl(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).');\n}\n\n//      \nvar isRgb = function isRgb(color) {\n  return typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number' && (typeof color.alpha !== 'number' || typeof color.alpha === 'undefined');\n};\n\nvar isRgba = function isRgba(color) {\n  return typeof color.red === 'number' && typeof color.green === 'number' && typeof color.blue === 'number' && typeof color.alpha === 'number';\n};\n\nvar isHsl = function isHsl(color) {\n  return typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number' && (typeof color.alpha !== 'number' || typeof color.alpha === 'undefined');\n};\n\nvar isHsla = function isHsla(color) {\n  return typeof color.hue === 'number' && typeof color.saturation === 'number' && typeof color.lightness === 'number' && typeof color.alpha === 'number';\n};\n\nvar errMsg = 'Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.';\n\n/**\n * Converts a RgbColor, RgbaColor, HslColor or HslaColor object to a color string.\n * This util is useful in case you only know on runtime which color object is\n * used. Otherwise we recommend to rely on `rgb`, `rgba`, `hsl` or `hsla`.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: toColorString({ red: 255, green: 205, blue: 100 }),\n *   background: toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 }),\n *   background: toColorString({ hue: 240, saturation: 1, lightness: 0.5 }),\n *   background: toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 }),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${toColorString({ red: 255, green: 205, blue: 100 })};\n *   background: ${toColorString({ red: 255, green: 205, blue: 100, alpha: 0.72 })};\n *   background: ${toColorString({ hue: 240, saturation: 1, lightness: 0.5 })};\n *   background: ${toColorString({ hue: 360, saturation: 0.75, lightness: 0.4, alpha: 0.72 })};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#ffcd64\";\n *   background: \"rgba(255,205,100,0.72)\";\n *   background: \"#00f\";\n *   background: \"rgba(179,25,25,0.72)\";\n * }\n */\n\nfunction toColorString(color) {\n  if ((typeof color === 'undefined' ? 'undefined' : _typeof(color)) !== 'object') throw new Error(errMsg);\n  if (isRgba(color)) return rgba(color);\n  if (isRgb(color)) return rgb(color);\n  if (isHsla(color)) return hsla(color);\n  if (isHsl(color)) return hsl(color);\n\n  throw new Error(errMsg);\n}\n\n//      \n\n// Type definitions taken from https://github.com/gcanti/flow-static-land/blob/master/src/Fun.js\n\n\n// eslint-disable-next-line no-unused-vars\n\n\n// eslint-disable-next-line no-unused-vars\n\n// eslint-disable-next-line no-redeclare\n\n\nfunction curried(f, length, acc) {\n  return function fn() {\n    // eslint-disable-next-line prefer-rest-params\n    var combined = acc.concat(Array.prototype.slice.call(arguments));\n    return combined.length >= length ? f.apply(this, combined) : curried(f, length, combined);\n  };\n}\n\n// eslint-disable-next-line no-redeclare\nfunction curry(f) {\n  // eslint-disable-line no-redeclare\n  return curried(f, f.length, []);\n}\n\n//      \n\n/**\n * Changes the hue of the color. Hue is a number between 0 to 360. The first\n * argument for adjustHue is the amount of degrees the color is rotated along\n * the color wheel.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: adjustHue(180, '#448'),\n *   background: adjustHue(180, 'rgba(101,100,205,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${adjustHue(180, '#448')};\n *   background: ${adjustHue(180, 'rgba(101,100,205,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#888844\";\n *   background: \"rgba(136,136,68,0.7)\";\n * }\n */\nfunction adjustHue(degree, color) {\n  var hslColor = parseToHsl(color);\n  return toColorString(_extends({}, hslColor, {\n    hue: (hslColor.hue + degree) % 360\n  }));\n}\n\nvar curriedAdjustHue = /*#__PURE__*/curry(adjustHue);\n\n//      \n\n/**\n * Returns the complement of the provided color. This is identical to adjustHue(180, <color>).\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: complement('#448'),\n *   background: complement('rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${complement('#448')};\n *   background: ${complement('rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#884\";\n *   background: \"rgba(153,153,153,0.7)\";\n * }\n */\nfunction complement(color) {\n  var hslColor = parseToHsl(color);\n  return toColorString(_extends({}, hslColor, {\n    hue: (hslColor.hue + 180) % 360\n  }));\n}\n\n//      \n\nfunction guard(lowerBoundary, upperBoundary, value) {\n  return Math.max(lowerBoundary, Math.min(upperBoundary, value));\n}\n\n//      \n\n/**\n * Returns a string value for the darkened color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: darken(0.2, '#FFCD64'),\n *   background: darken(0.2, 'rgba(255,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${darken(0.2, '#FFCD64')};\n *   background: ${darken(0.2, 'rgba(255,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#ffbd31\";\n *   background: \"rgba(255,189,49,0.7)\";\n * }\n */\nfunction darken(amount, color) {\n  var hslColor = parseToHsl(color);\n  return toColorString(_extends({}, hslColor, {\n    lightness: guard(0, 1, hslColor.lightness - amount)\n  }));\n}\n\nvar curriedDarken = /*#__PURE__*/curry(darken);\n\n//      \n\n/**\n * Decreases the intensity of a color. Its range is between 0 to 1. The first\n * argument of the desaturate function is the amount by how much the color\n * intensity should be decreased.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: desaturate(0.2, '#CCCD64'),\n *   background: desaturate(0.2, 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${desaturate(0.2, '#CCCD64')};\n *   background: ${desaturate(0.2, 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#b8b979\";\n *   background: \"rgba(184,185,121,0.7)\";\n * }\n */\nfunction desaturate(amount, color) {\n  var hslColor = parseToHsl(color);\n  return toColorString(_extends({}, hslColor, {\n    saturation: guard(0, 1, hslColor.saturation - amount)\n  }));\n}\n\nvar curriedDesaturate = /*#__PURE__*/curry(desaturate);\n\n//      \n/**\n * Returns a number (float) representing the luminance of a color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: getLuminance('#CCCD64') >= getLuminance('#0000ff') ? '#CCCD64' : '#0000ff',\n *   background: getLuminance('rgba(58, 133, 255, 1)') >= getLuminance('rgba(255, 57, 149, 1)') ?\n *                             'rgba(58, 133, 255, 1)' :\n *                             'rgba(255, 57, 149, 1)',\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${getLuminance('#CCCD64') >= getLuminance('#0000ff') ? '#CCCD64' : '#0000ff'};\n *   background: ${getLuminance('rgba(58, 133, 255, 1)') >= getLuminance('rgba(255, 57, 149, 1)') ?\n *                             'rgba(58, 133, 255, 1)' :\n *                             'rgba(255, 57, 149, 1)'};\n *\n * // CSS in JS Output\n *\n * div {\n *   background: \"#CCCD64\";\n *   background: \"rgba(58, 133, 255, 1)\";\n * }\n */\nfunction getLuminance(color) {\n  var rgbColor = parseToRgb(color);\n\n  var _Object$keys$map = Object.keys(rgbColor).map(function (key) {\n    var channel = rgbColor[key] / 255;\n    return channel <= 0.03928 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);\n  }),\n      r = _Object$keys$map[0],\n      g = _Object$keys$map[1],\n      b = _Object$keys$map[2];\n\n  return 0.2126 * r + 0.7152 * g + 0.0722 * b;\n}\n\n//      \n\n/**\n * Converts the color to a grayscale, by reducing its saturation to 0.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: grayscale('#CCCD64'),\n *   background: grayscale('rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${grayscale('#CCCD64')};\n *   background: ${grayscale('rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#999\";\n *   background: \"rgba(153,153,153,0.7)\";\n * }\n */\nfunction grayscale(color) {\n  return toColorString(_extends({}, parseToHsl(color), {\n    saturation: 0\n  }));\n}\n\n//      \n\n/**\n * Inverts the red, green and blue values of a color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: invert('#CCCD64'),\n *   background: invert('rgba(101,100,205,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${invert('#CCCD64')};\n *   background: ${invert('rgba(101,100,205,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#33329b\";\n *   background: \"rgba(154,155,50,0.7)\";\n * }\n */\nfunction invert(color) {\n  // parse color string to rgb\n  var value = parseToRgb(color);\n  return toColorString(_extends({}, value, {\n    red: 255 - value.red,\n    green: 255 - value.green,\n    blue: 255 - value.blue\n  }));\n}\n\n//      \n\n/**\n * Returns a string value for the lightened color.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: lighten(0.2, '#CCCD64'),\n *   background: lighten(0.2, 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${lighten(0.2, '#FFCD64')};\n *   background: ${lighten(0.2, 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#e5e6b1\";\n *   background: \"rgba(229,230,177,0.7)\";\n * }\n */\nfunction lighten(amount, color) {\n  var hslColor = parseToHsl(color);\n  return toColorString(_extends({}, hslColor, {\n    lightness: guard(0, 1, hslColor.lightness + amount)\n  }));\n}\n\nvar curriedLighten = /*#__PURE__*/curry(lighten);\n\n//      \n\n/**\n * Mixes two colors together by calculating the average of each of the RGB components.\n *\n * By default the weight is 0.5 meaning that half of the first color and half the second\n * color should be used. Optionally the weight can be modified by providing a number\n * as the first argument. 0.25 means that a quarter of the first color and three quarters\n * of the second color should be used.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: mix(0.5, '#f00', '#00f')\n *   background: mix(0.25, '#f00', '#00f')\n *   background: mix(0.5, 'rgba(255, 0, 0, 0.5)', '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${mix(0.5, '#f00', '#00f')};\n *   background: ${mix(0.25, '#f00', '#00f')};\n *   background: ${mix(0.5, 'rgba(255, 0, 0, 0.5)', '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#7f007f\";\n *   background: \"#3f00bf\";\n *   background: \"rgba(63, 0, 191, 0.75)\";\n * }\n */\nfunction mix() {\n  var weight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;\n  var color = arguments[1];\n  var otherColor = arguments[2];\n\n  var parsedColor1 = parseToRgb(color);\n  var color1 = _extends({}, parsedColor1, {\n    alpha: typeof parsedColor1.alpha === 'number' ? parsedColor1.alpha : 1\n  });\n\n  var parsedColor2 = parseToRgb(otherColor);\n  var color2 = _extends({}, parsedColor2, {\n    alpha: typeof parsedColor2.alpha === 'number' ? parsedColor2.alpha : 1\n  });\n\n  // The formular is copied from the original Sass implementation:\n  // http://sass-lang.com/documentation/Sass/Script/Functions.html#mix-instance_method\n  var alphaDelta = color1.alpha - color2.alpha;\n  var x = weight * 2 - 1;\n  var y = x * alphaDelta === -1 ? x : x + alphaDelta;\n  var z = 1 + x * alphaDelta;\n  var weight1 = (y / z + 1) / 2.0;\n  var weight2 = 1 - weight1;\n\n  var mixedColor = {\n    red: Math.floor(color1.red * weight1 + color2.red * weight2),\n    green: Math.floor(color1.green * weight1 + color2.green * weight2),\n    blue: Math.floor(color1.blue * weight1 + color2.blue * weight2),\n    alpha: color1.alpha + (color2.alpha - color1.alpha) * (weight / 1.0)\n  };\n\n  return rgba(mixedColor);\n}\n\nvar curriedMix = /*#__PURE__*/curry(mix);\n\n//      \n/**\n * Increases the opacity of a color. Its range for the amount is between 0 to 1.\n *\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: opacify(0.1, 'rgba(255, 255, 255, 0.9)');\n *   background: opacify(0.2, 'hsla(0, 0%, 100%, 0.5)'),\n *   background: opacify(0.5, 'rgba(255, 0, 0, 0.2)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${opacify(0.1, 'rgba(255, 255, 255, 0.9)')};\n *   background: ${opacify(0.2, 'hsla(0, 0%, 100%, 0.5)')},\n *   background: ${opacify(0.5, 'rgba(255, 0, 0, 0.2)')},\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#fff\";\n *   background: \"rgba(255,255,255,0.7)\";\n *   background: \"rgba(255,0,0,0.7)\";\n * }\n */\nfunction opacify(amount, color) {\n  var parsedColor = parseToRgb(color);\n  var alpha = typeof parsedColor.alpha === 'number' ? parsedColor.alpha : 1;\n  var colorWithAlpha = _extends({}, parsedColor, {\n    alpha: guard(0, 1, (alpha * 100 + amount * 100) / 100)\n  });\n  return rgba(colorWithAlpha);\n}\n\nvar curriedOpacify = /*#__PURE__*/curry(opacify);\n\n//      \n/**\n * Selects black or white for best contrast depending on the luminosity of the given color.\n * Follows W3C specs for readability at https://www.w3.org/TR/WCAG20-TECHS/G18.html\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   color: readableColor('#000'),\n *   color: readableColor('papayawhip'),\n *   color: readableColor('rgb(255,0,0)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   color: ${readableColor('#000')};\n *   color: ${readableColor('papayawhip')};\n *   color: ${readableColor('rgb(255,0,0)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   color: \"#fff\";\n *   color: \"#fff\";\n *   color: \"#000\";\n * }\n */\n\nfunction readableColor(color) {\n  return getLuminance(color) > 0.179 ? '#000' : '#fff';\n}\n\nvar curriedReadableColor = /*#__PURE__*/curry(readableColor);\n\n//      \n\n/**\n * Increases the intensity of a color. Its range is between 0 to 1. The first\n * argument of the saturate function is the amount by how much the color\n * intensity should be increased.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: saturate(0.2, '#CCCD64'),\n *   background: saturate(0.2, 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${saturate(0.2, '#FFCD64')};\n *   background: ${saturate(0.2, 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#e0e250\";\n *   background: \"rgba(224,226,80,0.7)\";\n * }\n */\nfunction saturate(amount, color) {\n  var hslColor = parseToHsl(color);\n  return toColorString(_extends({}, hslColor, {\n    saturation: guard(0, 1, hslColor.saturation + amount)\n  }));\n}\n\nvar curriedSaturate = /*#__PURE__*/curry(saturate);\n\n//      \n\n/**\n * Sets the hue of a color to the provided value. The hue range can be\n * from 0 and 359.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setHue(42, '#CCCD64'),\n *   background: setHue(244, 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setHue(42, '#CCCD64')};\n *   background: ${setHue(244, 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#cdae64\";\n *   background: \"rgba(107,100,205,0.7)\";\n * }\n */\nfunction setHue(hue, color) {\n  return toColorString(_extends({}, parseToHsl(color), {\n    hue: hue\n  }));\n}\n\nvar curriedSetHue = /*#__PURE__*/curry(setHue);\n\n//      \n\n/**\n * Sets the lightness of a color to the provided value. The lightness range can be\n * from 0 and 1.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setLightness(0.2, '#CCCD64'),\n *   background: setLightness(0.75, 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setLightness(0.2, '#CCCD64')};\n *   background: ${setLightness(0.75, 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#4d4d19\";\n *   background: \"rgba(223,224,159,0.7)\";\n * }\n */\nfunction setLightness(lightness, color) {\n  return toColorString(_extends({}, parseToHsl(color), {\n    lightness: lightness\n  }));\n}\n\nvar curriedSetLightness = /*#__PURE__*/curry(setLightness);\n\n//      \n\n/**\n * Sets the saturation of a color to the provided value. The lightness range can be\n * from 0 and 1.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: setSaturation(0.2, '#CCCD64'),\n *   background: setSaturation(0.75, 'rgba(204,205,100,0.7)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${setSaturation(0.2, '#CCCD64')};\n *   background: ${setSaturation(0.75, 'rgba(204,205,100,0.7)')};\n * `\n *\n * // CSS in JS Output\n * element {\n *   background: \"#adad84\";\n *   background: \"rgba(228,229,76,0.7)\";\n * }\n */\nfunction setSaturation(saturation, color) {\n  return toColorString(_extends({}, parseToHsl(color), {\n    saturation: saturation\n  }));\n}\n\nvar curriedSetSaturation = /*#__PURE__*/curry(setSaturation);\n\n//      \n\n/**\n * Shades a color by mixing it with black. `shade` can produce\n * hue shifts, where as `darken` manipulates the luminance channel and therefore\n * doesn't produce hue shifts.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: shade(0.25, '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${shade(0.25, '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#00003f\";\n * }\n */\n\nfunction shade(percentage, color) {\n  if (typeof percentage !== 'number' || percentage > 1 || percentage < -1) {\n    throw new Error('Passed an incorrect argument to shade, please pass a percentage less than or equal to 1 and larger than or equal to -1.');\n  }\n  if (typeof color !== 'string') {\n    throw new Error('Passed an incorrect argument to a color function, please pass a string representation of a color.');\n  }\n  return curriedMix(percentage, color, 'rgb(0, 0, 0)');\n}\n\nvar curriedShade = /*#__PURE__*/curry(shade);\n\n//      \n\n/**\n * Tints a color by mixing it with white. `tint` can produce\n * hue shifts, where as `lighten` manipulates the luminance channel and therefore\n * doesn't produce hue shifts.\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: tint(0.25, '#00f')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${tint(0.25, '#00f')};\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"#bfbfff\";\n * }\n */\n\nfunction tint(percentage, color) {\n  if (typeof percentage !== 'number' || percentage > 1 || percentage < -1) {\n    throw new Error('Passed an incorrect argument to tint, please pass a percentage less than or equal to 1 and larger than or equal to -1.');\n  }\n  if (typeof color !== 'string') {\n    throw new Error('Passed an incorrect argument to a color function, please pass a string representation of a color.');\n  }\n  return curriedMix(percentage, color, 'rgb(255, 255, 255)');\n}\n\nvar curriedTint = /*#__PURE__*/curry(tint);\n\n//      \n/**\n * Decreases the opacity of a color. Its range for the amount is between 0 to 1.\n *\n *\n * @example\n * // Styles as object usage\n * const styles = {\n *   background: transparentize(0.1, '#fff');\n *   background: transparentize(0.2, 'hsl(0, 0%, 100%)'),\n *   background: transparentize(0.5, 'rgba(255, 0, 0, 0.8)'),\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   background: ${transparentize(0.1, '#fff')};\n *   background: ${transparentize(0.2, 'hsl(0, 0%, 100%)')},\n *   background: ${transparentize(0.5, 'rgba(255, 0, 0, 0.8)')},\n * `\n *\n * // CSS in JS Output\n *\n * element {\n *   background: \"rgba(255,255,255,0.9)\";\n *   background: \"rgba(255,255,255,0.8)\";\n *   background: \"rgba(255,0,0,0.3)\";\n * }\n */\nfunction transparentize(amount, color) {\n  var parsedColor = parseToRgb(color);\n  var alpha = typeof parsedColor.alpha === 'number' ? parsedColor.alpha : 1;\n  var colorWithAlpha = _extends({}, parsedColor, {\n    alpha: guard(0, 1, (alpha * 100 - amount * 100) / 100)\n  });\n  return rgba(colorWithAlpha);\n}\n\nvar curriedTransparentize = /*#__PURE__*/curry(transparentize);\n\n//      \n\n/** */\n\n/**\n * Shorthand for easily setting the animation property. Allows either multiple arrays with animations\n * or a single animation spread over the arguments.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...animation(['rotate', '1s', 'ease-in-out'], ['colorchange', '2s'])\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${animation(['rotate', '1s', 'ease-in-out'], ['colorchange', '2s'])}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'animation': 'rotate 1s ease-in-out, colorchange 2s'\n * }\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...animation('rotate', '1s', 'ease-in-out')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${animation('rotate', '1s', 'ease-in-out')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'animation': 'rotate 1s ease-in-out'\n * }\n */\nfunction animation() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  // Allow single or multiple animations passed\n  var multiMode = Array.isArray(args[0]);\n  if (!multiMode && args.length > 8) {\n    throw new Error('The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation');\n  }\n  var code = args.map(function (arg) {\n    if (multiMode && !Array.isArray(arg) || !multiMode && Array.isArray(arg)) {\n      throw new Error(\"To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\");\n    }\n    if (Array.isArray(arg) && arg.length > 8) {\n      throw new Error('The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation');\n    }\n\n    return Array.isArray(arg) ? arg.join(' ') : arg;\n  }).join(', ');\n\n  return {\n    animation: code\n  };\n}\n\n//      \n\n/**\n * Shorthand that accepts any number of backgroundImage values as parameters for creating a single background statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...backgroundImages('url(\"/image/background.jpg\")', 'linear-gradient(red, green)')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${backgroundImages('url(\"/image/background.jpg\")', 'linear-gradient(red, green)')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'backgroundImage': 'url(\"/image/background.jpg\"), linear-gradient(red, green)'\n * }\n */\n\nfunction backgroundImages() {\n  for (var _len = arguments.length, properties = Array(_len), _key = 0; _key < _len; _key++) {\n    properties[_key] = arguments[_key];\n  }\n\n  return {\n    backgroundImage: properties.join(', ')\n  };\n}\n\n//      \n\n/**\n * Shorthand that accepts any number of background values as parameters for creating a single background statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...backgrounds('url(\"/image/background.jpg\")', 'linear-gradient(red, green)', 'center no-repeat')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${backgrounds('url(\"/image/background.jpg\")', 'linear-gradient(red, green)', 'center no-repeat')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'background': 'url(\"/image/background.jpg\"), linear-gradient(red, green), center no-repeat'\n * }\n */\nfunction backgrounds() {\n  for (var _len = arguments.length, properties = Array(_len), _key = 0; _key < _len; _key++) {\n    properties[_key] = arguments[_key];\n  }\n\n  return {\n    background: properties.join(', ')\n  };\n}\n\n//      \n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderColor('red', 'green', 'blue', 'yellow')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderColor('red', 'green', 'blue', 'yellow')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopColor': 'red',\n *   'borderRightColor': 'green',\n *   'borderBottomColor': 'blue',\n *   'borderLeftColor': 'yellow'\n * }\n */\n\nfunction borderColor() {\n  for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n\n  return directionalProperty.apply(undefined, ['borderColor'].concat(values));\n}\n\n//      \n/**\n * Shorthand that accepts a value for side and a value for radius and applies the radius value to both corners of the side.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderRadius('top', '5px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderRadius('top', '5px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopRightRadius': '5px',\n *   'borderTopLeftRadius': '5px',\n * }\n */\n\nfunction borderRadius(side, radius) {\n  var uppercaseSide = capitalizeString(side);\n  if (!radius && radius !== 0) {\n    throw new Error('borderRadius expects a radius value as a string or number as the second argument.');\n  }\n  if (uppercaseSide === 'Top' || uppercaseSide === 'Bottom') {\n    var _ref;\n\n    return _ref = {}, _ref['border' + uppercaseSide + 'RightRadius'] = radius, _ref['border' + uppercaseSide + 'LeftRadius'] = radius, _ref;\n  }\n\n  if (uppercaseSide === 'Left' || uppercaseSide === 'Right') {\n    var _ref2;\n\n    return _ref2 = {}, _ref2['borderTop' + uppercaseSide + 'Radius'] = radius, _ref2['borderBottom' + uppercaseSide + 'Radius'] = radius, _ref2;\n  }\n\n  throw new Error('borderRadius expects one of \"top\", \"bottom\", \"left\" or \"right\" as the first argument.');\n}\n\n//      \n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderStyle('solid', 'dashed', 'dotted', 'double')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderStyle('solid', 'dashed', 'dotted', 'double')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopStyle': 'solid',\n *   'borderRightStyle': 'dashed',\n *   'borderBottomStyle': 'dotted',\n *   'borderLeftStyle': 'double'\n * }\n */\n\nfunction borderStyle() {\n  for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n\n  return directionalProperty.apply(undefined, ['borderStyle'].concat(values));\n}\n\n//      \n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...borderWidth('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${borderWidth('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'borderTopWidth': '12px',\n *   'borderRightWidth': '24px',\n *   'borderBottomWidth': '36px',\n *   'borderLeftWidth': '48px'\n * }\n */\nfunction borderWidth() {\n  for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n\n  return directionalProperty.apply(undefined, ['borderWidth'].concat(values));\n}\n\n//      \n\n\nfunction generateSelectors(template, state) {\n  var stateSuffix = state ? ':' + state : '';\n  return template(stateSuffix);\n}\n\n/**\n * Function helper that adds an array of states to a template of selectors. Used in textInputs and buttons.\n * @private\n */\nfunction statefulSelectors(states, template, stateMap) {\n  if (!template) throw new Error('You must provide a template to this method.');\n  if (states.length === 0) return generateSelectors(template, null);\n  var selectors = [];\n  for (var i = 0; i < states.length; i += 1) {\n    if (stateMap && stateMap.indexOf(states[i]) < 0) {\n      throw new Error('You passed an unsupported selector state to this method.');\n    }\n    selectors.push(generateSelectors(template, states[i]));\n  }\n  selectors = selectors.join(',');\n  return selectors;\n}\n\n//      \nvar stateMap = [undefined, null, 'active', 'focus', 'hover'];\n\nfunction template(state) {\n  return 'button' + state + ',\\n  input[type=\"button\"]' + state + ',\\n  input[type=\"reset\"]' + state + ',\\n  input[type=\"submit\"]' + state;\n}\n\n/**\n * Populates selectors that target all buttons. You can pass optional states to append to the selectors.\n * @example\n * // Styles as object usage\n * const styles = {\n *   [buttons('active')]: {\n *     'border': 'none'\n *   }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   > ${buttons('active')} {\n *     border: none;\n *   }\n * `\n *\n * // CSS in JS Output\n *\n *  'button:active,\n *  'input[type=\"button\"]:active,\n *  'input[type=\\\"reset\\\"]:active,\n *  'input[type=\\\"submit\\\"]:active: {\n *   'border': 'none'\n * }\n */\n\nfunction buttons() {\n  for (var _len = arguments.length, states = Array(_len), _key = 0; _key < _len; _key++) {\n    states[_key] = arguments[_key];\n  }\n\n  return statefulSelectors(states, template, stateMap);\n}\n\n//      \n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...margin('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${margin('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'marginTop': '12px',\n *   'marginRight': '24px',\n *   'marginBottom': '36px',\n *   'marginLeft': '48px'\n * }\n */\n\nfunction margin() {\n  for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n\n  return directionalProperty.apply(undefined, ['margin'].concat(values));\n}\n\n//      \n/**\n * Shorthand that accepts up to four values, including null to skip a value, and maps them to their respective directions.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...padding('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${padding('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'paddingTop': '12px',\n *   'paddingRight': '24px',\n *   'paddingBottom': '36px',\n *   'paddingLeft': '48px'\n * }\n */\n\nfunction padding() {\n  for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n\n  return directionalProperty.apply(undefined, ['padding'].concat(values));\n}\n\n//      \nvar positionMap$1 = ['absolute', 'fixed', 'relative', 'static', 'sticky'];\n\n/**\n * Shorthand accepts up to five values, including null to skip a value, and maps them to their respective directions. The first value can optionally be a position keyword.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...position('12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${position('12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'top': '12px',\n *   'right': '24px',\n *   'bottom': '36px',\n *   'left': '48px'\n * }\n *\n * // Styles as object usage\n * const styles = {\n *   ...position('absolute', '12px', '24px', '36px', '48px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${position('absolute', '12px', '24px', '36px', '48px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'position': 'absolute',\n *   'top': '12px',\n *   'right': '24px',\n *   'bottom': '36px',\n *   'left': '48px'\n * }\n */\n\nfunction position(positionKeyword) {\n  for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    values[_key - 1] = arguments[_key];\n  }\n\n  if (positionMap$1.indexOf(positionKeyword) >= 0) {\n    return _extends({\n      position: positionKeyword\n    }, directionalProperty.apply(undefined, [''].concat(values)));\n  } else {\n    var firstValue = positionKeyword; // in this case position is actually the first value\n    return directionalProperty.apply(undefined, ['', firstValue].concat(values));\n  }\n}\n\n//      \n\n/**\n * Shorthand to set the height and width properties in a single statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...size('300px', '250px')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${size('300px', '250px')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'height': '300px',\n *   'width': '250px',\n * }\n */\n\nfunction size(height) {\n  var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : height;\n\n  return {\n    height: height,\n    width: width\n  };\n}\n\n//      \nvar stateMap$1 = [undefined, null, 'active', 'focus', 'hover'];\n\nfunction template$1(state) {\n  return 'input[type=\"color\"]' + state + ',\\n    input[type=\"date\"]' + state + ',\\n    input[type=\"datetime\"]' + state + ',\\n    input[type=\"datetime-local\"]' + state + ',\\n    input[type=\"email\"]' + state + ',\\n    input[type=\"month\"]' + state + ',\\n    input[type=\"number\"]' + state + ',\\n    input[type=\"password\"]' + state + ',\\n    input[type=\"search\"]' + state + ',\\n    input[type=\"tel\"]' + state + ',\\n    input[type=\"text\"]' + state + ',\\n    input[type=\"time\"]' + state + ',\\n    input[type=\"url\"]' + state + ',\\n    input[type=\"week\"]' + state + ',\\n    input:not([type])' + state + ',\\n    textarea' + state;\n}\n\n/**\n * Populates selectors that target all text inputs. You can pass optional states to append to the selectors.\n * @example\n * // Styles as object usage\n * const styles = {\n *   [textInputs('active')]: {\n *     'border': 'none'\n *   }\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   > ${textInputs('active')} {\n *     border: none;\n *   }\n * `\n *\n * // CSS in JS Output\n *\n *  'input[type=\"color\"]:active,\n *  input[type=\"date\"]:active,\n *  input[type=\"datetime\"]:active,\n *  input[type=\"datetime-local\"]:active,\n *  input[type=\"email\"]:active,\n *  input[type=\"month\"]:active,\n *  input[type=\"number\"]:active,\n *  input[type=\"password\"]:active,\n *  input[type=\"search\"]:active,\n *  input[type=\"tel\"]:active,\n *  input[type=\"text\"]:active,\n *  input[type=\"time\"]:active,\n *  input[type=\"url\"]:active,\n *  input[type=\"week\"]:active,\n *  input:not([type]):active,\n *  textarea:active': {\n *   'border': 'none'\n * }\n */\n\nfunction textInputs() {\n  for (var _len = arguments.length, states = Array(_len), _key = 0; _key < _len; _key++) {\n    states[_key] = arguments[_key];\n  }\n\n  return statefulSelectors(states, template$1, stateMap$1);\n}\n\n//      \n\n/**\n * Shorthand that accepts any number of transition values as parameters for creating a single transition statement.\n * @example\n * // Styles as object usage\n * const styles = {\n *   ...transitions('opacity 1.0s ease-in 0s', 'width 2.0s ease-in 2s')\n * }\n *\n * // styled-components usage\n * const div = styled.div`\n *   ${transitions('opacity 1.0s ease-in 0s', 'width 2.0s ease-in 2s')}\n * `\n *\n * // CSS as JS Output\n *\n * div {\n *   'transition': 'opacity 1.0s ease-in 0s, width 2.0s ease-in 2s'\n * }\n */\n\nfunction transitions() {\n  for (var _len = arguments.length, properties = Array(_len), _key = 0; _key < _len; _key++) {\n    properties[_key] = arguments[_key];\n  }\n\n  return {\n    transition: properties.join(', ')\n  };\n}\n\n//      \n// Helpers\n// Mixins\n// Color\n// Shorthands\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9saXNoZWQvZGlzdC9wb2xpc2hlZC5lcy5qcz80MzVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vICAgICAgXG5cbi8vIEBwcml2YXRlXG5mdW5jdGlvbiBjYXBpdGFsaXplU3RyaW5nKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufVxuXG4vLyAgICAgIFxudmFyIHBvc2l0aW9uTWFwID0gWydUb3AnLCAnUmlnaHQnLCAnQm90dG9tJywgJ0xlZnQnXTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVQcm9wZXJ0eShwcm9wZXJ0eSwgcG9zaXRpb24pIHtcbiAgaWYgKCFwcm9wZXJ0eSkgcmV0dXJuIHBvc2l0aW9uLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBzcGxpdFByb3BlcnR5ID0gcHJvcGVydHkuc3BsaXQoJy0nKTtcbiAgaWYgKHNwbGl0UHJvcGVydHkubGVuZ3RoID4gMSkge1xuICAgIHNwbGl0UHJvcGVydHkuc3BsaWNlKDEsIDAsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gc3BsaXRQcm9wZXJ0eS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdmFsKSB7XG4gICAgICByZXR1cm4gJycgKyBhY2MgKyBjYXBpdGFsaXplU3RyaW5nKHZhbCk7XG4gICAgfSk7XG4gIH1cbiAgdmFyIGpvaW5lZFByb3BlcnR5ID0gcHJvcGVydHkucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxJyArIHBvc2l0aW9uICsgJyQyJyk7XG4gIHJldHVybiBwcm9wZXJ0eSA9PT0gam9pbmVkUHJvcGVydHkgPyAnJyArIHByb3BlcnR5ICsgcG9zaXRpb24gOiBqb2luZWRQcm9wZXJ0eTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVTdHlsZXMocHJvcGVydHksIHZhbHVlc1dpdGhEZWZhdWx0cykge1xuICB2YXIgc3R5bGVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzV2l0aERlZmF1bHRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKHZhbHVlc1dpdGhEZWZhdWx0c1tpXSB8fCB2YWx1ZXNXaXRoRGVmYXVsdHNbaV0gPT09IDApIHtcbiAgICAgIHN0eWxlc1tnZW5lcmF0ZVByb3BlcnR5KHByb3BlcnR5LCBwb3NpdGlvbk1hcFtpXSldID0gdmFsdWVzV2l0aERlZmF1bHRzW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVzO1xufVxuXG4vKipcbiAqIEEgaGVscGVyIHRoYXQgZW5hYmxlcyBzaG9ydGhhbmQgZm9yIGRpcmVjdGlvbiBiYXNlZCBwcm9wZXJ0aWVzLiBJdCBhY2NlcHRzIGEgcHJvcGVydHkgKGh5cGhlbmF0ZWQgb3IgY2FtZWxDYXNlZCkgYW5kIHVwIHRvIGZvdXIgdmFsdWVzIHRoYXQgbWFwIHRvIHRvcCwgcmlnaHQsIGJvdHRvbSwgYW5kIGxlZnQsIHJlc3BlY3RpdmVseS4gWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYW4gZW1wdHkgc3RyaW5nIHRvIGdldCBvbmx5IHRoZSBkaXJlY3Rpb25hbCB2YWx1ZXMgYXMgcHJvcGVydGllcy4gWW91IGNhbiBhbHNvIG9wdGlvbmFsbHkgcGFzcyBhIG51bGwgYXJndW1lbnQgZm9yIGEgZGlyZWN0aW9uYWwgdmFsdWUgdG8gaWdub3JlIGl0LlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uZGlyZWN0aW9uYWxQcm9wZXJ0eSgncGFkZGluZycsICcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtkaXJlY3Rpb25hbFByb3BlcnR5KCdwYWRkaW5nJywgJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ3BhZGRpbmdUb3AnOiAnMTJweCcsXG4gKiAgICdwYWRkaW5nUmlnaHQnOiAnMjRweCcsXG4gKiAgICdwYWRkaW5nQm90dG9tJzogJzM2cHgnLFxuICogICAncGFkZGluZ0xlZnQnOiAnNDhweCdcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBkaXJlY3Rpb25hbFByb3BlcnR5KHByb3BlcnR5KSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdmFsdWVzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIC8vICBwcmV0dGllci1pZ25vcmVcbiAgdmFyIGZpcnN0VmFsdWUgPSB2YWx1ZXNbMF0sXG4gICAgICBfdmFsdWVzJCA9IHZhbHVlc1sxXSxcbiAgICAgIHNlY29uZFZhbHVlID0gX3ZhbHVlcyQgPT09IHVuZGVmaW5lZCA/IGZpcnN0VmFsdWUgOiBfdmFsdWVzJCxcbiAgICAgIF92YWx1ZXMkMiA9IHZhbHVlc1syXSxcbiAgICAgIHRoaXJkVmFsdWUgPSBfdmFsdWVzJDIgPT09IHVuZGVmaW5lZCA/IGZpcnN0VmFsdWUgOiBfdmFsdWVzJDIsXG4gICAgICBfdmFsdWVzJDMgPSB2YWx1ZXNbM10sXG4gICAgICBmb3VydGhWYWx1ZSA9IF92YWx1ZXMkMyA9PT0gdW5kZWZpbmVkID8gc2Vjb25kVmFsdWUgOiBfdmFsdWVzJDM7XG5cbiAgdmFyIHZhbHVlc1dpdGhEZWZhdWx0cyA9IFtmaXJzdFZhbHVlLCBzZWNvbmRWYWx1ZSwgdGhpcmRWYWx1ZSwgZm91cnRoVmFsdWVdO1xuICByZXR1cm4gZ2VuZXJhdGVTdHlsZXMocHJvcGVydHksIHZhbHVlc1dpdGhEZWZhdWx0cyk7XG59XG5cbi8vICAgICAgXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgZW5kcyB3aXRoIHNvbWV0aGluZ1xuICogQHByaXZhdGVcbiAqL1xudmFyIGVuZHNXaXRoID0gZnVuY3Rpb24gKHN0cmluZywgc3VmZml4KSB7XG4gIHJldHVybiBzdHJpbmcuc3Vic3RyKC1zdWZmaXgubGVuZ3RoKSA9PT0gc3VmZml4O1xufTtcblxuLy8gICAgICBcblxuLyoqXG4gKiBTdHJpcCB0aGUgdW5pdCBmcm9tIGEgZ2l2ZW4gQ1NTIHZhbHVlLCByZXR1cm5pbmcganVzdCB0aGUgbnVtYmVyLiAob3IgdGhlIG9yaWdpbmFsIHZhbHVlIGlmIGFuIGludmFsaWQgc3RyaW5nIHdhcyBwYXNzZWQpXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgJy0tZGltZW5zaW9uJzogc3RyaXBVbml0KCcxMDBweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIC0tZGltZW5zaW9uOiAke3N0cmlwVW5pdCgnMTAwcHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgICctLWRpbWVuc2lvbic6IDEwMFxuICogfVxuICovXG5cbmZ1bmN0aW9uIHN0cmlwVW5pdCh2YWx1ZSkge1xuICB2YXIgdW5pdGxlc3NWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICBpZiAoaXNOYU4odW5pdGxlc3NWYWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgcmV0dXJuIHVuaXRsZXNzVmFsdWU7XG59XG5cbi8vICAgICAgXG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgcGl4ZWwtdG8teCBjb252ZXJ0ZXJzXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgcHh0b0ZhY3RvcnkgPSBmdW5jdGlvbiBweHRvRmFjdG9yeSh0bykge1xuICByZXR1cm4gZnVuY3Rpb24gKHB4dmFsKSB7XG4gICAgdmFyIGJhc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcxNnB4JztcblxuICAgIHZhciBuZXdQeHZhbCA9IHB4dmFsO1xuICAgIHZhciBuZXdCYXNlID0gYmFzZTtcbiAgICBpZiAodHlwZW9mIHB4dmFsID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKCFlbmRzV2l0aChweHZhbCwgJ3B4JykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHN0cmluZyBlbmRpbmcgaW4gXCJweFwiIG9yIGEgbnVtYmVyIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gJyArIHRvICsgJygpLCBnb3QgXCInICsgcHh2YWwgKyAnXCIgaW5zdGVhZC4nKTtcbiAgICAgIH1cbiAgICAgIG5ld1B4dmFsID0gc3RyaXBVbml0KHB4dmFsKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGJhc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoIWVuZHNXaXRoKGJhc2UsICdweCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSBzdHJpbmcgZW5kaW5nIGluIFwicHhcIiBvciBhIG51bWJlciBwYXNzZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byAnICsgdG8gKyAnKCksIGdvdCBcIicgKyBiYXNlICsgJ1wiIGluc3RlYWQuJyk7XG4gICAgICB9XG4gICAgICBuZXdCYXNlID0gc3RyaXBVbml0KGJhc2UpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3UHh2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bhc3NlZCBpbnZhbGlkIHBpeGVsIHZhbHVlIChcIicgKyBweHZhbCArICdcIikgdG8gJyArIHRvICsgJygpLCBwbGVhc2UgcGFzcyBhIHZhbHVlIGxpa2UgXCIxMnB4XCIgb3IgMTIuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdCYXNlID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXNzZWQgaW52YWxpZCBiYXNlIHZhbHVlIChcIicgKyBiYXNlICsgJ1wiKSB0byAnICsgdG8gKyAnKCksIHBsZWFzZSBwYXNzIGEgdmFsdWUgbGlrZSBcIjEycHhcIiBvciAxMi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJycgKyBuZXdQeHZhbCAvIG5ld0Jhc2UgKyB0bztcbiAgfTtcbn07XG5cbi8vICAgICAgXG4vKipcbiAqIENvbnZlcnQgcGl4ZWwgdmFsdWUgdG8gZW1zLiBUaGUgZGVmYXVsdCBiYXNlIHZhbHVlIGlzIDE2cHgsIGJ1dCBjYW4gYmUgY2hhbmdlZCBieSBwYXNzaW5nIGFcbiAqIHNlY29uZCBhcmd1bWVudCB0byB0aGUgZnVuY3Rpb24uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gcHh2YWxcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2Jhc2U9JzE2cHgnXVxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgJ2hlaWdodCc6IGVtKCcxNnB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgaGVpZ2h0OiAke2VtKCcxNnB4Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICAnaGVpZ2h0JzogJzFlbSdcbiAqIH1cbiAqL1xuXG52YXIgZW0gPSAvKiNfX1BVUkVfXyovcHh0b0ZhY3RvcnkoJ2VtJyk7XG5cbi8vICAgICAgXG5cbnZhciByYXRpb05hbWVzID0ge1xuICBtaW5vclNlY29uZDogMS4wNjcsXG4gIG1ham9yU2Vjb25kOiAxLjEyNSxcbiAgbWlub3JUaGlyZDogMS4yLFxuICBtYWpvclRoaXJkOiAxLjI1LFxuICBwZXJmZWN0Rm91cnRoOiAxLjMzMyxcbiAgYXVnRm91cnRoOiAxLjQxNCxcbiAgcGVyZmVjdEZpZnRoOiAxLjUsXG4gIG1pbm9yU2l4dGg6IDEuNixcbiAgZ29sZGVuU2VjdGlvbjogMS42MTgsXG4gIG1ham9yU2l4dGg6IDEuNjY3LFxuICBtaW5vclNldmVudGg6IDEuNzc4LFxuICBtYWpvclNldmVudGg6IDEuODc1LFxuICBvY3RhdmU6IDIsXG4gIG1ham9yVGVudGg6IDIuNSxcbiAgbWFqb3JFbGV2ZW50aDogMi42NjcsXG4gIG1ham9yVHdlbGZ0aDogMyxcbiAgZG91YmxlT2N0YXZlOiA0XG59O1xuXG4vKiogKi9cblxuLyoqXG4gKiBFc3RhYmxpc2ggY29uc2lzdGVudCBtZWFzdXJlbWVudHMgYW5kIHNwYWNpYWwgcmVsYXRpb25zaGlwcyB0aHJvdWdob3V0IHlvdXIgcHJvamVjdHMgYnkgaW5jcmVtZW50aW5nIHVwIG9yIGRvd24gYSBkZWZpbmVkIHNjYWxlLiBXZSBwcm92aWRlIGEgbGlzdCBvZiBjb21tb25seSB1c2VkIHNjYWxlcyBhcyBwcmUtZGVmaW5lZCB2YXJpYWJsZXMsIHNlZSBiZWxvdy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICAvLyBJbmNyZW1lbnQgdHdvIHN0ZXBzIHVwIHRoZSBkZWZhdWx0IHNjYWxlXG4gKiAgICdmb250U2l6ZSc6IG1vZHVsYXJTY2FsZSgyKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAgLy8gSW5jcmVtZW50IHR3byBzdGVwcyB1cCB0aGUgZGVmYXVsdCBzY2FsZVxuICogICBmb250U2l6ZTogJHttb2R1bGFyU2NhbGUoMil9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICAnZm9udFNpemUnOiAnMS43NzY4OWVtJ1xuICogfVxuICovXG5mdW5jdGlvbiBtb2R1bGFyU2NhbGUoc3RlcHMpIHtcbiAgdmFyIGJhc2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcxZW0nO1xuICB2YXIgcmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdwZXJmZWN0Rm91cnRoJztcblxuICBpZiAodHlwZW9mIHN0ZXBzICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgYSBudW1iZXIgb2Ygc3RlcHMgdG8gdGhlIG1vZHVsYXJTY2FsZSBoZWxwZXIuJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiByYXRpbyA9PT0gJ3N0cmluZycgJiYgIXJhdGlvTmFtZXNbcmF0aW9dKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcGFzcyBhIG51bWJlciBvciBvbmUgb2YgdGhlIHByZWRlZmluZWQgc2NhbGVzIHRvIHRoZSBtb2R1bGFyU2NhbGUgaGVscGVyIGFzIHRoZSByYXRpby4nKTtcbiAgfVxuXG4gIHZhciByZWFsQmFzZSA9IHR5cGVvZiBiYXNlID09PSAnc3RyaW5nJyA/IHN0cmlwVW5pdChiYXNlKSA6IGJhc2U7XG4gIHZhciByZWFsUmF0aW8gPSB0eXBlb2YgcmF0aW8gPT09ICdzdHJpbmcnID8gcmF0aW9OYW1lc1tyYXRpb10gOiByYXRpbztcblxuICBpZiAodHlwZW9mIHJlYWxCYXNlID09PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSBwYXNzZWQgYXMgYmFzZSB0byBtb2R1bGFyU2NhbGUsIGV4cGVjdGVkIG51bWJlciBvciBlbSBzdHJpbmcgYnV0IGdvdCBcIicgKyBiYXNlICsgJ1wiJyk7XG4gIH1cblxuICByZXR1cm4gcmVhbEJhc2UgKiBNYXRoLnBvdyhyZWFsUmF0aW8sIHN0ZXBzKSArICdlbSc7XG59XG5cbi8vICAgICAgXG5cbi8qKlxuICogQ29udmVydCBwaXhlbCB2YWx1ZSB0byByZW1zLiBUaGUgZGVmYXVsdCBiYXNlIHZhbHVlIGlzIDE2cHgsIGJ1dCBjYW4gYmUgY2hhbmdlZCBieSBwYXNzaW5nIGFcbiAqIHNlY29uZCBhcmd1bWVudCB0byB0aGUgZnVuY3Rpb24uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gcHh2YWxcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW2Jhc2U9JzE2cHgnXVxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgJ2hlaWdodCc6IHJlbSgnMTZweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGhlaWdodDogJHtyZW0oJzE2cHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgICdoZWlnaHQnOiAnMXJlbSdcbiAqIH1cbiAqL1xuXG52YXIgcmVtID0gLyojX19QVVJFX18qL3B4dG9GYWN0b3J5KCdyZW0nKTtcblxuLy8gICAgICBcblxuLyoqXG4gKiBDU1MgdG8gY29udGFpbiBhIGZsb2F0IChjcmVkaXQgdG8gQ1NTTW9qbykuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgIC4uLmNsZWFyRml4KCksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7Y2xlYXJGaXgoKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogJyY6OmFmdGVyJzoge1xuICogICAnY2xlYXInOiAnYm90aCcsXG4gKiAgICdjb250ZW50JzogJ1wiXCInLFxuICogICAnZGlzcGxheSc6ICd0YWJsZSdcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBjbGVhckZpeCgpIHtcbiAgdmFyIF9yZWY7XG5cbiAgdmFyIHBhcmVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyYnO1xuXG4gIHZhciBwc2V1ZG9TZWxlY3RvciA9IHBhcmVudCArICc6OmFmdGVyJztcbiAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltwc2V1ZG9TZWxlY3Rvcl0gPSB7XG4gICAgY2xlYXI6ICdib3RoJyxcbiAgICBjb250ZW50OiAnXCJcIicsXG4gICAgZGlzcGxheTogJ3RhYmxlJ1xuICB9LCBfcmVmO1xufVxuXG4vLyAgICAgIFxuXG4vKipcbiAqIENTUyB0byByZXByZXNlbnQgdHJ1bmNhdGVkIHRleHQgd2l0aCBhbiBlbGxpcHNpcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5lbGxpcHNpcygnMjUwcHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2VsbGlwc2lzKCcyNTBweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXY6IHtcbiAqICAgJ2Rpc3BsYXknOiAnaW5saW5lLWJsb2NrJyxcbiAqICAgJ21heFdpZHRoJzogJzI1MHB4JyxcbiAqICAgJ292ZXJmbG93JzogJ2hpZGRlbicsXG4gKiAgICd0ZXh0T3ZlcmZsb3cnOiAnZWxsaXBzaXMnLFxuICogICAnd2hpdGVTcGFjZSc6ICdub3dyYXAnLFxuICogICAnd29yZFdyYXAnOiAnbm9ybWFsJ1xuICogfVxuICovXG5cbmZ1bmN0aW9uIGVsbGlwc2lzKCkge1xuICB2YXIgd2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICcxMDAlJztcblxuICByZXR1cm4ge1xuICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgIG1heFdpZHRoOiB3aWR0aCxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnLFxuICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIHdvcmRXcmFwOiAnbm9ybWFsJ1xuICB9O1xufVxuXG4vLyAgICAgIFxuXG4vKiogKi9cblxuZnVuY3Rpb24gZ2VuZXJhdGVGaWxlUmVmZXJlbmNlcyhmb250RmlsZVBhdGgsIGZpbGVGb3JtYXRzKSB7XG4gIHZhciBmaWxlRm9udFJlZmVyZW5jZXMgPSBmaWxlRm9ybWF0cy5tYXAoZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiAndXJsKFwiJyArIGZvbnRGaWxlUGF0aCArICcuJyArIGZvcm1hdCArICdcIiknO1xuICB9KTtcbiAgcmV0dXJuIGZpbGVGb250UmVmZXJlbmNlcy5qb2luKCcsICcpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUxvY2FsUmVmZXJlbmNlcyhsb2NhbEZvbnRzKSB7XG4gIHZhciBsb2NhbEZvbnRSZWZlcmVuY2VzID0gbG9jYWxGb250cy5tYXAoZnVuY3Rpb24gKGZvbnQpIHtcbiAgICByZXR1cm4gJ2xvY2FsKFwiJyArIGZvbnQgKyAnXCIpJztcbiAgfSk7XG4gIHJldHVybiBsb2NhbEZvbnRSZWZlcmVuY2VzLmpvaW4oJywgJyk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU291cmNlcyhmb250RmlsZVBhdGgsIGxvY2FsRm9udHMsIGZpbGVGb3JtYXRzKSB7XG4gIHZhciBmb250UmVmZXJlbmNlcyA9IFtdO1xuICBpZiAobG9jYWxGb250cykgZm9udFJlZmVyZW5jZXMucHVzaChnZW5lcmF0ZUxvY2FsUmVmZXJlbmNlcyhsb2NhbEZvbnRzKSk7XG4gIGlmIChmb250RmlsZVBhdGgpIHtcbiAgICBmb250UmVmZXJlbmNlcy5wdXNoKGdlbmVyYXRlRmlsZVJlZmVyZW5jZXMoZm9udEZpbGVQYXRoLCBmaWxlRm9ybWF0cykpO1xuICB9XG4gIHJldHVybiBmb250UmVmZXJlbmNlcy5qb2luKCcsICcpO1xufVxuXG4vKipcbiAqIENTUyBmb3IgYSBAZm9udC1mYWNlIGRlY2xhcmF0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IGJhc2ljIHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICAuLi5mb250RmFjZSh7XG4gKiAgICAgICdmb250RmFtaWx5JzogJ1NhbnMtUHJvJ1xuICogICAgICAnZm9udEZpbGVQYXRoJzogJ3BhdGgvdG8vZmlsZSdcbiAqICAgIH0pXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgYmFzaWMgdXNhZ2VcbiAqIGluamVjdEdsb2JhbGAke1xuICogICBmb250RmFjZSh7XG4gKiAgICAgJ2ZvbnRGYW1pbHknOiAnU2Fucy1Qcm8nXG4gKiAgICAgJ2ZvbnRGaWxlUGF0aCc6ICdwYXRoL3RvL2ZpbGUnXG4gKiAgIH1cbiAqICl9YFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiAnQGZvbnQtZmFjZSc6IHtcbiAqICAgJ2ZvbnRGYW1pbHknOiAnU2Fucy1Qcm8nLFxuICogICAnc3JjJzogJ3VybChcInBhdGgvdG8vZmlsZS5lb3RcIiksIHVybChcInBhdGgvdG8vZmlsZS53b2ZmMlwiKSwgdXJsKFwicGF0aC90by9maWxlLndvZmZcIiksIHVybChcInBhdGgvdG8vZmlsZS50dGZcIiksIHVybChcInBhdGgvdG8vZmlsZS5zdmdcIiknLFxuICogfVxuICovXG5cbmZ1bmN0aW9uIGZvbnRGYWNlKF9yZWYpIHtcbiAgdmFyIGZvbnRGYW1pbHkgPSBfcmVmLmZvbnRGYW1pbHksXG4gICAgICBmb250RmlsZVBhdGggPSBfcmVmLmZvbnRGaWxlUGF0aCxcbiAgICAgIGZvbnRTdHJldGNoID0gX3JlZi5mb250U3RyZXRjaCxcbiAgICAgIGZvbnRTdHlsZSA9IF9yZWYuZm9udFN0eWxlLFxuICAgICAgZm9udFZhcmlhbnQgPSBfcmVmLmZvbnRWYXJpYW50LFxuICAgICAgZm9udFdlaWdodCA9IF9yZWYuZm9udFdlaWdodCxcbiAgICAgIF9yZWYkZmlsZUZvcm1hdHMgPSBfcmVmLmZpbGVGb3JtYXRzLFxuICAgICAgZmlsZUZvcm1hdHMgPSBfcmVmJGZpbGVGb3JtYXRzID09PSB1bmRlZmluZWQgPyBbJ2VvdCcsICd3b2ZmMicsICd3b2ZmJywgJ3R0ZicsICdzdmcnXSA6IF9yZWYkZmlsZUZvcm1hdHMsXG4gICAgICBsb2NhbEZvbnRzID0gX3JlZi5sb2NhbEZvbnRzLFxuICAgICAgdW5pY29kZVJhbmdlID0gX3JlZi51bmljb2RlUmFuZ2U7XG5cbiAgLy8gRXJyb3IgSGFuZGxpbmdcbiAgaWYgKCFmb250RmFtaWx5KSB0aHJvdyBuZXcgRXJyb3IoJ2ZvbnRGYWNlIGV4cGVjdHMgYSBuYW1lIG9mIGEgZm9udC1mYW1pbHkuJyk7XG4gIGlmICghZm9udEZpbGVQYXRoICYmICFsb2NhbEZvbnRzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmb250RmFjZSBleHBlY3RzIGVpdGhlciB0aGUgcGF0aCB0byB0aGUgZm9udCBmaWxlKHMpIG9yIGEgbmFtZSBvZiBhIGxvY2FsIGNvcHkuJyk7XG4gIH1cbiAgaWYgKGxvY2FsRm9udHMgJiYgIUFycmF5LmlzQXJyYXkobG9jYWxGb250cykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZvbnRGYWNlIGV4cGVjdHMgbG9jYWxGb250cyB0byBiZSBhbiBhcnJheS4nKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsZUZvcm1hdHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmb250RmFjZSBleHBlY3RzIGZpbGVGb3JtYXRzIHRvIGJlIGFuIGFycmF5LicpO1xuICB9XG5cbiAgdmFyIGZvbnRGYWNlRGVjbGFyYXRpb24gPSB7XG4gICAgJ0Bmb250LWZhY2UnOiB7XG4gICAgICBmb250RmFtaWx5OiBmb250RmFtaWx5LFxuICAgICAgc3JjOiBnZW5lcmF0ZVNvdXJjZXMoZm9udEZpbGVQYXRoLCBsb2NhbEZvbnRzLCBmaWxlRm9ybWF0cyksXG4gICAgICB1bmljb2RlUmFuZ2U6IHVuaWNvZGVSYW5nZSxcbiAgICAgIGZvbnRTdHJldGNoOiBmb250U3RyZXRjaCxcbiAgICAgIGZvbnRTdHlsZTogZm9udFN0eWxlLFxuICAgICAgZm9udFZhcmlhbnQ6IGZvbnRWYXJpYW50LFxuICAgICAgZm9udFdlaWdodDogZm9udFdlaWdodFxuICAgIH1cbiAgfTtcblxuICAvLyBSZW1vdmVzIHVuZGVmaW5lZCBmaWVsZHMgZm9yIGNsZWFuZXIgY3NzIG9iamVjdC5cbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZm9udEZhY2VEZWNsYXJhdGlvbikpO1xufVxuXG4vLyAgICAgIFxuXG4vKipcbiAqIENTUyB0byBoaWRlIHRleHQgdG8gc2hvdyBhIGJhY2tncm91bmQgaW1hZ2UgaW4gYSBTRU8tZnJpZW5kbHkgd2F5LlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICdiYWNrZ3JvdW5kSW1hZ2UnOiAndXJsKGxvZ28ucG5nKScsXG4gKiAgIC4uLmhpZGVUZXh0KCksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmRJbWFnZTogdXJsKGxvZ28ucG5nKTtcbiAqICAgJHtoaWRlVGV4dCgpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogJ2Rpdic6IHtcbiAqICAgJ2JhY2tncm91bmRJbWFnZSc6ICd1cmwobG9nby5wbmcpJyxcbiAqICAgJ3RleHRJbmRlbnQnOiAnMTAxJScsXG4gKiAgICdvdmVyZmxvdyc6ICdoaWRkZW4nLFxuICogICAnd2hpdGVTcGFjZSc6ICdub3dyYXAnLFxuICogfVxuICovXG5cbmZ1bmN0aW9uIGhpZGVUZXh0KCkge1xuICByZXR1cm4ge1xuICAgIHRleHRJbmRlbnQ6ICcxMDElJyxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgd2hpdGVTcGFjZTogJ25vd3JhcCdcbiAgfTtcbn1cblxuLy8gICAgICBcblxuLyoqXG4gKiBDU1MgdG8gaGlkZSBjb250ZW50IHZpc3VhbGx5IGJ1dCByZW1haW4gYWNjZXNzaWJsZSB0byBzY3JlZW4gcmVhZGVycy5cbiAqIGZyb20gW0hUTUw1IEJvaWxlcnBsYXRlXShodHRwczovL2dpdGh1Yi5jb20vaDVicC9odG1sNS1ib2lsZXJwbGF0ZS9ibG9iLzlhMTc2ZjU3YWYxY2ZlOGVjNzAzMDBkYTQ2MjFmYjliMDdlNWZhMzEvc3JjL2Nzcy9tYWluLmNzcyNMMTIxKVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmhpZGVWaXN1YWxseSgpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2hpZGVWaXN1YWxseSgpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogJ2Rpdic6IHtcbiAqICAgJ2JvcmRlcic6ICcwJyxcbiAqICAgJ2NsaXAnOiAncmVjdCgwIDAgMCAwKScsXG4gKiAgICdjbGlwUGF0aCc6ICdpbnNldCg1MCUpJyxcbiAqICAgJ2hlaWdodCc6ICcxcHgnLFxuICogICAnbWFyZ2luJzogJy0xcHgnLFxuICogICAnb3ZlcmZsb3cnOiAnaGlkZGVuJyxcbiAqICAgJ3BhZGRpbmcnOiAnMCcsXG4gKiAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gKiAgICd3aGl0ZVNwYWNlJzogJ25vd3JhcCcsXG4gKiAgICd3aWR0aCc6ICcxcHgnLFxuICogfVxuICovXG5cbmZ1bmN0aW9uIGhpZGVWaXN1YWxseSgpIHtcbiAgcmV0dXJuIHtcbiAgICBib3JkZXI6ICcwJyxcbiAgICBjbGlwOiAncmVjdCgwIDAgMCAwKScsXG4gICAgY2xpcFBhdGg6ICdpbnNldCg1MCUpJyxcbiAgICBoZWlnaHQ6ICcxcHgnLFxuICAgIG1hcmdpbjogJy0xcHgnLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICBwYWRkaW5nOiAnMCcsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgd2lkdGg6ICcxcHgnXG4gIH07XG59XG5cbi8vICAgICAgXG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbWVkaWEgcXVlcnkgdG8gdGFyZ2V0IEhpRFBJIGRldmljZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICBbaGlEUEkoMS41KV06IHtcbiAqICAgIHdpZHRoOiAyMDBweDtcbiAqICB9XG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7aGlEUEkoMS41KX0ge1xuICogICAgIHdpZHRoOiAyMDBweDtcbiAqICAgfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiAnQG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAxLjUpLFxuICogIG9ubHkgc2NyZWVuIGFuZCAobWluLS1tb3otZGV2aWNlLXBpeGVsLXJhdGlvOiAxLjUpLFxuICogIG9ubHkgc2NyZWVuIGFuZCAoLW8tbWluLWRldmljZS1waXhlbC1yYXRpbzogMS41LzEpLFxuICogIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDE0NGRwaSksXG4gKiAgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMS41ZHBweCknOiB7XG4gKiAgICd3aWR0aCc6ICcyMDBweCcsXG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gaGlEUEkoKSB7XG4gIHZhciByYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMS4zO1xuXG4gIHJldHVybiBcIlxcbiAgICBAbWVkaWEgb25seSBzY3JlZW4gYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IFwiICsgcmF0aW8gKyBcIiksXFxuICAgIG9ubHkgc2NyZWVuIGFuZCAobWluLS1tb3otZGV2aWNlLXBpeGVsLXJhdGlvOiBcIiArIHJhdGlvICsgXCIpLFxcbiAgICBvbmx5IHNjcmVlbiBhbmQgKC1vLW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IFwiICsgcmF0aW8gKyBcIi8xKSxcXG4gICAgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogXCIgKyBNYXRoLnJvdW5kKHJhdGlvICogOTYpICsgXCJkcGkpLFxcbiAgICBvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiBcIiArIHJhdGlvICsgXCJkcHB4KVxcbiAgXCI7XG59XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciB0YWdnZWRUZW1wbGF0ZUxpdGVyYWxMb29zZSA9IGZ1bmN0aW9uIChzdHJpbmdzLCByYXcpIHtcbiAgc3RyaW5ncy5yYXcgPSByYXc7XG4gIHJldHVybiBzdHJpbmdzO1xufTtcblxudmFyIF9vcGluaW9uYXRlZFJ1bGVzO1xudmFyIF9hYmJyVGl0bGU7XG52YXIgX3Vub3BpbmlvbmF0ZWRSdWxlcztcblxuLy8gICAgICBcbnZhciBvcGluaW9uYXRlZFJ1bGVzID0gKF9vcGluaW9uYXRlZFJ1bGVzID0ge1xuICBodG1sOiB7XG4gICAgZm9udEZhbWlseTogJ3NhbnMtc2VyaWYnXG4gIH0sXG5cbiAgYm9keToge1xuICAgIG1hcmdpbjogJzAnXG4gIH1cblxufSwgX29waW5pb25hdGVkUnVsZXNbJ2E6YWN0aXZlLFxcbiAgYTpob3ZlciddID0ge1xuICBvdXRsaW5lV2lkdGg6ICcwJ1xufSwgX29waW5pb25hdGVkUnVsZXNbJ2J1dHRvbixcXG4gIGlucHV0LFxcbiAgb3B0Z3JvdXAsXFxuICBzZWxlY3QsXFxuICB0ZXh0YXJlYSddID0ge1xuICBmb250RmFtaWx5OiAnc2Fucy1zZXJpZicsXG4gIGZvbnRTaXplOiAnMTAwJScsXG4gIGxpbmVIZWlnaHQ6ICcxLjE1J1xufSwgX29waW5pb25hdGVkUnVsZXMpO1xuXG52YXIgdW5vcGluaW9uYXRlZFJ1bGVzID0gKF91bm9waW5pb25hdGVkUnVsZXMgPSB7XG4gIGh0bWw6IHtcbiAgICBsaW5lSGVpZ2h0OiAnMS4xNScsXG4gICAgdGV4dFNpemVBZGp1c3Q6ICcxMDAlJ1xuICB9XG5cbn0sIF91bm9waW5pb25hdGVkUnVsZXNbJ2FydGljbGUsXFxuICBhc2lkZSxcXG4gIGZvb3RlcixcXG4gIGhlYWRlcixcXG4gIG5hdixcXG4gIHNlY3Rpb24nXSA9IHtcbiAgZGlzcGxheTogJ2Jsb2NrJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlcy5oMSA9IHtcbiAgZm9udFNpemU6ICcyZW0nLFxuICBtYXJnaW46ICcwLjY3ZW0gMCdcbn0sIF91bm9waW5pb25hdGVkUnVsZXNbJ2ZpZ2NhcHRpb24sXFxuICBmaWd1cmUsXFxuICBtYWluJ10gPSB7XG4gIGRpc3BsYXk6ICdibG9jaydcbn0sIF91bm9waW5pb25hdGVkUnVsZXMuZmlndXJlID0ge1xuICBtYXJnaW46ICcxZW0gNDBweCdcbn0sIF91bm9waW5pb25hdGVkUnVsZXMuaHIgPSB7XG4gIGJveFNpemluZzogJ2NvbnRlbnQtYm94JyxcbiAgaGVpZ2h0OiAnMCcsXG4gIG92ZXJmbG93OiAndmlzaWJsZSdcbn0sIF91bm9waW5pb25hdGVkUnVsZXMucHJlID0ge1xuICBmb250RmFtaWx5OiAnbW9ub3NwYWNlLCBtb25vc3BhY2UnLFxuICBmb250U2l6ZTogJzFlbSdcbn0sIF91bm9waW5pb25hdGVkUnVsZXMuYSA9IHtcbiAgJ2JhY2tncm91bmQtY29sb3InOiAndHJhbnNwYXJlbnQnLFxuICAnLXdlYmtpdC10ZXh0LWRlY29yYXRpb24tc2tpcCc6ICdvYmplY3RzJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlc1snYWJiclt0aXRsZV0nXSA9IChfYWJiclRpdGxlID0ge1xuICBib3JkZXJCb3R0b206ICdub25lJyxcbiAgdGV4dERlY29yYXRpb246ICd1bmRlcmxpbmUnXG59LCBfYWJiclRpdGxlWyd0ZXh0RGVjb3JhdGlvbiddID0gJ3VuZGVybGluZSBkb3R0ZWQnLCBfYWJiclRpdGxlKSwgX3Vub3BpbmlvbmF0ZWRSdWxlc1snYixcXG4gIHN0cm9uZyddID0ge1xuICBmb250V2VpZ2h0OiAnaW5oZXJpdCdcbn0sIF91bm9waW5pb25hdGVkUnVsZXNbJ2NvZGUsXFxuICBrYmQsXFxuICBzYW1wJ10gPSB7XG4gIGZvbnRGYW1pbHk6ICdtb25vc3BhY2UsIG1vbm9zcGFjZScsXG4gIGZvbnRTaXplOiAnMWVtJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlcy5kZm4gPSB7XG4gIGZvbnRTdHlsZTogJ2l0YWxpYydcbn0sIF91bm9waW5pb25hdGVkUnVsZXMubWFyayA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnI2ZmMCcsXG4gIGNvbG9yOiAnIzAwMCdcbn0sIF91bm9waW5pb25hdGVkUnVsZXMuc21hbGwgPSB7XG4gIGZvbnRTaXplOiAnODAlJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlc1snc3ViLFxcbiAgc3VwJ10gPSB7XG4gIGZvbnRTaXplOiAnNzUlJyxcbiAgbGluZUhlaWdodDogJzAnLFxuICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgdmVydGljYWxBbGlnbjogJ2Jhc2VsaW5lJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlcy5zdWIgPSB7XG4gIGJvdHRvbTogJy0wLjI1ZW0nXG59LCBfdW5vcGluaW9uYXRlZFJ1bGVzLnN1cCA9IHtcbiAgdG9wOiAnLTAuNWVtJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlc1snYXVkaW8sXFxuICB2aWRlbyddID0ge1xuICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlc1snYXVkaW86bm90KFtjb250cm9sc10pJ10gPSB7XG4gIGRpc3BsYXk6ICdub25lJyxcbiAgaGVpZ2h0OiAnMCdcbn0sIF91bm9waW5pb25hdGVkUnVsZXMuaW1nID0ge1xuICBib3JkZXJTdHlsZTogJ25vbmUnXG59LCBfdW5vcGluaW9uYXRlZFJ1bGVzWydzdmc6bm90KDpyb290KSddID0ge1xuICBvdmVyZmxvdzogJ2hpZGRlbidcbn0sIF91bm9waW5pb25hdGVkUnVsZXNbJ2J1dHRvbixcXG4gIGlucHV0LFxcbiAgb3B0Z3JvdXAsXFxuICBzZWxlY3QsXFxuICB0ZXh0YXJlYSddID0ge1xuICBtYXJnaW46ICcwJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlc1snYnV0dG9uLFxcbiAgaW5wdXQnXSA9IHtcbiAgb3ZlcmZsb3c6ICd2aXNpYmxlJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlc1snYnV0dG9uLFxcbiAgc2VsZWN0J10gPSB7XG4gIHRleHRUcmFuc2Zvcm06ICdub25lJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlc1snYnV0dG9uLFxcbiAgaHRtbCBbdHlwZT1cImJ1dHRvblwiXSxcXG4gIFt0eXBlPVwicmVzZXRcIl0sXFxuICBbdHlwZT1cInN1Ym1pdFwiXSddID0ge1xuICAnLXdlYmtpdC1hcHBlYXJhbmNlJzogJ2J1dHRvbidcbn0sIF91bm9waW5pb25hdGVkUnVsZXNbJ2J1dHRvbjo6LW1vei1mb2N1cy1pbm5lcixcXG4gIFt0eXBlPVwiYnV0dG9uXCJdOjotbW96LWZvY3VzLWlubmVyLFxcbiAgW3R5cGU9XCJyZXNldFwiXTo6LW1vei1mb2N1cy1pbm5lcixcXG4gIFt0eXBlPVwic3VibWl0XCJdOjotbW96LWZvY3VzLWlubmVyJ10gPSB7XG4gIGJvcmRlclN0eWxlOiAnbm9uZScsXG4gIHBhZGRpbmc6ICcwJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlc1snYnV0dG9uOi1tb3otZm9jdXNyaW5nLFxcbiAgW3R5cGU9XCJidXR0b25cIl06LW1vei1mb2N1c3JpbmcsXFxuICBbdHlwZT1cInJlc2V0XCJdOi1tb3otZm9jdXNyaW5nLFxcbiAgW3R5cGU9XCJzdWJtaXRcIl06LW1vei1mb2N1c3JpbmcnXSA9IHtcbiAgb3V0bGluZTogJzFweCBkb3R0ZWQgQnV0dG9uVGV4dCdcbn0sIF91bm9waW5pb25hdGVkUnVsZXMuZmllbGRzZXQgPSB7XG4gIGJvcmRlcjogJzFweCBzb2xpZCAjYzBjMGMwJyxcbiAgbWFyZ2luOiAnMCAycHgnLFxuICBwYWRkaW5nOiAnMC4zNWVtIDAuNjI1ZW0gMC43NWVtJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlcy5sZWdlbmQgPSB7XG4gIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICBjb2xvcjogJ2luaGVyaXQnLFxuICBkaXNwbGF5OiAndGFibGUnLFxuICBtYXhXaWR0aDogJzEwMCUnLFxuICBwYWRkaW5nOiAnMCcsXG4gIHdoaXRlU3BhY2U6ICdub3JtYWwnXG59LCBfdW5vcGluaW9uYXRlZFJ1bGVzLnByb2dyZXNzID0ge1xuICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgdmVydGljYWxBbGlnbjogJ2Jhc2VsaW5lJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlcy50ZXh0YXJlYSA9IHtcbiAgb3ZlcmZsb3c6ICdhdXRvJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlc1snW3R5cGU9XCJjaGVja2JveFwiXSxcXG4gIFt0eXBlPVwicmFkaW9cIl0nXSA9IHtcbiAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gIHBhZGRpbmc6ICcwJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlc1snW3R5cGU9XCJudW1iZXJcIl06Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXFxuICBbdHlwZT1cIm51bWJlclwiXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiddID0ge1xuICBoZWlnaHQ6ICdhdXRvJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlc1snW3R5cGU9XCJzZWFyY2hcIl0nXSA9IHtcbiAgJy13ZWJraXQtYXBwZWFyYW5jZSc6ICd0ZXh0ZmllbGQnLFxuICBvdXRsaW5lT2Zmc2V0OiAnLTJweCdcbn0sIF91bm9waW5pb25hdGVkUnVsZXNbJ1t0eXBlPVwic2VhcmNoXCJdOjotd2Via2l0LXNlYXJjaC1jYW5jZWwtYnV0dG9uLFxcbiAgW3R5cGU9XCJzZWFyY2hcIl06Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24nXSA9IHtcbiAgJy13ZWJraXQtYXBwZWFyYW5jZSc6ICdub25lJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlc1snOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiddID0ge1xuICAnLXdlYmtpdC1hcHBlYXJhbmNlJzogJ2J1dHRvbicsXG4gIGZvbnQ6ICdpbmhlcml0J1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlc1snZGV0YWlscyxcXG4gIG1lbnUnXSA9IHtcbiAgZGlzcGxheTogJ2Jsb2NrJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlcy5zdW1tYXJ5ID0ge1xuICBkaXNwbGF5OiAnbGlzdC1pdGVtJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlcy5jYW52YXMgPSB7XG4gIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snXG59LCBfdW5vcGluaW9uYXRlZFJ1bGVzLnRlbXBsYXRlID0ge1xuICBkaXNwbGF5OiAnbm9uZSdcbn0sIF91bm9waW5pb25hdGVkUnVsZXNbJ1toaWRkZW5dJ10gPSB7XG4gIGRpc3BsYXk6ICdub25lJ1xufSwgX3Vub3BpbmlvbmF0ZWRSdWxlcyk7XG5cbmZ1bmN0aW9uIG1lcmdlUnVsZXMoYmFzZVJ1bGVzLCBhZGRpdGlvbmFsUnVsZXMpIHtcbiAgdmFyIG1lcmdlZFJ1bGVzID0gX2V4dGVuZHMoe30sIGJhc2VSdWxlcyk7XG4gIE9iamVjdC5rZXlzKGFkZGl0aW9uYWxSdWxlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKG1lcmdlZFJ1bGVzW2tleV0pIHtcbiAgICAgIG1lcmdlZFJ1bGVzW2tleV0gPSBfZXh0ZW5kcyh7fSwgbWVyZ2VkUnVsZXNba2V5XSwgYWRkaXRpb25hbFJ1bGVzW2tleV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZWRSdWxlc1trZXldID0gX2V4dGVuZHMoe30sIGFkZGl0aW9uYWxSdWxlc1trZXldKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWVyZ2VkUnVsZXM7XG59XG5cbi8qKlxuICogQ1NTIHRvIG5vcm1hbGl6ZSBhYm5vcm1hbGl0aWVzIGFjcm9zcyBicm93c2VycyAobm9ybWFsaXplLmNzcyB2NS4wLjAgfCBNSVQgTGljZW5zZSB8IGdpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzKVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgICAuLi5ub3JtYWxpemUoKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogaW5qZWN0R2xvYmFsYCR7bm9ybWFsaXplKCl9YFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBodG1sIHtcbiAqICAgZm9udEZhbWlseTogJ3NhbnMtc2VyaWYnLFxuICogICBsaW5lSGVpZ2h0OiAxLjE1LFxuICogICB0ZXh0U2l6ZUFkanVzdDogMTAwJSxcbiAqIH0gLi4uXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShleGNsdWRlT3BpbmlvbmF0ZWQpIHtcbiAgaWYgKGV4Y2x1ZGVPcGluaW9uYXRlZCkgcmV0dXJuIHVub3BpbmlvbmF0ZWRSdWxlcztcbiAgcmV0dXJuIG1lcmdlUnVsZXModW5vcGluaW9uYXRlZFJ1bGVzLCBvcGluaW9uYXRlZFJ1bGVzKTtcbn1cblxuLy8gICAgICBcblxuLyoqXG4gKiBDU1MgdG8gc3R5bGUgdGhlIHBsYWNlaG9sZGVyIHBzZXVkby1lbGVtZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnBsYWNlaG9sZGVyKHsnY29sb3InOiAnYmx1ZSd9KVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuaW5wdXRgXG4gKiAgICAke3BsYWNlaG9sZGVyKHsnY29sb3InOiAnYmx1ZSd9KX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogJ2lucHV0Jzoge1xuICogICAnJjotbW96LXBsYWNlaG9sZGVyJzoge1xuICogICAgICdjb2xvcic6ICdibHVlJyxcbiAqICAgfSxcbiAqICAgJyY6LW1zLWlucHV0LXBsYWNlaG9sZGVyJzoge1xuICogICAgICdjb2xvcic6ICdibHVlJyxcbiAqICAgfSxcbiAqICAgJyY6Oi1tb3otcGxhY2Vob2xkZXInOiB7XG4gKiAgICAgJ2NvbG9yJzogJ2JsdWUnLFxuICogICB9LFxuICogICAnJjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcic6IHtcbiAqICAgICAnY29sb3InOiAnYmx1ZScsXG4gKiAgIH0sXG4gKiB9LFxuICovXG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyKHN0eWxlcykge1xuICB2YXIgX3JlZjtcblxuICB2YXIgcGFyZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJic7XG5cbiAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltwYXJlbnQgKyAnOjotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVyJ10gPSBfZXh0ZW5kcyh7fSwgc3R5bGVzKSwgX3JlZltwYXJlbnQgKyAnOi1tb3otcGxhY2Vob2xkZXInXSA9IF9leHRlbmRzKHt9LCBzdHlsZXMpLCBfcmVmW3BhcmVudCArICc6Oi1tb3otcGxhY2Vob2xkZXInXSA9IF9leHRlbmRzKHt9LCBzdHlsZXMpLCBfcmVmW3BhcmVudCArICc6LW1zLWlucHV0LXBsYWNlaG9sZGVyJ10gPSBfZXh0ZW5kcyh7fSwgc3R5bGVzKSwgX3JlZjtcbn1cblxudmFyIF90ZW1wbGF0ZU9iamVjdCA9IC8qI19fUFVSRV9fKi8gdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UoWydyYWRpYWwtZ3JhZGllbnQoJywgJycsICcnLCAnJywgJyknXSwgWydyYWRpYWwtZ3JhZGllbnQoJywgJycsICcnLCAnJywgJyknXSk7XG5cbi8vICAgICAgXG5cbi8qKiAqL1xuXG5mdW5jdGlvbiBwYXJzZUZhbGxiYWNrKGNvbG9yU3RvcHMpIHtcbiAgcmV0dXJuIGNvbG9yU3RvcHNbMF0uc3BsaXQoJyAnKVswXTtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0R3JhZGllbnRWYWx1ZShsaXRlcmFscykge1xuICB2YXIgdGVtcGxhdGUgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXRlcmFscy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHRlbXBsYXRlICs9IGxpdGVyYWxzW2ldO1xuICAgIC8vIEFkZHMgbGVhZGluZyBjb21hIGlmIHByb3BlcnRpZXMgcHJlY2VlZCBjb2xvci1zdG9wc1xuICAgIGlmIChpID09PSAzICYmIChhcmd1bWVudHMubGVuZ3RoIDw9IGkgKyAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2kgKyAxXSkgJiYgKChhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV0pIHx8IChhcmd1bWVudHMubGVuZ3RoIDw9IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMl0pIHx8IChhcmd1bWVudHMubGVuZ3RoIDw9IDMgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbM10pKSkge1xuICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5zbGljZSgwLCAtMSk7XG4gICAgICB0ZW1wbGF0ZSArPSAnLCAnICsgKGFyZ3VtZW50cy5sZW5ndGggPD0gaSArIDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaSArIDFdKTtcbiAgICAgIC8vIE5vIHRyYWlsaW5nIHNwYWNlIGlmIGNvbG9yLXN0b3BzIGlzIHRoZSBvbmx5IHBhcmFtIHByb3ZpZGVkXG4gICAgfSBlbHNlIGlmIChpID09PSAzICYmIChhcmd1bWVudHMubGVuZ3RoIDw9IGkgKyAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2kgKyAxXSkgJiYgIShhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV0pICYmICEoYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzJdKSAmJiAhKGFyZ3VtZW50cy5sZW5ndGggPD0gMyA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1szXSkpIHtcbiAgICAgIHRlbXBsYXRlICs9ICcnICsgKGFyZ3VtZW50cy5sZW5ndGggPD0gaSArIDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaSArIDFdKTtcbiAgICAgIC8vIE9ubHkgYWRkcyBzdWJzdGl0dXRpb24gaWYgaXQgaXMgZGVmaW5lZFxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSBpICsgMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tpICsgMV0pIHtcbiAgICAgIHRlbXBsYXRlICs9IChhcmd1bWVudHMubGVuZ3RoIDw9IGkgKyAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2kgKyAxXSkgKyAnICc7XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZW1wbGF0ZS50cmltKCk7XG59XG5cbi8qKlxuICogQ1NTIGZvciBkZWNsYXJpbmcgYSByYWRpYWwgZ3JhZGllbnQsIGluY2x1ZGluZyBhIGZhbGxiYWNrIGJhY2tncm91bmQtY29sb3IuIFRoZSBmYWxsYmFjayBpcyBlaXRoZXIgdGhlIGZpcnN0IGNvbG9yLXN0b3Agb3IgYW4gZXhwbGljaXRseSBwYXNzZWQgZmFsbGJhY2sgY29sb3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4ucmFkaWFsR3JhZGllbnQoe1xuICogICAgIGNvbG9yU3RvcHM6IFsnIzAwRkZGRiAwJScsICdyZ2JhKDAsIDAsIDI1NSwgMCkgNTAlJywgJyMwMDAwRkYgOTUlJ10sXG4gKiAgICAgZXh0ZW50OiAnZmFydGhlc3QtY29ybmVyIGF0IDQ1cHggNDVweCcsXG4gKiAgICAgcG9zaXRpb246ICdjZW50ZXInLFxuICogICAgIHNoYXBlOiAnZWxsaXBzZScsXG4gKiAgIH0pXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7cmFkaWFsR3JhZGllbnQoe1xuICogICAgIGNvbG9yU3RvcHM6IFsnIzAwRkZGRiAwJScsICdyZ2JhKDAsIDAsIDI1NSwgMCkgNTAlJywgJyMwMDAwRkYgOTUlJ10sXG4gKiAgICAgZXh0ZW50OiAnZmFydGhlc3QtY29ybmVyIGF0IDQ1cHggNDVweCcsXG4gKiAgICAgcG9zaXRpb246ICdjZW50ZXInLFxuICogICAgIHNoYXBlOiAnZWxsaXBzZScsXG4gKiAgIH0pfVxuICpgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdjoge1xuICogICAnYmFja2dyb3VuZENvbG9yJzogJyMwMEZGRkYnLFxuICogICAnYmFja2dyb3VuZEltYWdlJzogJ3JhZGlhbC1ncmFkaWVudChjZW50ZXIgZWxsaXBzZSBmYXJ0aGVzdC1jb3JuZXIgYXQgNDVweCA0NXB4LCAjMDBGRkZGIDAlLCByZ2JhKDAsIDAsIDI1NSwgMCkgNTAlLCAjMDAwMEZGIDk1JSknLFxuICogfVxuICovXG5cbmZ1bmN0aW9uIHJhZGlhbEdyYWRpZW50KF9yZWYpIHtcbiAgdmFyIGNvbG9yU3RvcHMgPSBfcmVmLmNvbG9yU3RvcHMsXG4gICAgICBleHRlbnQgPSBfcmVmLmV4dGVudCxcbiAgICAgIGZhbGxiYWNrID0gX3JlZi5mYWxsYmFjayxcbiAgICAgIHBvc2l0aW9uID0gX3JlZi5wb3NpdGlvbixcbiAgICAgIHNoYXBlID0gX3JlZi5zaGFwZTtcblxuICBpZiAoIWNvbG9yU3RvcHMgfHwgY29sb3JTdG9wcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpYWxHcmFkaWVudCByZXF1cmllcyBhdCBsZWFzdCAyIGNvbG9yLXN0b3BzIHRvIHByb3Blcmx5IHJlbmRlci4nKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRDb2xvcjogZmFsbGJhY2sgfHwgcGFyc2VGYWxsYmFjayhjb2xvclN0b3BzKSxcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IGNvbnN0cnVjdEdyYWRpZW50VmFsdWUoX3RlbXBsYXRlT2JqZWN0LCBwb3NpdGlvbiwgc2hhcGUsIGV4dGVudCwgY29sb3JTdG9wcy5qb2luKCcsICcpKVxuICB9O1xufVxuXG4vLyAgICAgIFxuXG4vKipcbiAqIEEgaGVscGVyIHRvIGdlbmVyYXRlIGEgcmV0aW5hIGJhY2tncm91bmQgaW1hZ2UgYW5kIG5vbi1yZXRpbmFcbiAqIGJhY2tncm91bmQgaW1hZ2UuIFRoZSByZXRpbmEgYmFja2dyb3VuZCBpbWFnZSB3aWxsIG91dHB1dCB0byBhIEhpRFBJIG1lZGlhIHF1ZXJ5LiBUaGUgbWl4aW4gdXNlc1xuICogYSBfMngucG5nIGZpbGVuYW1lIHN1ZmZpeCBieSBkZWZhdWx0LlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgLi4ucmV0aW5hSW1hZ2UoJ215LWltZycpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7cmV0aW5hSW1hZ2UoJ215LWltZycpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqIGRpdiB7XG4gKiAgIGJhY2tncm91bmRJbWFnZTogJ3VybChteS1pbWcucG5nKScsXG4gKiAgICdAbWVkaWEgb25seSBzY3JlZW4gYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDEuMyksXG4gKiAgICBvbmx5IHNjcmVlbiBhbmQgKG1pbi0tbW96LWRldmljZS1waXhlbC1yYXRpbzogMS4zKSxcbiAqICAgIG9ubHkgc2NyZWVuIGFuZCAoLW8tbWluLWRldmljZS1waXhlbC1yYXRpbzogMS4zLzEpLFxuICogICAgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMTQ0ZHBpKSxcbiAqICAgIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDEuNWRwcHgpJzoge1xuICogICAgIGJhY2tncm91bmRJbWFnZTogJ3VybChteS1pbWdfMngucG5nKScsXG4gKiAgIH1cbiAqIH1cbiAqL1xuZnVuY3Rpb24gcmV0aW5hSW1hZ2UoZmlsZW5hbWUsIGJhY2tncm91bmRTaXplKSB7XG4gIHZhciBleHRlbnNpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdwbmcnO1xuXG4gIHZhciBfcmVmO1xuXG4gIHZhciByZXRpbmFGaWxlbmFtZSA9IGFyZ3VtZW50c1szXTtcbiAgdmFyIHJldGluYVN1ZmZpeCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogJ18yeCc7XG5cbiAgaWYgKCFmaWxlbmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHN1cHBseSBhIGZpbGVuYW1lIHRvIHJldGluYUltYWdlKCkgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LicpO1xuICB9XG4gIC8vIFJlcGxhY2UgdGhlIGRvdCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwYXNzZWQgZXh0ZW5zaW9uIGlmIG9uZSBleGlzdHNcbiAgdmFyIGV4dCA9IGV4dGVuc2lvbi5yZXBsYWNlKC9eXFwuLywgJycpO1xuICB2YXIgckZpbGVuYW1lID0gcmV0aW5hRmlsZW5hbWUgPyByZXRpbmFGaWxlbmFtZSArICcuJyArIGV4dCA6ICcnICsgZmlsZW5hbWUgKyByZXRpbmFTdWZmaXggKyAnLicgKyBleHQ7XG5cbiAgcmV0dXJuIF9yZWYgPSB7XG4gICAgYmFja2dyb3VuZEltYWdlOiAndXJsKCcgKyBmaWxlbmFtZSArICcuJyArIGV4dCArICcpJ1xuICB9LCBfcmVmW2hpRFBJKCldID0ge1xuICAgIGJhY2tncm91bmRJbWFnZTogJ3VybCgnICsgckZpbGVuYW1lICsgJyknLFxuICAgIGJhY2tncm91bmRTaXplOiBiYWNrZ3JvdW5kU2l6ZVxuICB9LCBfcmVmO1xufVxuXG4vLyAgICAgIFxuXG4vKipcbiAqIENTUyB0byBzdHlsZSB0aGUgc2VsZWN0aW9uIHBzZXVkby1lbGVtZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnNlbGVjdGlvbih7XG4gKiAgICAgJ2JhY2tncm91bmRDb2xvcic6ICdibHVlJ1xuICogICB9LCAnc2VjdGlvbicpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7c2VsZWN0aW9uKHsnYmFja2dyb3VuZENvbG9yJzogJ2JsdWUnfSwgJ3NlY3Rpb24nKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogJ2Rpdic6IHtcbiAqICAgJ3NlY3Rpb246Oi1tb3otc2VsZWN0aW9uJzoge1xuICogICAgICdiYWNrZ3JvdW5kQ29sb3InOidibHVlJyxcbiAqICAgfSxcbiAqICAgJ3NlY3Rpb246OnNlbGVjdGlvbic6IHtcbiAqICAgICAnYmFja2dyb3VuZENvbG9yJzogJ2JsdWUnLFxuICogICB9XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0aW9uKHN0eWxlcykge1xuICB2YXIgX3JlZjtcblxuICB2YXIgcGFyZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcblxuICByZXR1cm4gX3JlZiA9IHt9LCBfcmVmW3BhcmVudCArICc6Oi1tb3otc2VsZWN0aW9uJ10gPSBfZXh0ZW5kcyh7fSwgc3R5bGVzKSwgX3JlZltwYXJlbnQgKyAnOjpzZWxlY3Rpb24nXSA9IF9leHRlbmRzKHt9LCBzdHlsZXMpLCBfcmVmO1xufVxuXG4vLyAgICAgIFxuXG4vKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xudmFyIGZ1bmN0aW9uc01hcCA9IHtcbiAgZWFzZUluQmFjazogJ2N1YmljLWJlemllcigwLjYwMCwgLTAuMjgwLCAwLjczNSwgMC4wNDUpJyxcbiAgZWFzZUluQ2lyYzogJ2N1YmljLWJlemllcigwLjYwMCwgIDAuMDQwLCAwLjk4MCwgMC4zMzUpJyxcbiAgZWFzZUluQ3ViaWM6ICdjdWJpYy1iZXppZXIoMC41NTAsICAwLjA1NSwgMC42NzUsIDAuMTkwKScsXG4gIGVhc2VJbkV4cG86ICdjdWJpYy1iZXppZXIoMC45NTAsICAwLjA1MCwgMC43OTUsIDAuMDM1KScsXG4gIGVhc2VJblF1YWQ6ICdjdWJpYy1iZXppZXIoMC41NTAsICAwLjA4NSwgMC42ODAsIDAuNTMwKScsXG4gIGVhc2VJblF1YXJ0OiAnY3ViaWMtYmV6aWVyKDAuODk1LCAgMC4wMzAsIDAuNjg1LCAwLjIyMCknLFxuICBlYXNlSW5RdWludDogJ2N1YmljLWJlemllcigwLjc1NSwgIDAuMDUwLCAwLjg1NSwgMC4wNjApJyxcbiAgZWFzZUluU2luZTogJ2N1YmljLWJlemllcigwLjQ3MCwgIDAuMDAwLCAwLjc0NSwgMC43MTUpJyxcblxuICBlYXNlT3V0QmFjazogJ2N1YmljLWJlemllcigwLjE3NSwgIDAuODg1LCAwLjMyMCwgMS4yNzUpJyxcbiAgZWFzZU91dEN1YmljOiAnY3ViaWMtYmV6aWVyKDAuMjE1LCAgMC42MTAsIDAuMzU1LCAxLjAwMCknLFxuICBlYXNlT3V0Q2lyYzogJ2N1YmljLWJlemllcigwLjA3NSwgIDAuODIwLCAwLjE2NSwgMS4wMDApJyxcbiAgZWFzZU91dEV4cG86ICdjdWJpYy1iZXppZXIoMC4xOTAsICAxLjAwMCwgMC4yMjAsIDEuMDAwKScsXG4gIGVhc2VPdXRRdWFkOiAnY3ViaWMtYmV6aWVyKDAuMjUwLCAgMC40NjAsIDAuNDUwLCAwLjk0MCknLFxuICBlYXNlT3V0UXVhcnQ6ICdjdWJpYy1iZXppZXIoMC4xNjUsICAwLjg0MCwgMC40NDAsIDEuMDAwKScsXG4gIGVhc2VPdXRRdWludDogJ2N1YmljLWJlemllcigwLjIzMCwgIDEuMDAwLCAwLjMyMCwgMS4wMDApJyxcbiAgZWFzZU91dFNpbmU6ICdjdWJpYy1iZXppZXIoMC4zOTAsICAwLjU3NSwgMC41NjUsIDEuMDAwKScsXG5cbiAgZWFzZUluT3V0QmFjazogJ2N1YmljLWJlemllcigwLjY4MCwgLTAuNTUwLCAwLjI2NSwgMS41NTApJyxcbiAgZWFzZUluT3V0Q2lyYzogJ2N1YmljLWJlemllcigwLjc4NSwgIDAuMTM1LCAwLjE1MCwgMC44NjApJyxcbiAgZWFzZUluT3V0Q3ViaWM6ICdjdWJpYy1iZXppZXIoMC42NDUsICAwLjA0NSwgMC4zNTUsIDEuMDAwKScsXG4gIGVhc2VJbk91dEV4cG86ICdjdWJpYy1iZXppZXIoMS4wMDAsICAwLjAwMCwgMC4wMDAsIDEuMDAwKScsXG4gIGVhc2VJbk91dFF1YWQ6ICdjdWJpYy1iZXppZXIoMC40NTUsICAwLjAzMCwgMC41MTUsIDAuOTU1KScsXG4gIGVhc2VJbk91dFF1YXJ0OiAnY3ViaWMtYmV6aWVyKDAuNzcwLCAgMC4wMDAsIDAuMTc1LCAxLjAwMCknLFxuICBlYXNlSW5PdXRRdWludDogJ2N1YmljLWJlemllcigwLjg2MCwgIDAuMDAwLCAwLjA3MCwgMS4wMDApJyxcbiAgZWFzZUluT3V0U2luZTogJ2N1YmljLWJlemllcigwLjQ0NSwgIDAuMDUwLCAwLjU1MCwgMC45NTApJ1xufTtcbi8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cblxuLyoqICovXG5cbi8qKlxuICogU3RyaW5nIHRvIHJlcHJlc2VudCBjb21tb24gZWFzaW5nIGZ1bmN0aW9ucyBhcyBkZW1vbnN0cmF0ZWQgaGVyZTogKGdpdGh1Yi5jb20vamF1a2lhL2Vhc2llKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAndHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uJzogdGltaW5nRnVuY3Rpb25zKCdlYXNlSW5RdWFkJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogJHt0aW1pbmdGdW5jdGlvbnMoJ2Vhc2VJblF1YWQnKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqICdkaXYnOiB7XG4gKiAgICd0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24nOiAnY3ViaWMtYmV6aWVyKDAuNTUwLCAgMC4wODUsIDAuNjgwLCAwLjUzMCknLFxuICogfVxuICovXG5cbmZ1bmN0aW9uIHRpbWluZ0Z1bmN0aW9ucyh0aW1pbmdGdW5jdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb25zTWFwW3RpbWluZ0Z1bmN0aW9uXTtcbn1cblxuLy8gICAgICBcblxuLyoqICovXG5cbnZhciBnZXRCb3JkZXJXaWR0aCA9IGZ1bmN0aW9uIGdldEJvcmRlcldpZHRoKHBvaW50aW5nRGlyZWN0aW9uLCBoZWlnaHQsIHdpZHRoKSB7XG4gIHN3aXRjaCAocG9pbnRpbmdEaXJlY3Rpb24pIHtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgcmV0dXJuICcwICcgKyB3aWR0aCAvIDIgKyAncHggJyArIGhlaWdodCArICdweCAnICsgd2lkdGggLyAyICsgJ3B4JztcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHJldHVybiBoZWlnaHQgLyAyICsgJ3B4ICcgKyB3aWR0aCArICdweCAnICsgaGVpZ2h0IC8gMiArICdweCAwJztcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgcmV0dXJuIGhlaWdodCArICdweCAnICsgd2lkdGggLyAyICsgJ3B4IDAgJyArIHdpZHRoIC8gMiArICdweCc7XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgcmV0dXJuIGhlaWdodCAvIDIgKyAncHggMCAnICsgaGVpZ2h0IC8gMiArICdweCAnICsgd2lkdGggKyAncHgnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhc3NlZCBpbnZhbGlkIGFyZ3VtZW50IHRvIHRyaWFuZ2xlLCBwbGVhc2UgcGFzcyBjb3JyZWN0IHBvaXRpbmdEaXJlY3Rpb24gZS5nLiAncmlnaHQnLlwiKTtcbiAgfVxufTtcblxuLy8gbmVlZGVkIGZvciBib3JkZXItY29sb3JcbnZhciByZXZlcnNlRGlyZWN0aW9uID0ge1xuICBsZWZ0OiAnUmlnaHQnLFxuICByaWdodDogJ0xlZnQnLFxuICB0b3A6ICdCb3R0b20nLFxuICBib3R0b206ICdUb3AnXG59O1xuXG4vKipcbiAqIENTUyB0byByZXByZXNlbnQgdHJpYW5nbGUgd2l0aCBhbnkgcG9pbnRpbmcgZGlyZWN0aW9uIHdpdGggYW4gb3B0aW9uYWwgYmFja2dyb3VuZCBjb2xvci4gQWNjZXB0cyBudW1iZXIgb3IgcHggdmFsdWVzIGZvciBoZWlnaHQgYW5kIHdpZHRoLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKlxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi50cmlhbmdsZSh7IHBvaW50aW5nRGlyZWN0aW9uOiAncmlnaHQnLCB3aWR0aDogJzEwMHB4JywgaGVpZ2h0OiAnMTAwcHgnLCBmb3JlZ3JvdW5kQ29sb3I6ICdyZWQnIH0pXG4gKiB9XG4gKlxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke3RyaWFuZ2xlKHsgcG9pbnRpbmdEaXJlY3Rpb246ICdyaWdodCcsIHdpZHRoOiAnMTAwcHgnLCBoZWlnaHQ6ICcxMDBweCcsIGZvcmVncm91bmRDb2xvcjogJ3JlZCcgfSl9XG4gKlxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXY6IHtcbiAqICAnYm9yZGVyQ29sb3InOiAndHJhbnNwYXJlbnQnLFxuICogICdib3JkZXJMZWZ0Q29sb3InOiAncmVkICFpbXBvcnRhbnQnLFxuICogICdib3JkZXJTdHlsZSc6ICdzb2xpZCcsXG4gKiAgJ2JvcmRlcldpZHRoJzogJzUwcHggMCA1MHB4IDEwMHB4JyxcbiAqICAnaGVpZ2h0JzogJzAnLFxuICogICd3aWR0aCc6ICcwJyxcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiB0cmlhbmdsZShfcmVmKSB7XG4gIHZhciBfcmVmMjtcblxuICB2YXIgcG9pbnRpbmdEaXJlY3Rpb24gPSBfcmVmLnBvaW50aW5nRGlyZWN0aW9uLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQsXG4gICAgICB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBmb3JlZ3JvdW5kQ29sb3IgPSBfcmVmLmZvcmVncm91bmRDb2xvcixcbiAgICAgIF9yZWYkYmFja2dyb3VuZENvbG9yID0gX3JlZi5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBfcmVmJGJhY2tncm91bmRDb2xvciA9PT0gdW5kZWZpbmVkID8gJ3RyYW5zcGFyZW50JyA6IF9yZWYkYmFja2dyb3VuZENvbG9yO1xuXG4gIHZhciB1bml0bGVzc0hlaWdodCA9IHBhcnNlRmxvYXQoaGVpZ2h0KTtcbiAgdmFyIHVuaXRsZXNzV2lkdGggPSBwYXJzZUZsb2F0KHdpZHRoKTtcbiAgaWYgKGlzTmFOKHVuaXRsZXNzSGVpZ2h0KSB8fCBpc05hTih1bml0bGVzc1dpZHRoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFzc2VkIGFuIGludmFsaWQgdmFsdWUgdG8gYGhlaWdodGAgb3IgYHdpZHRoYC4gUGxlYXNlIHByb3ZpZGUgYSBwaXhlbCBiYXNlZCB1bml0Jyk7XG4gIH1cblxuICByZXR1cm4gX3JlZjIgPSB7XG4gICAgYm9yZGVyQ29sb3I6IGJhY2tncm91bmRDb2xvcixcbiAgICB3aWR0aDogJzAnLFxuICAgIGhlaWdodDogJzAnLFxuICAgIGJvcmRlcldpZHRoOiBnZXRCb3JkZXJXaWR0aChwb2ludGluZ0RpcmVjdGlvbiwgdW5pdGxlc3NIZWlnaHQsIHVuaXRsZXNzV2lkdGgpLFxuICAgIGJvcmRlclN0eWxlOiAnc29saWQnXG4gIH0sIF9yZWYyWydib3JkZXInICsgcmV2ZXJzZURpcmVjdGlvbltwb2ludGluZ0RpcmVjdGlvbl0gKyAnQ29sb3InXSA9IGZvcmVncm91bmRDb2xvciArICcgIWltcG9ydGFudCcsIF9yZWYyO1xufVxuXG4vLyAgICAgIFxuXG4vKipcbiAqIFByb3ZpZGVzIGFuIGVhc3kgd2F5IHRvIGNoYW5nZSB0aGUgYHdvcmRXcmFwYCBwcm9wZXJ0eS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi53b3JkV3JhcCgnYnJlYWstd29yZCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7d29yZFdyYXAoJ2JyZWFrLXdvcmQnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBvdmVyZmxvd1dyYXA6ICdicmVhay13b3JkJyxcbiAqICAgd29yZFdyYXA6ICdicmVhay13b3JkJyxcbiAqICAgd29yZEJyZWFrOiAnYnJlYWstYWxsJyxcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiB3b3JkV3JhcCgpIHtcbiAgdmFyIHdyYXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdicmVhay13b3JkJztcblxuICB2YXIgd29yZEJyZWFrID0gd3JhcCA9PT0gJ2JyZWFrLXdvcmQnID8gJ2JyZWFrLWFsbCcgOiB3cmFwO1xuICByZXR1cm4ge1xuICAgIG92ZXJmbG93V3JhcDogd3JhcCxcbiAgICB3b3JkV3JhcDogd3JhcCxcbiAgICB3b3JkQnJlYWs6IHdvcmRCcmVha1xuICB9O1xufVxuXG4vLyAgICAgIFxuXG5cbmZ1bmN0aW9uIGNvbG9yVG9JbnQoY29sb3IpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoY29sb3IgKiAyNTUpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VG9JbnQocmVkLCBncmVlbiwgYmx1ZSkge1xuICByZXR1cm4gY29sb3JUb0ludChyZWQpICsgXCIsXCIgKyBjb2xvclRvSW50KGdyZWVuKSArIFwiLFwiICsgY29sb3JUb0ludChibHVlKTtcbn1cblxuZnVuY3Rpb24gaHNsVG9SZ2IoaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MpIHtcbiAgdmFyIGNvbnZlcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGNvbnZlcnRUb0ludDtcblxuICBpZiAoc2F0dXJhdGlvbiA9PT0gMCkge1xuICAgIC8vIGFjaHJvbWF0aWNcbiAgICByZXR1cm4gY29udmVydChsaWdodG5lc3MsIGxpZ2h0bmVzcywgbGlnaHRuZXNzKTtcbiAgfVxuXG4gIC8vIGZvcm11bGFyIGZyb20gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSFNMX2FuZF9IU1ZcbiAgdmFyIGh1ZVByaW1lID0gaHVlICUgMzYwIC8gNjA7XG4gIHZhciBjaHJvbWEgPSAoMSAtIE1hdGguYWJzKDIgKiBsaWdodG5lc3MgLSAxKSkgKiBzYXR1cmF0aW9uO1xuICB2YXIgc2Vjb25kQ29tcG9uZW50ID0gY2hyb21hICogKDEgLSBNYXRoLmFicyhodWVQcmltZSAlIDIgLSAxKSk7XG5cbiAgdmFyIHJlZCA9IDA7XG4gIHZhciBncmVlbiA9IDA7XG4gIHZhciBibHVlID0gMDtcblxuICBpZiAoaHVlUHJpbWUgPj0gMCAmJiBodWVQcmltZSA8IDEpIHtcbiAgICByZWQgPSBjaHJvbWE7XG4gICAgZ3JlZW4gPSBzZWNvbmRDb21wb25lbnQ7XG4gIH0gZWxzZSBpZiAoaHVlUHJpbWUgPj0gMSAmJiBodWVQcmltZSA8IDIpIHtcbiAgICByZWQgPSBzZWNvbmRDb21wb25lbnQ7XG4gICAgZ3JlZW4gPSBjaHJvbWE7XG4gIH0gZWxzZSBpZiAoaHVlUHJpbWUgPj0gMiAmJiBodWVQcmltZSA8IDMpIHtcbiAgICBncmVlbiA9IGNocm9tYTtcbiAgICBibHVlID0gc2Vjb25kQ29tcG9uZW50O1xuICB9IGVsc2UgaWYgKGh1ZVByaW1lID49IDMgJiYgaHVlUHJpbWUgPCA0KSB7XG4gICAgZ3JlZW4gPSBzZWNvbmRDb21wb25lbnQ7XG4gICAgYmx1ZSA9IGNocm9tYTtcbiAgfSBlbHNlIGlmIChodWVQcmltZSA+PSA0ICYmIGh1ZVByaW1lIDwgNSkge1xuICAgIHJlZCA9IHNlY29uZENvbXBvbmVudDtcbiAgICBibHVlID0gY2hyb21hO1xuICB9IGVsc2UgaWYgKGh1ZVByaW1lID49IDUgJiYgaHVlUHJpbWUgPCA2KSB7XG4gICAgcmVkID0gY2hyb21hO1xuICAgIGJsdWUgPSBzZWNvbmRDb21wb25lbnQ7XG4gIH1cblxuICB2YXIgbGlnaHRuZXNzTW9kaWZpY2F0aW9uID0gbGlnaHRuZXNzIC0gY2hyb21hIC8gMjtcbiAgdmFyIGZpbmFsUmVkID0gcmVkICsgbGlnaHRuZXNzTW9kaWZpY2F0aW9uO1xuICB2YXIgZmluYWxHcmVlbiA9IGdyZWVuICsgbGlnaHRuZXNzTW9kaWZpY2F0aW9uO1xuICB2YXIgZmluYWxCbHVlID0gYmx1ZSArIGxpZ2h0bmVzc01vZGlmaWNhdGlvbjtcbiAgcmV0dXJuIGNvbnZlcnQoZmluYWxSZWQsIGZpbmFsR3JlZW4sIGZpbmFsQmx1ZSk7XG59XG5cbi8vICAgICAgXG52YXIgbmFtZWRDb2xvck1hcCA9IHtcbiAgYWxpY2VibHVlOiAnZjBmOGZmJyxcbiAgYW50aXF1ZXdoaXRlOiAnZmFlYmQ3JyxcbiAgYXF1YTogJzAwZmZmZicsXG4gIGFxdWFtYXJpbmU6ICc3ZmZmZDQnLFxuICBhenVyZTogJ2YwZmZmZicsXG4gIGJlaWdlOiAnZjVmNWRjJyxcbiAgYmlzcXVlOiAnZmZlNGM0JyxcbiAgYmxhY2s6ICcwMDAnLFxuICBibGFuY2hlZGFsbW9uZDogJ2ZmZWJjZCcsXG4gIGJsdWU6ICcwMDAwZmYnLFxuICBibHVldmlvbGV0OiAnOGEyYmUyJyxcbiAgYnJvd246ICdhNTJhMmEnLFxuICBidXJseXdvb2Q6ICdkZWI4ODcnLFxuICBjYWRldGJsdWU6ICc1ZjllYTAnLFxuICBjaGFydHJldXNlOiAnN2ZmZjAwJyxcbiAgY2hvY29sYXRlOiAnZDI2OTFlJyxcbiAgY29yYWw6ICdmZjdmNTAnLFxuICBjb3JuZmxvd2VyYmx1ZTogJzY0OTVlZCcsXG4gIGNvcm5zaWxrOiAnZmZmOGRjJyxcbiAgY3JpbXNvbjogJ2RjMTQzYycsXG4gIGN5YW46ICcwMGZmZmYnLFxuICBkYXJrYmx1ZTogJzAwMDA4YicsXG4gIGRhcmtjeWFuOiAnMDA4YjhiJyxcbiAgZGFya2dvbGRlbnJvZDogJ2I4ODYwYicsXG4gIGRhcmtncmF5OiAnYTlhOWE5JyxcbiAgZGFya2dyZWVuOiAnMDA2NDAwJyxcbiAgZGFya2dyZXk6ICdhOWE5YTknLFxuICBkYXJra2hha2k6ICdiZGI3NmInLFxuICBkYXJrbWFnZW50YTogJzhiMDA4YicsXG4gIGRhcmtvbGl2ZWdyZWVuOiAnNTU2YjJmJyxcbiAgZGFya29yYW5nZTogJ2ZmOGMwMCcsXG4gIGRhcmtvcmNoaWQ6ICc5OTMyY2MnLFxuICBkYXJrcmVkOiAnOGIwMDAwJyxcbiAgZGFya3NhbG1vbjogJ2U5OTY3YScsXG4gIGRhcmtzZWFncmVlbjogJzhmYmM4ZicsXG4gIGRhcmtzbGF0ZWJsdWU6ICc0ODNkOGInLFxuICBkYXJrc2xhdGVncmF5OiAnMmY0ZjRmJyxcbiAgZGFya3NsYXRlZ3JleTogJzJmNGY0ZicsXG4gIGRhcmt0dXJxdW9pc2U6ICcwMGNlZDEnLFxuICBkYXJrdmlvbGV0OiAnOTQwMGQzJyxcbiAgZGVlcHBpbms6ICdmZjE0OTMnLFxuICBkZWVwc2t5Ymx1ZTogJzAwYmZmZicsXG4gIGRpbWdyYXk6ICc2OTY5NjknLFxuICBkaW1ncmV5OiAnNjk2OTY5JyxcbiAgZG9kZ2VyYmx1ZTogJzFlOTBmZicsXG4gIGZpcmVicmljazogJ2IyMjIyMicsXG4gIGZsb3JhbHdoaXRlOiAnZmZmYWYwJyxcbiAgZm9yZXN0Z3JlZW46ICcyMjhiMjInLFxuICBmdWNoc2lhOiAnZmYwMGZmJyxcbiAgZ2FpbnNib3JvOiAnZGNkY2RjJyxcbiAgZ2hvc3R3aGl0ZTogJ2Y4ZjhmZicsXG4gIGdvbGQ6ICdmZmQ3MDAnLFxuICBnb2xkZW5yb2Q6ICdkYWE1MjAnLFxuICBncmF5OiAnODA4MDgwJyxcbiAgZ3JlZW46ICcwMDgwMDAnLFxuICBncmVlbnllbGxvdzogJ2FkZmYyZicsXG4gIGdyZXk6ICc4MDgwODAnLFxuICBob25leWRldzogJ2YwZmZmMCcsXG4gIGhvdHBpbms6ICdmZjY5YjQnLFxuICBpbmRpYW5yZWQ6ICdjZDVjNWMnLFxuICBpbmRpZ286ICc0YjAwODInLFxuICBpdm9yeTogJ2ZmZmZmMCcsXG4gIGtoYWtpOiAnZjBlNjhjJyxcbiAgbGF2ZW5kZXI6ICdlNmU2ZmEnLFxuICBsYXZlbmRlcmJsdXNoOiAnZmZmMGY1JyxcbiAgbGF3bmdyZWVuOiAnN2NmYzAwJyxcbiAgbGVtb25jaGlmZm9uOiAnZmZmYWNkJyxcbiAgbGlnaHRibHVlOiAnYWRkOGU2JyxcbiAgbGlnaHRjb3JhbDogJ2YwODA4MCcsXG4gIGxpZ2h0Y3lhbjogJ2UwZmZmZicsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiAnZmFmYWQyJyxcbiAgbGlnaHRncmF5OiAnZDNkM2QzJyxcbiAgbGlnaHRncmVlbjogJzkwZWU5MCcsXG4gIGxpZ2h0Z3JleTogJ2QzZDNkMycsXG4gIGxpZ2h0cGluazogJ2ZmYjZjMScsXG4gIGxpZ2h0c2FsbW9uOiAnZmZhMDdhJyxcbiAgbGlnaHRzZWFncmVlbjogJzIwYjJhYScsXG4gIGxpZ2h0c2t5Ymx1ZTogJzg3Y2VmYScsXG4gIGxpZ2h0c2xhdGVncmF5OiAnNzg5JyxcbiAgbGlnaHRzbGF0ZWdyZXk6ICc3ODknLFxuICBsaWdodHN0ZWVsYmx1ZTogJ2IwYzRkZScsXG4gIGxpZ2h0eWVsbG93OiAnZmZmZmUwJyxcbiAgbGltZTogJzBmMCcsXG4gIGxpbWVncmVlbjogJzMyY2QzMicsXG4gIGxpbmVuOiAnZmFmMGU2JyxcbiAgbWFnZW50YTogJ2YwZicsXG4gIG1hcm9vbjogJzgwMDAwMCcsXG4gIG1lZGl1bWFxdWFtYXJpbmU6ICc2NmNkYWEnLFxuICBtZWRpdW1ibHVlOiAnMDAwMGNkJyxcbiAgbWVkaXVtb3JjaGlkOiAnYmE1NWQzJyxcbiAgbWVkaXVtcHVycGxlOiAnOTM3MGRiJyxcbiAgbWVkaXVtc2VhZ3JlZW46ICczY2IzNzEnLFxuICBtZWRpdW1zbGF0ZWJsdWU6ICc3YjY4ZWUnLFxuICBtZWRpdW1zcHJpbmdncmVlbjogJzAwZmE5YScsXG4gIG1lZGl1bXR1cnF1b2lzZTogJzQ4ZDFjYycsXG4gIG1lZGl1bXZpb2xldHJlZDogJ2M3MTU4NScsXG4gIG1pZG5pZ2h0Ymx1ZTogJzE5MTk3MCcsXG4gIG1pbnRjcmVhbTogJ2Y1ZmZmYScsXG4gIG1pc3R5cm9zZTogJ2ZmZTRlMScsXG4gIG1vY2Nhc2luOiAnZmZlNGI1JyxcbiAgbmF2YWpvd2hpdGU6ICdmZmRlYWQnLFxuICBuYXZ5OiAnMDAwMDgwJyxcbiAgb2xkbGFjZTogJ2ZkZjVlNicsXG4gIG9saXZlOiAnODA4MDAwJyxcbiAgb2xpdmVkcmFiOiAnNmI4ZTIzJyxcbiAgb3JhbmdlOiAnZmZhNTAwJyxcbiAgb3JhbmdlcmVkOiAnZmY0NTAwJyxcbiAgb3JjaGlkOiAnZGE3MGQ2JyxcbiAgcGFsZWdvbGRlbnJvZDogJ2VlZThhYScsXG4gIHBhbGVncmVlbjogJzk4ZmI5OCcsXG4gIHBhbGV0dXJxdW9pc2U6ICdhZmVlZWUnLFxuICBwYWxldmlvbGV0cmVkOiAnZGI3MDkzJyxcbiAgcGFwYXlhd2hpcDogJ2ZmZWZkNScsXG4gIHBlYWNocHVmZjogJ2ZmZGFiOScsXG4gIHBlcnU6ICdjZDg1M2YnLFxuICBwaW5rOiAnZmZjMGNiJyxcbiAgcGx1bTogJ2RkYTBkZCcsXG4gIHBvd2RlcmJsdWU6ICdiMGUwZTYnLFxuICBwdXJwbGU6ICc4MDAwODAnLFxuICByZWJlY2NhcHVycGxlOiAnNjM5JyxcbiAgcmVkOiAnZjAwJyxcbiAgcm9zeWJyb3duOiAnYmM4ZjhmJyxcbiAgcm95YWxibHVlOiAnNDE2OWUxJyxcbiAgc2FkZGxlYnJvd246ICc4YjQ1MTMnLFxuICBzYWxtb246ICdmYTgwNzInLFxuICBzYW5keWJyb3duOiAnZjRhNDYwJyxcbiAgc2VhZ3JlZW46ICcyZThiNTcnLFxuICBzZWFzaGVsbDogJ2ZmZjVlZScsXG4gIHNpZW5uYTogJ2EwNTIyZCcsXG4gIHNpbHZlcjogJ2MwYzBjMCcsXG4gIHNreWJsdWU6ICc4N2NlZWInLFxuICBzbGF0ZWJsdWU6ICc2YTVhY2QnLFxuICBzbGF0ZWdyYXk6ICc3MDgwOTAnLFxuICBzbGF0ZWdyZXk6ICc3MDgwOTAnLFxuICBzbm93OiAnZmZmYWZhJyxcbiAgc3ByaW5nZ3JlZW46ICcwMGZmN2YnLFxuICBzdGVlbGJsdWU6ICc0NjgyYjQnLFxuICB0YW46ICdkMmI0OGMnLFxuICB0ZWFsOiAnMDA4MDgwJyxcbiAgdGhpc3RsZTogJ2Q4YmZkOCcsXG4gIHRvbWF0bzogJ2ZmNjM0NycsXG4gIHR1cnF1b2lzZTogJzQwZTBkMCcsXG4gIHZpb2xldDogJ2VlODJlZScsXG4gIHdoZWF0OiAnZjVkZWIzJyxcbiAgd2hpdGU6ICdmZmYnLFxuICB3aGl0ZXNtb2tlOiAnZjVmNWY1JyxcbiAgeWVsbG93OiAnZmYwJyxcbiAgeWVsbG93Z3JlZW46ICc5YWNkMzInXG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0cmluZyBpcyBhIENTUyBuYW1lZCBjb2xvciBhbmQgcmV0dXJucyBpdHMgZXF1aXZhbGVudCBoZXggdmFsdWUsIG90aGVyd2lzZSByZXR1cm5zIHRoZSBvcmlnaW5hbCBjb2xvci5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5hbWVUb0hleChjb2xvcikge1xuICBpZiAodHlwZW9mIGNvbG9yICE9PSAnc3RyaW5nJykgcmV0dXJuIGNvbG9yO1xuICB2YXIgbm9ybWFsaXplZENvbG9yTmFtZSA9IGNvbG9yLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBuYW1lZENvbG9yTWFwW25vcm1hbGl6ZWRDb2xvck5hbWVdID8gJyMnICsgbmFtZWRDb2xvck1hcFtub3JtYWxpemVkQ29sb3JOYW1lXSA6IGNvbG9yO1xufVxuXG4vLyAgICAgIFxudmFyIGhleFJlZ2V4ID0gL14jW2EtZkEtRjAtOV17Nn0kLztcbnZhciByZWR1Y2VkSGV4UmVnZXggPSAvXiNbYS1mQS1GMC05XXszfSQvO1xudmFyIHJnYlJlZ2V4ID0gL15yZ2JcXChcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKlxcKSQvO1xudmFyIHJnYmFSZWdleCA9IC9ecmdiYVxcKFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqLFxccyooWy0rXT9bMC05XSpbLl0/WzAtOV0rKVxccypcXCkkLztcbnZhciBoc2xSZWdleCA9IC9eaHNsXFwoXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pJVxccyosXFxzKihcXGR7MSwzfSklXFxzKlxcKSQvO1xudmFyIGhzbGFSZWdleCA9IC9eaHNsYVxcKFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KSVcXHMqLFxccyooXFxkezEsM30pJVxccyosXFxzKihbLStdP1swLTldKlsuXT9bMC05XSspXFxzKlxcKSQvO1xuXG4vKipcbiAqIFJldHVybnMgYW4gUmdiQ29sb3Igb3IgUmdiYUNvbG9yIG9iamVjdC4gVGhpcyB1dGlsaXR5IGZ1bmN0aW9uIGlzIG9ubHkgdXNlZnVsXG4gKiBpZiB3YW50IHRvIGV4dHJhY3QgYSBjb2xvciBjb21wb25lbnQuIFdpdGggdGhlIGNvbG9yIHV0aWwgYHRvQ29sb3JTdHJpbmdgIHlvdVxuICogY2FuIGNvbnZlcnQgYSBSZ2JDb2xvciBvciBSZ2JhQ29sb3Igb2JqZWN0IGJhY2sgdG8gYSBzdHJpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFzc2lnbnMgYHsgcmVkOiAyNTUsIGdyZWVuOiAwLCBibHVlOiAwIH1gIHRvIGNvbG9yMVxuICogY29uc3QgY29sb3IxID0gJ3JnYigyNTUsIDAsIDApJztcbiAqIC8vIEFzc2lnbnMgYHsgcmVkOiA5MiwgZ3JlZW46IDEwMiwgYmx1ZTogMTEyLCBhbHBoYTogMC43NSB9YCB0byBjb2xvcjJcbiAqIGNvbnN0IGNvbG9yMiA9ICdoc2xhKDIxMCwgMTAlLCA0MCUsIDAuNzUpJztcbiAqL1xuZnVuY3Rpb24gcGFyc2VUb1JnYihjb2xvcikge1xuICBpZiAodHlwZW9mIGNvbG9yICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFzc2VkIGFuIGluY29ycmVjdCBhcmd1bWVudCB0byBhIGNvbG9yIGZ1bmN0aW9uLCBwbGVhc2UgcGFzcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLicpO1xuICB9XG4gIHZhciBub3JtYWxpemVkQ29sb3IgPSBuYW1lVG9IZXgoY29sb3IpO1xuICBpZiAobm9ybWFsaXplZENvbG9yLm1hdGNoKGhleFJlZ2V4KSkge1xuICAgIHJldHVybiB7XG4gICAgICByZWQ6IHBhcnNlSW50KCcnICsgbm9ybWFsaXplZENvbG9yWzFdICsgbm9ybWFsaXplZENvbG9yWzJdLCAxNiksXG4gICAgICBncmVlbjogcGFyc2VJbnQoJycgKyBub3JtYWxpemVkQ29sb3JbM10gKyBub3JtYWxpemVkQ29sb3JbNF0sIDE2KSxcbiAgICAgIGJsdWU6IHBhcnNlSW50KCcnICsgbm9ybWFsaXplZENvbG9yWzVdICsgbm9ybWFsaXplZENvbG9yWzZdLCAxNilcbiAgICB9O1xuICB9XG4gIGlmIChub3JtYWxpemVkQ29sb3IubWF0Y2gocmVkdWNlZEhleFJlZ2V4KSkge1xuICAgIHJldHVybiB7XG4gICAgICByZWQ6IHBhcnNlSW50KCcnICsgbm9ybWFsaXplZENvbG9yWzFdICsgbm9ybWFsaXplZENvbG9yWzFdLCAxNiksXG4gICAgICBncmVlbjogcGFyc2VJbnQoJycgKyBub3JtYWxpemVkQ29sb3JbMl0gKyBub3JtYWxpemVkQ29sb3JbMl0sIDE2KSxcbiAgICAgIGJsdWU6IHBhcnNlSW50KCcnICsgbm9ybWFsaXplZENvbG9yWzNdICsgbm9ybWFsaXplZENvbG9yWzNdLCAxNilcbiAgICB9O1xuICB9XG4gIHZhciByZ2JNYXRjaGVkID0gcmdiUmVnZXguZXhlYyhub3JtYWxpemVkQ29sb3IpO1xuICBpZiAocmdiTWF0Y2hlZCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWQ6IHBhcnNlSW50KCcnICsgcmdiTWF0Y2hlZFsxXSwgMTApLFxuICAgICAgZ3JlZW46IHBhcnNlSW50KCcnICsgcmdiTWF0Y2hlZFsyXSwgMTApLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoJycgKyByZ2JNYXRjaGVkWzNdLCAxMClcbiAgICB9O1xuICB9XG4gIHZhciByZ2JhTWF0Y2hlZCA9IHJnYmFSZWdleC5leGVjKG5vcm1hbGl6ZWRDb2xvcik7XG4gIGlmIChyZ2JhTWF0Y2hlZCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWQ6IHBhcnNlSW50KCcnICsgcmdiYU1hdGNoZWRbMV0sIDEwKSxcbiAgICAgIGdyZWVuOiBwYXJzZUludCgnJyArIHJnYmFNYXRjaGVkWzJdLCAxMCksXG4gICAgICBibHVlOiBwYXJzZUludCgnJyArIHJnYmFNYXRjaGVkWzNdLCAxMCksXG4gICAgICBhbHBoYTogcGFyc2VGbG9hdCgnJyArIHJnYmFNYXRjaGVkWzRdKVxuICAgIH07XG4gIH1cbiAgdmFyIGhzbE1hdGNoZWQgPSBoc2xSZWdleC5leGVjKG5vcm1hbGl6ZWRDb2xvcik7XG4gIGlmIChoc2xNYXRjaGVkKSB7XG4gICAgdmFyIGh1ZSA9IHBhcnNlSW50KCcnICsgaHNsTWF0Y2hlZFsxXSwgMTApO1xuICAgIHZhciBzYXR1cmF0aW9uID0gcGFyc2VJbnQoJycgKyBoc2xNYXRjaGVkWzJdLCAxMCkgLyAxMDA7XG4gICAgdmFyIGxpZ2h0bmVzcyA9IHBhcnNlSW50KCcnICsgaHNsTWF0Y2hlZFszXSwgMTApIC8gMTAwO1xuICAgIHZhciByZ2JDb2xvclN0cmluZyA9ICdyZ2IoJyArIGhzbFRvUmdiKGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzKSArICcpJztcbiAgICB2YXIgaHNsUmdiTWF0Y2hlZCA9IHJnYlJlZ2V4LmV4ZWMocmdiQ29sb3JTdHJpbmcpO1xuICAgIHJldHVybiB7XG4gICAgICByZWQ6IHBhcnNlSW50KCcnICsgaHNsUmdiTWF0Y2hlZFsxXSwgMTApLFxuICAgICAgZ3JlZW46IHBhcnNlSW50KCcnICsgaHNsUmdiTWF0Y2hlZFsyXSwgMTApLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoJycgKyBoc2xSZ2JNYXRjaGVkWzNdLCAxMClcbiAgICB9O1xuICB9XG4gIHZhciBoc2xhTWF0Y2hlZCA9IGhzbGFSZWdleC5leGVjKG5vcm1hbGl6ZWRDb2xvcik7XG4gIGlmIChoc2xhTWF0Y2hlZCkge1xuICAgIHZhciBfaHVlID0gcGFyc2VJbnQoJycgKyBoc2xhTWF0Y2hlZFsxXSwgMTApO1xuICAgIHZhciBfc2F0dXJhdGlvbiA9IHBhcnNlSW50KCcnICsgaHNsYU1hdGNoZWRbMl0sIDEwKSAvIDEwMDtcbiAgICB2YXIgX2xpZ2h0bmVzcyA9IHBhcnNlSW50KCcnICsgaHNsYU1hdGNoZWRbM10sIDEwKSAvIDEwMDtcbiAgICB2YXIgX3JnYkNvbG9yU3RyaW5nID0gJ3JnYignICsgaHNsVG9SZ2IoX2h1ZSwgX3NhdHVyYXRpb24sIF9saWdodG5lc3MpICsgJyknO1xuICAgIHZhciBfaHNsUmdiTWF0Y2hlZCA9IHJnYlJlZ2V4LmV4ZWMoX3JnYkNvbG9yU3RyaW5nKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVkOiBwYXJzZUludCgnJyArIF9oc2xSZ2JNYXRjaGVkWzFdLCAxMCksXG4gICAgICBncmVlbjogcGFyc2VJbnQoJycgKyBfaHNsUmdiTWF0Y2hlZFsyXSwgMTApLFxuICAgICAgYmx1ZTogcGFyc2VJbnQoJycgKyBfaHNsUmdiTWF0Y2hlZFszXSwgMTApLFxuICAgICAgYWxwaGE6IHBhcnNlRmxvYXQoJycgKyBoc2xhTWF0Y2hlZFs0XSlcbiAgICB9O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IHBhcnNlIHRoZSBjb2xvciBzdHJpbmcuIFBsZWFzZSBwcm92aWRlIHRoZSBjb2xvciBhcyBhIHN0cmluZyBpbiBoZXgsIHJnYiwgcmdiYSwgaHNsIG9yIGhzbGEgbm90YXRpb24uXCIpO1xufVxuXG4vLyAgICAgIFxuXG5cbmZ1bmN0aW9uIHJnYlRvSHNsKGNvbG9yKSB7XG4gIC8vIG1ha2Ugc3VyZSByZ2IgYXJlIGNvbnRhaW5lZCBpbiBhIHNldCBvZiBbMCwgMjU1XVxuICB2YXIgcmVkID0gY29sb3IucmVkIC8gMjU1O1xuICB2YXIgZ3JlZW4gPSBjb2xvci5ncmVlbiAvIDI1NTtcbiAgdmFyIGJsdWUgPSBjb2xvci5ibHVlIC8gMjU1O1xuXG4gIHZhciBtYXggPSBNYXRoLm1heChyZWQsIGdyZWVuLCBibHVlKTtcbiAgdmFyIG1pbiA9IE1hdGgubWluKHJlZCwgZ3JlZW4sIGJsdWUpO1xuICB2YXIgbGlnaHRuZXNzID0gKG1heCArIG1pbikgLyAyO1xuXG4gIGlmIChtYXggPT09IG1pbikge1xuICAgIC8vIGFjaHJvbWF0aWNcbiAgICBpZiAoY29sb3IuYWxwaGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHsgaHVlOiAwLCBzYXR1cmF0aW9uOiAwLCBsaWdodG5lc3M6IGxpZ2h0bmVzcywgYWxwaGE6IGNvbG9yLmFscGhhIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IGh1ZTogMCwgc2F0dXJhdGlvbjogMCwgbGlnaHRuZXNzOiBsaWdodG5lc3MgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgaHVlID0gdm9pZCAwO1xuICB2YXIgZGVsdGEgPSBtYXggLSBtaW47XG4gIHZhciBzYXR1cmF0aW9uID0gbGlnaHRuZXNzID4gMC41ID8gZGVsdGEgLyAoMiAtIG1heCAtIG1pbikgOiBkZWx0YSAvIChtYXggKyBtaW4pO1xuICBzd2l0Y2ggKG1heCkge1xuICAgIGNhc2UgcmVkOlxuICAgICAgaHVlID0gKGdyZWVuIC0gYmx1ZSkgLyBkZWx0YSArIChncmVlbiA8IGJsdWUgPyA2IDogMCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGdyZWVuOlxuICAgICAgaHVlID0gKGJsdWUgLSByZWQpIC8gZGVsdGEgKyAyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGJsdWUgY2FzZVxuICAgICAgaHVlID0gKHJlZCAtIGdyZWVuKSAvIGRlbHRhICsgNDtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgaHVlICo9IDYwO1xuICBpZiAoY29sb3IuYWxwaGEgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7IGh1ZTogaHVlLCBzYXR1cmF0aW9uOiBzYXR1cmF0aW9uLCBsaWdodG5lc3M6IGxpZ2h0bmVzcywgYWxwaGE6IGNvbG9yLmFscGhhIH07XG4gIH1cbiAgcmV0dXJuIHsgaHVlOiBodWUsIHNhdHVyYXRpb246IHNhdHVyYXRpb24sIGxpZ2h0bmVzczogbGlnaHRuZXNzIH07XG59XG5cbi8vICAgICAgXG5cbi8qKlxuICogUmV0dXJucyBhbiBIc2xDb2xvciBvciBIc2xhQ29sb3Igb2JqZWN0LiBUaGlzIHV0aWxpdHkgZnVuY3Rpb24gaXMgb25seSB1c2VmdWxcbiAqIGlmIHdhbnQgdG8gZXh0cmFjdCBhIGNvbG9yIGNvbXBvbmVudC4gV2l0aCB0aGUgY29sb3IgdXRpbCBgdG9Db2xvclN0cmluZ2AgeW91XG4gKiBjYW4gY29udmVydCBhIEhzbENvbG9yIG9yIEhzbGFDb2xvciBvYmplY3QgYmFjayB0byBhIHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQXNzaWducyBgeyByZWQ6IDI1NSwgZ3JlZW46IDAsIGJsdWU6IDAgfWAgdG8gY29sb3IxXG4gKiBjb25zdCBjb2xvcjEgPSAncmdiKDI1NSwgMCwgMCknO1xuICogLy8gQXNzaWducyBgeyByZWQ6IDkyLCBncmVlbjogMTAyLCBibHVlOiAxMTIsIGFscGhhOiAwLjc1IH1gIHRvIGNvbG9yMlxuICogY29uc3QgY29sb3IyID0gJ2hzbGEoMjEwLCAxMCUsIDQwJSwgMC43NSknO1xuICovXG5mdW5jdGlvbiBwYXJzZVRvSHNsKGNvbG9yKSB7XG4gIC8vIE5vdGU6IEF0IGEgbGF0ZXIgc3RhZ2Ugd2UgY2FuIG9wdGltaXplIHRoaXMgZnVuY3Rpb24gYXMgcmlnaHQgbm93IGEgaHNsXG4gIC8vIGNvbG9yIHdvdWxkIGJlIHBhcnNlZCBjb252ZXJ0ZWQgdG8gcmdiIHZhbHVlcyBhbmQgY29udmVydGVkIGJhY2sgdG8gaHNsLlxuICByZXR1cm4gcmdiVG9Ic2wocGFyc2VUb1JnYihjb2xvcikpO1xufVxuXG4vLyAgICAgIFxuXG4vKipcbiAqIFJlZHVjZXMgaGV4IHZhbHVlcyBpZiBwb3NzaWJsZSBlLmcuICNmZjg4NjYgdG8gI2Y4NlxuICogQHByaXZhdGVcbiAqL1xudmFyIHJlZHVjZUhleFZhbHVlID0gZnVuY3Rpb24gcmVkdWNlSGV4VmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gNyAmJiB2YWx1ZVsxXSA9PT0gdmFsdWVbMl0gJiYgdmFsdWVbM10gPT09IHZhbHVlWzRdICYmIHZhbHVlWzVdID09PSB2YWx1ZVs2XSkge1xuICAgIHJldHVybiBcIiNcIiArIHZhbHVlWzFdICsgdmFsdWVbM10gKyB2YWx1ZVs1XTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyAgICAgIFxuZnVuY3Rpb24gbnVtYmVyVG9IZXgodmFsdWUpIHtcbiAgdmFyIGhleCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIGhleC5sZW5ndGggPT09IDEgPyBcIjBcIiArIGhleCA6IGhleDtcbn1cblxuLy8gICAgICBcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHZhbHVlIGZvciB0aGUgY29sb3IuIFRoZSByZXR1cm5lZCByZXN1bHQgaXMgdGhlIHNtYWxsZXN0IHBvc3NpYmxlIGhleCBub3RhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiByZ2IoMjU1LCAyMDUsIDEwMCksXG4gKiAgIGJhY2tncm91bmQ6IHJnYih7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAgfSksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7cmdiKDI1NSwgMjA1LCAxMDApfTtcbiAqICAgYmFja2dyb3VuZDogJHtyZ2IoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwIH0pfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2ZmY2Q2NFwiO1xuICogICBiYWNrZ3JvdW5kOiBcIiNmZmNkNjRcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gcmdiKHZhbHVlLCBncmVlbiwgYmx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgZ3JlZW4gPT09ICdudW1iZXInICYmIHR5cGVvZiBibHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiByZWR1Y2VIZXhWYWx1ZSgnIycgKyBudW1iZXJUb0hleCh2YWx1ZSkgKyBudW1iZXJUb0hleChncmVlbikgKyBudW1iZXJUb0hleChibHVlKSk7XG4gIH0gZWxzZSBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSA9PT0gJ29iamVjdCcgJiYgZ3JlZW4gPT09IHVuZGVmaW5lZCAmJiBibHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVkdWNlSGV4VmFsdWUoJyMnICsgbnVtYmVyVG9IZXgodmFsdWUucmVkKSArIG51bWJlclRvSGV4KHZhbHVlLmdyZWVuKSArIG51bWJlclRvSGV4KHZhbHVlLmJsdWUpKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignUGFzc2VkIGludmFsaWQgYXJndW1lbnRzIHRvIHJnYiwgcGxlYXNlIHBhc3MgbXVsdGlwbGUgbnVtYmVycyBlLmcuIHJnYigyNTUsIDIwNSwgMTAwKSBvciBhbiBvYmplY3QgZS5nLiByZ2IoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwIH0pLicpO1xufVxuXG4vLyAgICAgIFxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgdmFsdWUgZm9yIHRoZSBjb2xvci4gVGhlIHJldHVybmVkIHJlc3VsdCBpcyB0aGUgc21hbGxlc3QgcG9zc2libGUgcmdiYSBvciBoZXggbm90YXRpb24uXG4gKlxuICogQ2FuIGFsc28gYmUgdXNlZCB0byBmYWRlIGEgY29sb3IgYnkgcGFzc2luZyBhIGhleCB2YWx1ZSBvciBuYW1lZCBDU1MgY29sb3IgYWxvbmcgd2l0aCBhbiBhbHBoYSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjA1LCAxMDAsIDAuNyksXG4gKiAgIGJhY2tncm91bmQ6IHJnYmEoeyByZWQ6IDI1NSwgZ3JlZW46IDIwNSwgYmx1ZTogMTAwLCBhbHBoYTogMC43IH0pLFxuICogICBiYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjA1LCAxMDAsIDEpLFxuICogICBiYWNrZ3JvdW5kOiByZ2JhKCcjZmZmZmZmJywgMC40KSxcbiAqICAgYmFja2dyb3VuZDogcmdiYSgnYmxhY2snLCAwLjcpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3JnYmEoMjU1LCAyMDUsIDEwMCwgMC43KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7cmdiYSh7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAsIGFscGhhOiAwLjcgfSl9O1xuICogICBiYWNrZ3JvdW5kOiAke3JnYmEoMjU1LCAyMDUsIDEwMCwgMSl9O1xuICogICBiYWNrZ3JvdW5kOiAke3JnYmEoJyNmZmZmZmYnLCAwLjQpfTtcbiAqICAgYmFja2dyb3VuZDogJHtyZ2JhKCdibGFjaycsIDAuNyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwyMDUsMTAwLDAuNylcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwyMDUsMTAwLDAuNylcIjtcbiAqICAgYmFja2dyb3VuZDogXCIjZmZjZDY0XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMjU1LDI1NSwwLjQpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgwLDAsMCwwLjcpXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHJnYmEoZmlyc3RWYWx1ZSwgc2Vjb25kVmFsdWUsIHRoaXJkVmFsdWUsIGZvdXJ0aFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgZmlyc3RWYWx1ZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHNlY29uZFZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHZhciByZ2JWYWx1ZSA9IHBhcnNlVG9SZ2IoZmlyc3RWYWx1ZSk7XG4gICAgcmV0dXJuICdyZ2JhKCcgKyByZ2JWYWx1ZS5yZWQgKyAnLCcgKyByZ2JWYWx1ZS5ncmVlbiArICcsJyArIHJnYlZhbHVlLmJsdWUgKyAnLCcgKyBzZWNvbmRWYWx1ZSArICcpJztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZmlyc3RWYWx1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHNlY29uZFZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdGhpcmRWYWx1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGZvdXJ0aFZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmb3VydGhWYWx1ZSA+PSAxID8gcmdiKGZpcnN0VmFsdWUsIHNlY29uZFZhbHVlLCB0aGlyZFZhbHVlKSA6ICdyZ2JhKCcgKyBmaXJzdFZhbHVlICsgJywnICsgc2Vjb25kVmFsdWUgKyAnLCcgKyB0aGlyZFZhbHVlICsgJywnICsgZm91cnRoVmFsdWUgKyAnKSc7XG4gIH0gZWxzZSBpZiAoKHR5cGVvZiBmaXJzdFZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihmaXJzdFZhbHVlKSkgPT09ICdvYmplY3QnICYmIHNlY29uZFZhbHVlID09PSB1bmRlZmluZWQgJiYgdGhpcmRWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIGZvdXJ0aFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmlyc3RWYWx1ZS5hbHBoYSA+PSAxID8gcmdiKGZpcnN0VmFsdWUucmVkLCBmaXJzdFZhbHVlLmdyZWVuLCBmaXJzdFZhbHVlLmJsdWUpIDogJ3JnYmEoJyArIGZpcnN0VmFsdWUucmVkICsgJywnICsgZmlyc3RWYWx1ZS5ncmVlbiArICcsJyArIGZpcnN0VmFsdWUuYmx1ZSArICcsJyArIGZpcnN0VmFsdWUuYWxwaGEgKyAnKSc7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1Bhc3NlZCBpbnZhbGlkIGFyZ3VtZW50cyB0byByZ2JhLCBwbGVhc2UgcGFzcyBtdWx0aXBsZSBudW1iZXJzIGUuZy4gcmdiKDI1NSwgMjA1LCAxMDAsIDAuNzUpIG9yIGFuIG9iamVjdCBlLmcuIHJnYih7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAsIGFscGhhOiAwLjc1IH0pLicpO1xufVxuXG4vLyAgICAgIFxuZnVuY3Rpb24gY29sb3JUb0hleChjb2xvcikge1xuICByZXR1cm4gbnVtYmVyVG9IZXgoTWF0aC5yb3VuZChjb2xvciAqIDI1NSkpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VG9IZXgocmVkLCBncmVlbiwgYmx1ZSkge1xuICByZXR1cm4gcmVkdWNlSGV4VmFsdWUoJyMnICsgY29sb3JUb0hleChyZWQpICsgY29sb3JUb0hleChncmVlbikgKyBjb2xvclRvSGV4KGJsdWUpKTtcbn1cblxuZnVuY3Rpb24gaHNsVG9IZXgoaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MpIHtcbiAgcmV0dXJuIGhzbFRvUmdiKGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBjb252ZXJ0VG9IZXgpO1xufVxuXG4vLyAgICAgIFxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgdmFsdWUgZm9yIHRoZSBjb2xvci4gVGhlIHJldHVybmVkIHJlc3VsdCBpcyB0aGUgc21hbGxlc3QgcG9zc2libGUgaGV4IG5vdGF0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGhzbCgzNTksIDAuNzUsIDAuNCksXG4gKiAgIGJhY2tncm91bmQ6IGhzbCh7IGh1ZTogMzYwLCBzYXR1cmF0aW9uOiAwLjc1LCBsaWdodG5lc3M6IDAuNCB9KSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtoc2woMzU5LCAwLjc1LCAwLjQpfTtcbiAqICAgYmFja2dyb3VuZDogJHtoc2woeyBodWU6IDM2MCwgc2F0dXJhdGlvbjogMC43NSwgbGlnaHRuZXNzOiAwLjQgfSl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjYjMxOTFjXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2IzMTkxY1wiO1xuICogfVxuICovXG5mdW5jdGlvbiBoc2wodmFsdWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcykge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygc2F0dXJhdGlvbiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGxpZ2h0bmVzcyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gaHNsVG9IZXgodmFsdWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcyk7XG4gIH0gZWxzZSBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpKSA9PT0gJ29iamVjdCcgJiYgc2F0dXJhdGlvbiA9PT0gdW5kZWZpbmVkICYmIGxpZ2h0bmVzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGhzbFRvSGV4KHZhbHVlLmh1ZSwgdmFsdWUuc2F0dXJhdGlvbiwgdmFsdWUubGlnaHRuZXNzKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignUGFzc2VkIGludmFsaWQgYXJndW1lbnRzIHRvIGhzbCwgcGxlYXNlIHBhc3MgbXVsdGlwbGUgbnVtYmVycyBlLmcuIGhzbCgzNjAsIDAuNzUsIDAuNCkgb3IgYW4gb2JqZWN0IGUuZy4gcmdiKHsgaHVlOiAyNTUsIHNhdHVyYXRpb246IDAuNCwgbGlnaHRuZXNzOiAwLjc1IH0pLicpO1xufVxuXG4vLyAgICAgIFxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgdmFsdWUgZm9yIHRoZSBjb2xvci4gVGhlIHJldHVybmVkIHJlc3VsdCBpcyB0aGUgc21hbGxlc3QgcG9zc2libGUgcmdiYSBvciBoZXggbm90YXRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogaHNsYSgzNTksIDAuNzUsIDAuNCwgMC43KSxcbiAqICAgYmFja2dyb3VuZDogaHNsYSh7IGh1ZTogMzYwLCBzYXR1cmF0aW9uOiAwLjc1LCBsaWdodG5lc3M6IDAuNCwgYWxwaGE6IDAsNyB9KSxcbiAqICAgYmFja2dyb3VuZDogaHNsYSgzNTksIDAuNzUsIDAuNCwgMSksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7aHNsYSgzNTksIDAuNzUsIDAuNCwgMC43KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7aHNsYSh7IGh1ZTogMzYwLCBzYXR1cmF0aW9uOiAwLjc1LCBsaWdodG5lc3M6IDAuNCwgYWxwaGE6IDAsNyB9KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7aHNsYSgzNTksIDAuNzUsIDAuNCwgMSl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDE3OSwyNSwyOCwwLjcpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxNzksMjUsMjgsMC43KVwiO1xuICogICBiYWNrZ3JvdW5kOiBcIiNiMzE5MWNcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gaHNsYSh2YWx1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBhbHBoYSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygc2F0dXJhdGlvbiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGxpZ2h0bmVzcyA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFscGhhID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBhbHBoYSA+PSAxID8gaHNsVG9IZXgodmFsdWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcykgOiAncmdiYSgnICsgaHNsVG9SZ2IodmFsdWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcykgKyAnLCcgKyBhbHBoYSArICcpJztcbiAgfSBlbHNlIGlmICgodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnb2JqZWN0JyAmJiBzYXR1cmF0aW9uID09PSB1bmRlZmluZWQgJiYgbGlnaHRuZXNzID09PSB1bmRlZmluZWQgJiYgYWxwaGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2YWx1ZS5hbHBoYSA+PSAxID8gaHNsVG9IZXgodmFsdWUuaHVlLCB2YWx1ZS5zYXR1cmF0aW9uLCB2YWx1ZS5saWdodG5lc3MpIDogJ3JnYmEoJyArIGhzbFRvUmdiKHZhbHVlLmh1ZSwgdmFsdWUuc2F0dXJhdGlvbiwgdmFsdWUubGlnaHRuZXNzKSArICcsJyArIHZhbHVlLmFscGhhICsgJyknO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdQYXNzZWQgaW52YWxpZCBhcmd1bWVudHMgdG8gaHNsYSwgcGxlYXNlIHBhc3MgbXVsdGlwbGUgbnVtYmVycyBlLmcuIGhzbCgzNjAsIDAuNzUsIDAuNCwgMC43KSBvciBhbiBvYmplY3QgZS5nLiByZ2IoeyBodWU6IDI1NSwgc2F0dXJhdGlvbjogMC40LCBsaWdodG5lc3M6IDAuNzUsIGFscGhhOiAwLjcgfSkuJyk7XG59XG5cbi8vICAgICAgXG52YXIgaXNSZ2IgPSBmdW5jdGlvbiBpc1JnYihjb2xvcikge1xuICByZXR1cm4gdHlwZW9mIGNvbG9yLnJlZCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbG9yLmdyZWVuID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IuYmx1ZSA9PT0gJ251bWJlcicgJiYgKHR5cGVvZiBjb2xvci5hbHBoYSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGNvbG9yLmFscGhhID09PSAndW5kZWZpbmVkJyk7XG59O1xuXG52YXIgaXNSZ2JhID0gZnVuY3Rpb24gaXNSZ2JhKGNvbG9yKSB7XG4gIHJldHVybiB0eXBlb2YgY29sb3IucmVkID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IuZ3JlZW4gPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5ibHVlID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IuYWxwaGEgPT09ICdudW1iZXInO1xufTtcblxudmFyIGlzSHNsID0gZnVuY3Rpb24gaXNIc2woY29sb3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb2xvci5odWUgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5zYXR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IubGlnaHRuZXNzID09PSAnbnVtYmVyJyAmJiAodHlwZW9mIGNvbG9yLmFscGhhICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgY29sb3IuYWxwaGEgPT09ICd1bmRlZmluZWQnKTtcbn07XG5cbnZhciBpc0hzbGEgPSBmdW5jdGlvbiBpc0hzbGEoY29sb3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBjb2xvci5odWUgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb2xvci5zYXR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IubGlnaHRuZXNzID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29sb3IuYWxwaGEgPT09ICdudW1iZXInO1xufTtcblxudmFyIGVyck1zZyA9ICdQYXNzZWQgaW52YWxpZCBhcmd1bWVudCB0byB0b0NvbG9yU3RyaW5nLCBwbGVhc2UgcGFzcyBhIFJnYkNvbG9yLCBSZ2JhQ29sb3IsIEhzbENvbG9yIG9yIEhzbGFDb2xvciBvYmplY3QuJztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIFJnYkNvbG9yLCBSZ2JhQ29sb3IsIEhzbENvbG9yIG9yIEhzbGFDb2xvciBvYmplY3QgdG8gYSBjb2xvciBzdHJpbmcuXG4gKiBUaGlzIHV0aWwgaXMgdXNlZnVsIGluIGNhc2UgeW91IG9ubHkga25vdyBvbiBydW50aW1lIHdoaWNoIGNvbG9yIG9iamVjdCBpc1xuICogdXNlZC4gT3RoZXJ3aXNlIHdlIHJlY29tbWVuZCB0byByZWx5IG9uIGByZ2JgLCBgcmdiYWAsIGBoc2xgIG9yIGBoc2xhYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiB0b0NvbG9yU3RyaW5nKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCB9KSxcbiAqICAgYmFja2dyb3VuZDogdG9Db2xvclN0cmluZyh7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAsIGFscGhhOiAwLjcyIH0pLFxuICogICBiYWNrZ3JvdW5kOiB0b0NvbG9yU3RyaW5nKHsgaHVlOiAyNDAsIHNhdHVyYXRpb246IDEsIGxpZ2h0bmVzczogMC41IH0pLFxuICogICBiYWNrZ3JvdW5kOiB0b0NvbG9yU3RyaW5nKHsgaHVlOiAzNjAsIHNhdHVyYXRpb246IDAuNzUsIGxpZ2h0bmVzczogMC40LCBhbHBoYTogMC43MiB9KSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHt0b0NvbG9yU3RyaW5nKHsgcmVkOiAyNTUsIGdyZWVuOiAyMDUsIGJsdWU6IDEwMCB9KX07XG4gKiAgIGJhY2tncm91bmQ6ICR7dG9Db2xvclN0cmluZyh7IHJlZDogMjU1LCBncmVlbjogMjA1LCBibHVlOiAxMDAsIGFscGhhOiAwLjcyIH0pfTtcbiAqICAgYmFja2dyb3VuZDogJHt0b0NvbG9yU3RyaW5nKHsgaHVlOiAyNDAsIHNhdHVyYXRpb246IDEsIGxpZ2h0bmVzczogMC41IH0pfTtcbiAqICAgYmFja2dyb3VuZDogJHt0b0NvbG9yU3RyaW5nKHsgaHVlOiAzNjAsIHNhdHVyYXRpb246IDAuNzUsIGxpZ2h0bmVzczogMC40LCBhbHBoYTogMC43MiB9KX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2ZmY2Q2NFwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjU1LDIwNSwxMDAsMC43MilcIjtcbiAqICAgYmFja2dyb3VuZDogXCIjMDBmXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxNzksMjUsMjUsMC43MilcIjtcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiB0b0NvbG9yU3RyaW5nKGNvbG9yKSB7XG4gIGlmICgodHlwZW9mIGNvbG9yID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb2xvcikpICE9PSAnb2JqZWN0JykgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gIGlmIChpc1JnYmEoY29sb3IpKSByZXR1cm4gcmdiYShjb2xvcik7XG4gIGlmIChpc1JnYihjb2xvcikpIHJldHVybiByZ2IoY29sb3IpO1xuICBpZiAoaXNIc2xhKGNvbG9yKSkgcmV0dXJuIGhzbGEoY29sb3IpO1xuICBpZiAoaXNIc2woY29sb3IpKSByZXR1cm4gaHNsKGNvbG9yKTtcblxuICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbn1cblxuLy8gICAgICBcblxuLy8gVHlwZSBkZWZpbml0aW9ucyB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9nY2FudGkvZmxvdy1zdGF0aWMtbGFuZC9ibG9iL21hc3Rlci9zcmMvRnVuLmpzXG5cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuXG5mdW5jdGlvbiBjdXJyaWVkKGYsIGxlbmd0aCwgYWNjKSB7XG4gIHJldHVybiBmdW5jdGlvbiBmbigpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgdmFyIGNvbWJpbmVkID0gYWNjLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gY29tYmluZWQubGVuZ3RoID49IGxlbmd0aCA/IGYuYXBwbHkodGhpcywgY29tYmluZWQpIDogY3VycmllZChmLCBsZW5ndGgsIGNvbWJpbmVkKTtcbiAgfTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuZnVuY3Rpb24gY3VycnkoZikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlZGVjbGFyZVxuICByZXR1cm4gY3VycmllZChmLCBmLmxlbmd0aCwgW10pO1xufVxuXG4vLyAgICAgIFxuXG4vKipcbiAqIENoYW5nZXMgdGhlIGh1ZSBvZiB0aGUgY29sb3IuIEh1ZSBpcyBhIG51bWJlciBiZXR3ZWVuIDAgdG8gMzYwLiBUaGUgZmlyc3RcbiAqIGFyZ3VtZW50IGZvciBhZGp1c3RIdWUgaXMgdGhlIGFtb3VudCBvZiBkZWdyZWVzIHRoZSBjb2xvciBpcyByb3RhdGVkIGFsb25nXG4gKiB0aGUgY29sb3Igd2hlZWwuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogYWRqdXN0SHVlKDE4MCwgJyM0NDgnKSxcbiAqICAgYmFja2dyb3VuZDogYWRqdXN0SHVlKDE4MCwgJ3JnYmEoMTAxLDEwMCwyMDUsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2FkanVzdEh1ZSgxODAsICcjNDQ4Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke2FkanVzdEh1ZSgxODAsICdyZ2JhKDEwMSwxMDAsMjA1LDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzg4ODg0NFwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMTM2LDEzNiw2OCwwLjcpXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGFkanVzdEh1ZShkZWdyZWUsIGNvbG9yKSB7XG4gIHZhciBoc2xDb2xvciA9IHBhcnNlVG9Ic2woY29sb3IpO1xuICByZXR1cm4gdG9Db2xvclN0cmluZyhfZXh0ZW5kcyh7fSwgaHNsQ29sb3IsIHtcbiAgICBodWU6IChoc2xDb2xvci5odWUgKyBkZWdyZWUpICUgMzYwXG4gIH0pKTtcbn1cblxudmFyIGN1cnJpZWRBZGp1c3RIdWUgPSAvKiNfX1BVUkVfXyovY3VycnkoYWRqdXN0SHVlKTtcblxuLy8gICAgICBcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb21wbGVtZW50IG9mIHRoZSBwcm92aWRlZCBjb2xvci4gVGhpcyBpcyBpZGVudGljYWwgdG8gYWRqdXN0SHVlKDE4MCwgPGNvbG9yPikuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogY29tcGxlbWVudCgnIzQ0OCcpLFxuICogICBiYWNrZ3JvdW5kOiBjb21wbGVtZW50KCdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtjb21wbGVtZW50KCcjNDQ4Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke2NvbXBsZW1lbnQoJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjODg0XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxNTMsMTUzLDE1MywwLjcpXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGNvbXBsZW1lbnQoY29sb3IpIHtcbiAgdmFyIGhzbENvbG9yID0gcGFyc2VUb0hzbChjb2xvcik7XG4gIHJldHVybiB0b0NvbG9yU3RyaW5nKF9leHRlbmRzKHt9LCBoc2xDb2xvciwge1xuICAgIGh1ZTogKGhzbENvbG9yLmh1ZSArIDE4MCkgJSAzNjBcbiAgfSkpO1xufVxuXG4vLyAgICAgIFxuXG5mdW5jdGlvbiBndWFyZChsb3dlckJvdW5kYXJ5LCB1cHBlckJvdW5kYXJ5LCB2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5tYXgobG93ZXJCb3VuZGFyeSwgTWF0aC5taW4odXBwZXJCb3VuZGFyeSwgdmFsdWUpKTtcbn1cblxuLy8gICAgICBcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHZhbHVlIGZvciB0aGUgZGFya2VuZWQgY29sb3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogZGFya2VuKDAuMiwgJyNGRkNENjQnKSxcbiAqICAgYmFja2dyb3VuZDogZGFya2VuKDAuMiwgJ3JnYmEoMjU1LDIwNSwxMDAsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2RhcmtlbigwLjIsICcjRkZDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke2RhcmtlbigwLjIsICdyZ2JhKDI1NSwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiNmZmJkMzFcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwxODksNDksMC43KVwiO1xuICogfVxuICovXG5mdW5jdGlvbiBkYXJrZW4oYW1vdW50LCBjb2xvcikge1xuICB2YXIgaHNsQ29sb3IgPSBwYXJzZVRvSHNsKGNvbG9yKTtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIGhzbENvbG9yLCB7XG4gICAgbGlnaHRuZXNzOiBndWFyZCgwLCAxLCBoc2xDb2xvci5saWdodG5lc3MgLSBhbW91bnQpXG4gIH0pKTtcbn1cblxudmFyIGN1cnJpZWREYXJrZW4gPSAvKiNfX1BVUkVfXyovY3VycnkoZGFya2VuKTtcblxuLy8gICAgICBcblxuLyoqXG4gKiBEZWNyZWFzZXMgdGhlIGludGVuc2l0eSBvZiBhIGNvbG9yLiBJdHMgcmFuZ2UgaXMgYmV0d2VlbiAwIHRvIDEuIFRoZSBmaXJzdFxuICogYXJndW1lbnQgb2YgdGhlIGRlc2F0dXJhdGUgZnVuY3Rpb24gaXMgdGhlIGFtb3VudCBieSBob3cgbXVjaCB0aGUgY29sb3JcbiAqIGludGVuc2l0eSBzaG91bGQgYmUgZGVjcmVhc2VkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGRlc2F0dXJhdGUoMC4yLCAnI0NDQ0Q2NCcpLFxuICogICBiYWNrZ3JvdW5kOiBkZXNhdHVyYXRlKDAuMiwgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke2Rlc2F0dXJhdGUoMC4yLCAnI0NDQ0Q2NCcpfTtcbiAqICAgYmFja2dyb3VuZDogJHtkZXNhdHVyYXRlKDAuMiwgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjYjhiOTc5XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgxODQsMTg1LDEyMSwwLjcpXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGRlc2F0dXJhdGUoYW1vdW50LCBjb2xvcikge1xuICB2YXIgaHNsQ29sb3IgPSBwYXJzZVRvSHNsKGNvbG9yKTtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIGhzbENvbG9yLCB7XG4gICAgc2F0dXJhdGlvbjogZ3VhcmQoMCwgMSwgaHNsQ29sb3Iuc2F0dXJhdGlvbiAtIGFtb3VudClcbiAgfSkpO1xufVxuXG52YXIgY3VycmllZERlc2F0dXJhdGUgPSAvKiNfX1BVUkVfXyovY3VycnkoZGVzYXR1cmF0ZSk7XG5cbi8vICAgICAgXG4vKipcbiAqIFJldHVybnMgYSBudW1iZXIgKGZsb2F0KSByZXByZXNlbnRpbmcgdGhlIGx1bWluYW5jZSBvZiBhIGNvbG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IGdldEx1bWluYW5jZSgnI0NDQ0Q2NCcpID49IGdldEx1bWluYW5jZSgnIzAwMDBmZicpID8gJyNDQ0NENjQnIDogJyMwMDAwZmYnLFxuICogICBiYWNrZ3JvdW5kOiBnZXRMdW1pbmFuY2UoJ3JnYmEoNTgsIDEzMywgMjU1LCAxKScpID49IGdldEx1bWluYW5jZSgncmdiYSgyNTUsIDU3LCAxNDksIDEpJykgP1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZ2JhKDU4LCAxMzMsIDI1NSwgMSknIDpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmdiYSgyNTUsIDU3LCAxNDksIDEpJyxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtnZXRMdW1pbmFuY2UoJyNDQ0NENjQnKSA+PSBnZXRMdW1pbmFuY2UoJyMwMDAwZmYnKSA/ICcjQ0NDRDY0JyA6ICcjMDAwMGZmJ307XG4gKiAgIGJhY2tncm91bmQ6ICR7Z2V0THVtaW5hbmNlKCdyZ2JhKDU4LCAxMzMsIDI1NSwgMSknKSA+PSBnZXRMdW1pbmFuY2UoJ3JnYmEoMjU1LCA1NywgMTQ5LCAxKScpID9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmdiYSg1OCwgMTMzLCAyNTUsIDEpJyA6XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JnYmEoMjU1LCA1NywgMTQ5LCAxKSd9O1xuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICBiYWNrZ3JvdW5kOiBcIiNDQ0NENjRcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDU4LCAxMzMsIDI1NSwgMSlcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gZ2V0THVtaW5hbmNlKGNvbG9yKSB7XG4gIHZhciByZ2JDb2xvciA9IHBhcnNlVG9SZ2IoY29sb3IpO1xuXG4gIHZhciBfT2JqZWN0JGtleXMkbWFwID0gT2JqZWN0LmtleXMocmdiQ29sb3IpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGNoYW5uZWwgPSByZ2JDb2xvcltrZXldIC8gMjU1O1xuICAgIHJldHVybiBjaGFubmVsIDw9IDAuMDM5MjggPyBjaGFubmVsIC8gMTIuOTIgOiBNYXRoLnBvdygoY2hhbm5lbCArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuICB9KSxcbiAgICAgIHIgPSBfT2JqZWN0JGtleXMkbWFwWzBdLFxuICAgICAgZyA9IF9PYmplY3Qka2V5cyRtYXBbMV0sXG4gICAgICBiID0gX09iamVjdCRrZXlzJG1hcFsyXTtcblxuICByZXR1cm4gMC4yMTI2ICogciArIDAuNzE1MiAqIGcgKyAwLjA3MjIgKiBiO1xufVxuXG4vLyAgICAgIFxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBjb2xvciB0byBhIGdyYXlzY2FsZSwgYnkgcmVkdWNpbmcgaXRzIHNhdHVyYXRpb24gdG8gMC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBncmF5c2NhbGUoJyNDQ0NENjQnKSxcbiAqICAgYmFja2dyb3VuZDogZ3JheXNjYWxlKCdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtncmF5c2NhbGUoJyNDQ0NENjQnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7Z3JheXNjYWxlKCdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzk5OVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMTUzLDE1MywxNTMsMC43KVwiO1xuICogfVxuICovXG5mdW5jdGlvbiBncmF5c2NhbGUoY29sb3IpIHtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIHBhcnNlVG9Ic2woY29sb3IpLCB7XG4gICAgc2F0dXJhdGlvbjogMFxuICB9KSk7XG59XG5cbi8vICAgICAgXG5cbi8qKlxuICogSW52ZXJ0cyB0aGUgcmVkLCBncmVlbiBhbmQgYmx1ZSB2YWx1ZXMgb2YgYSBjb2xvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBpbnZlcnQoJyNDQ0NENjQnKSxcbiAqICAgYmFja2dyb3VuZDogaW52ZXJ0KCdyZ2JhKDEwMSwxMDAsMjA1LDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtpbnZlcnQoJyNDQ0NENjQnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7aW52ZXJ0KCdyZ2JhKDEwMSwxMDAsMjA1LDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICpcbiAqIGVsZW1lbnQge1xuICogICBiYWNrZ3JvdW5kOiBcIiMzMzMyOWJcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDE1NCwxNTUsNTAsMC43KVwiO1xuICogfVxuICovXG5mdW5jdGlvbiBpbnZlcnQoY29sb3IpIHtcbiAgLy8gcGFyc2UgY29sb3Igc3RyaW5nIHRvIHJnYlxuICB2YXIgdmFsdWUgPSBwYXJzZVRvUmdiKGNvbG9yKTtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIHZhbHVlLCB7XG4gICAgcmVkOiAyNTUgLSB2YWx1ZS5yZWQsXG4gICAgZ3JlZW46IDI1NSAtIHZhbHVlLmdyZWVuLFxuICAgIGJsdWU6IDI1NSAtIHZhbHVlLmJsdWVcbiAgfSkpO1xufVxuXG4vLyAgICAgIFxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgdmFsdWUgZm9yIHRoZSBsaWdodGVuZWQgY29sb3IuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogbGlnaHRlbigwLjIsICcjQ0NDRDY0JyksXG4gKiAgIGJhY2tncm91bmQ6IGxpZ2h0ZW4oMC4yLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7bGlnaHRlbigwLjIsICcjRkZDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke2xpZ2h0ZW4oMC4yLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjZTVlNmIxXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyMjksMjMwLDE3NywwLjcpXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGxpZ2h0ZW4oYW1vdW50LCBjb2xvcikge1xuICB2YXIgaHNsQ29sb3IgPSBwYXJzZVRvSHNsKGNvbG9yKTtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIGhzbENvbG9yLCB7XG4gICAgbGlnaHRuZXNzOiBndWFyZCgwLCAxLCBoc2xDb2xvci5saWdodG5lc3MgKyBhbW91bnQpXG4gIH0pKTtcbn1cblxudmFyIGN1cnJpZWRMaWdodGVuID0gLyojX19QVVJFX18qL2N1cnJ5KGxpZ2h0ZW4pO1xuXG4vLyAgICAgIFxuXG4vKipcbiAqIE1peGVzIHR3byBjb2xvcnMgdG9nZXRoZXIgYnkgY2FsY3VsYXRpbmcgdGhlIGF2ZXJhZ2Ugb2YgZWFjaCBvZiB0aGUgUkdCIGNvbXBvbmVudHMuXG4gKlxuICogQnkgZGVmYXVsdCB0aGUgd2VpZ2h0IGlzIDAuNSBtZWFuaW5nIHRoYXQgaGFsZiBvZiB0aGUgZmlyc3QgY29sb3IgYW5kIGhhbGYgdGhlIHNlY29uZFxuICogY29sb3Igc2hvdWxkIGJlIHVzZWQuIE9wdGlvbmFsbHkgdGhlIHdlaWdodCBjYW4gYmUgbW9kaWZpZWQgYnkgcHJvdmlkaW5nIGEgbnVtYmVyXG4gKiBhcyB0aGUgZmlyc3QgYXJndW1lbnQuIDAuMjUgbWVhbnMgdGhhdCBhIHF1YXJ0ZXIgb2YgdGhlIGZpcnN0IGNvbG9yIGFuZCB0aHJlZSBxdWFydGVyc1xuICogb2YgdGhlIHNlY29uZCBjb2xvciBzaG91bGQgYmUgdXNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBtaXgoMC41LCAnI2YwMCcsICcjMDBmJylcbiAqICAgYmFja2dyb3VuZDogbWl4KDAuMjUsICcjZjAwJywgJyMwMGYnKVxuICogICBiYWNrZ3JvdW5kOiBtaXgoMC41LCAncmdiYSgyNTUsIDAsIDAsIDAuNSknLCAnIzAwZicpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7bWl4KDAuNSwgJyNmMDAnLCAnIzAwZicpfTtcbiAqICAgYmFja2dyb3VuZDogJHttaXgoMC4yNSwgJyNmMDAnLCAnIzAwZicpfTtcbiAqICAgYmFja2dyb3VuZDogJHttaXgoMC41LCAncmdiYSgyNTUsIDAsIDAsIDAuNSknLCAnIzAwZicpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzdmMDA3ZlwiO1xuICogICBiYWNrZ3JvdW5kOiBcIiMzZjAwYmZcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDYzLCAwLCAxOTEsIDAuNzUpXCI7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIG1peCgpIHtcbiAgdmFyIHdlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMC41O1xuICB2YXIgY29sb3IgPSBhcmd1bWVudHNbMV07XG4gIHZhciBvdGhlckNvbG9yID0gYXJndW1lbnRzWzJdO1xuXG4gIHZhciBwYXJzZWRDb2xvcjEgPSBwYXJzZVRvUmdiKGNvbG9yKTtcbiAgdmFyIGNvbG9yMSA9IF9leHRlbmRzKHt9LCBwYXJzZWRDb2xvcjEsIHtcbiAgICBhbHBoYTogdHlwZW9mIHBhcnNlZENvbG9yMS5hbHBoYSA9PT0gJ251bWJlcicgPyBwYXJzZWRDb2xvcjEuYWxwaGEgOiAxXG4gIH0pO1xuXG4gIHZhciBwYXJzZWRDb2xvcjIgPSBwYXJzZVRvUmdiKG90aGVyQ29sb3IpO1xuICB2YXIgY29sb3IyID0gX2V4dGVuZHMoe30sIHBhcnNlZENvbG9yMiwge1xuICAgIGFscGhhOiB0eXBlb2YgcGFyc2VkQ29sb3IyLmFscGhhID09PSAnbnVtYmVyJyA/IHBhcnNlZENvbG9yMi5hbHBoYSA6IDFcbiAgfSk7XG5cbiAgLy8gVGhlIGZvcm11bGFyIGlzIGNvcGllZCBmcm9tIHRoZSBvcmlnaW5hbCBTYXNzIGltcGxlbWVudGF0aW9uOlxuICAvLyBodHRwOi8vc2Fzcy1sYW5nLmNvbS9kb2N1bWVudGF0aW9uL1Nhc3MvU2NyaXB0L0Z1bmN0aW9ucy5odG1sI21peC1pbnN0YW5jZV9tZXRob2RcbiAgdmFyIGFscGhhRGVsdGEgPSBjb2xvcjEuYWxwaGEgLSBjb2xvcjIuYWxwaGE7XG4gIHZhciB4ID0gd2VpZ2h0ICogMiAtIDE7XG4gIHZhciB5ID0geCAqIGFscGhhRGVsdGEgPT09IC0xID8geCA6IHggKyBhbHBoYURlbHRhO1xuICB2YXIgeiA9IDEgKyB4ICogYWxwaGFEZWx0YTtcbiAgdmFyIHdlaWdodDEgPSAoeSAvIHogKyAxKSAvIDIuMDtcbiAgdmFyIHdlaWdodDIgPSAxIC0gd2VpZ2h0MTtcblxuICB2YXIgbWl4ZWRDb2xvciA9IHtcbiAgICByZWQ6IE1hdGguZmxvb3IoY29sb3IxLnJlZCAqIHdlaWdodDEgKyBjb2xvcjIucmVkICogd2VpZ2h0MiksXG4gICAgZ3JlZW46IE1hdGguZmxvb3IoY29sb3IxLmdyZWVuICogd2VpZ2h0MSArIGNvbG9yMi5ncmVlbiAqIHdlaWdodDIpLFxuICAgIGJsdWU6IE1hdGguZmxvb3IoY29sb3IxLmJsdWUgKiB3ZWlnaHQxICsgY29sb3IyLmJsdWUgKiB3ZWlnaHQyKSxcbiAgICBhbHBoYTogY29sb3IxLmFscGhhICsgKGNvbG9yMi5hbHBoYSAtIGNvbG9yMS5hbHBoYSkgKiAod2VpZ2h0IC8gMS4wKVxuICB9O1xuXG4gIHJldHVybiByZ2JhKG1peGVkQ29sb3IpO1xufVxuXG52YXIgY3VycmllZE1peCA9IC8qI19fUFVSRV9fKi9jdXJyeShtaXgpO1xuXG4vLyAgICAgIFxuLyoqXG4gKiBJbmNyZWFzZXMgdGhlIG9wYWNpdHkgb2YgYSBjb2xvci4gSXRzIHJhbmdlIGZvciB0aGUgYW1vdW50IGlzIGJldHdlZW4gMCB0byAxLlxuICpcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBvcGFjaWZ5KDAuMSwgJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC45KScpO1xuICogICBiYWNrZ3JvdW5kOiBvcGFjaWZ5KDAuMiwgJ2hzbGEoMCwgMCUsIDEwMCUsIDAuNSknKSxcbiAqICAgYmFja2dyb3VuZDogb3BhY2lmeSgwLjUsICdyZ2JhKDI1NSwgMCwgMCwgMC4yKScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke29wYWNpZnkoMC4xLCAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpJyl9O1xuICogICBiYWNrZ3JvdW5kOiAke29wYWNpZnkoMC4yLCAnaHNsYSgwLCAwJSwgMTAwJSwgMC41KScpfSxcbiAqICAgYmFja2dyb3VuZDogJHtvcGFjaWZ5KDAuNSwgJ3JnYmEoMjU1LCAwLCAwLCAwLjIpJyl9LFxuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjZmZmXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMjU1LDI1NSwwLjcpXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyNTUsMCwwLDAuNylcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gb3BhY2lmeShhbW91bnQsIGNvbG9yKSB7XG4gIHZhciBwYXJzZWRDb2xvciA9IHBhcnNlVG9SZ2IoY29sb3IpO1xuICB2YXIgYWxwaGEgPSB0eXBlb2YgcGFyc2VkQ29sb3IuYWxwaGEgPT09ICdudW1iZXInID8gcGFyc2VkQ29sb3IuYWxwaGEgOiAxO1xuICB2YXIgY29sb3JXaXRoQWxwaGEgPSBfZXh0ZW5kcyh7fSwgcGFyc2VkQ29sb3IsIHtcbiAgICBhbHBoYTogZ3VhcmQoMCwgMSwgKGFscGhhICogMTAwICsgYW1vdW50ICogMTAwKSAvIDEwMClcbiAgfSk7XG4gIHJldHVybiByZ2JhKGNvbG9yV2l0aEFscGhhKTtcbn1cblxudmFyIGN1cnJpZWRPcGFjaWZ5ID0gLyojX19QVVJFX18qL2N1cnJ5KG9wYWNpZnkpO1xuXG4vLyAgICAgIFxuLyoqXG4gKiBTZWxlY3RzIGJsYWNrIG9yIHdoaXRlIGZvciBiZXN0IGNvbnRyYXN0IGRlcGVuZGluZyBvbiB0aGUgbHVtaW5vc2l0eSBvZiB0aGUgZ2l2ZW4gY29sb3IuXG4gKiBGb2xsb3dzIFczQyBzcGVjcyBmb3IgcmVhZGFiaWxpdHkgYXQgaHR0cHM6Ly93d3cudzMub3JnL1RSL1dDQUcyMC1URUNIUy9HMTguaHRtbFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGNvbG9yOiByZWFkYWJsZUNvbG9yKCcjMDAwJyksXG4gKiAgIGNvbG9yOiByZWFkYWJsZUNvbG9yKCdwYXBheWF3aGlwJyksXG4gKiAgIGNvbG9yOiByZWFkYWJsZUNvbG9yKCdyZ2IoMjU1LDAsMCknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgY29sb3I6ICR7cmVhZGFibGVDb2xvcignIzAwMCcpfTtcbiAqICAgY29sb3I6ICR7cmVhZGFibGVDb2xvcigncGFwYXlhd2hpcCcpfTtcbiAqICAgY29sb3I6ICR7cmVhZGFibGVDb2xvcigncmdiKDI1NSwwLDApJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgY29sb3I6IFwiI2ZmZlwiO1xuICogICBjb2xvcjogXCIjZmZmXCI7XG4gKiAgIGNvbG9yOiBcIiMwMDBcIjtcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiByZWFkYWJsZUNvbG9yKGNvbG9yKSB7XG4gIHJldHVybiBnZXRMdW1pbmFuY2UoY29sb3IpID4gMC4xNzkgPyAnIzAwMCcgOiAnI2ZmZic7XG59XG5cbnZhciBjdXJyaWVkUmVhZGFibGVDb2xvciA9IC8qI19fUFVSRV9fKi9jdXJyeShyZWFkYWJsZUNvbG9yKTtcblxuLy8gICAgICBcblxuLyoqXG4gKiBJbmNyZWFzZXMgdGhlIGludGVuc2l0eSBvZiBhIGNvbG9yLiBJdHMgcmFuZ2UgaXMgYmV0d2VlbiAwIHRvIDEuIFRoZSBmaXJzdFxuICogYXJndW1lbnQgb2YgdGhlIHNhdHVyYXRlIGZ1bmN0aW9uIGlzIHRoZSBhbW91bnQgYnkgaG93IG11Y2ggdGhlIGNvbG9yXG4gKiBpbnRlbnNpdHkgc2hvdWxkIGJlIGluY3JlYXNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBzYXR1cmF0ZSgwLjIsICcjQ0NDRDY0JyksXG4gKiAgIGJhY2tncm91bmQ6IHNhdHVyYXRlKDAuMiwgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpLFxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3NhdHVyYXRlKDAuMiwgJyNGRkNENjQnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7c2F0dXJhdGUoMC4yLCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjZTBlMjUwXCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyMjQsMjI2LDgwLDAuNylcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gc2F0dXJhdGUoYW1vdW50LCBjb2xvcikge1xuICB2YXIgaHNsQ29sb3IgPSBwYXJzZVRvSHNsKGNvbG9yKTtcbiAgcmV0dXJuIHRvQ29sb3JTdHJpbmcoX2V4dGVuZHMoe30sIGhzbENvbG9yLCB7XG4gICAgc2F0dXJhdGlvbjogZ3VhcmQoMCwgMSwgaHNsQ29sb3Iuc2F0dXJhdGlvbiArIGFtb3VudClcbiAgfSkpO1xufVxuXG52YXIgY3VycmllZFNhdHVyYXRlID0gLyojX19QVVJFX18qL2N1cnJ5KHNhdHVyYXRlKTtcblxuLy8gICAgICBcblxuLyoqXG4gKiBTZXRzIHRoZSBodWUgb2YgYSBjb2xvciB0byB0aGUgcHJvdmlkZWQgdmFsdWUuIFRoZSBodWUgcmFuZ2UgY2FuIGJlXG4gKiBmcm9tIDAgYW5kIDM1OS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBzZXRIdWUoNDIsICcjQ0NDRDY0JyksXG4gKiAgIGJhY2tncm91bmQ6IHNldEh1ZSgyNDQsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKSxcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgYmFja2dyb3VuZDogJHtzZXRIdWUoNDIsICcjQ0NDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke3NldEh1ZSgyNDQsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2NkYWU2NFwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMTA3LDEwMCwyMDUsMC43KVwiO1xuICogfVxuICovXG5mdW5jdGlvbiBzZXRIdWUoaHVlLCBjb2xvcikge1xuICByZXR1cm4gdG9Db2xvclN0cmluZyhfZXh0ZW5kcyh7fSwgcGFyc2VUb0hzbChjb2xvciksIHtcbiAgICBodWU6IGh1ZVxuICB9KSk7XG59XG5cbnZhciBjdXJyaWVkU2V0SHVlID0gLyojX19QVVJFX18qL2N1cnJ5KHNldEh1ZSk7XG5cbi8vICAgICAgXG5cbi8qKlxuICogU2V0cyB0aGUgbGlnaHRuZXNzIG9mIGEgY29sb3IgdG8gdGhlIHByb3ZpZGVkIHZhbHVlLiBUaGUgbGlnaHRuZXNzIHJhbmdlIGNhbiBiZVxuICogZnJvbSAwIGFuZCAxLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIGJhY2tncm91bmQ6IHNldExpZ2h0bmVzcygwLjIsICcjQ0NDRDY0JyksXG4gKiAgIGJhY2tncm91bmQ6IHNldExpZ2h0bmVzcygwLjc1LCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7c2V0TGlnaHRuZXNzKDAuMiwgJyNDQ0NENjQnKX07XG4gKiAgIGJhY2tncm91bmQ6ICR7c2V0TGlnaHRuZXNzKDAuNzUsICdyZ2JhKDIwNCwyMDUsMTAwLDAuNyknKX07XG4gKiBgXG4gKlxuICogLy8gQ1NTIGluIEpTIE91dHB1dFxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiIzRkNGQxOVwiO1xuICogICBiYWNrZ3JvdW5kOiBcInJnYmEoMjIzLDIyNCwxNTksMC43KVwiO1xuICogfVxuICovXG5mdW5jdGlvbiBzZXRMaWdodG5lc3MobGlnaHRuZXNzLCBjb2xvcikge1xuICByZXR1cm4gdG9Db2xvclN0cmluZyhfZXh0ZW5kcyh7fSwgcGFyc2VUb0hzbChjb2xvciksIHtcbiAgICBsaWdodG5lc3M6IGxpZ2h0bmVzc1xuICB9KSk7XG59XG5cbnZhciBjdXJyaWVkU2V0TGlnaHRuZXNzID0gLyojX19QVVJFX18qL2N1cnJ5KHNldExpZ2h0bmVzcyk7XG5cbi8vICAgICAgXG5cbi8qKlxuICogU2V0cyB0aGUgc2F0dXJhdGlvbiBvZiBhIGNvbG9yIHRvIHRoZSBwcm92aWRlZCB2YWx1ZS4gVGhlIGxpZ2h0bmVzcyByYW5nZSBjYW4gYmVcbiAqIGZyb20gMCBhbmQgMS5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBiYWNrZ3JvdW5kOiBzZXRTYXR1cmF0aW9uKDAuMiwgJyNDQ0NENjQnKSxcbiAqICAgYmFja2dyb3VuZDogc2V0U2F0dXJhdGlvbigwLjc1LCAncmdiYSgyMDQsMjA1LDEwMCwwLjcpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7c2V0U2F0dXJhdGlvbigwLjIsICcjQ0NDRDY0Jyl9O1xuICogICBiYWNrZ3JvdW5kOiAke3NldFNhdHVyYXRpb24oMC43NSwgJ3JnYmEoMjA0LDIwNSwxMDAsMC43KScpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjYWRhZDg0XCI7XG4gKiAgIGJhY2tncm91bmQ6IFwicmdiYSgyMjgsMjI5LDc2LDAuNylcIjtcbiAqIH1cbiAqL1xuZnVuY3Rpb24gc2V0U2F0dXJhdGlvbihzYXR1cmF0aW9uLCBjb2xvcikge1xuICByZXR1cm4gdG9Db2xvclN0cmluZyhfZXh0ZW5kcyh7fSwgcGFyc2VUb0hzbChjb2xvciksIHtcbiAgICBzYXR1cmF0aW9uOiBzYXR1cmF0aW9uXG4gIH0pKTtcbn1cblxudmFyIGN1cnJpZWRTZXRTYXR1cmF0aW9uID0gLyojX19QVVJFX18qL2N1cnJ5KHNldFNhdHVyYXRpb24pO1xuXG4vLyAgICAgIFxuXG4vKipcbiAqIFNoYWRlcyBhIGNvbG9yIGJ5IG1peGluZyBpdCB3aXRoIGJsYWNrLiBgc2hhZGVgIGNhbiBwcm9kdWNlXG4gKiBodWUgc2hpZnRzLCB3aGVyZSBhcyBgZGFya2VuYCBtYW5pcHVsYXRlcyB0aGUgbHVtaW5hbmNlIGNoYW5uZWwgYW5kIHRoZXJlZm9yZVxuICogZG9lc24ndCBwcm9kdWNlIGh1ZSBzaGlmdHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogc2hhZGUoMC4yNSwgJyMwMGYnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICBiYWNrZ3JvdW5kOiAke3NoYWRlKDAuMjUsICcjMDBmJyl9O1xuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCIjMDAwMDNmXCI7XG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gc2hhZGUocGVyY2VudGFnZSwgY29sb3IpIHtcbiAgaWYgKHR5cGVvZiBwZXJjZW50YWdlICE9PSAnbnVtYmVyJyB8fCBwZXJjZW50YWdlID4gMSB8fCBwZXJjZW50YWdlIDwgLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bhc3NlZCBhbiBpbmNvcnJlY3QgYXJndW1lbnQgdG8gc2hhZGUsIHBsZWFzZSBwYXNzIGEgcGVyY2VudGFnZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMSBhbmQgbGFyZ2VyIHRoYW4gb3IgZXF1YWwgdG8gLTEuJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb2xvciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bhc3NlZCBhbiBpbmNvcnJlY3QgYXJndW1lbnQgdG8gYSBjb2xvciBmdW5jdGlvbiwgcGxlYXNlIHBhc3MgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBjb2xvci4nKTtcbiAgfVxuICByZXR1cm4gY3VycmllZE1peChwZXJjZW50YWdlLCBjb2xvciwgJ3JnYigwLCAwLCAwKScpO1xufVxuXG52YXIgY3VycmllZFNoYWRlID0gLyojX19QVVJFX18qL2N1cnJ5KHNoYWRlKTtcblxuLy8gICAgICBcblxuLyoqXG4gKiBUaW50cyBhIGNvbG9yIGJ5IG1peGluZyBpdCB3aXRoIHdoaXRlLiBgdGludGAgY2FuIHByb2R1Y2VcbiAqIGh1ZSBzaGlmdHMsIHdoZXJlIGFzIGBsaWdodGVuYCBtYW5pcHVsYXRlcyB0aGUgbHVtaW5hbmNlIGNoYW5uZWwgYW5kIHRoZXJlZm9yZVxuICogZG9lc24ndCBwcm9kdWNlIGh1ZSBzaGlmdHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogdGludCgwLjI1LCAnIzAwZicpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7dGludCgwLjI1LCAnIzAwZicpfTtcbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogZWxlbWVudCB7XG4gKiAgIGJhY2tncm91bmQ6IFwiI2JmYmZmZlwiO1xuICogfVxuICovXG5cbmZ1bmN0aW9uIHRpbnQocGVyY2VudGFnZSwgY29sb3IpIHtcbiAgaWYgKHR5cGVvZiBwZXJjZW50YWdlICE9PSAnbnVtYmVyJyB8fCBwZXJjZW50YWdlID4gMSB8fCBwZXJjZW50YWdlIDwgLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bhc3NlZCBhbiBpbmNvcnJlY3QgYXJndW1lbnQgdG8gdGludCwgcGxlYXNlIHBhc3MgYSBwZXJjZW50YWdlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAxIGFuZCBsYXJnZXIgdGhhbiBvciBlcXVhbCB0byAtMS4nKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbG9yICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignUGFzc2VkIGFuIGluY29ycmVjdCBhcmd1bWVudCB0byBhIGNvbG9yIGZ1bmN0aW9uLCBwbGVhc2UgcGFzcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLicpO1xuICB9XG4gIHJldHVybiBjdXJyaWVkTWl4KHBlcmNlbnRhZ2UsIGNvbG9yLCAncmdiKDI1NSwgMjU1LCAyNTUpJyk7XG59XG5cbnZhciBjdXJyaWVkVGludCA9IC8qI19fUFVSRV9fKi9jdXJyeSh0aW50KTtcblxuLy8gICAgICBcbi8qKlxuICogRGVjcmVhc2VzIHRoZSBvcGFjaXR5IG9mIGEgY29sb3IuIEl0cyByYW5nZSBmb3IgdGhlIGFtb3VudCBpcyBiZXR3ZWVuIDAgdG8gMS5cbiAqXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnRpemUoMC4xLCAnI2ZmZicpO1xuICogICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudGl6ZSgwLjIsICdoc2woMCwgMCUsIDEwMCUpJyksXG4gKiAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50aXplKDAuNSwgJ3JnYmEoMjU1LCAwLCAwLCAwLjgpJyksXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgIGJhY2tncm91bmQ6ICR7dHJhbnNwYXJlbnRpemUoMC4xLCAnI2ZmZicpfTtcbiAqICAgYmFja2dyb3VuZDogJHt0cmFuc3BhcmVudGl6ZSgwLjIsICdoc2woMCwgMCUsIDEwMCUpJyl9LFxuICogICBiYWNrZ3JvdW5kOiAke3RyYW5zcGFyZW50aXplKDAuNSwgJ3JnYmEoMjU1LCAwLCAwLCAwLjgpJyl9LFxuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiBlbGVtZW50IHtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwyNTUsMjU1LDAuOSlcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwyNTUsMjU1LDAuOClcIjtcbiAqICAgYmFja2dyb3VuZDogXCJyZ2JhKDI1NSwwLDAsMC4zKVwiO1xuICogfVxuICovXG5mdW5jdGlvbiB0cmFuc3BhcmVudGl6ZShhbW91bnQsIGNvbG9yKSB7XG4gIHZhciBwYXJzZWRDb2xvciA9IHBhcnNlVG9SZ2IoY29sb3IpO1xuICB2YXIgYWxwaGEgPSB0eXBlb2YgcGFyc2VkQ29sb3IuYWxwaGEgPT09ICdudW1iZXInID8gcGFyc2VkQ29sb3IuYWxwaGEgOiAxO1xuICB2YXIgY29sb3JXaXRoQWxwaGEgPSBfZXh0ZW5kcyh7fSwgcGFyc2VkQ29sb3IsIHtcbiAgICBhbHBoYTogZ3VhcmQoMCwgMSwgKGFscGhhICogMTAwIC0gYW1vdW50ICogMTAwKSAvIDEwMClcbiAgfSk7XG4gIHJldHVybiByZ2JhKGNvbG9yV2l0aEFscGhhKTtcbn1cblxudmFyIGN1cnJpZWRUcmFuc3BhcmVudGl6ZSA9IC8qI19fUFVSRV9fKi9jdXJyeSh0cmFuc3BhcmVudGl6ZSk7XG5cbi8vICAgICAgXG5cbi8qKiAqL1xuXG4vKipcbiAqIFNob3J0aGFuZCBmb3IgZWFzaWx5IHNldHRpbmcgdGhlIGFuaW1hdGlvbiBwcm9wZXJ0eS4gQWxsb3dzIGVpdGhlciBtdWx0aXBsZSBhcnJheXMgd2l0aCBhbmltYXRpb25zXG4gKiBvciBhIHNpbmdsZSBhbmltYXRpb24gc3ByZWFkIG92ZXIgdGhlIGFyZ3VtZW50cy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmFuaW1hdGlvbihbJ3JvdGF0ZScsICcxcycsICdlYXNlLWluLW91dCddLCBbJ2NvbG9yY2hhbmdlJywgJzJzJ10pXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7YW5pbWF0aW9uKFsncm90YXRlJywgJzFzJywgJ2Vhc2UtaW4tb3V0J10sIFsnY29sb3JjaGFuZ2UnLCAnMnMnXSl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdhbmltYXRpb24nOiAncm90YXRlIDFzIGVhc2UtaW4tb3V0LCBjb2xvcmNoYW5nZSAycydcbiAqIH1cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmFuaW1hdGlvbigncm90YXRlJywgJzFzJywgJ2Vhc2UtaW4tb3V0JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHthbmltYXRpb24oJ3JvdGF0ZScsICcxcycsICdlYXNlLWluLW91dCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYW5pbWF0aW9uJzogJ3JvdGF0ZSAxcyBlYXNlLWluLW91dCdcbiAqIH1cbiAqL1xuZnVuY3Rpb24gYW5pbWF0aW9uKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICAvLyBBbGxvdyBzaW5nbGUgb3IgbXVsdGlwbGUgYW5pbWF0aW9ucyBwYXNzZWRcbiAgdmFyIG11bHRpTW9kZSA9IEFycmF5LmlzQXJyYXkoYXJnc1swXSk7XG4gIGlmICghbXVsdGlNb2RlICYmIGFyZ3MubGVuZ3RoID4gOCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGFuaW1hdGlvbiBzaG9ydGhhbmQgb25seSB0YWtlcyA4IGFyZ3VtZW50cy4gU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwOi8vbWRuLmlvL2FuaW1hdGlvbicpO1xuICB9XG4gIHZhciBjb2RlID0gYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgIGlmIChtdWx0aU1vZGUgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSB8fCAhbXVsdGlNb2RlICYmIEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG8gcGFzcyBtdWx0aXBsZSBhbmltYXRpb25zIHBsZWFzZSBzdXBwbHkgdGhlbSBpbiBhcnJheXMsIGUuZy4gYW5pbWF0aW9uKFsncm90YXRlJywgJzJzJ10sIFsnbW92ZScsICcxcyddKVxcblRvIHBhc3MgYSBzaW5nbGUgYW5pbWF0aW9uIHBsZWFzZSBzdXBwbHkgdGhlbSBpbiBzaW1wbGUgdmFsdWVzLCBlLmcuIGFuaW1hdGlvbigncm90YXRlJywgJzJzJylcIik7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykgJiYgYXJnLmxlbmd0aCA+IDgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGFuaW1hdGlvbiBzaG9ydGhhbmQgYXJyYXlzIGNhbiBvbmx5IGhhdmUgOCBlbGVtZW50cy4gU2VlIHRoZSBzcGVjaWZpY2F0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uOiBodHRwOi8vbWRuLmlvL2FuaW1hdGlvbicpO1xuICAgIH1cblxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZykgPyBhcmcuam9pbignICcpIDogYXJnO1xuICB9KS5qb2luKCcsICcpO1xuXG4gIHJldHVybiB7XG4gICAgYW5pbWF0aW9uOiBjb2RlXG4gIH07XG59XG5cbi8vICAgICAgXG5cbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyBhbnkgbnVtYmVyIG9mIGJhY2tncm91bmRJbWFnZSB2YWx1ZXMgYXMgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYSBzaW5nbGUgYmFja2dyb3VuZCBzdGF0ZW1lbnQuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5iYWNrZ3JvdW5kSW1hZ2VzKCd1cmwoXCIvaW1hZ2UvYmFja2dyb3VuZC5qcGdcIiknLCAnbGluZWFyLWdyYWRpZW50KHJlZCwgZ3JlZW4pJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtiYWNrZ3JvdW5kSW1hZ2VzKCd1cmwoXCIvaW1hZ2UvYmFja2dyb3VuZC5qcGdcIiknLCAnbGluZWFyLWdyYWRpZW50KHJlZCwgZ3JlZW4pJyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdiYWNrZ3JvdW5kSW1hZ2UnOiAndXJsKFwiL2ltYWdlL2JhY2tncm91bmQuanBnXCIpLCBsaW5lYXItZ3JhZGllbnQocmVkLCBncmVlbiknXG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gYmFja2dyb3VuZEltYWdlcygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHByb3BlcnRpZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBwcm9wZXJ0aWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IHByb3BlcnRpZXMuam9pbignLCAnKVxuICB9O1xufVxuXG4vLyAgICAgIFxuXG4vKipcbiAqIFNob3J0aGFuZCB0aGF0IGFjY2VwdHMgYW55IG51bWJlciBvZiBiYWNrZ3JvdW5kIHZhbHVlcyBhcyBwYXJhbWV0ZXJzIGZvciBjcmVhdGluZyBhIHNpbmdsZSBiYWNrZ3JvdW5kIHN0YXRlbWVudC5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmJhY2tncm91bmRzKCd1cmwoXCIvaW1hZ2UvYmFja2dyb3VuZC5qcGdcIiknLCAnbGluZWFyLWdyYWRpZW50KHJlZCwgZ3JlZW4pJywgJ2NlbnRlciBuby1yZXBlYXQnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2JhY2tncm91bmRzKCd1cmwoXCIvaW1hZ2UvYmFja2dyb3VuZC5qcGdcIiknLCAnbGluZWFyLWdyYWRpZW50KHJlZCwgZ3JlZW4pJywgJ2NlbnRlciBuby1yZXBlYXQnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2JhY2tncm91bmQnOiAndXJsKFwiL2ltYWdlL2JhY2tncm91bmQuanBnXCIpLCBsaW5lYXItZ3JhZGllbnQocmVkLCBncmVlbiksIGNlbnRlciBuby1yZXBlYXQnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGJhY2tncm91bmRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcHJvcGVydGllcyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHByb3BlcnRpZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmQ6IHByb3BlcnRpZXMuam9pbignLCAnKVxuICB9O1xufVxuXG4vLyAgICAgIFxuLyoqXG4gKiBTaG9ydGhhbmQgdGhhdCBhY2NlcHRzIHVwIHRvIGZvdXIgdmFsdWVzLCBpbmNsdWRpbmcgbnVsbCB0byBza2lwIGEgdmFsdWUsIGFuZCBtYXBzIHRoZW0gdG8gdGhlaXIgcmVzcGVjdGl2ZSBkaXJlY3Rpb25zLlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4uYm9yZGVyQ29sb3IoJ3JlZCcsICdncmVlbicsICdibHVlJywgJ3llbGxvdycpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7Ym9yZGVyQ29sb3IoJ3JlZCcsICdncmVlbicsICdibHVlJywgJ3llbGxvdycpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYm9yZGVyVG9wQ29sb3InOiAncmVkJyxcbiAqICAgJ2JvcmRlclJpZ2h0Q29sb3InOiAnZ3JlZW4nLFxuICogICAnYm9yZGVyQm90dG9tQ29sb3InOiAnYmx1ZScsXG4gKiAgICdib3JkZXJMZWZ0Q29sb3InOiAneWVsbG93J1xuICogfVxuICovXG5cbmZ1bmN0aW9uIGJvcmRlckNvbG9yKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdmFsdWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGRpcmVjdGlvbmFsUHJvcGVydHkuYXBwbHkodW5kZWZpbmVkLCBbJ2JvcmRlckNvbG9yJ10uY29uY2F0KHZhbHVlcykpO1xufVxuXG4vLyAgICAgIFxuLyoqXG4gKiBTaG9ydGhhbmQgdGhhdCBhY2NlcHRzIGEgdmFsdWUgZm9yIHNpZGUgYW5kIGEgdmFsdWUgZm9yIHJhZGl1cyBhbmQgYXBwbGllcyB0aGUgcmFkaXVzIHZhbHVlIHRvIGJvdGggY29ybmVycyBvZiB0aGUgc2lkZS5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLmJvcmRlclJhZGl1cygndG9wJywgJzVweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7Ym9yZGVyUmFkaXVzKCd0b3AnLCAnNXB4Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdib3JkZXJUb3BSaWdodFJhZGl1cyc6ICc1cHgnLFxuICogICAnYm9yZGVyVG9wTGVmdFJhZGl1cyc6ICc1cHgnLFxuICogfVxuICovXG5cbmZ1bmN0aW9uIGJvcmRlclJhZGl1cyhzaWRlLCByYWRpdXMpIHtcbiAgdmFyIHVwcGVyY2FzZVNpZGUgPSBjYXBpdGFsaXplU3RyaW5nKHNpZGUpO1xuICBpZiAoIXJhZGl1cyAmJiByYWRpdXMgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvcmRlclJhZGl1cyBleHBlY3RzIGEgcmFkaXVzIHZhbHVlIGFzIGEgc3RyaW5nIG9yIG51bWJlciBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LicpO1xuICB9XG4gIGlmICh1cHBlcmNhc2VTaWRlID09PSAnVG9wJyB8fCB1cHBlcmNhc2VTaWRlID09PSAnQm90dG9tJykge1xuICAgIHZhciBfcmVmO1xuXG4gICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZlsnYm9yZGVyJyArIHVwcGVyY2FzZVNpZGUgKyAnUmlnaHRSYWRpdXMnXSA9IHJhZGl1cywgX3JlZlsnYm9yZGVyJyArIHVwcGVyY2FzZVNpZGUgKyAnTGVmdFJhZGl1cyddID0gcmFkaXVzLCBfcmVmO1xuICB9XG5cbiAgaWYgKHVwcGVyY2FzZVNpZGUgPT09ICdMZWZ0JyB8fCB1cHBlcmNhc2VTaWRlID09PSAnUmlnaHQnKSB7XG4gICAgdmFyIF9yZWYyO1xuXG4gICAgcmV0dXJuIF9yZWYyID0ge30sIF9yZWYyWydib3JkZXJUb3AnICsgdXBwZXJjYXNlU2lkZSArICdSYWRpdXMnXSA9IHJhZGl1cywgX3JlZjJbJ2JvcmRlckJvdHRvbScgKyB1cHBlcmNhc2VTaWRlICsgJ1JhZGl1cyddID0gcmFkaXVzLCBfcmVmMjtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignYm9yZGVyUmFkaXVzIGV4cGVjdHMgb25lIG9mIFwidG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiIG9yIFwicmlnaHRcIiBhcyB0aGUgZmlyc3QgYXJndW1lbnQuJyk7XG59XG5cbi8vICAgICAgXG4vKipcbiAqIFNob3J0aGFuZCB0aGF0IGFjY2VwdHMgdXAgdG8gZm91ciB2YWx1ZXMsIGluY2x1ZGluZyBudWxsIHRvIHNraXAgYSB2YWx1ZSwgYW5kIG1hcHMgdGhlbSB0byB0aGVpciByZXNwZWN0aXZlIGRpcmVjdGlvbnMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5ib3JkZXJTdHlsZSgnc29saWQnLCAnZGFzaGVkJywgJ2RvdHRlZCcsICdkb3VibGUnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke2JvcmRlclN0eWxlKCdzb2xpZCcsICdkYXNoZWQnLCAnZG90dGVkJywgJ2RvdWJsZScpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnYm9yZGVyVG9wU3R5bGUnOiAnc29saWQnLFxuICogICAnYm9yZGVyUmlnaHRTdHlsZSc6ICdkYXNoZWQnLFxuICogICAnYm9yZGVyQm90dG9tU3R5bGUnOiAnZG90dGVkJyxcbiAqICAgJ2JvcmRlckxlZnRTdHlsZSc6ICdkb3VibGUnXG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gYm9yZGVyU3R5bGUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh1bmRlZmluZWQsIFsnYm9yZGVyU3R5bGUnXS5jb25jYXQodmFsdWVzKSk7XG59XG5cbi8vICAgICAgXG4vKipcbiAqIFNob3J0aGFuZCB0aGF0IGFjY2VwdHMgdXAgdG8gZm91ciB2YWx1ZXMsIGluY2x1ZGluZyBudWxsIHRvIHNraXAgYSB2YWx1ZSwgYW5kIG1hcHMgdGhlbSB0byB0aGVpciByZXNwZWN0aXZlIGRpcmVjdGlvbnMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5ib3JkZXJXaWR0aCgnMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7Ym9yZGVyV2lkdGgoJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ2JvcmRlclRvcFdpZHRoJzogJzEycHgnLFxuICogICAnYm9yZGVyUmlnaHRXaWR0aCc6ICcyNHB4JyxcbiAqICAgJ2JvcmRlckJvdHRvbVdpZHRoJzogJzM2cHgnLFxuICogICAnYm9yZGVyTGVmdFdpZHRoJzogJzQ4cHgnXG4gKiB9XG4gKi9cbmZ1bmN0aW9uIGJvcmRlcldpZHRoKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgdmFsdWVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGRpcmVjdGlvbmFsUHJvcGVydHkuYXBwbHkodW5kZWZpbmVkLCBbJ2JvcmRlcldpZHRoJ10uY29uY2F0KHZhbHVlcykpO1xufVxuXG4vLyAgICAgIFxuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlU2VsZWN0b3JzKHRlbXBsYXRlLCBzdGF0ZSkge1xuICB2YXIgc3RhdGVTdWZmaXggPSBzdGF0ZSA/ICc6JyArIHN0YXRlIDogJyc7XG4gIHJldHVybiB0ZW1wbGF0ZShzdGF0ZVN1ZmZpeCk7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gaGVscGVyIHRoYXQgYWRkcyBhbiBhcnJheSBvZiBzdGF0ZXMgdG8gYSB0ZW1wbGF0ZSBvZiBzZWxlY3RvcnMuIFVzZWQgaW4gdGV4dElucHV0cyBhbmQgYnV0dG9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHN0YXRlZnVsU2VsZWN0b3JzKHN0YXRlcywgdGVtcGxhdGUsIHN0YXRlTWFwKSB7XG4gIGlmICghdGVtcGxhdGUpIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcHJvdmlkZSBhIHRlbXBsYXRlIHRvIHRoaXMgbWV0aG9kLicpO1xuICBpZiAoc3RhdGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGdlbmVyYXRlU2VsZWN0b3JzKHRlbXBsYXRlLCBudWxsKTtcbiAgdmFyIHNlbGVjdG9ycyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChzdGF0ZU1hcCAmJiBzdGF0ZU1hcC5pbmRleE9mKHN0YXRlc1tpXSkgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBwYXNzZWQgYW4gdW5zdXBwb3J0ZWQgc2VsZWN0b3Igc3RhdGUgdG8gdGhpcyBtZXRob2QuJyk7XG4gICAgfVxuICAgIHNlbGVjdG9ycy5wdXNoKGdlbmVyYXRlU2VsZWN0b3JzKHRlbXBsYXRlLCBzdGF0ZXNbaV0pKTtcbiAgfVxuICBzZWxlY3RvcnMgPSBzZWxlY3RvcnMuam9pbignLCcpO1xuICByZXR1cm4gc2VsZWN0b3JzO1xufVxuXG4vLyAgICAgIFxudmFyIHN0YXRlTWFwID0gW3VuZGVmaW5lZCwgbnVsbCwgJ2FjdGl2ZScsICdmb2N1cycsICdob3ZlciddO1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZShzdGF0ZSkge1xuICByZXR1cm4gJ2J1dHRvbicgKyBzdGF0ZSArICcsXFxuICBpbnB1dFt0eXBlPVwiYnV0dG9uXCJdJyArIHN0YXRlICsgJyxcXG4gIGlucHV0W3R5cGU9XCJyZXNldFwiXScgKyBzdGF0ZSArICcsXFxuICBpbnB1dFt0eXBlPVwic3VibWl0XCJdJyArIHN0YXRlO1xufVxuXG4vKipcbiAqIFBvcHVsYXRlcyBzZWxlY3RvcnMgdGhhdCB0YXJnZXQgYWxsIGJ1dHRvbnMuIFlvdSBjYW4gcGFzcyBvcHRpb25hbCBzdGF0ZXMgdG8gYXBwZW5kIHRvIHRoZSBzZWxlY3RvcnMuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICBbYnV0dG9ucygnYWN0aXZlJyldOiB7XG4gKiAgICAgJ2JvcmRlcic6ICdub25lJ1xuICogICB9XG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgID4gJHtidXR0b25zKCdhY3RpdmUnKX0ge1xuICogICAgIGJvcmRlcjogbm9uZTtcbiAqICAgfVxuICogYFxuICpcbiAqIC8vIENTUyBpbiBKUyBPdXRwdXRcbiAqXG4gKiAgJ2J1dHRvbjphY3RpdmUsXG4gKiAgJ2lucHV0W3R5cGU9XCJidXR0b25cIl06YWN0aXZlLFxuICogICdpbnB1dFt0eXBlPVxcXCJyZXNldFxcXCJdOmFjdGl2ZSxcbiAqICAnaW5wdXRbdHlwZT1cXFwic3VibWl0XFxcIl06YWN0aXZlOiB7XG4gKiAgICdib3JkZXInOiAnbm9uZSdcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBidXR0b25zKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3RhdGVzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc3RhdGVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlZnVsU2VsZWN0b3JzKHN0YXRlcywgdGVtcGxhdGUsIHN0YXRlTWFwKTtcbn1cblxuLy8gICAgICBcbi8qKlxuICogU2hvcnRoYW5kIHRoYXQgYWNjZXB0cyB1cCB0byBmb3VyIHZhbHVlcywgaW5jbHVkaW5nIG51bGwgdG8gc2tpcCBhIHZhbHVlLCBhbmQgbWFwcyB0aGVtIHRvIHRoZWlyIHJlc3BlY3RpdmUgZGlyZWN0aW9ucy5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLm1hcmdpbignMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7bWFyZ2luKCcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdtYXJnaW5Ub3AnOiAnMTJweCcsXG4gKiAgICdtYXJnaW5SaWdodCc6ICcyNHB4JyxcbiAqICAgJ21hcmdpbkJvdHRvbSc6ICczNnB4JyxcbiAqICAgJ21hcmdpbkxlZnQnOiAnNDhweCdcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBtYXJnaW4oKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh1bmRlZmluZWQsIFsnbWFyZ2luJ10uY29uY2F0KHZhbHVlcykpO1xufVxuXG4vLyAgICAgIFxuLyoqXG4gKiBTaG9ydGhhbmQgdGhhdCBhY2NlcHRzIHVwIHRvIGZvdXIgdmFsdWVzLCBpbmNsdWRpbmcgbnVsbCB0byBza2lwIGEgdmFsdWUsIGFuZCBtYXBzIHRoZW0gdG8gdGhlaXIgcmVzcGVjdGl2ZSBkaXJlY3Rpb25zLlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4ucGFkZGluZygnMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7cGFkZGluZygnMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAncGFkZGluZ1RvcCc6ICcxMnB4JyxcbiAqICAgJ3BhZGRpbmdSaWdodCc6ICcyNHB4JyxcbiAqICAgJ3BhZGRpbmdCb3R0b20nOiAnMzZweCcsXG4gKiAgICdwYWRkaW5nTGVmdCc6ICc0OHB4J1xuICogfVxuICovXG5cbmZ1bmN0aW9uIHBhZGRpbmcoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCB2YWx1ZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh1bmRlZmluZWQsIFsncGFkZGluZyddLmNvbmNhdCh2YWx1ZXMpKTtcbn1cblxuLy8gICAgICBcbnZhciBwb3NpdGlvbk1hcCQxID0gWydhYnNvbHV0ZScsICdmaXhlZCcsICdyZWxhdGl2ZScsICdzdGF0aWMnLCAnc3RpY2t5J107XG5cbi8qKlxuICogU2hvcnRoYW5kIGFjY2VwdHMgdXAgdG8gZml2ZSB2YWx1ZXMsIGluY2x1ZGluZyBudWxsIHRvIHNraXAgYSB2YWx1ZSwgYW5kIG1hcHMgdGhlbSB0byB0aGVpciByZXNwZWN0aXZlIGRpcmVjdGlvbnMuIFRoZSBmaXJzdCB2YWx1ZSBjYW4gb3B0aW9uYWxseSBiZSBhIHBvc2l0aW9uIGtleXdvcmQuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi5wb3NpdGlvbignMTJweCcsICcyNHB4JywgJzM2cHgnLCAnNDhweCcpXG4gKiB9XG4gKlxuICogLy8gc3R5bGVkLWNvbXBvbmVudHMgdXNhZ2VcbiAqIGNvbnN0IGRpdiA9IHN0eWxlZC5kaXZgXG4gKiAgICR7cG9zaXRpb24oJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKX1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgYXMgSlMgT3V0cHV0XG4gKlxuICogZGl2IHtcbiAqICAgJ3RvcCc6ICcxMnB4JyxcbiAqICAgJ3JpZ2h0JzogJzI0cHgnLFxuICogICAnYm90dG9tJzogJzM2cHgnLFxuICogICAnbGVmdCc6ICc0OHB4J1xuICogfVxuICpcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgLi4ucG9zaXRpb24oJ2Fic29sdXRlJywgJzEycHgnLCAnMjRweCcsICczNnB4JywgJzQ4cHgnKVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICAke3Bvc2l0aW9uKCdhYnNvbHV0ZScsICcxMnB4JywgJzI0cHgnLCAnMzZweCcsICc0OHB4Jyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gKiAgICd0b3AnOiAnMTJweCcsXG4gKiAgICdyaWdodCc6ICcyNHB4JyxcbiAqICAgJ2JvdHRvbSc6ICczNnB4JyxcbiAqICAgJ2xlZnQnOiAnNDhweCdcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBwb3NpdGlvbihwb3NpdGlvbktleXdvcmQpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICB2YWx1ZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgaWYgKHBvc2l0aW9uTWFwJDEuaW5kZXhPZihwb3NpdGlvbktleXdvcmQpID49IDApIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgcG9zaXRpb246IHBvc2l0aW9uS2V5d29yZFxuICAgIH0sIGRpcmVjdGlvbmFsUHJvcGVydHkuYXBwbHkodW5kZWZpbmVkLCBbJyddLmNvbmNhdCh2YWx1ZXMpKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGZpcnN0VmFsdWUgPSBwb3NpdGlvbktleXdvcmQ7IC8vIGluIHRoaXMgY2FzZSBwb3NpdGlvbiBpcyBhY3R1YWxseSB0aGUgZmlyc3QgdmFsdWVcbiAgICByZXR1cm4gZGlyZWN0aW9uYWxQcm9wZXJ0eS5hcHBseSh1bmRlZmluZWQsIFsnJywgZmlyc3RWYWx1ZV0uY29uY2F0KHZhbHVlcykpO1xuICB9XG59XG5cbi8vICAgICAgXG5cbi8qKlxuICogU2hvcnRoYW5kIHRvIHNldCB0aGUgaGVpZ2h0IGFuZCB3aWR0aCBwcm9wZXJ0aWVzIGluIGEgc2luZ2xlIHN0YXRlbWVudC5cbiAqIEBleGFtcGxlXG4gKiAvLyBTdHlsZXMgYXMgb2JqZWN0IHVzYWdlXG4gKiBjb25zdCBzdHlsZXMgPSB7XG4gKiAgIC4uLnNpemUoJzMwMHB4JywgJzI1MHB4JylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHtzaXplKCczMDBweCcsICcyNTBweCcpfVxuICogYFxuICpcbiAqIC8vIENTUyBhcyBKUyBPdXRwdXRcbiAqXG4gKiBkaXYge1xuICogICAnaGVpZ2h0JzogJzMwMHB4JyxcbiAqICAgJ3dpZHRoJzogJzI1MHB4JyxcbiAqIH1cbiAqL1xuXG5mdW5jdGlvbiBzaXplKGhlaWdodCkge1xuICB2YXIgd2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGhlaWdodDtcblxuICByZXR1cm4ge1xuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHdpZHRoOiB3aWR0aFxuICB9O1xufVxuXG4vLyAgICAgIFxudmFyIHN0YXRlTWFwJDEgPSBbdW5kZWZpbmVkLCBudWxsLCAnYWN0aXZlJywgJ2ZvY3VzJywgJ2hvdmVyJ107XG5cbmZ1bmN0aW9uIHRlbXBsYXRlJDEoc3RhdGUpIHtcbiAgcmV0dXJuICdpbnB1dFt0eXBlPVwiY29sb3JcIl0nICsgc3RhdGUgKyAnLFxcbiAgICBpbnB1dFt0eXBlPVwiZGF0ZVwiXScgKyBzdGF0ZSArICcsXFxuICAgIGlucHV0W3R5cGU9XCJkYXRldGltZVwiXScgKyBzdGF0ZSArICcsXFxuICAgIGlucHV0W3R5cGU9XCJkYXRldGltZS1sb2NhbFwiXScgKyBzdGF0ZSArICcsXFxuICAgIGlucHV0W3R5cGU9XCJlbWFpbFwiXScgKyBzdGF0ZSArICcsXFxuICAgIGlucHV0W3R5cGU9XCJtb250aFwiXScgKyBzdGF0ZSArICcsXFxuICAgIGlucHV0W3R5cGU9XCJudW1iZXJcIl0nICsgc3RhdGUgKyAnLFxcbiAgICBpbnB1dFt0eXBlPVwicGFzc3dvcmRcIl0nICsgc3RhdGUgKyAnLFxcbiAgICBpbnB1dFt0eXBlPVwic2VhcmNoXCJdJyArIHN0YXRlICsgJyxcXG4gICAgaW5wdXRbdHlwZT1cInRlbFwiXScgKyBzdGF0ZSArICcsXFxuICAgIGlucHV0W3R5cGU9XCJ0ZXh0XCJdJyArIHN0YXRlICsgJyxcXG4gICAgaW5wdXRbdHlwZT1cInRpbWVcIl0nICsgc3RhdGUgKyAnLFxcbiAgICBpbnB1dFt0eXBlPVwidXJsXCJdJyArIHN0YXRlICsgJyxcXG4gICAgaW5wdXRbdHlwZT1cIndlZWtcIl0nICsgc3RhdGUgKyAnLFxcbiAgICBpbnB1dDpub3QoW3R5cGVdKScgKyBzdGF0ZSArICcsXFxuICAgIHRleHRhcmVhJyArIHN0YXRlO1xufVxuXG4vKipcbiAqIFBvcHVsYXRlcyBzZWxlY3RvcnMgdGhhdCB0YXJnZXQgYWxsIHRleHQgaW5wdXRzLiBZb3UgY2FuIHBhc3Mgb3B0aW9uYWwgc3RhdGVzIHRvIGFwcGVuZCB0byB0aGUgc2VsZWN0b3JzLlxuICogQGV4YW1wbGVcbiAqIC8vIFN0eWxlcyBhcyBvYmplY3QgdXNhZ2VcbiAqIGNvbnN0IHN0eWxlcyA9IHtcbiAqICAgW3RleHRJbnB1dHMoJ2FjdGl2ZScpXToge1xuICogICAgICdib3JkZXInOiAnbm9uZSdcbiAqICAgfVxuICogfVxuICpcbiAqIC8vIHN0eWxlZC1jb21wb25lbnRzIHVzYWdlXG4gKiBjb25zdCBkaXYgPSBzdHlsZWQuZGl2YFxuICogICA+ICR7dGV4dElucHV0cygnYWN0aXZlJyl9IHtcbiAqICAgICBib3JkZXI6IG5vbmU7XG4gKiAgIH1cbiAqIGBcbiAqXG4gKiAvLyBDU1MgaW4gSlMgT3V0cHV0XG4gKlxuICogICdpbnB1dFt0eXBlPVwiY29sb3JcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJkYXRlXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwiZGF0ZXRpbWVcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJkYXRldGltZS1sb2NhbFwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cImVtYWlsXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwibW9udGhcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJudW1iZXJcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJwYXNzd29yZFwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cInNlYXJjaFwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cInRlbFwiXTphY3RpdmUsXG4gKiAgaW5wdXRbdHlwZT1cInRleHRcIl06YWN0aXZlLFxuICogIGlucHV0W3R5cGU9XCJ0aW1lXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwidXJsXCJdOmFjdGl2ZSxcbiAqICBpbnB1dFt0eXBlPVwid2Vla1wiXTphY3RpdmUsXG4gKiAgaW5wdXQ6bm90KFt0eXBlXSk6YWN0aXZlLFxuICogIHRleHRhcmVhOmFjdGl2ZSc6IHtcbiAqICAgJ2JvcmRlcic6ICdub25lJ1xuICogfVxuICovXG5cbmZ1bmN0aW9uIHRleHRJbnB1dHMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdGF0ZXMgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzdGF0ZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gc3RhdGVmdWxTZWxlY3RvcnMoc3RhdGVzLCB0ZW1wbGF0ZSQxLCBzdGF0ZU1hcCQxKTtcbn1cblxuLy8gICAgICBcblxuLyoqXG4gKiBTaG9ydGhhbmQgdGhhdCBhY2NlcHRzIGFueSBudW1iZXIgb2YgdHJhbnNpdGlvbiB2YWx1ZXMgYXMgcGFyYW1ldGVycyBmb3IgY3JlYXRpbmcgYSBzaW5nbGUgdHJhbnNpdGlvbiBzdGF0ZW1lbnQuXG4gKiBAZXhhbXBsZVxuICogLy8gU3R5bGVzIGFzIG9iamVjdCB1c2FnZVxuICogY29uc3Qgc3R5bGVzID0ge1xuICogICAuLi50cmFuc2l0aW9ucygnb3BhY2l0eSAxLjBzIGVhc2UtaW4gMHMnLCAnd2lkdGggMi4wcyBlYXNlLWluIDJzJylcbiAqIH1cbiAqXG4gKiAvLyBzdHlsZWQtY29tcG9uZW50cyB1c2FnZVxuICogY29uc3QgZGl2ID0gc3R5bGVkLmRpdmBcbiAqICAgJHt0cmFuc2l0aW9ucygnb3BhY2l0eSAxLjBzIGVhc2UtaW4gMHMnLCAnd2lkdGggMi4wcyBlYXNlLWluIDJzJyl9XG4gKiBgXG4gKlxuICogLy8gQ1NTIGFzIEpTIE91dHB1dFxuICpcbiAqIGRpdiB7XG4gKiAgICd0cmFuc2l0aW9uJzogJ29wYWNpdHkgMS4wcyBlYXNlLWluIDBzLCB3aWR0aCAyLjBzIGVhc2UtaW4gMnMnXG4gKiB9XG4gKi9cblxuZnVuY3Rpb24gdHJhbnNpdGlvbnMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwcm9wZXJ0aWVzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcHJvcGVydGllc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHJhbnNpdGlvbjogcHJvcGVydGllcy5qb2luKCcsICcpXG4gIH07XG59XG5cbi8vICAgICAgXG4vLyBIZWxwZXJzXG4vLyBNaXhpbnNcbi8vIENvbG9yXG4vLyBTaG9ydGhhbmRzXG5cbmV4cG9ydCB7IGN1cnJpZWRBZGp1c3RIdWUgYXMgYWRqdXN0SHVlLCBhbmltYXRpb24sIGJhY2tncm91bmRJbWFnZXMsIGJhY2tncm91bmRzLCBib3JkZXJDb2xvciwgYm9yZGVyUmFkaXVzLCBib3JkZXJTdHlsZSwgYm9yZGVyV2lkdGgsIGJ1dHRvbnMsIGNsZWFyRml4LCBjb21wbGVtZW50LCBjdXJyaWVkRGFya2VuIGFzIGRhcmtlbiwgY3VycmllZERlc2F0dXJhdGUgYXMgZGVzYXR1cmF0ZSwgZGlyZWN0aW9uYWxQcm9wZXJ0eSwgZWxsaXBzaXMsIGVtLCBmb250RmFjZSwgZ2V0THVtaW5hbmNlLCBncmF5c2NhbGUsIGludmVydCwgaGlkZVRleHQsIGhpZGVWaXN1YWxseSwgaGlEUEksIGhzbCwgaHNsYSwgY3VycmllZExpZ2h0ZW4gYXMgbGlnaHRlbiwgbWFyZ2luLCBjdXJyaWVkTWl4IGFzIG1peCwgbW9kdWxhclNjYWxlLCBub3JtYWxpemUsIGN1cnJpZWRPcGFjaWZ5IGFzIG9wYWNpZnksIHBhZGRpbmcsIHBhcnNlVG9Ic2wsIHBhcnNlVG9SZ2IsIHBsYWNlaG9sZGVyLCBwb3NpdGlvbiwgcmFkaWFsR3JhZGllbnQsIGN1cnJpZWRSZWFkYWJsZUNvbG9yIGFzIHJlYWRhYmxlQ29sb3IsIHJlbSwgcmV0aW5hSW1hZ2UsIHJnYiwgcmdiYSwgY3VycmllZFNhdHVyYXRlIGFzIHNhdHVyYXRlLCBzZWxlY3Rpb24sIGN1cnJpZWRTZXRIdWUgYXMgc2V0SHVlLCBjdXJyaWVkU2V0TGlnaHRuZXNzIGFzIHNldExpZ2h0bmVzcywgY3VycmllZFNldFNhdHVyYXRpb24gYXMgc2V0U2F0dXJhdGlvbiwgY3VycmllZFNoYWRlIGFzIHNoYWRlLCBzaXplLCBzdHJpcFVuaXQsIHRleHRJbnB1dHMsIHRpbWluZ0Z1bmN0aW9ucywgY3VycmllZFRpbnQgYXMgdGludCwgdG9Db2xvclN0cmluZywgdHJhbnNpdGlvbnMsIGN1cnJpZWRUcmFuc3BhcmVudGl6ZSBhcyB0cmFuc3BhcmVudGl6ZSwgdHJpYW5nbGUsIHdvcmRXcmFwIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wb2xpc2hlZC9kaXN0L3BvbGlzaGVkLmVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n");

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return memoize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return STYLES_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return TARGET_KEY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return unitless; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return hashString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return pa; });\n// murmurhash2 via https://gist.github.com/raycmorgan/588423\nfunction hashString(str) {\n  return hash(str, str.length).toString(36);\n}\n\nfunction hash(str, seed) {\n  var m = 0x5bd1e995;\n  var r = 24;\n  var h = seed ^ str.length;\n  var length = str.length;\n  var currentIndex = 0;\n\n  while (length >= 4) {\n    var k = UInt32(str, currentIndex);\n    k = Umul32(k, m);\n    k ^= k >>> r;\n    k = Umul32(k, m);\n    h = Umul32(h, m);\n    h ^= k;\n    currentIndex += 4;\n    length -= 4;\n  }\n\n  switch (length) {\n    case 3:\n      h ^= UInt16(str, currentIndex);\n      h ^= str.charCodeAt(currentIndex + 2) << 16;\n      h = Umul32(h, m);\n      break;\n\n    case 2:\n      h ^= UInt16(str, currentIndex);\n      h = Umul32(h, m);\n      break;\n\n    case 1:\n      h ^= str.charCodeAt(currentIndex);\n      h = Umul32(h, m);\n      break;\n  }\n\n  h ^= h >>> 13;\n  h = Umul32(h, m);\n  h ^= h >>> 15;\n  return h >>> 0;\n}\n\nfunction UInt32(str, pos) {\n  return str.charCodeAt(pos++) + (str.charCodeAt(pos++) << 8) + (str.charCodeAt(pos++) << 16) + (str.charCodeAt(pos) << 24);\n}\n\nfunction UInt16(str, pos) {\n  return str.charCodeAt(pos++) + (str.charCodeAt(pos++) << 8);\n}\n\nfunction Umul32(n, m) {\n  n = n | 0;\n  m = m | 0;\n  var nlo = n & 0xffff;\n  var nhi = n >>> 16;\n  var res = nlo * m + ((nhi * m & 0xffff) << 16) | 0;\n  return res;\n}\n\nvar pa = function fa(ha) {\n  function V(b, c, d, k, l) {\n    for (var a = 0, f = 0, n = 0, e = 0, h, q, m, v = 0, A = 0, B = 0, x = 0, C = 0, p = 0, G = 0, r = 0, N = q = 0, L = 0, t = 0, D = d.length, F = D - 1, g = \"\", u = \"\", S = \"\", M = \"\", H; r < D;) {\n      m = d.charCodeAt(r);\n      r === F && 0 !== f + e + n + a && (0 !== f && (m = 47 === f ? 10 : 47), e = n = a = 0, D++, F++);\n\n      if (0 === f + e + n + a) {\n        if (r === F && (0 < q && (g = g.replace(P, \"\")), 0 < g.trim().length)) {\n          switch (m) {\n            case 32:\n            case 9:\n            case 59:\n            case 13:\n            case 10:\n              break;\n\n            default:\n              g += d.charAt(r);\n          }\n\n          m = 59;\n        }\n\n        if (1 === N) switch (m) {\n          case 123:\n          case 125:\n          case 59:\n          case 34:\n          case 39:\n          case 40:\n          case 41:\n          case 44:\n            N = 0;\n\n          case 9:\n          case 13:\n          case 10:\n          case 32:\n            break;\n\n          default:\n            for (N = 0, t = r, h = m, r--, m = 59; t < D;) {\n              switch (d.charCodeAt(++t)) {\n                case 10:\n                case 13:\n                case 59:\n                  r++, m = h;\n\n                case 58:\n                case 123:\n                  t = D;\n              }\n            }\n\n        }\n\n        switch (m) {\n          case 123:\n            g = g.trim();\n            h = g.charCodeAt(0);\n            x = 1;\n\n            for (t = ++r; r < D;) {\n              m = d.charCodeAt(r);\n\n              switch (m) {\n                case 123:\n                  x++;\n                  break;\n\n                case 125:\n                  x--;\n              }\n\n              if (0 === x) break;\n              r++;\n            }\n\n            p = d.substring(t, r);\n            0 === h && (h = (g = g.replace(qa, \"\").trim()).charCodeAt(0));\n\n            switch (h) {\n              case 64:\n                0 < q && (g = g.replace(P, \"\"));\n                q = g.charCodeAt(1);\n\n                switch (q) {\n                  case 100:\n                  case 109:\n                  case 115:\n                  case 45:\n                    h = c;\n                    break;\n\n                  default:\n                    h = W;\n                }\n\n                p = V(c, h, p, q, l + 1);\n                t = p.length;\n                0 < X && 0 === t && (t = g.length);\n                0 < E && (h = ia(W, g, L), H = O(3, p, h, c, I, y, t, q, l), g = h.join(\"\"), void 0 !== H && 0 === (t = (p = H.trim()).length) && (q = 0, p = \"\"));\n                if (0 < t) switch (q) {\n                  case 115:\n                    g = g.replace(ra, sa);\n\n                  case 100:\n                  case 109:\n                  case 45:\n                    p = g + \"{\" + p + \"}\";\n                    break;\n\n                  case 107:\n                    g = g.replace(ta, \"$1 $2\" + (0 < Q ? T : \"\"));\n                    p = g + \"{\" + p + \"}\";\n                    p = 1 === w || 2 === w && U(\"@\" + p, 3) ? \"@-webkit-\" + p + \"@\" + p : \"@\" + p;\n                    break;\n\n                  default:\n                    p = g + p, 112 === k && (p = (u += p, \"\"));\n                } else p = \"\";\n                break;\n\n              default:\n                p = V(c, ia(c, g, L), p, k, l + 1);\n            }\n\n            S += p;\n            p = L = q = G = N = C = 0;\n            g = \"\";\n            m = d.charCodeAt(++r);\n            break;\n\n          case 125:\n          case 59:\n            g = (0 < q ? g.replace(P, \"\") : g).trim();\n            if (1 < (t = g.length)) switch (0 === G && (h = g.charCodeAt(0), 45 === h || 96 < h && 123 > h) && (t = (g = g.replace(\" \", \":\")).length), 0 < E && void 0 !== (H = O(1, g, c, b, I, y, u.length, k, l)) && 0 === (t = (g = H.trim()).length) && (g = \"\\x00\\x00\"), h = g.charCodeAt(0), q = g.charCodeAt(1), h + q) {\n              case 0:\n                break;\n\n              case 169:\n              case 163:\n                M += g + d.charAt(r);\n                break;\n\n              default:\n                58 !== g.charCodeAt(t - 1) && (u += ja(g, h, q, g.charCodeAt(2)));\n            }\n            L = q = G = N = C = 0;\n            g = \"\";\n            m = d.charCodeAt(++r);\n        }\n      }\n\n      switch (m) {\n        case 13:\n        case 10:\n          if (0 === f + e + n + a + ka) switch (B) {\n            case 41:\n            case 39:\n            case 34:\n            case 64:\n            case 126:\n            case 62:\n            case 42:\n            case 43:\n            case 47:\n            case 45:\n            case 58:\n            case 44:\n            case 59:\n            case 123:\n            case 125:\n              break;\n\n            default:\n              0 < G && (N = 1);\n          }\n          47 === f ? f = 0 : 0 === z + C && (q = 1, g += \"\\x00\");\n          0 < E * la && O(0, g, c, b, I, y, u.length, k, l);\n          y = 1;\n          I++;\n          break;\n\n        case 59:\n        case 125:\n          if (0 === f + e + n + a) {\n            y++;\n            break;\n          }\n\n        default:\n          y++;\n          h = d.charAt(r);\n\n          switch (m) {\n            case 9:\n            case 32:\n              if (0 === e + a + f) switch (v) {\n                case 44:\n                case 58:\n                case 9:\n                case 32:\n                  h = \"\";\n                  break;\n\n                default:\n                  32 !== m && (h = \" \");\n              }\n              break;\n\n            case 0:\n              h = \"\\\\0\";\n              break;\n\n            case 12:\n              h = \"\\\\f\";\n              break;\n\n            case 11:\n              h = \"\\\\v\";\n              break;\n\n            case 38:\n              0 === e + f + a && 0 < z && (q = L = 1, h = \"\\f\" + h);\n              break;\n\n            case 108:\n              if (0 === e + f + a + J && 0 < G) switch (r - G) {\n                case 2:\n                  112 === v && 58 === d.charCodeAt(r - 3) && (J = v);\n\n                case 8:\n                  111 === A && (J = A);\n              }\n              break;\n\n            case 58:\n              0 === e + f + a && (G = r);\n              break;\n\n            case 44:\n              0 === f + n + e + a && (q = 1, h += \"\\r\");\n              break;\n\n            case 34:\n              0 === f && (e = e === m ? 0 : 0 === e ? m : e);\n              break;\n\n            case 39:\n              0 === f && (e = e === m ? 0 : 0 === e ? m : e);\n              break;\n\n            case 91:\n              0 === e + f + n && a++;\n              break;\n\n            case 93:\n              0 === e + f + n && a--;\n              break;\n\n            case 41:\n              0 === e + f + a && n--;\n              break;\n\n            case 40:\n              if (0 === e + f + a) {\n                if (0 === C) switch (2 * v + 3 * A) {\n                  case 533:\n                    break;\n\n                  default:\n                    x = 0, C = 1;\n                }\n                n++;\n              }\n\n              break;\n\n            case 64:\n              0 === f + n + e + a + G + p && (p = 1);\n              break;\n\n            case 42:\n            case 47:\n              if (!(0 < e + a + n)) switch (f) {\n                case 0:\n                  switch (2 * m + 3 * d.charCodeAt(r + 1)) {\n                    case 235:\n                      f = 47;\n                      break;\n\n                    case 220:\n                      t = r, f = 42;\n                  }\n\n                  break;\n\n                case 42:\n                  47 === m && 42 === v && (33 === d.charCodeAt(t + 2) && (u += d.substring(t, r + 1)), h = \"\", f = 0);\n              }\n          }\n\n          if (0 === f) {\n            if (0 === z + e + a + p && 107 !== k && 59 !== m) switch (m) {\n              case 44:\n              case 126:\n              case 62:\n              case 43:\n              case 41:\n              case 40:\n                if (0 === C) {\n                  switch (v) {\n                    case 9:\n                    case 32:\n                    case 10:\n                    case 13:\n                      h += \"\\x00\";\n                      break;\n\n                    default:\n                      h = \"\\x00\" + h + (44 === m ? \"\" : \"\\x00\");\n                  }\n\n                  q = 1;\n                } else switch (m) {\n                  case 40:\n                    C = ++x;\n                    break;\n\n                  case 41:\n                    0 === (C = --x) && (q = 1, h += \"\\x00\");\n                }\n\n                break;\n\n              case 9:\n              case 32:\n                switch (v) {\n                  case 0:\n                  case 123:\n                  case 125:\n                  case 59:\n                  case 44:\n                  case 12:\n                  case 9:\n                  case 32:\n                  case 10:\n                  case 13:\n                    break;\n\n                  default:\n                    0 === C && (q = 1, h += \"\\x00\");\n                }\n\n            }\n            g += h;\n            32 !== m && 9 !== m && (B = m);\n          }\n\n      }\n\n      A = v;\n      v = m;\n      r++;\n    }\n\n    t = u.length;\n    0 < X && 0 === t && 0 === S.length && 0 === c[0].length === !1 && (109 !== k || 1 === c.length && (0 < z ? K : R) === c[0]) && (t = c.join(\",\").length + 2);\n\n    if (0 < t) {\n      if (0 === z && 107 !== k) {\n        d = 0;\n        a = c.length;\n\n        for (f = Array(a); d < a; ++d) {\n          v = c[d].split(ua);\n          A = \"\";\n          B = 0;\n\n          for (D = v.length; B < D; ++B) {\n            if (!(0 === (x = (e = v[B]).length) && 1 < D)) {\n              r = A.charCodeAt(A.length - 1);\n              L = e.charCodeAt(0);\n              n = \"\";\n              if (0 !== B) switch (r) {\n                case 42:\n                case 126:\n                case 62:\n                case 43:\n                case 32:\n                case 40:\n                  break;\n\n                default:\n                  n = \" \";\n              }\n\n              switch (L) {\n                case 38:\n                  e = n + K;\n\n                case 126:\n                case 62:\n                case 43:\n                case 32:\n                case 41:\n                case 40:\n                  break;\n\n                case 91:\n                  e = n + e + K;\n                  break;\n\n                case 58:\n                  switch (2 * e.charCodeAt(1) + 3 * e.charCodeAt(2)) {\n                    case 530:\n                      if (0 < Y) {\n                        e = n + e.substring(8, x - 1);\n                        break;\n                      }\n\n                    default:\n                      if (1 > B || 1 > v[B - 1].length) e = n + K + e;\n                  }\n\n                  break;\n\n                case 44:\n                  n = \"\";\n\n                default:\n                  e = 1 < x && 0 < e.indexOf(\":\") ? n + e.replace(va, \"$1\" + K + \"$2\") : n + e + K;\n              }\n\n              A += e;\n            }\n          }\n\n          f[d] = A.replace(P, \"\").trim();\n        }\n\n        c = f;\n      }\n\n      h = c;\n      if (0 < E && (H = O(2, u, h, b, I, y, t, k, l), void 0 !== H && 0 === (u = H).length)) return M + u + S;\n      u = h.join(\",\") + \"{\" + u + \"}\";\n\n      if (0 !== w * J) {\n        2 !== w || U(u, 2) || (J = 0);\n\n        switch (J) {\n          case 111:\n            u = u.replace(wa, \":-moz-$1\") + u;\n            break;\n\n          case 112:\n            u = u.replace(Z, \"::-webkit-input-$1\") + u.replace(Z, \"::-moz-$1\") + u.replace(Z, \":-ms-input-$1\") + u;\n        }\n\n        J = 0;\n      }\n    }\n\n    return M + u + S;\n  }\n\n  function ia(b, c, d) {\n    var k = c.trim().split(xa);\n    c = k;\n    var l = k.length,\n        a = b.length;\n\n    switch (a) {\n      case 0:\n      case 1:\n        var f = 0;\n\n        for (b = 0 === a ? \"\" : b[0] + \" \"; f < l; ++f) {\n          c[f] = ma(b, c[f], d, a).trim();\n        }\n\n        break;\n\n      default:\n        var n = f = 0;\n\n        for (c = []; f < l; ++f) {\n          for (var e = 0; e < a; ++e) {\n            c[n++] = ma(b[e] + \" \", k[f], d, a).trim();\n          }\n        }\n\n    }\n\n    return c;\n  }\n\n  function ma(b, c, d, k) {\n    var l = c.charCodeAt(0);\n    33 > l && (l = (c = c.trim()).charCodeAt(0));\n\n    switch (l) {\n      case 38:\n        switch (z + k) {\n          case 0:\n          case 1:\n            if (0 === b.trim().length) break;\n\n          default:\n            return c.replace(M, \"$1\" + b.trim());\n        }\n\n        break;\n\n      case 58:\n        switch (c.charCodeAt(1)) {\n          case 103:\n            if (0 < Y && 0 < z) return c.replace(ya, \"$1\").replace(M, \"$1\" + R);\n            break;\n\n          default:\n            return b.trim() + c;\n        }\n\n      default:\n        if (0 < d * z && 0 < c.indexOf(\"\\f\")) return c.replace(M, (58 === b.charCodeAt(0) ? \"\" : \"$1\") + b.trim());\n    }\n\n    return b + c;\n  }\n\n  function ja(b, c, d, k) {\n    var l = 0,\n        a = b + \";\";\n    c = 2 * c + 3 * d + 4 * k;\n\n    if (944 === c) {\n      l = a.length;\n      b = a.indexOf(\":\", 9) + 1;\n      d = a.substring(0, b).trim();\n      k = a.substring(b, l - 1).trim();\n\n      switch (a.charCodeAt(9) * Q) {\n        case 0:\n          break;\n\n        case 45:\n          if (110 !== a.charCodeAt(10)) break;\n\n        default:\n          for (a = k.split((k = \"\", za)), b = c = 0, l = a.length; c < l; b = 0, ++c) {\n            for (var f = a[c], n = f.split(Aa); f = n[b];) {\n              var e = f.charCodeAt(0);\n              if (1 === Q && (64 < e && 90 > e || 96 < e && 123 > e || 95 === e || 45 === e && 45 !== f.charCodeAt(1))) switch (isNaN(parseFloat(f)) + (-1 !== f.indexOf(\"(\"))) {\n                case 1:\n                  switch (f) {\n                    case \"infinite\":\n                    case \"alternate\":\n                    case \"backwards\":\n                    case \"running\":\n                    case \"normal\":\n                    case \"forwards\":\n                    case \"both\":\n                    case \"none\":\n                    case \"linear\":\n                    case \"ease\":\n                    case \"ease-in\":\n                    case \"ease-out\":\n                    case \"ease-in-out\":\n                    case \"paused\":\n                    case \"reverse\":\n                    case \"alternate-reverse\":\n                    case \"inherit\":\n                    case \"initial\":\n                    case \"unset\":\n                    case \"step-start\":\n                    case \"step-end\":\n                      break;\n\n                    default:\n                      f += T;\n                  }\n\n              }\n              n[b++] = f;\n            }\n\n            k += (0 === c ? \"\" : \",\") + n.join(\" \");\n          }\n\n      }\n\n      k = d + k + \";\";\n      return 1 === w || 2 === w && U(k, 1) ? \"-webkit-\" + k + k : k;\n    }\n\n    if (0 === w || 2 === w && !U(a, 1)) return a;\n\n    switch (c) {\n      case 1015:\n        return 45 === a.charCodeAt(9) ? \"-webkit-\" + a + a : a;\n\n      case 951:\n        return 116 === a.charCodeAt(3) ? \"-webkit-\" + a + a : a;\n\n      case 963:\n        return 110 === a.charCodeAt(5) ? \"-webkit-\" + a + a : a;\n\n      case 1009:\n        if (100 !== a.charCodeAt(4)) break;\n\n      case 969:\n      case 942:\n        return \"-webkit-\" + a + a;\n\n      case 978:\n        return \"-webkit-\" + a + \"-moz-\" + a + a;\n\n      case 1019:\n      case 983:\n        return \"-webkit-\" + a + \"-moz-\" + a + \"-ms-\" + a + a;\n\n      case 883:\n        return 45 === a.charCodeAt(8) ? \"-webkit-\" + a + a : a;\n\n      case 932:\n        if (45 === a.charCodeAt(4)) switch (a.charCodeAt(5)) {\n          case 103:\n            return \"-webkit-box-\" + a.replace(\"-grow\", \"\") + \"-webkit-\" + a + \"-ms-\" + a.replace(\"grow\", \"positive\") + a;\n\n          case 115:\n            return \"-webkit-\" + a + \"-ms-\" + a.replace(\"shrink\", \"negative\") + a;\n\n          case 98:\n            return \"-webkit-\" + a + \"-ms-\" + a.replace(\"basis\", \"preferred-size\") + a;\n        }\n        return \"-webkit-\" + a + \"-ms-\" + a + a;\n\n      case 964:\n        return \"-webkit-\" + a + \"-ms-flex-\" + a + a;\n\n      case 1023:\n        if (99 !== a.charCodeAt(8)) break;\n        b = a.substring(a.indexOf(\":\", 15)).replace(\"flex-\", \"\").replace(\"space-between\", \"justify\");\n        return \"-webkit-box-pack\" + b + \"-webkit-\" + a + \"-ms-flex-pack\" + b + a;\n\n      case 1005:\n        return Ba.test(a) ? a.replace(na, \":-webkit-\") + a.replace(na, \":-moz-\") + a : a;\n\n      case 1E3:\n        b = a.substring(13).trim();\n        l = b.indexOf(\"-\") + 1;\n\n        switch (b.charCodeAt(0) + b.charCodeAt(l)) {\n          case 226:\n            b = a.replace(aa, \"tb\");\n            break;\n\n          case 232:\n            b = a.replace(aa, \"tb-rl\");\n            break;\n\n          case 220:\n            b = a.replace(aa, \"lr\");\n            break;\n\n          default:\n            return a;\n        }\n\n        return \"-webkit-\" + a + \"-ms-\" + b + a;\n\n      case 1017:\n        if (-1 === a.indexOf(\"sticky\", 9)) break;\n\n      case 975:\n        l = (a = b).length - 10;\n        b = (33 === a.charCodeAt(l) ? a.substring(0, l) : a).substring(b.indexOf(\":\", 7) + 1).trim();\n\n        switch (c = b.charCodeAt(0) + (b.charCodeAt(7) | 0)) {\n          case 203:\n            if (111 > b.charCodeAt(8)) break;\n\n          case 115:\n            a = a.replace(b, \"-webkit-\" + b) + \";\" + a;\n            break;\n\n          case 207:\n          case 102:\n            a = a.replace(b, \"-webkit-\" + (102 < c ? \"inline-\" : \"\") + \"box\") + \";\" + a.replace(b, \"-webkit-\" + b) + \";\" + a.replace(b, \"-ms-\" + b + \"box\") + \";\" + a;\n        }\n\n        return a + \";\";\n\n      case 938:\n        if (45 === a.charCodeAt(5)) switch (a.charCodeAt(6)) {\n          case 105:\n            return b = a.replace(\"-items\", \"\"), \"-webkit-\" + a + \"-webkit-box-\" + b + \"-ms-flex-\" + b + a;\n\n          case 115:\n            return \"-webkit-\" + a + \"-ms-flex-item-\" + a.replace(Ca, \"\") + a;\n\n          default:\n            return \"-webkit-\" + a + \"-ms-flex-line-pack\" + a.replace(\"align-content\", \"\") + a;\n        }\n        break;\n\n      case 953:\n        if (0 < (l = a.indexOf(\"-content\", 9)) && 109 === a.charCodeAt(l - 3) && 45 !== a.charCodeAt(l - 4)) return b = a.substring(l - 3), \"width:-webkit-\" + b + \"width:-moz-\" + b + \"width:\" + b;\n        break;\n\n      case 962:\n        if (a = \"-webkit-\" + a + (102 === a.charCodeAt(5) ? \"-ms-\" + a : \"\") + a, 211 === d + k && 105 === a.charCodeAt(13) && 0 < a.indexOf(\"transform\", 10)) return a.substring(0, a.indexOf(\";\", 27) + 1).replace(Da, \"$1-webkit-$2\") + a;\n    }\n\n    return a;\n  }\n\n  function U(b, c) {\n    var d = b.indexOf(1 === c ? \":\" : \"{\"),\n        k = b.substring(0, 3 !== c ? d : 10);\n    d = b.substring(d + 1, b.length - 1);\n    return ba(2 !== c ? k : k.replace(Ea, \"$1\"), d, c);\n  }\n\n  function sa(b, c) {\n    var d = ja(c, c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2));\n    return d !== c + \";\" ? d.replace(Fa, \" or ($1)\").substring(4) : \"(\" + c + \")\";\n  }\n\n  function O(b, c, d, k, l, a, f, n, e) {\n    for (var h = 0, q = c, m; h < E; ++h) {\n      switch (m = ca[h].call(F, b, q, d, k, l, a, f, n, e)) {\n        case void 0:\n        case !1:\n        case !0:\n        case null:\n          break;\n\n        default:\n          q = m;\n      }\n    }\n\n    switch (q) {\n      case void 0:\n      case !1:\n      case !0:\n      case null:\n      case c:\n        break;\n\n      default:\n        return q;\n    }\n  }\n\n  function da(b) {\n    switch (b) {\n      case void 0:\n      case null:\n        E = ca.length = 0;\n        break;\n\n      default:\n        switch (b.constructor) {\n          case Array:\n            for (var c = 0, d = b.length; c < d; ++c) {\n              da(b[c]);\n            }\n\n            break;\n\n          case Function:\n            ca[E++] = b;\n            break;\n\n          case Boolean:\n            la = !!b | 0;\n        }\n\n    }\n\n    return da;\n  }\n\n  function ea(b) {\n    for (var c in b) {\n      var d = b[c];\n\n      switch (c) {\n        case \"keyframe\":\n          Q = d | 0;\n          break;\n\n        case \"global\":\n          Y = d | 0;\n          break;\n\n        case \"cascade\":\n          z = d | 0;\n          break;\n\n        case \"compress\":\n          oa = d | 0;\n          break;\n\n        case \"semicolon\":\n          ka = d | 0;\n          break;\n\n        case \"preserve\":\n          X = d | 0;\n          break;\n\n        case \"prefix\":\n          ba = null, d ? \"function\" !== typeof d ? w = 1 : (w = 2, ba = d) : w = 0;\n      }\n    }\n\n    return ea;\n  }\n\n  function F(b, c) {\n    if (void 0 !== this && this.constructor === F) return fa(b);\n    var d = b,\n        k = d.charCodeAt(0);\n    33 > k && (k = (d = d.trim()).charCodeAt(0));\n    0 < Q && (T = d.replace(Ga, 91 === k ? \"\" : \"-\"));\n    k = 1;\n    1 === z ? R = d : K = d;\n    d = [R];\n\n    if (0 < E) {\n      var l = O(-1, c, d, d, I, y, 0, 0, 0);\n      void 0 !== l && \"string\" === typeof l && (c = l);\n    }\n\n    var a = V(W, d, c, 0, 0);\n    0 < E && (l = O(-2, a, d, d, I, y, a.length, 0, 0), void 0 !== l && \"string\" !== typeof (a = l) && (k = 0));\n    K = R = T = \"\";\n    J = 0;\n    y = I = 1;\n    return 0 === oa * k ? a : a.replace(P, \"\").replace(Ha, \"\").replace(Ia, \"$1\").replace(Ja, \"$1\").replace(Ka, \" \");\n  }\n\n  var qa = /^\\0+/g,\n      P = /[\\0\\r\\f]/g,\n      na = /: */g,\n      Ba = /zoo|gra/,\n      Da = /([,: ])(transform)/g,\n      za = /,+\\s*(?![^(]*[)])/g,\n      Aa = / +\\s*(?![^(]*[)])/g,\n      ua = / *[\\0] */g,\n      xa = /,\\r+?/g,\n      M = /([\\t\\r\\n ])*\\f?&/g,\n      ya = /:global\\(((?:[^\\(\\)\\[\\]]*|\\[.*\\]|\\([^\\(\\)]*\\))*)\\)/g,\n      Ga = /\\W+/g,\n      ta = /@(k\\w+)\\s*(\\S*)\\s*/,\n      Z = /::(place)/g,\n      wa = /:(read-only)/g,\n      Ha = /\\s+(?=[{\\];=:>])/g,\n      Ia = /([[}=:>])\\s+/g,\n      Ja = /(\\{[^{]+?);(?=\\})/g,\n      Ka = /\\s{2,}/g,\n      va = /([^\\(])(:+) */g,\n      aa = /[svh]\\w+-[tblr]{2}/,\n      ra = /\\(\\s*(.*)\\s*\\)/g,\n      Fa = /([^]*?);/g,\n      Ca = /-self|flex-/g,\n      Ea = /[^]*?(:[rp][el]a[\\w-]+)[^]*/,\n      y = 1,\n      I = 1,\n      J = 0,\n      z = 1,\n      w = 1,\n      Y = 1,\n      oa = 0,\n      ka = 0,\n      X = 0,\n      W = [],\n      ca = [],\n      E = 0,\n      ba = null,\n      la = 0,\n      Q = 1,\n      T = \"\",\n      K = \"\",\n      R = \"\";\n  F.use = da;\n  F.set = ea;\n  void 0 !== ha && ea(ha);\n  return F;\n};\n\n//  weak\nfunction memoize(fn) {\n  var cache = {};\n  return function (arg) {\n    if (cache[arg] === undefined) cache[arg] = fn(arg);\n    return cache[arg];\n  };\n}\nvar STYLES_KEY = '__emotion_styles';\nvar TARGET_KEY = '__emotion_target';\nvar unitless = {\n  animationIterationCount: 1,\n  borderImageOutset: 1,\n  borderImageSlice: 1,\n  borderImageWidth: 1,\n  boxFlex: 1,\n  boxFlexGroup: 1,\n  boxOrdinalGroup: 1,\n  columnCount: 1,\n  columns: 1,\n  flex: 1,\n  flexGrow: 1,\n  flexPositive: 1,\n  flexShrink: 1,\n  flexNegative: 1,\n  flexOrder: 1,\n  gridRow: 1,\n  gridRowEnd: 1,\n  gridRowSpan: 1,\n  gridRowStart: 1,\n  gridColumn: 1,\n  gridColumnEnd: 1,\n  gridColumnSpan: 1,\n  gridColumnStart: 1,\n  fontWeight: 1,\n  lineClamp: 1,\n  lineHeight: 1,\n  opacity: 1,\n  order: 1,\n  orphans: 1,\n  tabSize: 1,\n  widows: 1,\n  zIndex: 1,\n  zoom: 1,\n  // SVG-related properties\n  fillOpacity: 1,\n  floodOpacity: 1,\n  stopOpacity: 1,\n  strokeDasharray: 1,\n  strokeDashoffset: 1,\n  strokeMiterlimit: 1,\n  strokeOpacity: 1,\n  strokeWidth: 1\n};\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW1vdGlvbi11dGlscy9kaXN0L2luZGV4LmVzLmpzP2M2NWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbXVybXVyaGFzaDIgdmlhIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3JheWNtb3JnYW4vNTg4NDIzXG5mdW5jdGlvbiBoYXNoU3RyaW5nKHN0cikge1xuICByZXR1cm4gaGFzaChzdHIsIHN0ci5sZW5ndGgpLnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gaGFzaChzdHIsIHNlZWQpIHtcbiAgdmFyIG0gPSAweDViZDFlOTk1O1xuICB2YXIgciA9IDI0O1xuICB2YXIgaCA9IHNlZWQgXiBzdHIubGVuZ3RoO1xuICB2YXIgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgdmFyIGN1cnJlbnRJbmRleCA9IDA7XG5cbiAgd2hpbGUgKGxlbmd0aCA+PSA0KSB7XG4gICAgdmFyIGsgPSBVSW50MzIoc3RyLCBjdXJyZW50SW5kZXgpO1xuICAgIGsgPSBVbXVsMzIoaywgbSk7XG4gICAgayBePSBrID4+PiByO1xuICAgIGsgPSBVbXVsMzIoaywgbSk7XG4gICAgaCA9IFVtdWwzMihoLCBtKTtcbiAgICBoIF49IGs7XG4gICAgY3VycmVudEluZGV4ICs9IDQ7XG4gICAgbGVuZ3RoIC09IDQ7XG4gIH1cblxuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMzpcbiAgICAgIGggXj0gVUludDE2KHN0ciwgY3VycmVudEluZGV4KTtcbiAgICAgIGggXj0gc3RyLmNoYXJDb2RlQXQoY3VycmVudEluZGV4ICsgMikgPDwgMTY7XG4gICAgICBoID0gVW11bDMyKGgsIG0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgICBoIF49IFVJbnQxNihzdHIsIGN1cnJlbnRJbmRleCk7XG4gICAgICBoID0gVW11bDMyKGgsIG0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDE6XG4gICAgICBoIF49IHN0ci5jaGFyQ29kZUF0KGN1cnJlbnRJbmRleCk7XG4gICAgICBoID0gVW11bDMyKGgsIG0pO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBoIF49IGggPj4+IDEzO1xuICBoID0gVW11bDMyKGgsIG0pO1xuICBoIF49IGggPj4+IDE1O1xuICByZXR1cm4gaCA+Pj4gMDtcbn1cblxuZnVuY3Rpb24gVUludDMyKHN0ciwgcG9zKSB7XG4gIHJldHVybiBzdHIuY2hhckNvZGVBdChwb3MrKykgKyAoc3RyLmNoYXJDb2RlQXQocG9zKyspIDw8IDgpICsgKHN0ci5jaGFyQ29kZUF0KHBvcysrKSA8PCAxNikgKyAoc3RyLmNoYXJDb2RlQXQocG9zKSA8PCAyNCk7XG59XG5cbmZ1bmN0aW9uIFVJbnQxNihzdHIsIHBvcykge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQocG9zKyspICsgKHN0ci5jaGFyQ29kZUF0KHBvcysrKSA8PCA4KTtcbn1cblxuZnVuY3Rpb24gVW11bDMyKG4sIG0pIHtcbiAgbiA9IG4gfCAwO1xuICBtID0gbSB8IDA7XG4gIHZhciBubG8gPSBuICYgMHhmZmZmO1xuICB2YXIgbmhpID0gbiA+Pj4gMTY7XG4gIHZhciByZXMgPSBubG8gKiBtICsgKChuaGkgKiBtICYgMHhmZmZmKSA8PCAxNikgfCAwO1xuICByZXR1cm4gcmVzO1xufVxuXG52YXIgcGEgPSBmdW5jdGlvbiBmYShoYSkge1xuICBmdW5jdGlvbiBWKGIsIGMsIGQsIGssIGwpIHtcbiAgICBmb3IgKHZhciBhID0gMCwgZiA9IDAsIG4gPSAwLCBlID0gMCwgaCwgcSwgbSwgdiA9IDAsIEEgPSAwLCBCID0gMCwgeCA9IDAsIEMgPSAwLCBwID0gMCwgRyA9IDAsIHIgPSAwLCBOID0gcSA9IDAsIEwgPSAwLCB0ID0gMCwgRCA9IGQubGVuZ3RoLCBGID0gRCAtIDEsIGcgPSBcIlwiLCB1ID0gXCJcIiwgUyA9IFwiXCIsIE0gPSBcIlwiLCBIOyByIDwgRDspIHtcbiAgICAgIG0gPSBkLmNoYXJDb2RlQXQocik7XG4gICAgICByID09PSBGICYmIDAgIT09IGYgKyBlICsgbiArIGEgJiYgKDAgIT09IGYgJiYgKG0gPSA0NyA9PT0gZiA/IDEwIDogNDcpLCBlID0gbiA9IGEgPSAwLCBEKyssIEYrKyk7XG5cbiAgICAgIGlmICgwID09PSBmICsgZSArIG4gKyBhKSB7XG4gICAgICAgIGlmIChyID09PSBGICYmICgwIDwgcSAmJiAoZyA9IGcucmVwbGFjZShQLCBcIlwiKSksIDAgPCBnLnRyaW0oKS5sZW5ndGgpKSB7XG4gICAgICAgICAgc3dpdGNoIChtKSB7XG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgZyArPSBkLmNoYXJBdChyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtID0gNTk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoMSA9PT0gTikgc3dpdGNoIChtKSB7XG4gICAgICAgICAgY2FzZSAxMjM6XG4gICAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICBjYXNlIDQxOlxuICAgICAgICAgIGNhc2UgNDQ6XG4gICAgICAgICAgICBOID0gMDtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGZvciAoTiA9IDAsIHQgPSByLCBoID0gbSwgci0tLCBtID0gNTk7IHQgPCBEOykge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGQuY2hhckNvZGVBdCgrK3QpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgIGNhc2UgNTk6XG4gICAgICAgICAgICAgICAgICByKyssIG0gPSBoO1xuXG4gICAgICAgICAgICAgICAgY2FzZSA1ODpcbiAgICAgICAgICAgICAgICBjYXNlIDEyMzpcbiAgICAgICAgICAgICAgICAgIHQgPSBEO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAobSkge1xuICAgICAgICAgIGNhc2UgMTIzOlxuICAgICAgICAgICAgZyA9IGcudHJpbSgpO1xuICAgICAgICAgICAgaCA9IGcuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIHggPSAxO1xuXG4gICAgICAgICAgICBmb3IgKHQgPSArK3I7IHIgPCBEOykge1xuICAgICAgICAgICAgICBtID0gZC5jaGFyQ29kZUF0KHIpO1xuXG4gICAgICAgICAgICAgIHN3aXRjaCAobSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTIzOlxuICAgICAgICAgICAgICAgICAgeCsrO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDEyNTpcbiAgICAgICAgICAgICAgICAgIHgtLTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICgwID09PSB4KSBicmVhaztcbiAgICAgICAgICAgICAgcisrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwID0gZC5zdWJzdHJpbmcodCwgcik7XG4gICAgICAgICAgICAwID09PSBoICYmIChoID0gKGcgPSBnLnJlcGxhY2UocWEsIFwiXCIpLnRyaW0oKSkuY2hhckNvZGVBdCgwKSk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoaCkge1xuICAgICAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgICAgIDAgPCBxICYmIChnID0gZy5yZXBsYWNlKFAsIFwiXCIpKTtcbiAgICAgICAgICAgICAgICBxID0gZy5jaGFyQ29kZUF0KDEpO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoIChxKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDEwMDpcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTA5OlxuICAgICAgICAgICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICAgICAgICBjYXNlIDQ1OlxuICAgICAgICAgICAgICAgICAgICBoID0gYztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGggPSBXO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHAgPSBWKGMsIGgsIHAsIHEsIGwgKyAxKTtcbiAgICAgICAgICAgICAgICB0ID0gcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgMCA8IFggJiYgMCA9PT0gdCAmJiAodCA9IGcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAwIDwgRSAmJiAoaCA9IGlhKFcsIGcsIEwpLCBIID0gTygzLCBwLCBoLCBjLCBJLCB5LCB0LCBxLCBsKSwgZyA9IGguam9pbihcIlwiKSwgdm9pZCAwICE9PSBIICYmIDAgPT09ICh0ID0gKHAgPSBILnRyaW0oKSkubGVuZ3RoKSAmJiAocSA9IDAsIHAgPSBcIlwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKDAgPCB0KSBzd2l0Y2ggKHEpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgICAgICAgICAgICBnID0gZy5yZXBsYWNlKHJhLCBzYSk7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTAwOlxuICAgICAgICAgICAgICAgICAgY2FzZSAxMDk6XG4gICAgICAgICAgICAgICAgICBjYXNlIDQ1OlxuICAgICAgICAgICAgICAgICAgICBwID0gZyArIFwie1wiICsgcCArIFwifVwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSAxMDc6XG4gICAgICAgICAgICAgICAgICAgIGcgPSBnLnJlcGxhY2UodGEsIFwiJDEgJDJcIiArICgwIDwgUSA/IFQgOiBcIlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBnICsgXCJ7XCIgKyBwICsgXCJ9XCI7XG4gICAgICAgICAgICAgICAgICAgIHAgPSAxID09PSB3IHx8IDIgPT09IHcgJiYgVShcIkBcIiArIHAsIDMpID8gXCJALXdlYmtpdC1cIiArIHAgKyBcIkBcIiArIHAgOiBcIkBcIiArIHA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBwID0gZyArIHAsIDExMiA9PT0gayAmJiAocCA9ICh1ICs9IHAsIFwiXCIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgcCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBwID0gVihjLCBpYShjLCBnLCBMKSwgcCwgaywgbCArIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBTICs9IHA7XG4gICAgICAgICAgICBwID0gTCA9IHEgPSBHID0gTiA9IEMgPSAwO1xuICAgICAgICAgICAgZyA9IFwiXCI7XG4gICAgICAgICAgICBtID0gZC5jaGFyQ29kZUF0KCsrcik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTI1OlxuICAgICAgICAgIGNhc2UgNTk6XG4gICAgICAgICAgICBnID0gKDAgPCBxID8gZy5yZXBsYWNlKFAsIFwiXCIpIDogZykudHJpbSgpO1xuICAgICAgICAgICAgaWYgKDEgPCAodCA9IGcubGVuZ3RoKSkgc3dpdGNoICgwID09PSBHICYmIChoID0gZy5jaGFyQ29kZUF0KDApLCA0NSA9PT0gaCB8fCA5NiA8IGggJiYgMTIzID4gaCkgJiYgKHQgPSAoZyA9IGcucmVwbGFjZShcIiBcIiwgXCI6XCIpKS5sZW5ndGgpLCAwIDwgRSAmJiB2b2lkIDAgIT09IChIID0gTygxLCBnLCBjLCBiLCBJLCB5LCB1Lmxlbmd0aCwgaywgbCkpICYmIDAgPT09ICh0ID0gKGcgPSBILnRyaW0oKSkubGVuZ3RoKSAmJiAoZyA9IFwiXFx4MDBcXHgwMFwiKSwgaCA9IGcuY2hhckNvZGVBdCgwKSwgcSA9IGcuY2hhckNvZGVBdCgxKSwgaCArIHEpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTY5OlxuICAgICAgICAgICAgICBjYXNlIDE2MzpcbiAgICAgICAgICAgICAgICBNICs9IGcgKyBkLmNoYXJBdChyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIDU4ICE9PSBnLmNoYXJDb2RlQXQodCAtIDEpICYmICh1ICs9IGphKGcsIGgsIHEsIGcuY2hhckNvZGVBdCgyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTCA9IHEgPSBHID0gTiA9IEMgPSAwO1xuICAgICAgICAgICAgZyA9IFwiXCI7XG4gICAgICAgICAgICBtID0gZC5jaGFyQ29kZUF0KCsrcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChtKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgaWYgKDAgPT09IGYgKyBlICsgbiArIGEgKyBrYSkgc3dpdGNoIChCKSB7XG4gICAgICAgICAgICBjYXNlIDQxOlxuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgY2FzZSAxMjY6XG4gICAgICAgICAgICBjYXNlIDYyOlxuICAgICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgIGNhc2UgNDM6XG4gICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgY2FzZSA0NTpcbiAgICAgICAgICAgIGNhc2UgNTg6XG4gICAgICAgICAgICBjYXNlIDQ0OlxuICAgICAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgICAgIGNhc2UgMTIzOlxuICAgICAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAwIDwgRyAmJiAoTiA9IDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICA0NyA9PT0gZiA/IGYgPSAwIDogMCA9PT0geiArIEMgJiYgKHEgPSAxLCBnICs9IFwiXFx4MDBcIik7XG4gICAgICAgICAgMCA8IEUgKiBsYSAmJiBPKDAsIGcsIGMsIGIsIEksIHksIHUubGVuZ3RoLCBrLCBsKTtcbiAgICAgICAgICB5ID0gMTtcbiAgICAgICAgICBJKys7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA1OTpcbiAgICAgICAgY2FzZSAxMjU6XG4gICAgICAgICAgaWYgKDAgPT09IGYgKyBlICsgbiArIGEpIHtcbiAgICAgICAgICAgIHkrKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHkrKztcbiAgICAgICAgICBoID0gZC5jaGFyQXQocik7XG5cbiAgICAgICAgICBzd2l0Y2ggKG0pIHtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgIGlmICgwID09PSBlICsgYSArIGYpIHN3aXRjaCAodikge1xuICAgICAgICAgICAgICAgIGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgY2FzZSA1ODpcbiAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAgIGggPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgMzIgIT09IG0gJiYgKGggPSBcIiBcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaCA9IFwiXFxcXDBcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIGggPSBcIlxcXFxmXCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBoID0gXCJcXFxcdlwiO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgICAgMCA9PT0gZSArIGYgKyBhICYmIDAgPCB6ICYmIChxID0gTCA9IDEsIGggPSBcIlxcZlwiICsgaCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDEwODpcbiAgICAgICAgICAgICAgaWYgKDAgPT09IGUgKyBmICsgYSArIEogJiYgMCA8IEcpIHN3aXRjaCAociAtIEcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAxMTIgPT09IHYgJiYgNTggPT09IGQuY2hhckNvZGVBdChyIC0gMykgJiYgKEogPSB2KTtcblxuICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgIDExMSA9PT0gQSAmJiAoSiA9IEEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDU4OlxuICAgICAgICAgICAgICAwID09PSBlICsgZiArIGEgJiYgKEcgPSByKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNDQ6XG4gICAgICAgICAgICAgIDAgPT09IGYgKyBuICsgZSArIGEgJiYgKHEgPSAxLCBoICs9IFwiXFxyXCIpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgMCA9PT0gZiAmJiAoZSA9IGUgPT09IG0gPyAwIDogMCA9PT0gZSA/IG0gOiBlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgIDAgPT09IGYgJiYgKGUgPSBlID09PSBtID8gMCA6IDAgPT09IGUgPyBtIDogZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDkxOlxuICAgICAgICAgICAgICAwID09PSBlICsgZiArIG4gJiYgYSsrO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA5MzpcbiAgICAgICAgICAgICAgMCA9PT0gZSArIGYgKyBuICYmIGEtLTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNDE6XG4gICAgICAgICAgICAgIDAgPT09IGUgKyBmICsgYSAmJiBuLS07XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICBpZiAoMCA9PT0gZSArIGYgKyBhKSB7XG4gICAgICAgICAgICAgICAgaWYgKDAgPT09IEMpIHN3aXRjaCAoMiAqIHYgKyAzICogQSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSA1MzM6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB4ID0gMCwgQyA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDY0OlxuICAgICAgICAgICAgICAwID09PSBmICsgbiArIGUgKyBhICsgRyArIHAgJiYgKHAgPSAxKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICBpZiAoISgwIDwgZSArIGEgKyBuKSkgc3dpdGNoIChmKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgc3dpdGNoICgyICogbSArIDMgKiBkLmNoYXJDb2RlQXQociArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjM1OlxuICAgICAgICAgICAgICAgICAgICAgIGYgPSA0NztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDIyMDpcbiAgICAgICAgICAgICAgICAgICAgICB0ID0gciwgZiA9IDQyO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICAgICAgICA0NyA9PT0gbSAmJiA0MiA9PT0gdiAmJiAoMzMgPT09IGQuY2hhckNvZGVBdCh0ICsgMikgJiYgKHUgKz0gZC5zdWJzdHJpbmcodCwgciArIDEpKSwgaCA9IFwiXCIsIGYgPSAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgwID09PSBmKSB7XG4gICAgICAgICAgICBpZiAoMCA9PT0geiArIGUgKyBhICsgcCAmJiAxMDcgIT09IGsgJiYgNTkgIT09IG0pIHN3aXRjaCAobSkge1xuICAgICAgICAgICAgICBjYXNlIDQ0OlxuICAgICAgICAgICAgICBjYXNlIDEyNjpcbiAgICAgICAgICAgICAgY2FzZSA2MjpcbiAgICAgICAgICAgICAgY2FzZSA0MzpcbiAgICAgICAgICAgICAgY2FzZSA0MTpcbiAgICAgICAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgICAgICBpZiAoMCA9PT0gQykge1xuICAgICAgICAgICAgICAgICAgc3dpdGNoICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgICBoICs9IFwiXFx4MDBcIjtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIGggPSBcIlxceDAwXCIgKyBoICsgKDQ0ID09PSBtID8gXCJcIiA6IFwiXFx4MDBcIik7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHEgPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBzd2l0Y2ggKG0pIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICAgICAgICAgIEMgPSArK3g7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDQxOlxuICAgICAgICAgICAgICAgICAgICAwID09PSAoQyA9IC0teCkgJiYgKHEgPSAxLCBoICs9IFwiXFx4MDBcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAodikge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgY2FzZSAxMjM6XG4gICAgICAgICAgICAgICAgICBjYXNlIDEyNTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgNTk6XG4gICAgICAgICAgICAgICAgICBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIDAgPT09IEMgJiYgKHEgPSAxLCBoICs9IFwiXFx4MDBcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnICs9IGg7XG4gICAgICAgICAgICAzMiAhPT0gbSAmJiA5ICE9PSBtICYmIChCID0gbSk7XG4gICAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIEEgPSB2O1xuICAgICAgdiA9IG07XG4gICAgICByKys7XG4gICAgfVxuXG4gICAgdCA9IHUubGVuZ3RoO1xuICAgIDAgPCBYICYmIDAgPT09IHQgJiYgMCA9PT0gUy5sZW5ndGggJiYgMCA9PT0gY1swXS5sZW5ndGggPT09ICExICYmICgxMDkgIT09IGsgfHwgMSA9PT0gYy5sZW5ndGggJiYgKDAgPCB6ID8gSyA6IFIpID09PSBjWzBdKSAmJiAodCA9IGMuam9pbihcIixcIikubGVuZ3RoICsgMik7XG5cbiAgICBpZiAoMCA8IHQpIHtcbiAgICAgIGlmICgwID09PSB6ICYmIDEwNyAhPT0gaykge1xuICAgICAgICBkID0gMDtcbiAgICAgICAgYSA9IGMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoZiA9IEFycmF5KGEpOyBkIDwgYTsgKytkKSB7XG4gICAgICAgICAgdiA9IGNbZF0uc3BsaXQodWEpO1xuICAgICAgICAgIEEgPSBcIlwiO1xuICAgICAgICAgIEIgPSAwO1xuXG4gICAgICAgICAgZm9yIChEID0gdi5sZW5ndGg7IEIgPCBEOyArK0IpIHtcbiAgICAgICAgICAgIGlmICghKDAgPT09ICh4ID0gKGUgPSB2W0JdKS5sZW5ndGgpICYmIDEgPCBEKSkge1xuICAgICAgICAgICAgICByID0gQS5jaGFyQ29kZUF0KEEubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIEwgPSBlLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgIG4gPSBcIlwiO1xuICAgICAgICAgICAgICBpZiAoMCAhPT0gQikgc3dpdGNoIChyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgICAgICBjYXNlIDEyNjpcbiAgICAgICAgICAgICAgICBjYXNlIDYyOlxuICAgICAgICAgICAgICAgIGNhc2UgNDM6XG4gICAgICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgbiA9IFwiIFwiO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3dpdGNoIChMKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgICAgICAgIGUgPSBuICsgSztcblxuICAgICAgICAgICAgICAgIGNhc2UgMTI2OlxuICAgICAgICAgICAgICAgIGNhc2UgNjI6XG4gICAgICAgICAgICAgICAgY2FzZSA0MzpcbiAgICAgICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIGNhc2UgNDE6XG4gICAgICAgICAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSA5MTpcbiAgICAgICAgICAgICAgICAgIGUgPSBuICsgZSArIEs7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgNTg6XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKDIgKiBlLmNoYXJDb2RlQXQoMSkgKyAzICogZS5jaGFyQ29kZUF0KDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTMwOlxuICAgICAgICAgICAgICAgICAgICAgIGlmICgwIDwgWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IG4gKyBlLnN1YnN0cmluZyg4LCB4IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoMSA+IEIgfHwgMSA+IHZbQiAtIDFdLmxlbmd0aCkgZSA9IG4gKyBLICsgZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgICAgbiA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgZSA9IDEgPCB4ICYmIDAgPCBlLmluZGV4T2YoXCI6XCIpID8gbiArIGUucmVwbGFjZSh2YSwgXCIkMVwiICsgSyArIFwiJDJcIikgOiBuICsgZSArIEs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBBICs9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZltkXSA9IEEucmVwbGFjZShQLCBcIlwiKS50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjID0gZjtcbiAgICAgIH1cblxuICAgICAgaCA9IGM7XG4gICAgICBpZiAoMCA8IEUgJiYgKEggPSBPKDIsIHUsIGgsIGIsIEksIHksIHQsIGssIGwpLCB2b2lkIDAgIT09IEggJiYgMCA9PT0gKHUgPSBIKS5sZW5ndGgpKSByZXR1cm4gTSArIHUgKyBTO1xuICAgICAgdSA9IGguam9pbihcIixcIikgKyBcIntcIiArIHUgKyBcIn1cIjtcblxuICAgICAgaWYgKDAgIT09IHcgKiBKKSB7XG4gICAgICAgIDIgIT09IHcgfHwgVSh1LCAyKSB8fCAoSiA9IDApO1xuXG4gICAgICAgIHN3aXRjaCAoSikge1xuICAgICAgICAgIGNhc2UgMTExOlxuICAgICAgICAgICAgdSA9IHUucmVwbGFjZSh3YSwgXCI6LW1vei0kMVwiKSArIHU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTEyOlxuICAgICAgICAgICAgdSA9IHUucmVwbGFjZShaLCBcIjo6LXdlYmtpdC1pbnB1dC0kMVwiKSArIHUucmVwbGFjZShaLCBcIjo6LW1vei0kMVwiKSArIHUucmVwbGFjZShaLCBcIjotbXMtaW5wdXQtJDFcIikgKyB1O1xuICAgICAgICB9XG5cbiAgICAgICAgSiA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIE0gKyB1ICsgUztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlhKGIsIGMsIGQpIHtcbiAgICB2YXIgayA9IGMudHJpbSgpLnNwbGl0KHhhKTtcbiAgICBjID0gaztcbiAgICB2YXIgbCA9IGsubGVuZ3RoLFxuICAgICAgICBhID0gYi5sZW5ndGg7XG5cbiAgICBzd2l0Y2ggKGEpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdmFyIGYgPSAwO1xuXG4gICAgICAgIGZvciAoYiA9IDAgPT09IGEgPyBcIlwiIDogYlswXSArIFwiIFwiOyBmIDwgbDsgKytmKSB7XG4gICAgICAgICAgY1tmXSA9IG1hKGIsIGNbZl0sIGQsIGEpLnRyaW0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgbiA9IGYgPSAwO1xuXG4gICAgICAgIGZvciAoYyA9IFtdOyBmIDwgbDsgKytmKSB7XG4gICAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBhOyArK2UpIHtcbiAgICAgICAgICAgIGNbbisrXSA9IG1hKGJbZV0gKyBcIiBcIiwga1tmXSwgZCwgYSkudHJpbSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICBmdW5jdGlvbiBtYShiLCBjLCBkLCBrKSB7XG4gICAgdmFyIGwgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgMzMgPiBsICYmIChsID0gKGMgPSBjLnRyaW0oKSkuY2hhckNvZGVBdCgwKSk7XG5cbiAgICBzd2l0Y2ggKGwpIHtcbiAgICAgIGNhc2UgMzg6XG4gICAgICAgIHN3aXRjaCAoeiArIGspIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaWYgKDAgPT09IGIudHJpbSgpLmxlbmd0aCkgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGMucmVwbGFjZShNLCBcIiQxXCIgKyBiLnRyaW0oKSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA1ODpcbiAgICAgICAgc3dpdGNoIChjLmNoYXJDb2RlQXQoMSkpIHtcbiAgICAgICAgICBjYXNlIDEwMzpcbiAgICAgICAgICAgIGlmICgwIDwgWSAmJiAwIDwgeikgcmV0dXJuIGMucmVwbGFjZSh5YSwgXCIkMVwiKS5yZXBsYWNlKE0sIFwiJDFcIiArIFIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGIudHJpbSgpICsgYztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoMCA8IGQgKiB6ICYmIDAgPCBjLmluZGV4T2YoXCJcXGZcIikpIHJldHVybiBjLnJlcGxhY2UoTSwgKDU4ID09PSBiLmNoYXJDb2RlQXQoMCkgPyBcIlwiIDogXCIkMVwiKSArIGIudHJpbSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYiArIGM7XG4gIH1cblxuICBmdW5jdGlvbiBqYShiLCBjLCBkLCBrKSB7XG4gICAgdmFyIGwgPSAwLFxuICAgICAgICBhID0gYiArIFwiO1wiO1xuICAgIGMgPSAyICogYyArIDMgKiBkICsgNCAqIGs7XG5cbiAgICBpZiAoOTQ0ID09PSBjKSB7XG4gICAgICBsID0gYS5sZW5ndGg7XG4gICAgICBiID0gYS5pbmRleE9mKFwiOlwiLCA5KSArIDE7XG4gICAgICBkID0gYS5zdWJzdHJpbmcoMCwgYikudHJpbSgpO1xuICAgICAgayA9IGEuc3Vic3RyaW5nKGIsIGwgLSAxKS50cmltKCk7XG5cbiAgICAgIHN3aXRjaCAoYS5jaGFyQ29kZUF0KDkpICogUSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0NTpcbiAgICAgICAgICBpZiAoMTEwICE9PSBhLmNoYXJDb2RlQXQoMTApKSBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGZvciAoYSA9IGsuc3BsaXQoKGsgPSBcIlwiLCB6YSkpLCBiID0gYyA9IDAsIGwgPSBhLmxlbmd0aDsgYyA8IGw7IGIgPSAwLCArK2MpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGYgPSBhW2NdLCBuID0gZi5zcGxpdChBYSk7IGYgPSBuW2JdOykge1xuICAgICAgICAgICAgICB2YXIgZSA9IGYuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgaWYgKDEgPT09IFEgJiYgKDY0IDwgZSAmJiA5MCA+IGUgfHwgOTYgPCBlICYmIDEyMyA+IGUgfHwgOTUgPT09IGUgfHwgNDUgPT09IGUgJiYgNDUgIT09IGYuY2hhckNvZGVBdCgxKSkpIHN3aXRjaCAoaXNOYU4ocGFyc2VGbG9hdChmKSkgKyAoLTEgIT09IGYuaW5kZXhPZihcIihcIikpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgc3dpdGNoIChmKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbmZpbml0ZVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYWx0ZXJuYXRlXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJiYWNrd2FyZHNcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJ1bm5pbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vcm1hbFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZm9yd2FyZHNcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvdGhcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm5vbmVcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxpbmVhclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZWFzZVwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZWFzZS1pblwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZWFzZS1vdXRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVhc2UtaW4tb3V0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwYXVzZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJldmVyc2VcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImFsdGVybmF0ZS1yZXZlcnNlXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbmhlcml0XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbml0aWFsXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1bnNldFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RlcC1zdGFydFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RlcC1lbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIGYgKz0gVDtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5bYisrXSA9IGY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGsgKz0gKDAgPT09IGMgPyBcIlwiIDogXCIsXCIpICsgbi5qb2luKFwiIFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgayA9IGQgKyBrICsgXCI7XCI7XG4gICAgICByZXR1cm4gMSA9PT0gdyB8fCAyID09PSB3ICYmIFUoaywgMSkgPyBcIi13ZWJraXQtXCIgKyBrICsgayA6IGs7XG4gICAgfVxuXG4gICAgaWYgKDAgPT09IHcgfHwgMiA9PT0gdyAmJiAhVShhLCAxKSkgcmV0dXJuIGE7XG5cbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgIGNhc2UgMTAxNTpcbiAgICAgICAgcmV0dXJuIDQ1ID09PSBhLmNoYXJDb2RlQXQoOSkgPyBcIi13ZWJraXQtXCIgKyBhICsgYSA6IGE7XG5cbiAgICAgIGNhc2UgOTUxOlxuICAgICAgICByZXR1cm4gMTE2ID09PSBhLmNoYXJDb2RlQXQoMykgPyBcIi13ZWJraXQtXCIgKyBhICsgYSA6IGE7XG5cbiAgICAgIGNhc2UgOTYzOlxuICAgICAgICByZXR1cm4gMTEwID09PSBhLmNoYXJDb2RlQXQoNSkgPyBcIi13ZWJraXQtXCIgKyBhICsgYSA6IGE7XG5cbiAgICAgIGNhc2UgMTAwOTpcbiAgICAgICAgaWYgKDEwMCAhPT0gYS5jaGFyQ29kZUF0KDQpKSBicmVhaztcblxuICAgICAgY2FzZSA5Njk6XG4gICAgICBjYXNlIDk0MjpcbiAgICAgICAgcmV0dXJuIFwiLXdlYmtpdC1cIiArIGEgKyBhO1xuXG4gICAgICBjYXNlIDk3ODpcbiAgICAgICAgcmV0dXJuIFwiLXdlYmtpdC1cIiArIGEgKyBcIi1tb3otXCIgKyBhICsgYTtcblxuICAgICAgY2FzZSAxMDE5OlxuICAgICAgY2FzZSA5ODM6XG4gICAgICAgIHJldHVybiBcIi13ZWJraXQtXCIgKyBhICsgXCItbW96LVwiICsgYSArIFwiLW1zLVwiICsgYSArIGE7XG5cbiAgICAgIGNhc2UgODgzOlxuICAgICAgICByZXR1cm4gNDUgPT09IGEuY2hhckNvZGVBdCg4KSA/IFwiLXdlYmtpdC1cIiArIGEgKyBhIDogYTtcblxuICAgICAgY2FzZSA5MzI6XG4gICAgICAgIGlmICg0NSA9PT0gYS5jaGFyQ29kZUF0KDQpKSBzd2l0Y2ggKGEuY2hhckNvZGVBdCg1KSkge1xuICAgICAgICAgIGNhc2UgMTAzOlxuICAgICAgICAgICAgcmV0dXJuIFwiLXdlYmtpdC1ib3gtXCIgKyBhLnJlcGxhY2UoXCItZ3Jvd1wiLCBcIlwiKSArIFwiLXdlYmtpdC1cIiArIGEgKyBcIi1tcy1cIiArIGEucmVwbGFjZShcImdyb3dcIiwgXCJwb3NpdGl2ZVwiKSArIGE7XG5cbiAgICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICAgIHJldHVybiBcIi13ZWJraXQtXCIgKyBhICsgXCItbXMtXCIgKyBhLnJlcGxhY2UoXCJzaHJpbmtcIiwgXCJuZWdhdGl2ZVwiKSArIGE7XG5cbiAgICAgICAgICBjYXNlIDk4OlxuICAgICAgICAgICAgcmV0dXJuIFwiLXdlYmtpdC1cIiArIGEgKyBcIi1tcy1cIiArIGEucmVwbGFjZShcImJhc2lzXCIsIFwicHJlZmVycmVkLXNpemVcIikgKyBhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIi13ZWJraXQtXCIgKyBhICsgXCItbXMtXCIgKyBhICsgYTtcblxuICAgICAgY2FzZSA5NjQ6XG4gICAgICAgIHJldHVybiBcIi13ZWJraXQtXCIgKyBhICsgXCItbXMtZmxleC1cIiArIGEgKyBhO1xuXG4gICAgICBjYXNlIDEwMjM6XG4gICAgICAgIGlmICg5OSAhPT0gYS5jaGFyQ29kZUF0KDgpKSBicmVhaztcbiAgICAgICAgYiA9IGEuc3Vic3RyaW5nKGEuaW5kZXhPZihcIjpcIiwgMTUpKS5yZXBsYWNlKFwiZmxleC1cIiwgXCJcIikucmVwbGFjZShcInNwYWNlLWJldHdlZW5cIiwgXCJqdXN0aWZ5XCIpO1xuICAgICAgICByZXR1cm4gXCItd2Via2l0LWJveC1wYWNrXCIgKyBiICsgXCItd2Via2l0LVwiICsgYSArIFwiLW1zLWZsZXgtcGFja1wiICsgYiArIGE7XG5cbiAgICAgIGNhc2UgMTAwNTpcbiAgICAgICAgcmV0dXJuIEJhLnRlc3QoYSkgPyBhLnJlcGxhY2UobmEsIFwiOi13ZWJraXQtXCIpICsgYS5yZXBsYWNlKG5hLCBcIjotbW96LVwiKSArIGEgOiBhO1xuXG4gICAgICBjYXNlIDFFMzpcbiAgICAgICAgYiA9IGEuc3Vic3RyaW5nKDEzKS50cmltKCk7XG4gICAgICAgIGwgPSBiLmluZGV4T2YoXCItXCIpICsgMTtcblxuICAgICAgICBzd2l0Y2ggKGIuY2hhckNvZGVBdCgwKSArIGIuY2hhckNvZGVBdChsKSkge1xuICAgICAgICAgIGNhc2UgMjI2OlxuICAgICAgICAgICAgYiA9IGEucmVwbGFjZShhYSwgXCJ0YlwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMzI6XG4gICAgICAgICAgICBiID0gYS5yZXBsYWNlKGFhLCBcInRiLXJsXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIyMDpcbiAgICAgICAgICAgIGIgPSBhLnJlcGxhY2UoYWEsIFwibHJcIik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcIi13ZWJraXQtXCIgKyBhICsgXCItbXMtXCIgKyBiICsgYTtcblxuICAgICAgY2FzZSAxMDE3OlxuICAgICAgICBpZiAoLTEgPT09IGEuaW5kZXhPZihcInN0aWNreVwiLCA5KSkgYnJlYWs7XG5cbiAgICAgIGNhc2UgOTc1OlxuICAgICAgICBsID0gKGEgPSBiKS5sZW5ndGggLSAxMDtcbiAgICAgICAgYiA9ICgzMyA9PT0gYS5jaGFyQ29kZUF0KGwpID8gYS5zdWJzdHJpbmcoMCwgbCkgOiBhKS5zdWJzdHJpbmcoYi5pbmRleE9mKFwiOlwiLCA3KSArIDEpLnRyaW0oKTtcblxuICAgICAgICBzd2l0Y2ggKGMgPSBiLmNoYXJDb2RlQXQoMCkgKyAoYi5jaGFyQ29kZUF0KDcpIHwgMCkpIHtcbiAgICAgICAgICBjYXNlIDIwMzpcbiAgICAgICAgICAgIGlmICgxMTEgPiBiLmNoYXJDb2RlQXQoOCkpIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgICBhID0gYS5yZXBsYWNlKGIsIFwiLXdlYmtpdC1cIiArIGIpICsgXCI7XCIgKyBhO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIwNzpcbiAgICAgICAgICBjYXNlIDEwMjpcbiAgICAgICAgICAgIGEgPSBhLnJlcGxhY2UoYiwgXCItd2Via2l0LVwiICsgKDEwMiA8IGMgPyBcImlubGluZS1cIiA6IFwiXCIpICsgXCJib3hcIikgKyBcIjtcIiArIGEucmVwbGFjZShiLCBcIi13ZWJraXQtXCIgKyBiKSArIFwiO1wiICsgYS5yZXBsYWNlKGIsIFwiLW1zLVwiICsgYiArIFwiYm94XCIpICsgXCI7XCIgKyBhO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGEgKyBcIjtcIjtcblxuICAgICAgY2FzZSA5Mzg6XG4gICAgICAgIGlmICg0NSA9PT0gYS5jaGFyQ29kZUF0KDUpKSBzd2l0Y2ggKGEuY2hhckNvZGVBdCg2KSkge1xuICAgICAgICAgIGNhc2UgMTA1OlxuICAgICAgICAgICAgcmV0dXJuIGIgPSBhLnJlcGxhY2UoXCItaXRlbXNcIiwgXCJcIiksIFwiLXdlYmtpdC1cIiArIGEgKyBcIi13ZWJraXQtYm94LVwiICsgYiArIFwiLW1zLWZsZXgtXCIgKyBiICsgYTtcblxuICAgICAgICAgIGNhc2UgMTE1OlxuICAgICAgICAgICAgcmV0dXJuIFwiLXdlYmtpdC1cIiArIGEgKyBcIi1tcy1mbGV4LWl0ZW0tXCIgKyBhLnJlcGxhY2UoQ2EsIFwiXCIpICsgYTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCItd2Via2l0LVwiICsgYSArIFwiLW1zLWZsZXgtbGluZS1wYWNrXCIgKyBhLnJlcGxhY2UoXCJhbGlnbi1jb250ZW50XCIsIFwiXCIpICsgYTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA5NTM6XG4gICAgICAgIGlmICgwIDwgKGwgPSBhLmluZGV4T2YoXCItY29udGVudFwiLCA5KSkgJiYgMTA5ID09PSBhLmNoYXJDb2RlQXQobCAtIDMpICYmIDQ1ICE9PSBhLmNoYXJDb2RlQXQobCAtIDQpKSByZXR1cm4gYiA9IGEuc3Vic3RyaW5nKGwgLSAzKSwgXCJ3aWR0aDotd2Via2l0LVwiICsgYiArIFwid2lkdGg6LW1vei1cIiArIGIgKyBcIndpZHRoOlwiICsgYjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgOTYyOlxuICAgICAgICBpZiAoYSA9IFwiLXdlYmtpdC1cIiArIGEgKyAoMTAyID09PSBhLmNoYXJDb2RlQXQoNSkgPyBcIi1tcy1cIiArIGEgOiBcIlwiKSArIGEsIDIxMSA9PT0gZCArIGsgJiYgMTA1ID09PSBhLmNoYXJDb2RlQXQoMTMpICYmIDAgPCBhLmluZGV4T2YoXCJ0cmFuc2Zvcm1cIiwgMTApKSByZXR1cm4gYS5zdWJzdHJpbmcoMCwgYS5pbmRleE9mKFwiO1wiLCAyNykgKyAxKS5yZXBsYWNlKERhLCBcIiQxLXdlYmtpdC0kMlwiKSArIGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH1cblxuICBmdW5jdGlvbiBVKGIsIGMpIHtcbiAgICB2YXIgZCA9IGIuaW5kZXhPZigxID09PSBjID8gXCI6XCIgOiBcIntcIiksXG4gICAgICAgIGsgPSBiLnN1YnN0cmluZygwLCAzICE9PSBjID8gZCA6IDEwKTtcbiAgICBkID0gYi5zdWJzdHJpbmcoZCArIDEsIGIubGVuZ3RoIC0gMSk7XG4gICAgcmV0dXJuIGJhKDIgIT09IGMgPyBrIDogay5yZXBsYWNlKEVhLCBcIiQxXCIpLCBkLCBjKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhKGIsIGMpIHtcbiAgICB2YXIgZCA9IGphKGMsIGMuY2hhckNvZGVBdCgwKSwgYy5jaGFyQ29kZUF0KDEpLCBjLmNoYXJDb2RlQXQoMikpO1xuICAgIHJldHVybiBkICE9PSBjICsgXCI7XCIgPyBkLnJlcGxhY2UoRmEsIFwiIG9yICgkMSlcIikuc3Vic3RyaW5nKDQpIDogXCIoXCIgKyBjICsgXCIpXCI7XG4gIH1cblxuICBmdW5jdGlvbiBPKGIsIGMsIGQsIGssIGwsIGEsIGYsIG4sIGUpIHtcbiAgICBmb3IgKHZhciBoID0gMCwgcSA9IGMsIG07IGggPCBFOyArK2gpIHtcbiAgICAgIHN3aXRjaCAobSA9IGNhW2hdLmNhbGwoRiwgYiwgcSwgZCwgaywgbCwgYSwgZiwgbiwgZSkpIHtcbiAgICAgICAgY2FzZSB2b2lkIDA6XG4gICAgICAgIGNhc2UgITE6XG4gICAgICAgIGNhc2UgITA6XG4gICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHEgPSBtO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAocSkge1xuICAgICAgY2FzZSB2b2lkIDA6XG4gICAgICBjYXNlICExOlxuICAgICAgY2FzZSAhMDpcbiAgICAgIGNhc2UgbnVsbDpcbiAgICAgIGNhc2UgYzpcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBxO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRhKGIpIHtcbiAgICBzd2l0Y2ggKGIpIHtcbiAgICAgIGNhc2Ugdm9pZCAwOlxuICAgICAgY2FzZSBudWxsOlxuICAgICAgICBFID0gY2EubGVuZ3RoID0gMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN3aXRjaCAoYi5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgIGNhc2UgQXJyYXk6XG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMCwgZCA9IGIubGVuZ3RoOyBjIDwgZDsgKytjKSB7XG4gICAgICAgICAgICAgIGRhKGJbY10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgRnVuY3Rpb246XG4gICAgICAgICAgICBjYVtFKytdID0gYjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICAgICAgbGEgPSAhIWIgfCAwO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZGE7XG4gIH1cblxuICBmdW5jdGlvbiBlYShiKSB7XG4gICAgZm9yICh2YXIgYyBpbiBiKSB7XG4gICAgICB2YXIgZCA9IGJbY107XG5cbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIFwia2V5ZnJhbWVcIjpcbiAgICAgICAgICBRID0gZCB8IDA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcImdsb2JhbFwiOlxuICAgICAgICAgIFkgPSBkIHwgMDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiY2FzY2FkZVwiOlxuICAgICAgICAgIHogPSBkIHwgMDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiY29tcHJlc3NcIjpcbiAgICAgICAgICBvYSA9IGQgfCAwO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJzZW1pY29sb25cIjpcbiAgICAgICAgICBrYSA9IGQgfCAwO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJwcmVzZXJ2ZVwiOlxuICAgICAgICAgIFggPSBkIHwgMDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwicHJlZml4XCI6XG4gICAgICAgICAgYmEgPSBudWxsLCBkID8gXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgZCA/IHcgPSAxIDogKHcgPSAyLCBiYSA9IGQpIDogdyA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVhO1xuICB9XG5cbiAgZnVuY3Rpb24gRihiLCBjKSB7XG4gICAgaWYgKHZvaWQgMCAhPT0gdGhpcyAmJiB0aGlzLmNvbnN0cnVjdG9yID09PSBGKSByZXR1cm4gZmEoYik7XG4gICAgdmFyIGQgPSBiLFxuICAgICAgICBrID0gZC5jaGFyQ29kZUF0KDApO1xuICAgIDMzID4gayAmJiAoayA9IChkID0gZC50cmltKCkpLmNoYXJDb2RlQXQoMCkpO1xuICAgIDAgPCBRICYmIChUID0gZC5yZXBsYWNlKEdhLCA5MSA9PT0gayA/IFwiXCIgOiBcIi1cIikpO1xuICAgIGsgPSAxO1xuICAgIDEgPT09IHogPyBSID0gZCA6IEsgPSBkO1xuICAgIGQgPSBbUl07XG5cbiAgICBpZiAoMCA8IEUpIHtcbiAgICAgIHZhciBsID0gTygtMSwgYywgZCwgZCwgSSwgeSwgMCwgMCwgMCk7XG4gICAgICB2b2lkIDAgIT09IGwgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGwgJiYgKGMgPSBsKTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IFYoVywgZCwgYywgMCwgMCk7XG4gICAgMCA8IEUgJiYgKGwgPSBPKC0yLCBhLCBkLCBkLCBJLCB5LCBhLmxlbmd0aCwgMCwgMCksIHZvaWQgMCAhPT0gbCAmJiBcInN0cmluZ1wiICE9PSB0eXBlb2YgKGEgPSBsKSAmJiAoayA9IDApKTtcbiAgICBLID0gUiA9IFQgPSBcIlwiO1xuICAgIEogPSAwO1xuICAgIHkgPSBJID0gMTtcbiAgICByZXR1cm4gMCA9PT0gb2EgKiBrID8gYSA6IGEucmVwbGFjZShQLCBcIlwiKS5yZXBsYWNlKEhhLCBcIlwiKS5yZXBsYWNlKElhLCBcIiQxXCIpLnJlcGxhY2UoSmEsIFwiJDFcIikucmVwbGFjZShLYSwgXCIgXCIpO1xuICB9XG5cbiAgdmFyIHFhID0gL15cXDArL2csXG4gICAgICBQID0gL1tcXDBcXHJcXGZdL2csXG4gICAgICBuYSA9IC86ICovZyxcbiAgICAgIEJhID0gL3pvb3xncmEvLFxuICAgICAgRGEgPSAvKFssOiBdKSh0cmFuc2Zvcm0pL2csXG4gICAgICB6YSA9IC8sK1xccyooPyFbXihdKlspXSkvZyxcbiAgICAgIEFhID0gLyArXFxzKig/IVteKF0qWyldKS9nLFxuICAgICAgdWEgPSAvICpbXFwwXSAqL2csXG4gICAgICB4YSA9IC8sXFxyKz8vZyxcbiAgICAgIE0gPSAvKFtcXHRcXHJcXG4gXSkqXFxmPyYvZyxcbiAgICAgIHlhID0gLzpnbG9iYWxcXCgoKD86W15cXChcXClcXFtcXF1dKnxcXFsuKlxcXXxcXChbXlxcKFxcKV0qXFwpKSopXFwpL2csXG4gICAgICBHYSA9IC9cXFcrL2csXG4gICAgICB0YSA9IC9AKGtcXHcrKVxccyooXFxTKilcXHMqLyxcbiAgICAgIFogPSAvOjoocGxhY2UpL2csXG4gICAgICB3YSA9IC86KHJlYWQtb25seSkvZyxcbiAgICAgIEhhID0gL1xccysoPz1be1xcXTs9Oj5dKS9nLFxuICAgICAgSWEgPSAvKFtbfT06Pl0pXFxzKy9nLFxuICAgICAgSmEgPSAvKFxce1tee10rPyk7KD89XFx9KS9nLFxuICAgICAgS2EgPSAvXFxzezIsfS9nLFxuICAgICAgdmEgPSAvKFteXFwoXSkoOispICovZyxcbiAgICAgIGFhID0gL1tzdmhdXFx3Ky1bdGJscl17Mn0vLFxuICAgICAgcmEgPSAvXFwoXFxzKiguKilcXHMqXFwpL2csXG4gICAgICBGYSA9IC8oW15dKj8pOy9nLFxuICAgICAgQ2EgPSAvLXNlbGZ8ZmxleC0vZyxcbiAgICAgIEVhID0gL1teXSo/KDpbcnBdW2VsXWFbXFx3LV0rKVteXSovLFxuICAgICAgeSA9IDEsXG4gICAgICBJID0gMSxcbiAgICAgIEogPSAwLFxuICAgICAgeiA9IDEsXG4gICAgICB3ID0gMSxcbiAgICAgIFkgPSAxLFxuICAgICAgb2EgPSAwLFxuICAgICAga2EgPSAwLFxuICAgICAgWCA9IDAsXG4gICAgICBXID0gW10sXG4gICAgICBjYSA9IFtdLFxuICAgICAgRSA9IDAsXG4gICAgICBiYSA9IG51bGwsXG4gICAgICBsYSA9IDAsXG4gICAgICBRID0gMSxcbiAgICAgIFQgPSBcIlwiLFxuICAgICAgSyA9IFwiXCIsXG4gICAgICBSID0gXCJcIjtcbiAgRi51c2UgPSBkYTtcbiAgRi5zZXQgPSBlYTtcbiAgdm9pZCAwICE9PSBoYSAmJiBlYShoYSk7XG4gIHJldHVybiBGO1xufTtcblxuLy8gIHdlYWtcbmZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgaWYgKGNhY2hlW2FyZ10gPT09IHVuZGVmaW5lZCkgY2FjaGVbYXJnXSA9IGZuKGFyZyk7XG4gICAgcmV0dXJuIGNhY2hlW2FyZ107XG4gIH07XG59XG52YXIgU1RZTEVTX0tFWSA9ICdfX2Vtb3Rpb25fc3R5bGVzJztcbnZhciBUQVJHRVRfS0VZID0gJ19fZW1vdGlvbl90YXJnZXQnO1xudmFyIHVuaXRsZXNzID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogMSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IDEsXG4gIGJvcmRlckltYWdlU2xpY2U6IDEsXG4gIGJvcmRlckltYWdlV2lkdGg6IDEsXG4gIGJveEZsZXg6IDEsXG4gIGJveEZsZXhHcm91cDogMSxcbiAgYm94T3JkaW5hbEdyb3VwOiAxLFxuICBjb2x1bW5Db3VudDogMSxcbiAgY29sdW1uczogMSxcbiAgZmxleDogMSxcbiAgZmxleEdyb3c6IDEsXG4gIGZsZXhQb3NpdGl2ZTogMSxcbiAgZmxleFNocmluazogMSxcbiAgZmxleE5lZ2F0aXZlOiAxLFxuICBmbGV4T3JkZXI6IDEsXG4gIGdyaWRSb3c6IDEsXG4gIGdyaWRSb3dFbmQ6IDEsXG4gIGdyaWRSb3dTcGFuOiAxLFxuICBncmlkUm93U3RhcnQ6IDEsXG4gIGdyaWRDb2x1bW46IDEsXG4gIGdyaWRDb2x1bW5FbmQ6IDEsXG4gIGdyaWRDb2x1bW5TcGFuOiAxLFxuICBncmlkQ29sdW1uU3RhcnQ6IDEsXG4gIGZvbnRXZWlnaHQ6IDEsXG4gIGxpbmVDbGFtcDogMSxcbiAgbGluZUhlaWdodDogMSxcbiAgb3BhY2l0eTogMSxcbiAgb3JkZXI6IDEsXG4gIG9ycGhhbnM6IDEsXG4gIHRhYlNpemU6IDEsXG4gIHdpZG93czogMSxcbiAgekluZGV4OiAxLFxuICB6b29tOiAxLFxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiAxLFxuICBmbG9vZE9wYWNpdHk6IDEsXG4gIHN0b3BPcGFjaXR5OiAxLFxuICBzdHJva2VEYXNoYXJyYXk6IDEsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IDEsXG4gIHN0cm9rZU1pdGVybGltaXQ6IDEsXG4gIHN0cm9rZU9wYWNpdHk6IDEsXG4gIHN0cm9rZVdpZHRoOiAxXG59O1xuXG5leHBvcnQgeyBtZW1vaXplLCBTVFlMRVNfS0VZLCBUQVJHRVRfS0VZLCB1bml0bGVzcywgaGFzaFN0cmluZywgcGEgYXMgU3R5bGlzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Vtb3Rpb24tdXRpbHMvZGlzdC9pbmRleC5lcy5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///18\n");

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"l\", function() { return sheet; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"m\", function() { return useStylisPlugin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"k\", function() { return registered; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"h\", function() { return inserted; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return css; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"i\", function() { return keyframes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"g\", function() { return injectGlobal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return fontFace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return getRegisteredStyles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"j\", function() { return merge; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return cx; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return hydrate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return flush; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_emotion_utils__ = __webpack_require__(18);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_stylis_rule_sheet__ = __webpack_require__(33);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_stylis_rule_sheet___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_stylis_rule_sheet__);\n\n\n\n/*\n\nhigh performance StyleSheet for css-in-js systems\n\n- uses multiple style tags behind the scenes for millions of rules\n- uses `insertRule` for appending in production for *much* faster performance\n- 'polyfills' on server side\n\n// usage\n\nimport StyleSheet from 'glamor/lib/sheet'\nlet styleSheet = new StyleSheet()\n\nstyleSheet.inject()\n- 'injects' the stylesheet into the page (or into memory if on server)\n\nstyleSheet.insert('#box { border: 1px solid red; }')\n- appends a css rule into the stylesheet\n\nstyleSheet.flush()\n- empties the stylesheet of all its contents\n\n*/\nfunction sheetForTag(tag) {\n  if (tag.sheet) {\n    return tag.sheet;\n  } // this weirdness brought to you by firefox\n\n\n  for (var i = 0; i < document.styleSheets.length; i++) {\n    if (document.styleSheets[i].ownerNode === tag) {\n      return document.styleSheets[i];\n    }\n  }\n}\n\nfunction makeStyleTag() {\n  var tag = document.createElement('style');\n  tag.type = 'text/css';\n  tag.setAttribute('data-emotion', '');\n  tag.appendChild(document.createTextNode(''));\n  document.head.appendChild(tag);\n  return tag;\n}\n\nvar StyleSheet =\n/*#__PURE__*/\nfunction () {\n  function StyleSheet() {\n    this.isBrowser = typeof window !== 'undefined';\n    this.isSpeedy = \"development\" === 'production'; // the big drawback here is that the css won't be editable in devtools\n\n    this.tags = [];\n    this.ctr = 0;\n  }\n\n  var _proto = StyleSheet.prototype;\n\n  _proto.inject = function inject() {\n    if (this.injected) {\n      throw new Error('already injected!');\n    }\n\n    if (this.isBrowser) {\n      this.tags[0] = makeStyleTag();\n    } else {\n      // server side 'polyfill'. just enough behavior to be useful.\n      this.sheet = [];\n    }\n\n    this.injected = true;\n  };\n\n  _proto.speedy = function speedy(bool) {\n    if (this.ctr !== 0) {\n      // cannot change speedy mode after inserting any rule to sheet. Either call speedy(${bool}) earlier in your app, or call flush() before speedy(${bool})\n      throw new Error(\"cannot change speedy now\");\n    }\n\n    this.isSpeedy = !!bool;\n  };\n\n  _proto.insert = function insert(rule, sourceMap) {\n    if (this.isBrowser) {\n      // this is the ultrafast version, works across browsers\n      if (this.isSpeedy) {\n        var tag = this.tags[this.tags.length - 1];\n        var sheet = sheetForTag(tag);\n\n        try {\n          sheet.insertRule(rule, sheet.cssRules.length);\n        } catch (e) {\n          if (true) {\n            console.warn('illegal rule', rule); // eslint-disable-line no-console\n          }\n        }\n      } else {\n        var _tag = makeStyleTag();\n\n        this.tags.push(_tag);\n\n        _tag.appendChild(document.createTextNode(rule + (sourceMap || '')));\n      }\n\n      this.ctr++;\n\n      if (this.ctr % 65000 === 0) {\n        this.tags.push(makeStyleTag());\n      }\n    } else {\n      // enough 'spec compliance' to be able to extract the rules later\n      // in other words, just the rule\n      this.sheet.push(rule);\n    }\n  };\n\n  _proto.flush = function flush() {\n    if (this.isBrowser) {\n      this.tags.forEach(function (tag) {\n        return tag.parentNode.removeChild(tag);\n      });\n      this.tags = [];\n      this.ctr = 0; // todo - look for remnants in document.styleSheets\n    } else {\n      // simpler on server\n      this.sheet = [];\n    }\n\n    this.injected = false;\n  };\n\n  return StyleSheet;\n}();\n\nvar sheet = new StyleSheet(); // \n\nsheet.inject();\nvar stylisOptions = {\n  keyframe: false\n};\n\nif (true) {\n  stylisOptions.compress = false;\n}\n\nvar stylis = new __WEBPACK_IMPORTED_MODULE_0_emotion_utils__[\"b\" /* Stylis */](stylisOptions);\nvar externalStylisPlugins = [];\nvar use = stylis.use;\n\nfunction insertRule(rule) {\n  sheet.insert(rule, currentSourceMap);\n}\n\nvar insertionPlugin = __WEBPACK_IMPORTED_MODULE_1_stylis_rule_sheet___default()(insertRule);\nvar useStylisPlugin = function useStylisPlugin(plugin) {\n  externalStylisPlugins.push(plugin);\n  use(null)(externalStylisPlugins)(insertionPlugin);\n};\nvar registered = {};\nvar inserted = {};\nvar currentSourceMap = '';\nstylis.use(insertionPlugin);\n\nfunction handleInterpolation(interpolation, couldBeSelectorInterpolation) {\n  if (interpolation == null) {\n    return '';\n  }\n\n  switch (typeof interpolation) {\n    case 'boolean':\n      return '';\n\n    case 'function':\n      if (interpolation[__WEBPACK_IMPORTED_MODULE_0_emotion_utils__[\"a\" /* STYLES_KEY */]] !== undefined) {\n        if (\"development\" !== 'production' && interpolation[__WEBPACK_IMPORTED_MODULE_0_emotion_utils__[\"c\" /* TARGET_KEY */]] === undefined) {\n          throw new Error('Component selectors can only be used in conjunction with babel-plugin-emotion.');\n        }\n\n        return \".\" + interpolation[__WEBPACK_IMPORTED_MODULE_0_emotion_utils__[\"c\" /* TARGET_KEY */]];\n      }\n\n      return handleInterpolation.call(this, this === undefined ? interpolation() : interpolation(this.mergedProps, this.context), couldBeSelectorInterpolation);\n\n    case 'object':\n      return createStringFromObject.call(this, interpolation);\n\n    default:\n      var cached = registered[interpolation];\n      return couldBeSelectorInterpolation === false && cached !== undefined ? cached : interpolation;\n  }\n}\n\nvar hyphenateRegex = /[A-Z]|^ms/g;\nvar processStyleName = Object(__WEBPACK_IMPORTED_MODULE_0_emotion_utils__[\"e\" /* memoize */])(function (styleName) {\n  return styleName.replace(hyphenateRegex, '-$&').toLowerCase();\n});\n\nvar processStyleValue = function processStyleValue(key, value) {\n  if (value === undefined || value === null || typeof value === 'boolean') return '';\n\n  if (__WEBPACK_IMPORTED_MODULE_0_emotion_utils__[\"f\" /* unitless */][key] !== 1 && key.charCodeAt(1) !== 45 && // custom properties\n  !isNaN(value) && value !== 0) {\n    return value + 'px';\n  }\n\n  return value;\n};\n\nvar objectToStringCache = new WeakMap();\n\nfunction createStringFromObject(obj) {\n  if (objectToStringCache.has(obj)) {\n    return objectToStringCache.get(obj);\n  }\n\n  var string = '';\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (interpolation) {\n      string += handleInterpolation.call(this, interpolation, false);\n    }, this);\n  } else {\n    Object.keys(obj).forEach(function (key) {\n      if (typeof obj[key] !== 'object') {\n        if (registered[obj[key]] !== undefined) {\n          string += key + \"{\" + registered[obj[key]] + \"}\";\n        } else {\n          string += processStyleName(key) + \":\" + processStyleValue(key, obj[key]) + \";\";\n        }\n      } else {\n        string += key + \"{\" + handleInterpolation.call(this, obj[key], false) + \"}\";\n      }\n    }, this);\n  }\n\n  objectToStringCache.set(obj, string);\n  return string;\n}\n\nfunction isLastCharDot(string) {\n  return string.charCodeAt(string.length - 1) === 46; // .\n}\n\nvar hash;\nvar name;\nvar labelPattern = /label:\\s*([^\\s;\\n]+)\\s*[;\\n]/g;\n\nfunction createStyles(strings) {\n  var stringMode = true;\n  var styles = '';\n  var identifierName = '';\n\n  if (strings == null || strings.raw === undefined) {\n    stringMode = false;\n    styles = handleInterpolation.call(this, strings, false);\n  } else {\n    styles = strings[0];\n  }\n\n  for (var _len = arguments.length, interpolations = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    interpolations[_key - 1] = arguments[_key];\n  }\n\n  interpolations.forEach(function (interpolation, i) {\n    styles += handleInterpolation.call(this, interpolation, isLastCharDot(styles));\n\n    if (stringMode === true && strings[i + 1] !== undefined) {\n      styles += strings[i + 1];\n    }\n  }, this);\n  styles = styles.replace(labelPattern, function (match, p1) {\n    identifierName += \"-\" + p1;\n    return '';\n  });\n  hash = Object(__WEBPACK_IMPORTED_MODULE_0_emotion_utils__[\"d\" /* hashString */])(styles + identifierName);\n  name = hash + identifierName;\n  return styles;\n}\n\nif (true) {\n  var sourceMapRegEx = /\\/\\*#\\ssourceMappingURL=data:application\\/json;\\S+\\s+\\*\\//;\n  var oldStylis = stylis;\n\n  stylis = function stylis(selector, styles) {\n    var result = sourceMapRegEx.exec(styles);\n    currentSourceMap = result ? result[0] : '';\n    oldStylis(selector, styles);\n    currentSourceMap = '';\n  };\n}\n\nfunction css() {\n  var styles = createStyles.apply(this, arguments);\n  var selector = \"css-\" + name;\n\n  if (registered[selector] === undefined) {\n    registered[selector] = styles;\n  }\n\n  if (inserted[hash] === undefined) {\n    stylis(\".\" + selector, styles);\n    inserted[hash] = true;\n  }\n\n  return selector;\n}\nfunction keyframes() {\n  var styles = createStyles.apply(this, arguments);\n  var animation = \"animation-\" + name;\n\n  if (inserted[hash] === undefined) {\n    stylis('', \"@keyframes \" + animation + \"{\" + styles + \"}\");\n    inserted[hash] = true;\n  }\n\n  return animation;\n}\nfunction injectGlobal() {\n  var styles = createStyles.apply(this, arguments);\n\n  if (inserted[hash] === undefined) {\n    stylis('', styles);\n    inserted[hash] = true;\n  }\n}\nfunction fontFace() {\n  var styles = createStyles.apply(void 0, arguments);\n\n  if (inserted[hash] === undefined) {\n    stylis('', \"@font-face{\" + styles + \"}\");\n    inserted[hash] = true;\n  }\n}\nfunction getRegisteredStyles(registeredStyles, classNames) {\n  var rawClassName = '';\n  classNames.split(' ').forEach(function (className) {\n    if (registered[className] !== undefined) {\n      registeredStyles.push(className);\n    } else {\n      rawClassName += className + \" \";\n    }\n  });\n  return rawClassName;\n}\nfunction merge(className, sourceMap) {\n  var registeredStyles = [];\n  var rawClassName = getRegisteredStyles(registeredStyles, className);\n\n  if (registeredStyles.length < 2) {\n    return className;\n  }\n\n  return rawClassName + css(registeredStyles, sourceMap);\n}\n\nfunction classnames() {\n  var len = arguments.length;\n  var i = 0;\n  var cls = '';\n\n  for (; i < len; i++) {\n    var arg = arguments[i];\n    if (arg == null) continue;\n    var next = cls && cls + ' ' || cls;\n\n    switch (typeof arg) {\n      case 'boolean':\n        break;\n\n      case 'function':\n        cls = next + classnames(arg());\n        break;\n\n      case 'object':\n        {\n          if (Array.isArray(arg)) {\n            cls = next + classnames.apply(null, arg);\n          } else {\n            for (var k in arg) {\n              if (arg[k]) {\n                cls && (cls += ' ');\n                cls += k;\n              }\n            }\n          }\n\n          break;\n        }\n\n      default:\n        {\n          cls = next + arg;\n        }\n    }\n  }\n\n  return cls;\n}\n\nfunction cx() {\n  return merge(classnames.apply(void 0, arguments));\n}\nfunction hydrate(ids) {\n  ids.forEach(function (id) {\n    inserted[id] = true;\n  });\n}\nfunction flush() {\n  sheet.flush();\n  inserted = {};\n  registered = {};\n  sheet.inject();\n}\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW1vdGlvbi9kaXN0L2luZGV4LmVzLmpzPzkwNWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU1RZTEVTX0tFWSwgU3R5bGlzLCBUQVJHRVRfS0VZLCBoYXNoU3RyaW5nLCBtZW1vaXplLCB1bml0bGVzcyB9IGZyb20gJ2Vtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHN0eWxpc1J1bGVTaGVldCBmcm9tICdzdHlsaXMtcnVsZS1zaGVldCc7XG5cbi8qXG5cbmhpZ2ggcGVyZm9ybWFuY2UgU3R5bGVTaGVldCBmb3IgY3NzLWluLWpzIHN5c3RlbXNcblxuLSB1c2VzIG11bHRpcGxlIHN0eWxlIHRhZ3MgYmVoaW5kIHRoZSBzY2VuZXMgZm9yIG1pbGxpb25zIG9mIHJ1bGVzXG4tIHVzZXMgYGluc2VydFJ1bGVgIGZvciBhcHBlbmRpbmcgaW4gcHJvZHVjdGlvbiBmb3IgKm11Y2gqIGZhc3RlciBwZXJmb3JtYW5jZVxuLSAncG9seWZpbGxzJyBvbiBzZXJ2ZXIgc2lkZVxuXG4vLyB1c2FnZVxuXG5pbXBvcnQgU3R5bGVTaGVldCBmcm9tICdnbGFtb3IvbGliL3NoZWV0J1xubGV0IHN0eWxlU2hlZXQgPSBuZXcgU3R5bGVTaGVldCgpXG5cbnN0eWxlU2hlZXQuaW5qZWN0KClcbi0gJ2luamVjdHMnIHRoZSBzdHlsZXNoZWV0IGludG8gdGhlIHBhZ2UgKG9yIGludG8gbWVtb3J5IGlmIG9uIHNlcnZlcilcblxuc3R5bGVTaGVldC5pbnNlcnQoJyNib3ggeyBib3JkZXI6IDFweCBzb2xpZCByZWQ7IH0nKVxuLSBhcHBlbmRzIGEgY3NzIHJ1bGUgaW50byB0aGUgc3R5bGVzaGVldFxuXG5zdHlsZVNoZWV0LmZsdXNoKClcbi0gZW1wdGllcyB0aGUgc3R5bGVzaGVldCBvZiBhbGwgaXRzIGNvbnRlbnRzXG5cbiovXG5mdW5jdGlvbiBzaGVldEZvclRhZyh0YWcpIHtcbiAgaWYgKHRhZy5zaGVldCkge1xuICAgIHJldHVybiB0YWcuc2hlZXQ7XG4gIH0gLy8gdGhpcyB3ZWlyZG5lc3MgYnJvdWdodCB0byB5b3UgYnkgZmlyZWZveFxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2N1bWVudC5zdHlsZVNoZWV0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChkb2N1bWVudC5zdHlsZVNoZWV0c1tpXS5vd25lck5vZGUgPT09IHRhZykge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlU3R5bGVUYWcoKSB7XG4gIHZhciB0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICB0YWcudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gIHRhZy5zZXRBdHRyaWJ1dGUoJ2RhdGEtZW1vdGlvbicsICcnKTtcbiAgdGFnLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKSk7XG4gIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodGFnKTtcbiAgcmV0dXJuIHRhZztcbn1cblxudmFyIFN0eWxlU2hlZXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHlsZVNoZWV0KCkge1xuICAgIHRoaXMuaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgdGhpcy5pc1NwZWVkeSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbic7IC8vIHRoZSBiaWcgZHJhd2JhY2sgaGVyZSBpcyB0aGF0IHRoZSBjc3Mgd29uJ3QgYmUgZWRpdGFibGUgaW4gZGV2dG9vbHNcblxuICAgIHRoaXMudGFncyA9IFtdO1xuICAgIHRoaXMuY3RyID0gMDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTdHlsZVNoZWV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW5qZWN0ID0gZnVuY3Rpb24gaW5qZWN0KCkge1xuICAgIGlmICh0aGlzLmluamVjdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscmVhZHkgaW5qZWN0ZWQhJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNCcm93c2VyKSB7XG4gICAgICB0aGlzLnRhZ3NbMF0gPSBtYWtlU3R5bGVUYWcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2VydmVyIHNpZGUgJ3BvbHlmaWxsJy4ganVzdCBlbm91Z2ggYmVoYXZpb3IgdG8gYmUgdXNlZnVsLlxuICAgICAgdGhpcy5zaGVldCA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuaW5qZWN0ZWQgPSB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5zcGVlZHkgPSBmdW5jdGlvbiBzcGVlZHkoYm9vbCkge1xuICAgIGlmICh0aGlzLmN0ciAhPT0gMCkge1xuICAgICAgLy8gY2Fubm90IGNoYW5nZSBzcGVlZHkgbW9kZSBhZnRlciBpbnNlcnRpbmcgYW55IHJ1bGUgdG8gc2hlZXQuIEVpdGhlciBjYWxsIHNwZWVkeSgke2Jvb2x9KSBlYXJsaWVyIGluIHlvdXIgYXBwLCBvciBjYWxsIGZsdXNoKCkgYmVmb3JlIHNwZWVkeSgke2Jvb2x9KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNoYW5nZSBzcGVlZHkgbm93XCIpO1xuICAgIH1cblxuICAgIHRoaXMuaXNTcGVlZHkgPSAhIWJvb2w7XG4gIH07XG5cbiAgX3Byb3RvLmluc2VydCA9IGZ1bmN0aW9uIGluc2VydChydWxlLCBzb3VyY2VNYXApIHtcbiAgICBpZiAodGhpcy5pc0Jyb3dzZXIpIHtcbiAgICAgIC8vIHRoaXMgaXMgdGhlIHVsdHJhZmFzdCB2ZXJzaW9uLCB3b3JrcyBhY3Jvc3MgYnJvd3NlcnNcbiAgICAgIGlmICh0aGlzLmlzU3BlZWR5KSB7XG4gICAgICAgIHZhciB0YWcgPSB0aGlzLnRhZ3NbdGhpcy50YWdzLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgc2hlZXQgPSBzaGVldEZvclRhZyh0YWcpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShydWxlLCBzaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignaWxsZWdhbCBydWxlJywgcnVsZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF90YWcgPSBtYWtlU3R5bGVUYWcoKTtcblxuICAgICAgICB0aGlzLnRhZ3MucHVzaChfdGFnKTtcblxuICAgICAgICBfdGFnLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJ1bGUgKyAoc291cmNlTWFwIHx8ICcnKSkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN0cisrO1xuXG4gICAgICBpZiAodGhpcy5jdHIgJSA2NTAwMCA9PT0gMCkge1xuICAgICAgICB0aGlzLnRhZ3MucHVzaChtYWtlU3R5bGVUYWcoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVub3VnaCAnc3BlYyBjb21wbGlhbmNlJyB0byBiZSBhYmxlIHRvIGV4dHJhY3QgdGhlIHJ1bGVzIGxhdGVyXG4gICAgICAvLyBpbiBvdGhlciB3b3JkcywganVzdCB0aGUgcnVsZVxuICAgICAgdGhpcy5zaGVldC5wdXNoKHJ1bGUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICBpZiAodGhpcy5pc0Jyb3dzZXIpIHtcbiAgICAgIHRoaXMudGFncy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgcmV0dXJuIHRhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRhZyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudGFncyA9IFtdO1xuICAgICAgdGhpcy5jdHIgPSAwOyAvLyB0b2RvIC0gbG9vayBmb3IgcmVtbmFudHMgaW4gZG9jdW1lbnQuc3R5bGVTaGVldHNcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2ltcGxlciBvbiBzZXJ2ZXJcbiAgICAgIHRoaXMuc2hlZXQgPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLmluamVjdGVkID0gZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCk7XG5cbnZhciBzaGVldCA9IG5ldyBTdHlsZVNoZWV0KCk7IC8vIPCfmoBcblxuc2hlZXQuaW5qZWN0KCk7XG52YXIgc3R5bGlzT3B0aW9ucyA9IHtcbiAga2V5ZnJhbWU6IGZhbHNlXG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHlsaXNPcHRpb25zLmNvbXByZXNzID0gZmFsc2U7XG59XG5cbnZhciBzdHlsaXMgPSBuZXcgU3R5bGlzKHN0eWxpc09wdGlvbnMpO1xudmFyIGV4dGVybmFsU3R5bGlzUGx1Z2lucyA9IFtdO1xudmFyIHVzZSA9IHN0eWxpcy51c2U7XG5cbmZ1bmN0aW9uIGluc2VydFJ1bGUocnVsZSkge1xuICBzaGVldC5pbnNlcnQocnVsZSwgY3VycmVudFNvdXJjZU1hcCk7XG59XG5cbnZhciBpbnNlcnRpb25QbHVnaW4gPSBzdHlsaXNSdWxlU2hlZXQoaW5zZXJ0UnVsZSk7XG52YXIgdXNlU3R5bGlzUGx1Z2luID0gZnVuY3Rpb24gdXNlU3R5bGlzUGx1Z2luKHBsdWdpbikge1xuICBleHRlcm5hbFN0eWxpc1BsdWdpbnMucHVzaChwbHVnaW4pO1xuICB1c2UobnVsbCkoZXh0ZXJuYWxTdHlsaXNQbHVnaW5zKShpbnNlcnRpb25QbHVnaW4pO1xufTtcbnZhciByZWdpc3RlcmVkID0ge307XG52YXIgaW5zZXJ0ZWQgPSB7fTtcbnZhciBjdXJyZW50U291cmNlTWFwID0gJyc7XG5zdHlsaXMudXNlKGluc2VydGlvblBsdWdpbik7XG5cbmZ1bmN0aW9uIGhhbmRsZUludGVycG9sYXRpb24oaW50ZXJwb2xhdGlvbiwgY291bGRCZVNlbGVjdG9ySW50ZXJwb2xhdGlvbikge1xuICBpZiAoaW50ZXJwb2xhdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlb2YgaW50ZXJwb2xhdGlvbikge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuICcnO1xuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgaWYgKGludGVycG9sYXRpb25bU1RZTEVTX0tFWV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpbnRlcnBvbGF0aW9uW1RBUkdFVF9LRVldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCBzZWxlY3RvcnMgY2FuIG9ubHkgYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGJhYmVsLXBsdWdpbi1lbW90aW9uLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwiLlwiICsgaW50ZXJwb2xhdGlvbltUQVJHRVRfS0VZXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhhbmRsZUludGVycG9sYXRpb24uY2FsbCh0aGlzLCB0aGlzID09PSB1bmRlZmluZWQgPyBpbnRlcnBvbGF0aW9uKCkgOiBpbnRlcnBvbGF0aW9uKHRoaXMubWVyZ2VkUHJvcHMsIHRoaXMuY29udGV4dCksIGNvdWxkQmVTZWxlY3RvckludGVycG9sYXRpb24pO1xuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJldHVybiBjcmVhdGVTdHJpbmdGcm9tT2JqZWN0LmNhbGwodGhpcywgaW50ZXJwb2xhdGlvbik7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGNhY2hlZCA9IHJlZ2lzdGVyZWRbaW50ZXJwb2xhdGlvbl07XG4gICAgICByZXR1cm4gY291bGRCZVNlbGVjdG9ySW50ZXJwb2xhdGlvbiA9PT0gZmFsc2UgJiYgY2FjaGVkICE9PSB1bmRlZmluZWQgPyBjYWNoZWQgOiBpbnRlcnBvbGF0aW9uO1xuICB9XG59XG5cbnZhciBoeXBoZW5hdGVSZWdleCA9IC9bQS1aXXxebXMvZztcbnZhciBwcm9jZXNzU3R5bGVOYW1lID0gbWVtb2l6ZShmdW5jdGlvbiAoc3R5bGVOYW1lKSB7XG4gIHJldHVybiBzdHlsZU5hbWUucmVwbGFjZShoeXBoZW5hdGVSZWdleCwgJy0kJicpLnRvTG93ZXJDYXNlKCk7XG59KTtcblxudmFyIHByb2Nlc3NTdHlsZVZhbHVlID0gZnVuY3Rpb24gcHJvY2Vzc1N0eWxlVmFsdWUoa2V5LCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykgcmV0dXJuICcnO1xuXG4gIGlmICh1bml0bGVzc1trZXldICE9PSAxICYmIGtleS5jaGFyQ29kZUF0KDEpICE9PSA0NSAmJiAvLyBjdXN0b20gcHJvcGVydGllc1xuICAhaXNOYU4odmFsdWUpICYmIHZhbHVlICE9PSAwKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JztcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBvYmplY3RUb1N0cmluZ0NhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuZnVuY3Rpb24gY3JlYXRlU3RyaW5nRnJvbU9iamVjdChvYmopIHtcbiAgaWYgKG9iamVjdFRvU3RyaW5nQ2FjaGUuaGFzKG9iaikpIHtcbiAgICByZXR1cm4gb2JqZWN0VG9TdHJpbmdDYWNoZS5nZXQob2JqKTtcbiAgfVxuXG4gIHZhciBzdHJpbmcgPSAnJztcblxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgb2JqLmZvckVhY2goZnVuY3Rpb24gKGludGVycG9sYXRpb24pIHtcbiAgICAgIHN0cmluZyArPSBoYW5kbGVJbnRlcnBvbGF0aW9uLmNhbGwodGhpcywgaW50ZXJwb2xhdGlvbiwgZmFsc2UpO1xuICAgIH0sIHRoaXMpO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAodHlwZW9mIG9ialtrZXldICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocmVnaXN0ZXJlZFtvYmpba2V5XV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHN0cmluZyArPSBrZXkgKyBcIntcIiArIHJlZ2lzdGVyZWRbb2JqW2tleV1dICsgXCJ9XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyaW5nICs9IHByb2Nlc3NTdHlsZU5hbWUoa2V5KSArIFwiOlwiICsgcHJvY2Vzc1N0eWxlVmFsdWUoa2V5LCBvYmpba2V5XSkgKyBcIjtcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyaW5nICs9IGtleSArIFwie1wiICsgaGFuZGxlSW50ZXJwb2xhdGlvbi5jYWxsKHRoaXMsIG9ialtrZXldLCBmYWxzZSkgKyBcIn1cIjtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfVxuXG4gIG9iamVjdFRvU3RyaW5nQ2FjaGUuc2V0KG9iaiwgc3RyaW5nKTtcbiAgcmV0dXJuIHN0cmluZztcbn1cblxuZnVuY3Rpb24gaXNMYXN0Q2hhckRvdChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5jaGFyQ29kZUF0KHN0cmluZy5sZW5ndGggLSAxKSA9PT0gNDY7IC8vIC5cbn1cblxudmFyIGhhc2g7XG52YXIgbmFtZTtcbnZhciBsYWJlbFBhdHRlcm4gPSAvbGFiZWw6XFxzKihbXlxccztcXG5dKylcXHMqWztcXG5dL2c7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlcyhzdHJpbmdzKSB7XG4gIHZhciBzdHJpbmdNb2RlID0gdHJ1ZTtcbiAgdmFyIHN0eWxlcyA9ICcnO1xuICB2YXIgaWRlbnRpZmllck5hbWUgPSAnJztcblxuICBpZiAoc3RyaW5ncyA9PSBudWxsIHx8IHN0cmluZ3MucmF3ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHJpbmdNb2RlID0gZmFsc2U7XG4gICAgc3R5bGVzID0gaGFuZGxlSW50ZXJwb2xhdGlvbi5jYWxsKHRoaXMsIHN0cmluZ3MsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZXMgPSBzdHJpbmdzWzBdO1xuICB9XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGludGVycG9sYXRpb25zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBpbnRlcnBvbGF0aW9uc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpbnRlcnBvbGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcnBvbGF0aW9uLCBpKSB7XG4gICAgc3R5bGVzICs9IGhhbmRsZUludGVycG9sYXRpb24uY2FsbCh0aGlzLCBpbnRlcnBvbGF0aW9uLCBpc0xhc3RDaGFyRG90KHN0eWxlcykpO1xuXG4gICAgaWYgKHN0cmluZ01vZGUgPT09IHRydWUgJiYgc3RyaW5nc1tpICsgMV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3R5bGVzICs9IHN0cmluZ3NbaSArIDFdO1xuICAgIH1cbiAgfSwgdGhpcyk7XG4gIHN0eWxlcyA9IHN0eWxlcy5yZXBsYWNlKGxhYmVsUGF0dGVybiwgZnVuY3Rpb24gKG1hdGNoLCBwMSkge1xuICAgIGlkZW50aWZpZXJOYW1lICs9IFwiLVwiICsgcDE7XG4gICAgcmV0dXJuICcnO1xuICB9KTtcbiAgaGFzaCA9IGhhc2hTdHJpbmcoc3R5bGVzICsgaWRlbnRpZmllck5hbWUpO1xuICBuYW1lID0gaGFzaCArIGlkZW50aWZpZXJOYW1lO1xuICByZXR1cm4gc3R5bGVzO1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgc291cmNlTWFwUmVnRXggPSAvXFwvXFwqI1xcc3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvblxcL2pzb247XFxTK1xccytcXCpcXC8vO1xuICB2YXIgb2xkU3R5bGlzID0gc3R5bGlzO1xuXG4gIHN0eWxpcyA9IGZ1bmN0aW9uIHN0eWxpcyhzZWxlY3Rvciwgc3R5bGVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHNvdXJjZU1hcFJlZ0V4LmV4ZWMoc3R5bGVzKTtcbiAgICBjdXJyZW50U291cmNlTWFwID0gcmVzdWx0ID8gcmVzdWx0WzBdIDogJyc7XG4gICAgb2xkU3R5bGlzKHNlbGVjdG9yLCBzdHlsZXMpO1xuICAgIGN1cnJlbnRTb3VyY2VNYXAgPSAnJztcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3NzKCkge1xuICB2YXIgc3R5bGVzID0gY3JlYXRlU3R5bGVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHZhciBzZWxlY3RvciA9IFwiY3NzLVwiICsgbmFtZTtcblxuICBpZiAocmVnaXN0ZXJlZFtzZWxlY3Rvcl0gPT09IHVuZGVmaW5lZCkge1xuICAgIHJlZ2lzdGVyZWRbc2VsZWN0b3JdID0gc3R5bGVzO1xuICB9XG5cbiAgaWYgKGluc2VydGVkW2hhc2hdID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHlsaXMoXCIuXCIgKyBzZWxlY3Rvciwgc3R5bGVzKTtcbiAgICBpbnNlcnRlZFtoYXNoXSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gc2VsZWN0b3I7XG59XG5mdW5jdGlvbiBrZXlmcmFtZXMoKSB7XG4gIHZhciBzdHlsZXMgPSBjcmVhdGVTdHlsZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdmFyIGFuaW1hdGlvbiA9IFwiYW5pbWF0aW9uLVwiICsgbmFtZTtcblxuICBpZiAoaW5zZXJ0ZWRbaGFzaF0gPT09IHVuZGVmaW5lZCkge1xuICAgIHN0eWxpcygnJywgXCJAa2V5ZnJhbWVzIFwiICsgYW5pbWF0aW9uICsgXCJ7XCIgKyBzdHlsZXMgKyBcIn1cIik7XG4gICAgaW5zZXJ0ZWRbaGFzaF0gPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn1cbmZ1bmN0aW9uIGluamVjdEdsb2JhbCgpIHtcbiAgdmFyIHN0eWxlcyA9IGNyZWF0ZVN0eWxlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmIChpbnNlcnRlZFtoYXNoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3R5bGlzKCcnLCBzdHlsZXMpO1xuICAgIGluc2VydGVkW2hhc2hdID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gZm9udEZhY2UoKSB7XG4gIHZhciBzdHlsZXMgPSBjcmVhdGVTdHlsZXMuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuXG4gIGlmIChpbnNlcnRlZFtoYXNoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3R5bGlzKCcnLCBcIkBmb250LWZhY2V7XCIgKyBzdHlsZXMgKyBcIn1cIik7XG4gICAgaW5zZXJ0ZWRbaGFzaF0gPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZWdpc3RlcmVkU3R5bGVzKHJlZ2lzdGVyZWRTdHlsZXMsIGNsYXNzTmFtZXMpIHtcbiAgdmFyIHJhd0NsYXNzTmFtZSA9ICcnO1xuICBjbGFzc05hbWVzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgaWYgKHJlZ2lzdGVyZWRbY2xhc3NOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZWdpc3RlcmVkU3R5bGVzLnB1c2goY2xhc3NOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmF3Q2xhc3NOYW1lICs9IGNsYXNzTmFtZSArIFwiIFwiO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByYXdDbGFzc05hbWU7XG59XG5mdW5jdGlvbiBtZXJnZShjbGFzc05hbWUsIHNvdXJjZU1hcCkge1xuICB2YXIgcmVnaXN0ZXJlZFN0eWxlcyA9IFtdO1xuICB2YXIgcmF3Q2xhc3NOYW1lID0gZ2V0UmVnaXN0ZXJlZFN0eWxlcyhyZWdpc3RlcmVkU3R5bGVzLCBjbGFzc05hbWUpO1xuXG4gIGlmIChyZWdpc3RlcmVkU3R5bGVzLmxlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9XG5cbiAgcmV0dXJuIHJhd0NsYXNzTmFtZSArIGNzcyhyZWdpc3RlcmVkU3R5bGVzLCBzb3VyY2VNYXApO1xufVxuXG5mdW5jdGlvbiBjbGFzc25hbWVzKCkge1xuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgY2xzID0gJyc7XG5cbiAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKGFyZyA9PSBudWxsKSBjb250aW51ZTtcbiAgICB2YXIgbmV4dCA9IGNscyAmJiBjbHMgKyAnICcgfHwgY2xzO1xuXG4gICAgc3dpdGNoICh0eXBlb2YgYXJnKSB7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgY2xzID0gbmV4dCArIGNsYXNzbmFtZXMoYXJnKCkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgIGNscyA9IG5leHQgKyBjbGFzc25hbWVzLmFwcGx5KG51bGwsIGFyZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gYXJnKSB7XG4gICAgICAgICAgICAgIGlmIChhcmdba10pIHtcbiAgICAgICAgICAgICAgICBjbHMgJiYgKGNscyArPSAnICcpO1xuICAgICAgICAgICAgICAgIGNscyArPSBrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGNscyA9IG5leHQgKyBhcmc7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xzO1xufVxuXG5mdW5jdGlvbiBjeCgpIHtcbiAgcmV0dXJuIG1lcmdlKGNsYXNzbmFtZXMuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpKTtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGUoaWRzKSB7XG4gIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIGluc2VydGVkW2lkXSA9IHRydWU7XG4gIH0pO1xufVxuZnVuY3Rpb24gZmx1c2goKSB7XG4gIHNoZWV0LmZsdXNoKCk7XG4gIGluc2VydGVkID0ge307XG4gIHJlZ2lzdGVyZWQgPSB7fTtcbiAgc2hlZXQuaW5qZWN0KCk7XG59XG5cbmV4cG9ydCB7IHNoZWV0LCB1c2VTdHlsaXNQbHVnaW4sIHJlZ2lzdGVyZWQsIGluc2VydGVkLCBjc3MsIGtleWZyYW1lcywgaW5qZWN0R2xvYmFsLCBmb250RmFjZSwgZ2V0UmVnaXN0ZXJlZFN0eWxlcywgbWVyZ2UsIGN4LCBoeWRyYXRlLCBmbHVzaCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9lbW90aW9uL2Rpc3QvaW5kZXguZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nfunction makeEmptyFunction(arg) {\n  return function () {\n    return arg;\n  };\n}\n\n/**\n * This function accepts and discards inputs; it has no side effects. This is\n * primarily useful idiomatically for overridable function endpoints which\n * always need to be callable, since JS lacks a null-call idiom ala Cocoa.\n */\nvar emptyFunction = function emptyFunction() {};\n\nemptyFunction.thatReturns = makeEmptyFunction;\nemptyFunction.thatReturnsFalse = makeEmptyFunction(false);\nemptyFunction.thatReturnsTrue = makeEmptyFunction(true);\nemptyFunction.thatReturnsNull = makeEmptyFunction(null);\nemptyFunction.thatReturnsThis = function () {\n  return this;\n};\nemptyFunction.thatReturnsArgument = function (arg) {\n  return arg;\n};\n\nmodule.exports = emptyFunction;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcz83YmFmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5RnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///20\n");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function validateFormat(format) {};\n\nif (true) {\n  validateFormat = function validateFormat(format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nmodule.exports = invariant;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzPzczMTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///21\n");

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\nvar emptyFunction = __webpack_require__(20);\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = emptyFunction;\n\nif (true) {\n  var printWarning = function printWarning(format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  warning = function warning(condition, format) {\n    if (format === undefined) {\n      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n\n    if (format.indexOf('Failed Composite propType: ') === 0) {\n      return; // Ignore CompositeComponent proptype check.\n    }\n\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcz82MzI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///22\n");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanM/ODJkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///23\n");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _preact = __webpack_require__(2);\n\nvar _randomcolor = __webpack_require__(25);\n\nvar _randomcolor2 = _interopRequireDefault(_randomcolor);\n\nvar _store = __webpack_require__(6);\n\nvar _actions = __webpack_require__(7);\n\nvar _actions2 = _interopRequireDefault(_actions);\n\nvar _api = __webpack_require__(8);\n\nvar _polished = __webpack_require__(17);\n\nvar P = _interopRequireWildcard(_polished);\n\nvar _components = __webpack_require__(31);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/***********  FUTURES DEMO  *************/\n\n// Why Futures      versus       promises?\n//     -------                   ---------\n//     lazy                      eager\n//     cancellable               not cancellable\n//     not cached                cached          (you may make Futures stateful by wrapping it in a caching helper)\n//     enforced error handling   optional error handling\n//     catch expected errors     catch all errors\n\n// look at api.js to see the Futures\n// To see the effection fo cancellation, comment out the this.cancel() code below\n// and checkout the network tab when clicking around\n\nvar App = function (_Component) {\n  _inherits(App, _Component);\n\n  function App() {\n    _classCallCheck(this, App);\n\n    return _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));\n  }\n\n  _createClass(App, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.props.getBreeds();\n      this.loadImages = this.loadImages.bind(this);\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(_ref) {\n      var nextIndex = _ref.imagesIndex,\n          breeds = _ref.breeds;\n\n      if (nextIndex === null && breeds.length > 0) {\n        // default to 'a' in breeds list\n        this.props.setImagesIndex(0);\n      }\n      if (this.props.imagesIndex !== nextIndex) {\n        // load new images\n        // In case there is an unresolved Future, cancel\n        if (this.cancel) {\n          this.cancel();\n          this.props.setLoading(false);\n        }\n        this.loadImages(nextIndex);\n      }\n    }\n  }, {\n    key: \"loadImages\",\n    value: function loadImages(nextIndex) {\n      var _this2 = this;\n\n      this.props.setLoading(true);\n      var breeds = this.props.breeds;\n\n      var ids = breeds[nextIndex];\n      // future executed when fork is called\n      this.cancel = (0, _api.getImagesConcurrently)(ids).fork(\n      // rejection branch\n      function (err) {\n        console.log(err);\n        _this2.props.setLoading(false);\n      },\n      // success branch\n      function (res) {\n        _this2.props.setImages(res);\n        _this2.props.setLoading(false);\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(_ref2) {\n      var letters = _ref2.letters,\n          color = _ref2.color,\n          imagesIndex = _ref2.imagesIndex,\n          toggleColor = _ref2.toggleColor,\n          getImages = _ref2.getImages,\n          decrementIndex = _ref2.decrementIndex,\n          incrementIndex = _ref2.incrementIndex,\n          setImagesIndex = _ref2.setImagesIndex,\n          images = _ref2.images,\n          breeds = _ref2.breeds,\n          loading = _ref2.loading;\n\n      // Change background so we see each rerender\n      var superColor = (0, _randomcolor2.default)({ luminosity: \"light\" });\n      return (0, _preact.h)(\n        \"div\",\n        { style: { backgroundColor: P.lighten(0.1, superColor), height: '180vh', padding: '10px' } },\n        (0, _preact.h)(\n          _components.Nav,\n          null,\n          letters.map(function (letter, i) {\n            return (0, _preact.h)(\n              _components.LetterButton,\n              {\n                key: i,\n                \"data-images-index\": i,\n                color: superColor,\n                onClick: function onClick(e) {\n                  return setImagesIndex(Number(e.target.getAttribute(\"data-images-index\")));\n                },\n                active: i === imagesIndex\n              },\n              letter\n            );\n          })\n        ),\n        (0, _preact.h)(\n          _components.ArrowButtons,\n          null,\n          (0, _preact.h)(\n            _components.Arrow,\n            { onClick: decrementIndex },\n            \"\\u2190\"\n          ),\n          (0, _preact.h)(\n            _components.Arrow,\n            { onClick: incrementIndex },\n            \"\\u2192\"\n          )\n        ),\n        (0, _preact.h)(\n          _components.Main,\n          null,\n          !loading ? images.map(function (src, i) {\n            return (0, _preact.h)(_components.Pic, { src: src, key: src, name: breeds[imagesIndex][i] });\n          }) : (0, _preact.h)(_components.LoadingSpinner, { color: superColor })\n        ),\n        (0, _preact.h)(_components.SourceLink, { color: superColor })\n      );\n    }\n  }]);\n\n  return App;\n}(_preact.Component);\n\nexports.default = (0, _store.connect)(\"imagesIndex,letters,images,breeds,loading\", _actions2.default)(App);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL0FwcC5qcz8xNGIxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGgsIENvbXBvbmVudCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCByYW5kb21Db2xvciBmcm9tIFwicmFuZG9tY29sb3JcIjtcbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tIFwiLi9zdG9yZVwiO1xuaW1wb3J0IGFjdGlvbnMgZnJvbSBcIi4vYWN0aW9uc1wiO1xuaW1wb3J0IHsgZ2V0QnJlZWRzLCBnZXRJbWFnZXMsIGdldEltYWdlc0NvbmN1cnJlbnRseSB9IGZyb20gXCIuL2FwaVwiO1xuaW1wb3J0ICogYXMgUCBmcm9tIFwicG9saXNoZWRcIjtcbmltcG9ydCB7XG4gIExldHRlckJ1dHRvbixcbiAgTmF2LFxuICBBcnJvd0J1dHRvbnMsXG4gIEFycm93LFxuICBNYWluLFxuICBQaWMsXG4gIExvYWRpbmdTcGlubmVyLFxuICBTb3VyY2VMaW5rXG59IGZyb20gXCIuL2NvbXBvbmVudHNcIjtcblxuLyoqKioqKioqKioqICBGVVRVUkVTIERFTU8gICoqKioqKioqKioqKiovXG5cbi8vIFdoeSBGdXR1cmVzICAgICAgdmVyc3VzICAgICAgIHByb21pc2VzP1xuLy8gICAgIC0tLS0tLS0gICAgICAgICAgICAgICAgICAgLS0tLS0tLS0tXG4vLyAgICAgbGF6eSAgICAgICAgICAgICAgICAgICAgICBlYWdlclxuLy8gICAgIGNhbmNlbGxhYmxlICAgICAgICAgICAgICAgbm90IGNhbmNlbGxhYmxlXG4vLyAgICAgbm90IGNhY2hlZCAgICAgICAgICAgICAgICBjYWNoZWQgICAgICAgICAgKHlvdSBtYXkgbWFrZSBGdXR1cmVzIHN0YXRlZnVsIGJ5IHdyYXBwaW5nIGl0IGluIGEgY2FjaGluZyBoZWxwZXIpXG4vLyAgICAgZW5mb3JjZWQgZXJyb3IgaGFuZGxpbmcgICBvcHRpb25hbCBlcnJvciBoYW5kbGluZ1xuLy8gICAgIGNhdGNoIGV4cGVjdGVkIGVycm9ycyAgICAgY2F0Y2ggYWxsIGVycm9yc1xuXG4vLyBsb29rIGF0IGFwaS5qcyB0byBzZWUgdGhlIEZ1dHVyZXNcbi8vIFRvIHNlZSB0aGUgZWZmZWN0aW9uIGZvIGNhbmNlbGxhdGlvbiwgY29tbWVudCBvdXQgdGhlIHRoaXMuY2FuY2VsKCkgY29kZSBiZWxvd1xuLy8gYW5kIGNoZWNrb3V0IHRoZSBuZXR3b3JrIHRhYiB3aGVuIGNsaWNraW5nIGFyb3VuZFxuXG5jbGFzcyBBcHAgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnByb3BzLmdldEJyZWVkcygpO1xuICAgIHRoaXMubG9hZEltYWdlcyA9IHRoaXMubG9hZEltYWdlcy5iaW5kKHRoaXMpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh7IGltYWdlc0luZGV4OiBuZXh0SW5kZXgsIGJyZWVkcyB9KSB7XG4gICAgaWYgKG5leHRJbmRleCA9PT0gbnVsbCAmJiBicmVlZHMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gZGVmYXVsdCB0byAnYScgaW4gYnJlZWRzIGxpc3RcbiAgICAgIHRoaXMucHJvcHMuc2V0SW1hZ2VzSW5kZXgoMCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BzLmltYWdlc0luZGV4ICE9PSBuZXh0SW5kZXgpIHtcbiAgICAgIC8vIGxvYWQgbmV3IGltYWdlc1xuICAgICAgLy8gSW4gY2FzZSB0aGVyZSBpcyBhbiB1bnJlc29sdmVkIEZ1dHVyZSwgY2FuY2VsXG4gICAgICBpZiAodGhpcy5jYW5jZWwpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKVxuICAgICAgICB0aGlzLnByb3BzLnNldExvYWRpbmcoZmFsc2UpXG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRJbWFnZXMobmV4dEluZGV4KTtcbiAgICB9XG4gIH1cblxuICBsb2FkSW1hZ2VzKG5leHRJbmRleCkge1xuICAgIHRoaXMucHJvcHMuc2V0TG9hZGluZyh0cnVlKVxuICAgIGNvbnN0IHsgYnJlZWRzIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGlkcyA9IGJyZWVkc1tuZXh0SW5kZXhdO1xuICAgIC8vIGZ1dHVyZSBleGVjdXRlZCB3aGVuIGZvcmsgaXMgY2FsbGVkXG4gICAgdGhpcy5jYW5jZWwgPSBnZXRJbWFnZXNDb25jdXJyZW50bHkoaWRzKS5mb3JrKFxuICAgICAgLy8gcmVqZWN0aW9uIGJyYW5jaFxuICAgICAgZXJyID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coZXJyKVxuICAgICAgICB0aGlzLnByb3BzLnNldExvYWRpbmcoZmFsc2UpXG4gICAgICB9LFxuICAgICAgLy8gc3VjY2VzcyBicmFuY2hcbiAgICAgIHJlcyA9PiB7XG4gICAgICAgIHRoaXMucHJvcHMuc2V0SW1hZ2VzKHJlcylcbiAgICAgICAgdGhpcy5wcm9wcy5zZXRMb2FkaW5nKGZhbHNlKVxuICAgICAgfSk7XG4gIH1cblxuICByZW5kZXIoe1xuICAgIGxldHRlcnMsXG4gICAgY29sb3IsXG4gICAgaW1hZ2VzSW5kZXgsXG4gICAgdG9nZ2xlQ29sb3IsXG4gICAgZ2V0SW1hZ2VzLFxuICAgIGRlY3JlbWVudEluZGV4LFxuICAgIGluY3JlbWVudEluZGV4LFxuICAgIHNldEltYWdlc0luZGV4LFxuICAgIGltYWdlcyxcbiAgICBicmVlZHMsXG4gICAgbG9hZGluZ1xuICB9KSB7XG4gICAgLy8gQ2hhbmdlIGJhY2tncm91bmQgc28gd2Ugc2VlIGVhY2ggcmVyZW5kZXJcbiAgICBjb25zdCBzdXBlckNvbG9yID0gcmFuZG9tQ29sb3IoeyBsdW1pbm9zaXR5OiBcImxpZ2h0XCIgfSk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgc3R5bGU9e3sgYmFja2dyb3VuZENvbG9yOiBQLmxpZ2h0ZW4oMC4xLCBzdXBlckNvbG9yKSwgaGVpZ2h0OiAnMTgwdmgnLCBwYWRkaW5nOiAnMTBweCcgfX0+XG4gICAgICAgIDxOYXY+XG4gICAgICAgICAge2xldHRlcnMubWFwKChsZXR0ZXIsIGkpID0+IChcbiAgICAgICAgICAgIDxMZXR0ZXJCdXR0b25cbiAgICAgICAgICAgICAga2V5PXtpfVxuICAgICAgICAgICAgICBkYXRhLWltYWdlcy1pbmRleD17aX1cbiAgICAgICAgICAgICAgY29sb3I9e3N1cGVyQ29sb3J9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9e2UgPT5cbiAgICAgICAgICAgICAgICBzZXRJbWFnZXNJbmRleChcbiAgICAgICAgICAgICAgICAgIE51bWJlcihlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWltYWdlcy1pbmRleFwiKSlcbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICBhY3RpdmU9e2kgPT09IGltYWdlc0luZGV4fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7bGV0dGVyfVxuICAgICAgICAgICAgPC9MZXR0ZXJCdXR0b24+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvTmF2PlxuICAgICAgICA8QXJyb3dCdXR0b25zPlxuICAgICAgICAgIDxBcnJvdyBvbkNsaWNrPXtkZWNyZW1lbnRJbmRleH0+JiM4NTkyOzwvQXJyb3c+XG4gICAgICAgICAgPEFycm93IG9uQ2xpY2s9e2luY3JlbWVudEluZGV4fT4mIzg1OTQ7PC9BcnJvdz5cbiAgICAgICAgPC9BcnJvd0J1dHRvbnM+XG4gICAgICAgIDxNYWluPlxuICAgICAgICAgIHshbG9hZGluZyA/IGltYWdlcy5tYXAoKHNyYywgaSkgPT4gKFxuICAgICAgICAgICAgPFBpYyBzcmM9e3NyY30ga2V5PXtzcmN9IG5hbWU9e2JyZWVkc1tpbWFnZXNJbmRleF1baV19IC8+XG4gICAgICAgICAgKSkgOiA8TG9hZGluZ1NwaW5uZXIgY29sb3I9e3N1cGVyQ29sb3J9IC8+fVxuICAgICAgICA8L01haW4+XG4gICAgICAgIDxTb3VyY2VMaW5rIGNvbG9yPXtzdXBlckNvbG9yfSAvPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjb25uZWN0KFwiaW1hZ2VzSW5kZXgsbGV0dGVycyxpbWFnZXMsYnJlZWRzLGxvYWRpbmdcIiwgYWN0aW9ucykoQXBwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvQXBwLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7QUFBQTtBQUNBO0FBQUE7QUFDQTs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBY0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFJQTtBQVJBO0FBVUE7QUFWQTtBQURBO0FBREE7QUFnQkE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFGQTtBQUlBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQURBO0FBS0E7QUExQkE7QUE2QkE7Ozs7OztBQUdBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///24\n");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {// randomColor by David Merfield under the CC0 license\n// https://github.com/davidmerfield/randomColor/\n\n;(function(root, factory) {\n\n  // Support CommonJS\n  if (true) {\n    var randomColor = factory();\n\n    // Support NodeJS & Component, which allow module.exports to be a function\n    if (typeof module === 'object' && module && module.exports) {\n      exports = module.exports = randomColor;\n    }\n\n    // Support CommonJS 1.1.1 spec\n    exports.randomColor = randomColor;\n\n  // Support AMD\n  } else if (typeof define === 'function' && define.amd) {\n    define([], factory);\n\n  // Support vanilla script loading\n  } else {\n    root.randomColor = factory();\n  }\n\n}(this, function() {\n\n  // Seed to get repeatable colors\n  var seed = null;\n\n  // Shared color dictionary\n  var colorDictionary = {};\n\n  // Populate the color dictionary\n  loadColorBounds();\n\n  var randomColor = function (options) {\n\n    options = options || {};\n\n    // Check if there is a seed and ensure it's an\n    // integer. Otherwise, reset the seed value.\n    if (options.seed !== undefined && options.seed !== null && options.seed === parseInt(options.seed, 10)) {\n      seed = options.seed;\n\n    // A string was passed as a seed\n    } else if (typeof options.seed === 'string') {\n      seed = stringToInteger(options.seed);\n\n    // Something was passed as a seed but it wasn't an integer or string\n    } else if (options.seed !== undefined && options.seed !== null) {\n      throw new TypeError('The seed value must be an integer or string');\n\n    // No seed, reset the value outside.\n    } else {\n      seed = null;\n    }\n\n    var H,S,B;\n\n    // Check if we need to generate multiple colors\n    if (options.count !== null && options.count !== undefined) {\n\n      var totalColors = options.count,\n          colors = [];\n\n      options.count = null;\n\n      while (totalColors > colors.length) {\n\n        // Since we're generating multiple colors,\n        // incremement the seed. Otherwise we'd just\n        // generate the same color each time...\n        if (seed && options.seed) options.seed += 1;\n\n        colors.push(randomColor(options));\n      }\n\n      options.count = totalColors;\n\n      return colors;\n    }\n\n    // First we pick a hue (H)\n    H = pickHue(options);\n\n    // Then use H to determine saturation (S)\n    S = pickSaturation(H, options);\n\n    // Then use S and H to determine brightness (B).\n    B = pickBrightness(H, S, options);\n\n    // Then we return the HSB color in the desired format\n    return setFormat([H,S,B], options);\n  };\n\n  function pickHue (options) {\n\n    var hueRange = getHueRange(options.hue),\n        hue = randomWithin(hueRange);\n\n    // Instead of storing red as two seperate ranges,\n    // we group them, using negative numbers\n    if (hue < 0) {hue = 360 + hue;}\n\n    return hue;\n\n  }\n\n  function pickSaturation (hue, options) {\n\n    if (options.hue === 'monochrome') {\n      return 0;\n    }\n\n    if (options.luminosity === 'random') {\n      return randomWithin([0,100]);\n    }\n\n    var saturationRange = getSaturationRange(hue);\n\n    var sMin = saturationRange[0],\n        sMax = saturationRange[1];\n\n    switch (options.luminosity) {\n\n      case 'bright':\n        sMin = 55;\n        break;\n\n      case 'dark':\n        sMin = sMax - 10;\n        break;\n\n      case 'light':\n        sMax = 55;\n        break;\n   }\n\n    return randomWithin([sMin, sMax]);\n\n  }\n\n  function pickBrightness (H, S, options) {\n\n    var bMin = getMinimumBrightness(H, S),\n        bMax = 100;\n\n    switch (options.luminosity) {\n\n      case 'dark':\n        bMax = bMin + 20;\n        break;\n\n      case 'light':\n        bMin = (bMax + bMin)/2;\n        break;\n\n      case 'random':\n        bMin = 0;\n        bMax = 100;\n        break;\n    }\n\n    return randomWithin([bMin, bMax]);\n  }\n\n  function setFormat (hsv, options) {\n\n    switch (options.format) {\n\n      case 'hsvArray':\n        return hsv;\n\n      case 'hslArray':\n        return HSVtoHSL(hsv);\n\n      case 'hsl':\n        var hsl = HSVtoHSL(hsv);\n        return 'hsl('+hsl[0]+', '+hsl[1]+'%, '+hsl[2]+'%)';\n\n      case 'hsla':\n        var hslColor = HSVtoHSL(hsv);\n        var alpha = options.alpha || Math.random();\n        return 'hsla('+hslColor[0]+', '+hslColor[1]+'%, '+hslColor[2]+'%, ' + alpha + ')';\n\n      case 'rgbArray':\n        return HSVtoRGB(hsv);\n\n      case 'rgb':\n        var rgb = HSVtoRGB(hsv);\n        return 'rgb(' + rgb.join(', ') + ')';\n\n      case 'rgba':\n        var rgbColor = HSVtoRGB(hsv);\n        var alpha = options.alpha || Math.random();\n        return 'rgba(' + rgbColor.join(', ') + ', ' + alpha + ')';\n\n      default:\n        return HSVtoHex(hsv);\n    }\n\n  }\n\n  function getMinimumBrightness(H, S) {\n\n    var lowerBounds = getColorInfo(H).lowerBounds;\n\n    for (var i = 0; i < lowerBounds.length - 1; i++) {\n\n      var s1 = lowerBounds[i][0],\n          v1 = lowerBounds[i][1];\n\n      var s2 = lowerBounds[i+1][0],\n          v2 = lowerBounds[i+1][1];\n\n      if (S >= s1 && S <= s2) {\n\n         var m = (v2 - v1)/(s2 - s1),\n             b = v1 - m*s1;\n\n         return m*S + b;\n      }\n\n    }\n\n    return 0;\n  }\n\n  function getHueRange (colorInput) {\n\n    if (typeof parseInt(colorInput) === 'number') {\n\n      var number = parseInt(colorInput);\n\n      if (number < 360 && number > 0) {\n        return [number, number];\n      }\n\n    }\n\n    if (typeof colorInput === 'string') {\n\n      if (colorDictionary[colorInput]) {\n        var color = colorDictionary[colorInput];\n        if (color.hueRange) {return color.hueRange;}\n      } else if (colorInput.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {\n        var hue = HexToHSB(colorInput)[0];\n        return [ hue, hue ];\n      }\n    }\n\n    return [0,360];\n\n  }\n\n  function getSaturationRange (hue) {\n    return getColorInfo(hue).saturationRange;\n  }\n\n  function getColorInfo (hue) {\n\n    // Maps red colors to make picking hue easier\n    if (hue >= 334 && hue <= 360) {\n      hue-= 360;\n    }\n\n    for (var colorName in colorDictionary) {\n       var color = colorDictionary[colorName];\n       if (color.hueRange &&\n           hue >= color.hueRange[0] &&\n           hue <= color.hueRange[1]) {\n          return colorDictionary[colorName];\n       }\n    } return 'Color not found';\n  }\n\n  function randomWithin (range) {\n    if (seed === null) {\n      return Math.floor(range[0] + Math.random()*(range[1] + 1 - range[0]));\n    } else {\n      //Seeded random algorithm from http://indiegamr.com/generate-repeatable-random-numbers-in-js/\n      var max = range[1] || 1;\n      var min = range[0] || 0;\n      seed = (seed * 9301 + 49297) % 233280;\n      var rnd = seed / 233280.0;\n      return Math.floor(min + rnd * (max - min));\n    }\n  }\n\n  function HSVtoHex (hsv){\n\n    var rgb = HSVtoRGB(hsv);\n\n    function componentToHex(c) {\n        var hex = c.toString(16);\n        return hex.length == 1 ? '0' + hex : hex;\n    }\n\n    var hex = '#' + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);\n\n    return hex;\n\n  }\n\n  function defineColor (name, hueRange, lowerBounds) {\n\n    var sMin = lowerBounds[0][0],\n        sMax = lowerBounds[lowerBounds.length - 1][0],\n\n        bMin = lowerBounds[lowerBounds.length - 1][1],\n        bMax = lowerBounds[0][1];\n\n    colorDictionary[name] = {\n      hueRange: hueRange,\n      lowerBounds: lowerBounds,\n      saturationRange: [sMin, sMax],\n      brightnessRange: [bMin, bMax]\n    };\n\n  }\n\n  function loadColorBounds () {\n\n    defineColor(\n      'monochrome',\n      null,\n      [[0,0],[100,0]]\n    );\n\n    defineColor(\n      'red',\n      [-26,18],\n      [[20,100],[30,92],[40,89],[50,85],[60,78],[70,70],[80,60],[90,55],[100,50]]\n    );\n\n    defineColor(\n      'orange',\n      [19,46],\n      [[20,100],[30,93],[40,88],[50,86],[60,85],[70,70],[100,70]]\n    );\n\n    defineColor(\n      'yellow',\n      [47,62],\n      [[25,100],[40,94],[50,89],[60,86],[70,84],[80,82],[90,80],[100,75]]\n    );\n\n    defineColor(\n      'green',\n      [63,178],\n      [[30,100],[40,90],[50,85],[60,81],[70,74],[80,64],[90,50],[100,40]]\n    );\n\n    defineColor(\n      'blue',\n      [179, 257],\n      [[20,100],[30,86],[40,80],[50,74],[60,60],[70,52],[80,44],[90,39],[100,35]]\n    );\n\n    defineColor(\n      'purple',\n      [258, 282],\n      [[20,100],[30,87],[40,79],[50,70],[60,65],[70,59],[80,52],[90,45],[100,42]]\n    );\n\n    defineColor(\n      'pink',\n      [283, 334],\n      [[20,100],[30,90],[40,86],[60,84],[80,80],[90,75],[100,73]]\n    );\n\n  }\n\n  function HSVtoRGB (hsv) {\n\n    // this doesn't work for the values of 0 and 360\n    // here's the hacky fix\n    var h = hsv[0];\n    if (h === 0) {h = 1;}\n    if (h === 360) {h = 359;}\n\n    // Rebase the h,s,v values\n    h = h/360;\n    var s = hsv[1]/100,\n        v = hsv[2]/100;\n\n    var h_i = Math.floor(h*6),\n      f = h * 6 - h_i,\n      p = v * (1 - s),\n      q = v * (1 - f*s),\n      t = v * (1 - (1 - f)*s),\n      r = 256,\n      g = 256,\n      b = 256;\n\n    switch(h_i) {\n      case 0: r = v; g = t; b = p;  break;\n      case 1: r = q; g = v; b = p;  break;\n      case 2: r = p; g = v; b = t;  break;\n      case 3: r = p; g = q; b = v;  break;\n      case 4: r = t; g = p; b = v;  break;\n      case 5: r = v; g = p; b = q;  break;\n    }\n\n    var result = [Math.floor(r*255), Math.floor(g*255), Math.floor(b*255)];\n    return result;\n  }\n\n  function HexToHSB (hex) {\n    hex = hex.replace(/^#/, '');\n    hex = hex.length === 3 ? hex.replace(/(.)/g, '$1$1') : hex;\n\n    var red = parseInt(hex.substr(0, 2), 16) / 255,\n          green = parseInt(hex.substr(2, 2), 16) / 255,\n          blue = parseInt(hex.substr(4, 2), 16) / 255;\n\n    var cMax = Math.max(red, green, blue),\n          delta = cMax - Math.min(red, green, blue),\n          saturation = cMax ? (delta / cMax) : 0;\n\n    switch (cMax) {\n      case red: return [ 60 * (((green - blue) / delta) % 6) || 0, saturation, cMax ];\n      case green: return [ 60 * (((blue - red) / delta) + 2) || 0, saturation, cMax ];\n      case blue: return [ 60 * (((red - green) / delta) + 4) || 0, saturation, cMax ];\n    }\n  }\n\n  function HSVtoHSL (hsv) {\n    var h = hsv[0],\n      s = hsv[1]/100,\n      v = hsv[2]/100,\n      k = (2-s)*v;\n\n    return [\n      h,\n      Math.round(s*v / (k<1 ? k : 2-k) * 10000) / 100,\n      k/2 * 100\n    ];\n  }\n\n  function stringToInteger (string) {\n    var total = 0\n    for (var i = 0; i !== string.length; i++) {\n      if (total >= Number.MAX_SAFE_INTEGER) break;\n      total += string.charCodeAt(i)\n    }\n    return total\n  }\n\n  return randomColor;\n}));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmFuZG9tY29sb3IvcmFuZG9tQ29sb3IuanM/NWIyNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByYW5kb21Db2xvciBieSBEYXZpZCBNZXJmaWVsZCB1bmRlciB0aGUgQ0MwIGxpY2Vuc2Vcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXZpZG1lcmZpZWxkL3JhbmRvbUNvbG9yL1xuXG47KGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblxuICAvLyBTdXBwb3J0IENvbW1vbkpTXG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmFuZG9tQ29sb3IgPSBmYWN0b3J5KCk7XG5cbiAgICAvLyBTdXBwb3J0IE5vZGVKUyAmIENvbXBvbmVudCwgd2hpY2ggYWxsb3cgbW9kdWxlLmV4cG9ydHMgdG8gYmUgYSBmdW5jdGlvblxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJhbmRvbUNvbG9yO1xuICAgIH1cblxuICAgIC8vIFN1cHBvcnQgQ29tbW9uSlMgMS4xLjEgc3BlY1xuICAgIGV4cG9ydHMucmFuZG9tQ29sb3IgPSByYW5kb21Db2xvcjtcblxuICAvLyBTdXBwb3J0IEFNRFxuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG5cbiAgLy8gU3VwcG9ydCB2YW5pbGxhIHNjcmlwdCBsb2FkaW5nXG4gIH0gZWxzZSB7XG4gICAgcm9vdC5yYW5kb21Db2xvciA9IGZhY3RvcnkoKTtcbiAgfVxuXG59KHRoaXMsIGZ1bmN0aW9uKCkge1xuXG4gIC8vIFNlZWQgdG8gZ2V0IHJlcGVhdGFibGUgY29sb3JzXG4gIHZhciBzZWVkID0gbnVsbDtcblxuICAvLyBTaGFyZWQgY29sb3IgZGljdGlvbmFyeVxuICB2YXIgY29sb3JEaWN0aW9uYXJ5ID0ge307XG5cbiAgLy8gUG9wdWxhdGUgdGhlIGNvbG9yIGRpY3Rpb25hcnlcbiAgbG9hZENvbG9yQm91bmRzKCk7XG5cbiAgdmFyIHJhbmRvbUNvbG9yID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgYSBzZWVkIGFuZCBlbnN1cmUgaXQncyBhblxuICAgIC8vIGludGVnZXIuIE90aGVyd2lzZSwgcmVzZXQgdGhlIHNlZWQgdmFsdWUuXG4gICAgaWYgKG9wdGlvbnMuc2VlZCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuc2VlZCAhPT0gbnVsbCAmJiBvcHRpb25zLnNlZWQgPT09IHBhcnNlSW50KG9wdGlvbnMuc2VlZCwgMTApKSB7XG4gICAgICBzZWVkID0gb3B0aW9ucy5zZWVkO1xuXG4gICAgLy8gQSBzdHJpbmcgd2FzIHBhc3NlZCBhcyBhIHNlZWRcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLnNlZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzZWVkID0gc3RyaW5nVG9JbnRlZ2VyKG9wdGlvbnMuc2VlZCk7XG5cbiAgICAvLyBTb21ldGhpbmcgd2FzIHBhc3NlZCBhcyBhIHNlZWQgYnV0IGl0IHdhc24ndCBhbiBpbnRlZ2VyIG9yIHN0cmluZ1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZWVkICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5zZWVkICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgc2VlZCB2YWx1ZSBtdXN0IGJlIGFuIGludGVnZXIgb3Igc3RyaW5nJyk7XG5cbiAgICAvLyBObyBzZWVkLCByZXNldCB0aGUgdmFsdWUgb3V0c2lkZS5cbiAgICB9IGVsc2Uge1xuICAgICAgc2VlZCA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIEgsUyxCO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBnZW5lcmF0ZSBtdWx0aXBsZSBjb2xvcnNcbiAgICBpZiAob3B0aW9ucy5jb3VudCAhPT0gbnVsbCAmJiBvcHRpb25zLmNvdW50ICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgdmFyIHRvdGFsQ29sb3JzID0gb3B0aW9ucy5jb3VudCxcbiAgICAgICAgICBjb2xvcnMgPSBbXTtcblxuICAgICAgb3B0aW9ucy5jb3VudCA9IG51bGw7XG5cbiAgICAgIHdoaWxlICh0b3RhbENvbG9ycyA+IGNvbG9ycy5sZW5ndGgpIHtcblxuICAgICAgICAvLyBTaW5jZSB3ZSdyZSBnZW5lcmF0aW5nIG11bHRpcGxlIGNvbG9ycyxcbiAgICAgICAgLy8gaW5jcmVtZW1lbnQgdGhlIHNlZWQuIE90aGVyd2lzZSB3ZSdkIGp1c3RcbiAgICAgICAgLy8gZ2VuZXJhdGUgdGhlIHNhbWUgY29sb3IgZWFjaCB0aW1lLi4uXG4gICAgICAgIGlmIChzZWVkICYmIG9wdGlvbnMuc2VlZCkgb3B0aW9ucy5zZWVkICs9IDE7XG5cbiAgICAgICAgY29sb3JzLnB1c2gocmFuZG9tQ29sb3Iob3B0aW9ucykpO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zLmNvdW50ID0gdG90YWxDb2xvcnM7XG5cbiAgICAgIHJldHVybiBjb2xvcnM7XG4gICAgfVxuXG4gICAgLy8gRmlyc3Qgd2UgcGljayBhIGh1ZSAoSClcbiAgICBIID0gcGlja0h1ZShvcHRpb25zKTtcblxuICAgIC8vIFRoZW4gdXNlIEggdG8gZGV0ZXJtaW5lIHNhdHVyYXRpb24gKFMpXG4gICAgUyA9IHBpY2tTYXR1cmF0aW9uKEgsIG9wdGlvbnMpO1xuXG4gICAgLy8gVGhlbiB1c2UgUyBhbmQgSCB0byBkZXRlcm1pbmUgYnJpZ2h0bmVzcyAoQikuXG4gICAgQiA9IHBpY2tCcmlnaHRuZXNzKEgsIFMsIG9wdGlvbnMpO1xuXG4gICAgLy8gVGhlbiB3ZSByZXR1cm4gdGhlIEhTQiBjb2xvciBpbiB0aGUgZGVzaXJlZCBmb3JtYXRcbiAgICByZXR1cm4gc2V0Rm9ybWF0KFtILFMsQl0sIG9wdGlvbnMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBpY2tIdWUgKG9wdGlvbnMpIHtcblxuICAgIHZhciBodWVSYW5nZSA9IGdldEh1ZVJhbmdlKG9wdGlvbnMuaHVlKSxcbiAgICAgICAgaHVlID0gcmFuZG9tV2l0aGluKGh1ZVJhbmdlKTtcblxuICAgIC8vIEluc3RlYWQgb2Ygc3RvcmluZyByZWQgYXMgdHdvIHNlcGVyYXRlIHJhbmdlcyxcbiAgICAvLyB3ZSBncm91cCB0aGVtLCB1c2luZyBuZWdhdGl2ZSBudW1iZXJzXG4gICAgaWYgKGh1ZSA8IDApIHtodWUgPSAzNjAgKyBodWU7fVxuXG4gICAgcmV0dXJuIGh1ZTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcGlja1NhdHVyYXRpb24gKGh1ZSwgb3B0aW9ucykge1xuXG4gICAgaWYgKG9wdGlvbnMuaHVlID09PSAnbW9ub2Nocm9tZScpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmx1bWlub3NpdHkgPT09ICdyYW5kb20nKSB7XG4gICAgICByZXR1cm4gcmFuZG9tV2l0aGluKFswLDEwMF0pO1xuICAgIH1cblxuICAgIHZhciBzYXR1cmF0aW9uUmFuZ2UgPSBnZXRTYXR1cmF0aW9uUmFuZ2UoaHVlKTtcblxuICAgIHZhciBzTWluID0gc2F0dXJhdGlvblJhbmdlWzBdLFxuICAgICAgICBzTWF4ID0gc2F0dXJhdGlvblJhbmdlWzFdO1xuXG4gICAgc3dpdGNoIChvcHRpb25zLmx1bWlub3NpdHkpIHtcblxuICAgICAgY2FzZSAnYnJpZ2h0JzpcbiAgICAgICAgc01pbiA9IDU1O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZGFyayc6XG4gICAgICAgIHNNaW4gPSBzTWF4IC0gMTA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdsaWdodCc6XG4gICAgICAgIHNNYXggPSA1NTtcbiAgICAgICAgYnJlYWs7XG4gICB9XG5cbiAgICByZXR1cm4gcmFuZG9tV2l0aGluKFtzTWluLCBzTWF4XSk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHBpY2tCcmlnaHRuZXNzIChILCBTLCBvcHRpb25zKSB7XG5cbiAgICB2YXIgYk1pbiA9IGdldE1pbmltdW1CcmlnaHRuZXNzKEgsIFMpLFxuICAgICAgICBiTWF4ID0gMTAwO1xuXG4gICAgc3dpdGNoIChvcHRpb25zLmx1bWlub3NpdHkpIHtcblxuICAgICAgY2FzZSAnZGFyayc6XG4gICAgICAgIGJNYXggPSBiTWluICsgMjA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdsaWdodCc6XG4gICAgICAgIGJNaW4gPSAoYk1heCArIGJNaW4pLzI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyYW5kb20nOlxuICAgICAgICBiTWluID0gMDtcbiAgICAgICAgYk1heCA9IDEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmRvbVdpdGhpbihbYk1pbiwgYk1heF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0Rm9ybWF0IChoc3YsIG9wdGlvbnMpIHtcblxuICAgIHN3aXRjaCAob3B0aW9ucy5mb3JtYXQpIHtcblxuICAgICAgY2FzZSAnaHN2QXJyYXknOlxuICAgICAgICByZXR1cm4gaHN2O1xuXG4gICAgICBjYXNlICdoc2xBcnJheSc6XG4gICAgICAgIHJldHVybiBIU1Z0b0hTTChoc3YpO1xuXG4gICAgICBjYXNlICdoc2wnOlxuICAgICAgICB2YXIgaHNsID0gSFNWdG9IU0woaHN2KTtcbiAgICAgICAgcmV0dXJuICdoc2woJytoc2xbMF0rJywgJytoc2xbMV0rJyUsICcraHNsWzJdKyclKSc7XG5cbiAgICAgIGNhc2UgJ2hzbGEnOlxuICAgICAgICB2YXIgaHNsQ29sb3IgPSBIU1Z0b0hTTChoc3YpO1xuICAgICAgICB2YXIgYWxwaGEgPSBvcHRpb25zLmFscGhhIHx8IE1hdGgucmFuZG9tKCk7XG4gICAgICAgIHJldHVybiAnaHNsYSgnK2hzbENvbG9yWzBdKycsICcraHNsQ29sb3JbMV0rJyUsICcraHNsQ29sb3JbMl0rJyUsICcgKyBhbHBoYSArICcpJztcblxuICAgICAgY2FzZSAncmdiQXJyYXknOlxuICAgICAgICByZXR1cm4gSFNWdG9SR0IoaHN2KTtcblxuICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgdmFyIHJnYiA9IEhTVnRvUkdCKGhzdik7XG4gICAgICAgIHJldHVybiAncmdiKCcgKyByZ2Iuam9pbignLCAnKSArICcpJztcblxuICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgIHZhciByZ2JDb2xvciA9IEhTVnRvUkdCKGhzdik7XG4gICAgICAgIHZhciBhbHBoYSA9IG9wdGlvbnMuYWxwaGEgfHwgTWF0aC5yYW5kb20oKTtcbiAgICAgICAgcmV0dXJuICdyZ2JhKCcgKyByZ2JDb2xvci5qb2luKCcsICcpICsgJywgJyArIGFscGhhICsgJyknO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gSFNWdG9IZXgoaHN2KTtcbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1pbmltdW1CcmlnaHRuZXNzKEgsIFMpIHtcblxuICAgIHZhciBsb3dlckJvdW5kcyA9IGdldENvbG9ySW5mbyhIKS5sb3dlckJvdW5kcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG93ZXJCb3VuZHMubGVuZ3RoIC0gMTsgaSsrKSB7XG5cbiAgICAgIHZhciBzMSA9IGxvd2VyQm91bmRzW2ldWzBdLFxuICAgICAgICAgIHYxID0gbG93ZXJCb3VuZHNbaV1bMV07XG5cbiAgICAgIHZhciBzMiA9IGxvd2VyQm91bmRzW2krMV1bMF0sXG4gICAgICAgICAgdjIgPSBsb3dlckJvdW5kc1tpKzFdWzFdO1xuXG4gICAgICBpZiAoUyA+PSBzMSAmJiBTIDw9IHMyKSB7XG5cbiAgICAgICAgIHZhciBtID0gKHYyIC0gdjEpLyhzMiAtIHMxKSxcbiAgICAgICAgICAgICBiID0gdjEgLSBtKnMxO1xuXG4gICAgICAgICByZXR1cm4gbSpTICsgYjtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SHVlUmFuZ2UgKGNvbG9ySW5wdXQpIHtcblxuICAgIGlmICh0eXBlb2YgcGFyc2VJbnQoY29sb3JJbnB1dCkgPT09ICdudW1iZXInKSB7XG5cbiAgICAgIHZhciBudW1iZXIgPSBwYXJzZUludChjb2xvcklucHV0KTtcblxuICAgICAgaWYgKG51bWJlciA8IDM2MCAmJiBudW1iZXIgPiAwKSB7XG4gICAgICAgIHJldHVybiBbbnVtYmVyLCBudW1iZXJdO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb2xvcklucHV0ID09PSAnc3RyaW5nJykge1xuXG4gICAgICBpZiAoY29sb3JEaWN0aW9uYXJ5W2NvbG9ySW5wdXRdKSB7XG4gICAgICAgIHZhciBjb2xvciA9IGNvbG9yRGljdGlvbmFyeVtjb2xvcklucHV0XTtcbiAgICAgICAgaWYgKGNvbG9yLmh1ZVJhbmdlKSB7cmV0dXJuIGNvbG9yLmh1ZVJhbmdlO31cbiAgICAgIH0gZWxzZSBpZiAoY29sb3JJbnB1dC5tYXRjaCgvXiM/KFswLTlBLUZdezN9fFswLTlBLUZdezZ9KSQvaSkpIHtcbiAgICAgICAgdmFyIGh1ZSA9IEhleFRvSFNCKGNvbG9ySW5wdXQpWzBdO1xuICAgICAgICByZXR1cm4gWyBodWUsIGh1ZSBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbMCwzNjBdO1xuXG4gIH1cblxuICBmdW5jdGlvbiBnZXRTYXR1cmF0aW9uUmFuZ2UgKGh1ZSkge1xuICAgIHJldHVybiBnZXRDb2xvckluZm8oaHVlKS5zYXR1cmF0aW9uUmFuZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb2xvckluZm8gKGh1ZSkge1xuXG4gICAgLy8gTWFwcyByZWQgY29sb3JzIHRvIG1ha2UgcGlja2luZyBodWUgZWFzaWVyXG4gICAgaWYgKGh1ZSA+PSAzMzQgJiYgaHVlIDw9IDM2MCkge1xuICAgICAgaHVlLT0gMzYwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGNvbG9yTmFtZSBpbiBjb2xvckRpY3Rpb25hcnkpIHtcbiAgICAgICB2YXIgY29sb3IgPSBjb2xvckRpY3Rpb25hcnlbY29sb3JOYW1lXTtcbiAgICAgICBpZiAoY29sb3IuaHVlUmFuZ2UgJiZcbiAgICAgICAgICAgaHVlID49IGNvbG9yLmh1ZVJhbmdlWzBdICYmXG4gICAgICAgICAgIGh1ZSA8PSBjb2xvci5odWVSYW5nZVsxXSkge1xuICAgICAgICAgIHJldHVybiBjb2xvckRpY3Rpb25hcnlbY29sb3JOYW1lXTtcbiAgICAgICB9XG4gICAgfSByZXR1cm4gJ0NvbG9yIG5vdCBmb3VuZCc7XG4gIH1cblxuICBmdW5jdGlvbiByYW5kb21XaXRoaW4gKHJhbmdlKSB7XG4gICAgaWYgKHNlZWQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKHJhbmdlWzBdICsgTWF0aC5yYW5kb20oKSoocmFuZ2VbMV0gKyAxIC0gcmFuZ2VbMF0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy9TZWVkZWQgcmFuZG9tIGFsZ29yaXRobSBmcm9tIGh0dHA6Ly9pbmRpZWdhbXIuY29tL2dlbmVyYXRlLXJlcGVhdGFibGUtcmFuZG9tLW51bWJlcnMtaW4tanMvXG4gICAgICB2YXIgbWF4ID0gcmFuZ2VbMV0gfHwgMTtcbiAgICAgIHZhciBtaW4gPSByYW5nZVswXSB8fCAwO1xuICAgICAgc2VlZCA9IChzZWVkICogOTMwMSArIDQ5Mjk3KSAlIDIzMzI4MDtcbiAgICAgIHZhciBybmQgPSBzZWVkIC8gMjMzMjgwLjA7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcihtaW4gKyBybmQgKiAobWF4IC0gbWluKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gSFNWdG9IZXggKGhzdil7XG5cbiAgICB2YXIgcmdiID0gSFNWdG9SR0IoaHN2KTtcblxuICAgIGZ1bmN0aW9uIGNvbXBvbmVudFRvSGV4KGMpIHtcbiAgICAgICAgdmFyIGhleCA9IGMudG9TdHJpbmcoMTYpO1xuICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PSAxID8gJzAnICsgaGV4IDogaGV4O1xuICAgIH1cblxuICAgIHZhciBoZXggPSAnIycgKyBjb21wb25lbnRUb0hleChyZ2JbMF0pICsgY29tcG9uZW50VG9IZXgocmdiWzFdKSArIGNvbXBvbmVudFRvSGV4KHJnYlsyXSk7XG5cbiAgICByZXR1cm4gaGV4O1xuXG4gIH1cblxuICBmdW5jdGlvbiBkZWZpbmVDb2xvciAobmFtZSwgaHVlUmFuZ2UsIGxvd2VyQm91bmRzKSB7XG5cbiAgICB2YXIgc01pbiA9IGxvd2VyQm91bmRzWzBdWzBdLFxuICAgICAgICBzTWF4ID0gbG93ZXJCb3VuZHNbbG93ZXJCb3VuZHMubGVuZ3RoIC0gMV1bMF0sXG5cbiAgICAgICAgYk1pbiA9IGxvd2VyQm91bmRzW2xvd2VyQm91bmRzLmxlbmd0aCAtIDFdWzFdLFxuICAgICAgICBiTWF4ID0gbG93ZXJCb3VuZHNbMF1bMV07XG5cbiAgICBjb2xvckRpY3Rpb25hcnlbbmFtZV0gPSB7XG4gICAgICBodWVSYW5nZTogaHVlUmFuZ2UsXG4gICAgICBsb3dlckJvdW5kczogbG93ZXJCb3VuZHMsXG4gICAgICBzYXR1cmF0aW9uUmFuZ2U6IFtzTWluLCBzTWF4XSxcbiAgICAgIGJyaWdodG5lc3NSYW5nZTogW2JNaW4sIGJNYXhdXG4gICAgfTtcblxuICB9XG5cbiAgZnVuY3Rpb24gbG9hZENvbG9yQm91bmRzICgpIHtcblxuICAgIGRlZmluZUNvbG9yKFxuICAgICAgJ21vbm9jaHJvbWUnLFxuICAgICAgbnVsbCxcbiAgICAgIFtbMCwwXSxbMTAwLDBdXVxuICAgICk7XG5cbiAgICBkZWZpbmVDb2xvcihcbiAgICAgICdyZWQnLFxuICAgICAgWy0yNiwxOF0sXG4gICAgICBbWzIwLDEwMF0sWzMwLDkyXSxbNDAsODldLFs1MCw4NV0sWzYwLDc4XSxbNzAsNzBdLFs4MCw2MF0sWzkwLDU1XSxbMTAwLDUwXV1cbiAgICApO1xuXG4gICAgZGVmaW5lQ29sb3IoXG4gICAgICAnb3JhbmdlJyxcbiAgICAgIFsxOSw0Nl0sXG4gICAgICBbWzIwLDEwMF0sWzMwLDkzXSxbNDAsODhdLFs1MCw4Nl0sWzYwLDg1XSxbNzAsNzBdLFsxMDAsNzBdXVxuICAgICk7XG5cbiAgICBkZWZpbmVDb2xvcihcbiAgICAgICd5ZWxsb3cnLFxuICAgICAgWzQ3LDYyXSxcbiAgICAgIFtbMjUsMTAwXSxbNDAsOTRdLFs1MCw4OV0sWzYwLDg2XSxbNzAsODRdLFs4MCw4Ml0sWzkwLDgwXSxbMTAwLDc1XV1cbiAgICApO1xuXG4gICAgZGVmaW5lQ29sb3IoXG4gICAgICAnZ3JlZW4nLFxuICAgICAgWzYzLDE3OF0sXG4gICAgICBbWzMwLDEwMF0sWzQwLDkwXSxbNTAsODVdLFs2MCw4MV0sWzcwLDc0XSxbODAsNjRdLFs5MCw1MF0sWzEwMCw0MF1dXG4gICAgKTtcblxuICAgIGRlZmluZUNvbG9yKFxuICAgICAgJ2JsdWUnLFxuICAgICAgWzE3OSwgMjU3XSxcbiAgICAgIFtbMjAsMTAwXSxbMzAsODZdLFs0MCw4MF0sWzUwLDc0XSxbNjAsNjBdLFs3MCw1Ml0sWzgwLDQ0XSxbOTAsMzldLFsxMDAsMzVdXVxuICAgICk7XG5cbiAgICBkZWZpbmVDb2xvcihcbiAgICAgICdwdXJwbGUnLFxuICAgICAgWzI1OCwgMjgyXSxcbiAgICAgIFtbMjAsMTAwXSxbMzAsODddLFs0MCw3OV0sWzUwLDcwXSxbNjAsNjVdLFs3MCw1OV0sWzgwLDUyXSxbOTAsNDVdLFsxMDAsNDJdXVxuICAgICk7XG5cbiAgICBkZWZpbmVDb2xvcihcbiAgICAgICdwaW5rJyxcbiAgICAgIFsyODMsIDMzNF0sXG4gICAgICBbWzIwLDEwMF0sWzMwLDkwXSxbNDAsODZdLFs2MCw4NF0sWzgwLDgwXSxbOTAsNzVdLFsxMDAsNzNdXVxuICAgICk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIEhTVnRvUkdCIChoc3YpIHtcblxuICAgIC8vIHRoaXMgZG9lc24ndCB3b3JrIGZvciB0aGUgdmFsdWVzIG9mIDAgYW5kIDM2MFxuICAgIC8vIGhlcmUncyB0aGUgaGFja3kgZml4XG4gICAgdmFyIGggPSBoc3ZbMF07XG4gICAgaWYgKGggPT09IDApIHtoID0gMTt9XG4gICAgaWYgKGggPT09IDM2MCkge2ggPSAzNTk7fVxuXG4gICAgLy8gUmViYXNlIHRoZSBoLHMsdiB2YWx1ZXNcbiAgICBoID0gaC8zNjA7XG4gICAgdmFyIHMgPSBoc3ZbMV0vMTAwLFxuICAgICAgICB2ID0gaHN2WzJdLzEwMDtcblxuICAgIHZhciBoX2kgPSBNYXRoLmZsb29yKGgqNiksXG4gICAgICBmID0gaCAqIDYgLSBoX2ksXG4gICAgICBwID0gdiAqICgxIC0gcyksXG4gICAgICBxID0gdiAqICgxIC0gZipzKSxcbiAgICAgIHQgPSB2ICogKDEgLSAoMSAtIGYpKnMpLFxuICAgICAgciA9IDI1NixcbiAgICAgIGcgPSAyNTYsXG4gICAgICBiID0gMjU2O1xuXG4gICAgc3dpdGNoKGhfaSkge1xuICAgICAgY2FzZSAwOiByID0gdjsgZyA9IHQ7IGIgPSBwOyAgYnJlYWs7XG4gICAgICBjYXNlIDE6IHIgPSBxOyBnID0gdjsgYiA9IHA7ICBicmVhaztcbiAgICAgIGNhc2UgMjogciA9IHA7IGcgPSB2OyBiID0gdDsgIGJyZWFrO1xuICAgICAgY2FzZSAzOiByID0gcDsgZyA9IHE7IGIgPSB2OyAgYnJlYWs7XG4gICAgICBjYXNlIDQ6IHIgPSB0OyBnID0gcDsgYiA9IHY7ICBicmVhaztcbiAgICAgIGNhc2UgNTogciA9IHY7IGcgPSBwOyBiID0gcTsgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBbTWF0aC5mbG9vcihyKjI1NSksIE1hdGguZmxvb3IoZyoyNTUpLCBNYXRoLmZsb29yKGIqMjU1KV07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIEhleFRvSFNCIChoZXgpIHtcbiAgICBoZXggPSBoZXgucmVwbGFjZSgvXiMvLCAnJyk7XG4gICAgaGV4ID0gaGV4Lmxlbmd0aCA9PT0gMyA/IGhleC5yZXBsYWNlKC8oLikvZywgJyQxJDEnKSA6IGhleDtcblxuICAgIHZhciByZWQgPSBwYXJzZUludChoZXguc3Vic3RyKDAsIDIpLCAxNikgLyAyNTUsXG4gICAgICAgICAgZ3JlZW4gPSBwYXJzZUludChoZXguc3Vic3RyKDIsIDIpLCAxNikgLyAyNTUsXG4gICAgICAgICAgYmx1ZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoNCwgMiksIDE2KSAvIDI1NTtcblxuICAgIHZhciBjTWF4ID0gTWF0aC5tYXgocmVkLCBncmVlbiwgYmx1ZSksXG4gICAgICAgICAgZGVsdGEgPSBjTWF4IC0gTWF0aC5taW4ocmVkLCBncmVlbiwgYmx1ZSksXG4gICAgICAgICAgc2F0dXJhdGlvbiA9IGNNYXggPyAoZGVsdGEgLyBjTWF4KSA6IDA7XG5cbiAgICBzd2l0Y2ggKGNNYXgpIHtcbiAgICAgIGNhc2UgcmVkOiByZXR1cm4gWyA2MCAqICgoKGdyZWVuIC0gYmx1ZSkgLyBkZWx0YSkgJSA2KSB8fCAwLCBzYXR1cmF0aW9uLCBjTWF4IF07XG4gICAgICBjYXNlIGdyZWVuOiByZXR1cm4gWyA2MCAqICgoKGJsdWUgLSByZWQpIC8gZGVsdGEpICsgMikgfHwgMCwgc2F0dXJhdGlvbiwgY01heCBdO1xuICAgICAgY2FzZSBibHVlOiByZXR1cm4gWyA2MCAqICgoKHJlZCAtIGdyZWVuKSAvIGRlbHRhKSArIDQpIHx8IDAsIHNhdHVyYXRpb24sIGNNYXggXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBIU1Z0b0hTTCAoaHN2KSB7XG4gICAgdmFyIGggPSBoc3ZbMF0sXG4gICAgICBzID0gaHN2WzFdLzEwMCxcbiAgICAgIHYgPSBoc3ZbMl0vMTAwLFxuICAgICAgayA9ICgyLXMpKnY7XG5cbiAgICByZXR1cm4gW1xuICAgICAgaCxcbiAgICAgIE1hdGgucm91bmQocyp2IC8gKGs8MSA/IGsgOiAyLWspICogMTAwMDApIC8gMTAwLFxuICAgICAgay8yICogMTAwXG4gICAgXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ1RvSW50ZWdlciAoc3RyaW5nKSB7XG4gICAgdmFyIHRvdGFsID0gMFxuICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0b3RhbCA+PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikgYnJlYWs7XG4gICAgICB0b3RhbCArPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuICAgIH1cbiAgICByZXR1cm4gdG90YWxcbiAgfVxuXG4gIHJldHVybiByYW5kb21Db2xvcjtcbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3JhbmRvbWNvbG9yL3JhbmRvbUNvbG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25\n");

/***/ }),
/* 26 */
/***/ (function(module, exports) {

eval("(function(f) {\n\n  'use strict';\n\n  /*istanbul ignore next*/\n  if(typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f();\n  }else{\n    self.inspectf = f();\n  }\n\n}(function() {\n\n  'use strict';\n\n  function checkn(n) {\n    if(typeof n !== 'number') {\n      throw new TypeError(\n        'inspectf expects its first argument to be a number'\n      );\n    }\n  }\n\n  function checkf(f) {\n    if(typeof f !== 'function') {\n      throw new TypeError(\n        'inspectf expects its second argument to be a function'\n      );\n    }\n  }\n\n  var RSPACE = /^ */;\n  var RCODE = /\\s*[^\\s]/;\n  var RTABS = /\\t/g;\n  var REOL = /\\n\\r?/;\n\n  function isCode(line) {\n    return RCODE.test(line);\n  }\n\n  function getPadding(line) {\n    return line.match(RSPACE)[0].length;\n  }\n\n  function guessIndentation(lines) {\n    var filtered = lines.filter(isCode);\n    var paddings = filtered.map(getPadding);\n    var depth = paddings.reduce(Math.min, Infinity);\n    var tabsize = paddings\n    .map(function(x) { return x - depth; })\n    .find(function(x) { return x > 1; }) || 2;\n    return {depth: depth, tabsize: tabsize};\n  }\n\n  function pad(n) {\n    return (new Array(n + 1)).join(' ');\n  }\n\n  function show(f, indentation) {\n    return f.toString().replace(RTABS, indentation);\n  }\n\n  function toLines(s) {\n    return s.split(REOL);\n  }\n\n  function fixIndentation(lines, indentation) {\n    var info = guessIndentation(lines.slice(1));\n    var RPAD = new RegExp(pad(info.tabsize), 'g');\n    return lines.map(function(line) {\n      return line.slice(Math.min(info.depth, getPadding(line)))\n      .replace(RPAD, '\\t').replace(RTABS, indentation);\n    }).join('\\n');\n  }\n\n  return function inspectf(n, f) {\n    checkn(n);\n\n    if(arguments.length < 2) {\n      return function inspectf$partial(f) { return inspectf(n, f); };\n    }\n\n    checkf(f);\n    if(f.toString !== Function.prototype.toString) { return f.toString(); }\n    var i = pad(n), shown = show(f, i), lines = toLines(shown, i);\n    if(lines.length < 2) { return shown; }\n    return fixIndentation(lines, i);\n  };\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5zcGVjdC1mL2luZGV4LmpzP2MzNDUiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKGYpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgbmV4dCovXG4gIGlmKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGYoKTtcbiAgfWVsc2V7XG4gICAgc2VsZi5pbnNwZWN0ZiA9IGYoKTtcbiAgfVxuXG59KGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBjaGVja24obikge1xuICAgIGlmKHR5cGVvZiBuICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ2luc3BlY3RmIGV4cGVjdHMgaXRzIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGEgbnVtYmVyJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja2YoZikge1xuICAgIGlmKHR5cGVvZiBmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnaW5zcGVjdGYgZXhwZWN0cyBpdHMgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24nXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBSU1BBQ0UgPSAvXiAqLztcbiAgdmFyIFJDT0RFID0gL1xccypbXlxcc10vO1xuICB2YXIgUlRBQlMgPSAvXFx0L2c7XG4gIHZhciBSRU9MID0gL1xcblxccj8vO1xuXG4gIGZ1bmN0aW9uIGlzQ29kZShsaW5lKSB7XG4gICAgcmV0dXJuIFJDT0RFLnRlc3QobGluZSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYWRkaW5nKGxpbmUpIHtcbiAgICByZXR1cm4gbGluZS5tYXRjaChSU1BBQ0UpWzBdLmxlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGd1ZXNzSW5kZW50YXRpb24obGluZXMpIHtcbiAgICB2YXIgZmlsdGVyZWQgPSBsaW5lcy5maWx0ZXIoaXNDb2RlKTtcbiAgICB2YXIgcGFkZGluZ3MgPSBmaWx0ZXJlZC5tYXAoZ2V0UGFkZGluZyk7XG4gICAgdmFyIGRlcHRoID0gcGFkZGluZ3MucmVkdWNlKE1hdGgubWluLCBJbmZpbml0eSk7XG4gICAgdmFyIHRhYnNpemUgPSBwYWRkaW5nc1xuICAgIC5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4geCAtIGRlcHRoOyB9KVxuICAgIC5maW5kKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggPiAxOyB9KSB8fCAyO1xuICAgIHJldHVybiB7ZGVwdGg6IGRlcHRoLCB0YWJzaXplOiB0YWJzaXplfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhZChuKSB7XG4gICAgcmV0dXJuIChuZXcgQXJyYXkobiArIDEpKS5qb2luKCcgJyk7XG4gIH1cblxuICBmdW5jdGlvbiBzaG93KGYsIGluZGVudGF0aW9uKSB7XG4gICAgcmV0dXJuIGYudG9TdHJpbmcoKS5yZXBsYWNlKFJUQUJTLCBpbmRlbnRhdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiB0b0xpbmVzKHMpIHtcbiAgICByZXR1cm4gcy5zcGxpdChSRU9MKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpeEluZGVudGF0aW9uKGxpbmVzLCBpbmRlbnRhdGlvbikge1xuICAgIHZhciBpbmZvID0gZ3Vlc3NJbmRlbnRhdGlvbihsaW5lcy5zbGljZSgxKSk7XG4gICAgdmFyIFJQQUQgPSBuZXcgUmVnRXhwKHBhZChpbmZvLnRhYnNpemUpLCAnZycpO1xuICAgIHJldHVybiBsaW5lcy5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgcmV0dXJuIGxpbmUuc2xpY2UoTWF0aC5taW4oaW5mby5kZXB0aCwgZ2V0UGFkZGluZyhsaW5lKSkpXG4gICAgICAucmVwbGFjZShSUEFELCAnXFx0JykucmVwbGFjZShSVEFCUywgaW5kZW50YXRpb24pO1xuICAgIH0pLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGluc3BlY3RmKG4sIGYpIHtcbiAgICBjaGVja24obik7XG5cbiAgICBpZihhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGluc3BlY3RmJHBhcnRpYWwoZikgeyByZXR1cm4gaW5zcGVjdGYobiwgZik7IH07XG4gICAgfVxuXG4gICAgY2hlY2tmKGYpO1xuICAgIGlmKGYudG9TdHJpbmcgIT09IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZykgeyByZXR1cm4gZi50b1N0cmluZygpOyB9XG4gICAgdmFyIGkgPSBwYWQobiksIHNob3duID0gc2hvdyhmLCBpKSwgbGluZXMgPSB0b0xpbmVzKHNob3duLCBpKTtcbiAgICBpZihsaW5lcy5sZW5ndGggPCAyKSB7IHJldHVybiBzaG93bjsgfVxuICAgIHJldHVybiBmaXhJbmRlbnRhdGlvbihsaW5lcywgaSk7XG4gIH07XG5cbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2luc3BlY3QtZi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///26\n");

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

eval("(function(f){\n\n  'use strict';\n\n  /*istanbul ignore next*/\n  if(typeof module === 'object' && typeof module.exports === 'object'){\n    module.exports = f(__webpack_require__(11), __webpack_require__(1));\n  }else{\n    self.concurrify = f(self.sanctuaryTypeClasses, self.sanctuaryTypeIdentifiers);\n  }\n\n}(function(Z, type){\n\n  'use strict';\n\n  var $alt = 'fantasy-land/alt';\n  var $ap = 'fantasy-land/ap';\n  var $map = 'fantasy-land/map';\n  var $of = 'fantasy-land/of';\n  var $zero = 'fantasy-land/zero';\n  var $$type = '@@type';\n  var ordinal = ['first', 'second', 'third', 'fourth', 'fifth'];\n\n  function isFunction(f){\n    return typeof f === 'function';\n  }\n\n  function isBinary(f){\n    return f.length >= 2;\n  }\n\n  function isApplicativeRepr(Repr){\n    try{\n      return Z.Applicative.test(Z.of(Repr));\n    }catch(_){\n      return false;\n    }\n  }\n\n  function invalidArgument(it, at, expected, actual){\n    throw new TypeError(\n      it\n      + ' expects its '\n      + ordinal[at]\n      + ' argument to '\n      + expected\n      + '\\n  Actual: '\n      + Z.toString(actual)\n    );\n  }\n\n  function invalidContext(it, actual, an){\n    throw new TypeError(\n      it + ' was invoked outside the context of a ' + an + '. \\n  Called on: ' + Z.toString(actual)\n    );\n  }\n\n  //       getTypeIdentifier :: TypeRepresentative -> TypeIdentifier\n  function getTypeIdentifier(Repr){\n    return Repr[$$type] || Repr.name || 'Anonymous';\n  }\n\n  //       generateTypeIdentifier :: TypeIdentifier -> TypeIdentifier\n  function generateTypeIdentifier(identifier){\n    var o = type.parse(identifier);\n    return (o.namespace || 'concurrify') + '/Concurrent' + o.name + '@' + o.version;\n  }\n\n  //concurrify :: Applicative m\n  //           => (TypeRep m, m a, (m a, m a) -> m a, (m a, m (a -> b)) -> m b)\n  //           -> Concurrently m\n  return function concurrify(Repr, zero, alt, ap){\n\n    var INNERTYPE = getTypeIdentifier(Repr);\n    var OUTERTYPE = generateTypeIdentifier(INNERTYPE);\n    var INNERNAME = type.parse(INNERTYPE).name;\n    var OUTERNAME = type.parse(OUTERTYPE).name;\n\n    function Concurrently(sequential){\n      this.sequential = sequential;\n    }\n\n    function isInner(x){\n      return x instanceof Repr\n      || (Boolean(x) && x.constructor === Repr)\n      || type(x) === Repr[$$type];\n    }\n\n    function isOuter(x){\n      return x instanceof Concurrently\n      || (Boolean(x) && x.constructor === Concurrently)\n      || type(x) === OUTERTYPE;\n    }\n\n    function construct(x){\n      if(!isInner(x)) invalidArgument(OUTERNAME, 0, 'be of type \"' + INNERNAME + '\"', x);\n      return new Concurrently(x);\n    }\n\n    if(!isApplicativeRepr(Repr)) invalidArgument('concurrify', 0, 'represent an Applicative', Repr);\n    if(!isInner(zero)) invalidArgument('concurrify', 1, 'be of type \"' + INNERNAME + '\"', zero);\n    if(!isFunction(alt)) invalidArgument('concurrify', 2, 'be a function', alt);\n    if(!isBinary(alt)) invalidArgument('concurrify', 2, 'be binary', alt);\n    if(!isFunction(ap)) invalidArgument('concurrify', 3, 'be a function', ap);\n    if(!isBinary(ap)) invalidArgument('concurrify', 3, 'be binary', ap);\n\n    var proto = Concurrently.prototype = construct.prototype = {constructor: construct};\n\n    construct[$$type] = OUTERTYPE;\n\n    var mzero = new Concurrently(zero);\n\n    construct[$zero] = function Concurrently$zero(){\n      return mzero;\n    };\n\n    construct[$of] = function Concurrently$of(value){\n      return new Concurrently(Z.of(Repr, value));\n    };\n\n    proto[$map] = function Concurrently$map(mapper){\n      if(!isOuter(this)) invalidContext(OUTERNAME + '#map', this, OUTERNAME);\n      if(!isFunction(mapper)) invalidArgument(OUTERNAME + '#map', 0, 'be a function', mapper);\n      return new Concurrently(Z.map(mapper, this.sequential));\n    };\n\n    proto[$ap] = function Concurrently$ap(m){\n      if(!isOuter(this)) invalidContext(OUTERNAME + '#ap', this, OUTERNAME);\n      if(!isOuter(m)) invalidArgument(OUTERNAME + '#ap', 0, 'be a ' + OUTERNAME, m);\n      return new Concurrently(ap(this.sequential, m.sequential));\n    };\n\n    proto[$alt] = function Concurrently$alt(m){\n      if(!isOuter(this)) invalidContext(OUTERNAME + '#alt', this, OUTERNAME);\n      if(!isOuter(m)) invalidArgument(OUTERNAME + '#alt', 0, 'be a ' + OUTERNAME, m);\n      return new Concurrently(alt(this.sequential, m.sequential));\n    };\n\n    proto.toString = function Concurrently$toString(){\n      if(!isOuter(this)) invalidContext(OUTERNAME + '#toString', this, OUTERNAME);\n      return OUTERNAME + '(' + Z.toString(this.sequential) + ')';\n    };\n\n    return construct;\n\n  };\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29uY3VycmlmeS9pbmRleC5qcz83YWVmIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbihmKXtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgbmV4dCovXG4gIGlmKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpe1xuICAgIG1vZHVsZS5leHBvcnRzID0gZihyZXF1aXJlKCdzYW5jdHVhcnktdHlwZS1jbGFzc2VzJyksIHJlcXVpcmUoJ3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzJykpO1xuICB9ZWxzZXtcbiAgICBzZWxmLmNvbmN1cnJpZnkgPSBmKHNlbGYuc2FuY3R1YXJ5VHlwZUNsYXNzZXMsIHNlbGYuc2FuY3R1YXJ5VHlwZUlkZW50aWZpZXJzKTtcbiAgfVxuXG59KGZ1bmN0aW9uKFosIHR5cGUpe1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgJGFsdCA9ICdmYW50YXN5LWxhbmQvYWx0JztcbiAgdmFyICRhcCA9ICdmYW50YXN5LWxhbmQvYXAnO1xuICB2YXIgJG1hcCA9ICdmYW50YXN5LWxhbmQvbWFwJztcbiAgdmFyICRvZiA9ICdmYW50YXN5LWxhbmQvb2YnO1xuICB2YXIgJHplcm8gPSAnZmFudGFzeS1sYW5kL3plcm8nO1xuICB2YXIgJCR0eXBlID0gJ0BAdHlwZSc7XG4gIHZhciBvcmRpbmFsID0gWydmaXJzdCcsICdzZWNvbmQnLCAndGhpcmQnLCAnZm91cnRoJywgJ2ZpZnRoJ107XG5cbiAgZnVuY3Rpb24gaXNGdW5jdGlvbihmKXtcbiAgICByZXR1cm4gdHlwZW9mIGYgPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBmdW5jdGlvbiBpc0JpbmFyeShmKXtcbiAgICByZXR1cm4gZi5sZW5ndGggPj0gMjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQXBwbGljYXRpdmVSZXByKFJlcHIpe1xuICAgIHRyeXtcbiAgICAgIHJldHVybiBaLkFwcGxpY2F0aXZlLnRlc3QoWi5vZihSZXByKSk7XG4gICAgfWNhdGNoKF8pe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRBcmd1bWVudChpdCwgYXQsIGV4cGVjdGVkLCBhY3R1YWwpe1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBpdFxuICAgICAgKyAnIGV4cGVjdHMgaXRzICdcbiAgICAgICsgb3JkaW5hbFthdF1cbiAgICAgICsgJyBhcmd1bWVudCB0byAnXG4gICAgICArIGV4cGVjdGVkXG4gICAgICArICdcXG4gIEFjdHVhbDogJ1xuICAgICAgKyBaLnRvU3RyaW5nKGFjdHVhbClcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52YWxpZENvbnRleHQoaXQsIGFjdHVhbCwgYW4pe1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBpdCArICcgd2FzIGludm9rZWQgb3V0c2lkZSB0aGUgY29udGV4dCBvZiBhICcgKyBhbiArICcuIFxcbiAgQ2FsbGVkIG9uOiAnICsgWi50b1N0cmluZyhhY3R1YWwpXG4gICAgKTtcbiAgfVxuXG4gIC8vICAgICAgIGdldFR5cGVJZGVudGlmaWVyIDo6IFR5cGVSZXByZXNlbnRhdGl2ZSAtPiBUeXBlSWRlbnRpZmllclxuICBmdW5jdGlvbiBnZXRUeXBlSWRlbnRpZmllcihSZXByKXtcbiAgICByZXR1cm4gUmVwclskJHR5cGVdIHx8IFJlcHIubmFtZSB8fCAnQW5vbnltb3VzJztcbiAgfVxuXG4gIC8vICAgICAgIGdlbmVyYXRlVHlwZUlkZW50aWZpZXIgOjogVHlwZUlkZW50aWZpZXIgLT4gVHlwZUlkZW50aWZpZXJcbiAgZnVuY3Rpb24gZ2VuZXJhdGVUeXBlSWRlbnRpZmllcihpZGVudGlmaWVyKXtcbiAgICB2YXIgbyA9IHR5cGUucGFyc2UoaWRlbnRpZmllcik7XG4gICAgcmV0dXJuIChvLm5hbWVzcGFjZSB8fCAnY29uY3VycmlmeScpICsgJy9Db25jdXJyZW50JyArIG8ubmFtZSArICdAJyArIG8udmVyc2lvbjtcbiAgfVxuXG4gIC8vY29uY3VycmlmeSA6OiBBcHBsaWNhdGl2ZSBtXG4gIC8vICAgICAgICAgICA9PiAoVHlwZVJlcCBtLCBtIGEsIChtIGEsIG0gYSkgLT4gbSBhLCAobSBhLCBtIChhIC0+IGIpKSAtPiBtIGIpXG4gIC8vICAgICAgICAgICAtPiBDb25jdXJyZW50bHkgbVxuICByZXR1cm4gZnVuY3Rpb24gY29uY3VycmlmeShSZXByLCB6ZXJvLCBhbHQsIGFwKXtcblxuICAgIHZhciBJTk5FUlRZUEUgPSBnZXRUeXBlSWRlbnRpZmllcihSZXByKTtcbiAgICB2YXIgT1VURVJUWVBFID0gZ2VuZXJhdGVUeXBlSWRlbnRpZmllcihJTk5FUlRZUEUpO1xuICAgIHZhciBJTk5FUk5BTUUgPSB0eXBlLnBhcnNlKElOTkVSVFlQRSkubmFtZTtcbiAgICB2YXIgT1VURVJOQU1FID0gdHlwZS5wYXJzZShPVVRFUlRZUEUpLm5hbWU7XG5cbiAgICBmdW5jdGlvbiBDb25jdXJyZW50bHkoc2VxdWVudGlhbCl7XG4gICAgICB0aGlzLnNlcXVlbnRpYWwgPSBzZXF1ZW50aWFsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW5uZXIoeCl7XG4gICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFJlcHJcbiAgICAgIHx8IChCb29sZWFuKHgpICYmIHguY29uc3RydWN0b3IgPT09IFJlcHIpXG4gICAgICB8fCB0eXBlKHgpID09PSBSZXByWyQkdHlwZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPdXRlcih4KXtcbiAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgQ29uY3VycmVudGx5XG4gICAgICB8fCAoQm9vbGVhbih4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDb25jdXJyZW50bHkpXG4gICAgICB8fCB0eXBlKHgpID09PSBPVVRFUlRZUEU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uc3RydWN0KHgpe1xuICAgICAgaWYoIWlzSW5uZXIoeCkpIGludmFsaWRBcmd1bWVudChPVVRFUk5BTUUsIDAsICdiZSBvZiB0eXBlIFwiJyArIElOTkVSTkFNRSArICdcIicsIHgpO1xuICAgICAgcmV0dXJuIG5ldyBDb25jdXJyZW50bHkoeCk7XG4gICAgfVxuXG4gICAgaWYoIWlzQXBwbGljYXRpdmVSZXByKFJlcHIpKSBpbnZhbGlkQXJndW1lbnQoJ2NvbmN1cnJpZnknLCAwLCAncmVwcmVzZW50IGFuIEFwcGxpY2F0aXZlJywgUmVwcik7XG4gICAgaWYoIWlzSW5uZXIoemVybykpIGludmFsaWRBcmd1bWVudCgnY29uY3VycmlmeScsIDEsICdiZSBvZiB0eXBlIFwiJyArIElOTkVSTkFNRSArICdcIicsIHplcm8pO1xuICAgIGlmKCFpc0Z1bmN0aW9uKGFsdCkpIGludmFsaWRBcmd1bWVudCgnY29uY3VycmlmeScsIDIsICdiZSBhIGZ1bmN0aW9uJywgYWx0KTtcbiAgICBpZighaXNCaW5hcnkoYWx0KSkgaW52YWxpZEFyZ3VtZW50KCdjb25jdXJyaWZ5JywgMiwgJ2JlIGJpbmFyeScsIGFsdCk7XG4gICAgaWYoIWlzRnVuY3Rpb24oYXApKSBpbnZhbGlkQXJndW1lbnQoJ2NvbmN1cnJpZnknLCAzLCAnYmUgYSBmdW5jdGlvbicsIGFwKTtcbiAgICBpZighaXNCaW5hcnkoYXApKSBpbnZhbGlkQXJndW1lbnQoJ2NvbmN1cnJpZnknLCAzLCAnYmUgYmluYXJ5JywgYXApO1xuXG4gICAgdmFyIHByb3RvID0gQ29uY3VycmVudGx5LnByb3RvdHlwZSA9IGNvbnN0cnVjdC5wcm90b3R5cGUgPSB7Y29uc3RydWN0b3I6IGNvbnN0cnVjdH07XG5cbiAgICBjb25zdHJ1Y3RbJCR0eXBlXSA9IE9VVEVSVFlQRTtcblxuICAgIHZhciBtemVybyA9IG5ldyBDb25jdXJyZW50bHkoemVybyk7XG5cbiAgICBjb25zdHJ1Y3RbJHplcm9dID0gZnVuY3Rpb24gQ29uY3VycmVudGx5JHplcm8oKXtcbiAgICAgIHJldHVybiBtemVybztcbiAgICB9O1xuXG4gICAgY29uc3RydWN0WyRvZl0gPSBmdW5jdGlvbiBDb25jdXJyZW50bHkkb2YodmFsdWUpe1xuICAgICAgcmV0dXJuIG5ldyBDb25jdXJyZW50bHkoWi5vZihSZXByLCB2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBwcm90b1skbWFwXSA9IGZ1bmN0aW9uIENvbmN1cnJlbnRseSRtYXAobWFwcGVyKXtcbiAgICAgIGlmKCFpc091dGVyKHRoaXMpKSBpbnZhbGlkQ29udGV4dChPVVRFUk5BTUUgKyAnI21hcCcsIHRoaXMsIE9VVEVSTkFNRSk7XG4gICAgICBpZighaXNGdW5jdGlvbihtYXBwZXIpKSBpbnZhbGlkQXJndW1lbnQoT1VURVJOQU1FICsgJyNtYXAnLCAwLCAnYmUgYSBmdW5jdGlvbicsIG1hcHBlcik7XG4gICAgICByZXR1cm4gbmV3IENvbmN1cnJlbnRseShaLm1hcChtYXBwZXIsIHRoaXMuc2VxdWVudGlhbCkpO1xuICAgIH07XG5cbiAgICBwcm90b1skYXBdID0gZnVuY3Rpb24gQ29uY3VycmVudGx5JGFwKG0pe1xuICAgICAgaWYoIWlzT3V0ZXIodGhpcykpIGludmFsaWRDb250ZXh0KE9VVEVSTkFNRSArICcjYXAnLCB0aGlzLCBPVVRFUk5BTUUpO1xuICAgICAgaWYoIWlzT3V0ZXIobSkpIGludmFsaWRBcmd1bWVudChPVVRFUk5BTUUgKyAnI2FwJywgMCwgJ2JlIGEgJyArIE9VVEVSTkFNRSwgbSk7XG4gICAgICByZXR1cm4gbmV3IENvbmN1cnJlbnRseShhcCh0aGlzLnNlcXVlbnRpYWwsIG0uc2VxdWVudGlhbCkpO1xuICAgIH07XG5cbiAgICBwcm90b1skYWx0XSA9IGZ1bmN0aW9uIENvbmN1cnJlbnRseSRhbHQobSl7XG4gICAgICBpZighaXNPdXRlcih0aGlzKSkgaW52YWxpZENvbnRleHQoT1VURVJOQU1FICsgJyNhbHQnLCB0aGlzLCBPVVRFUk5BTUUpO1xuICAgICAgaWYoIWlzT3V0ZXIobSkpIGludmFsaWRBcmd1bWVudChPVVRFUk5BTUUgKyAnI2FsdCcsIDAsICdiZSBhICcgKyBPVVRFUk5BTUUsIG0pO1xuICAgICAgcmV0dXJuIG5ldyBDb25jdXJyZW50bHkoYWx0KHRoaXMuc2VxdWVudGlhbCwgbS5zZXF1ZW50aWFsKSk7XG4gICAgfTtcblxuICAgIHByb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gQ29uY3VycmVudGx5JHRvU3RyaW5nKCl7XG4gICAgICBpZighaXNPdXRlcih0aGlzKSkgaW52YWxpZENvbnRleHQoT1VURVJOQU1FICsgJyN0b1N0cmluZycsIHRoaXMsIE9VVEVSTkFNRSk7XG4gICAgICByZXR1cm4gT1VURVJOQU1FICsgJygnICsgWi50b1N0cmluZyh0aGlzLnNlcXVlbnRpYWwpICsgJyknO1xuICAgIH07XG5cbiAgICByZXR1cm4gY29uc3RydWN0O1xuXG4gIH07XG5cbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvbmN1cnJpZnkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///27\n");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Custom implementation of a double ended queue.\n */\nfunction Denque(array) {\n  // circular buffer\n  this._list = new Array(4);\n  // bit mask\n  this._capacityMask = 0x3;\n  // next unread item\n  this._head = 0;\n  // next empty slot\n  this._tail = 0;\n\n  if (Array.isArray(array)) {\n    this._fromArray(array);\n  }\n}\n\n/**\n * -------------\n *  PUBLIC API\n * -------------\n */\n\n/**\n * Returns the item at the specified index from the list.\n * 0 is the first element, 1 is the second, and so on...\n * Elements at negative values are that many from the end: -1 is one before the end\n * (the last element), -2 is two before the end (one before last), etc.\n * @param index\n * @returns {*}\n */\nDenque.prototype.peekAt = function peekAt(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var len = this.size();\n  if (i >= len || i < -len) return undefined;\n  if (i < 0) i += len;\n  i = (this._head + i) & this._capacityMask;\n  return this._list[i];\n};\n\n/**\n * Alias for peakAt()\n * @param i\n * @returns {*}\n */\nDenque.prototype.get = function get(i) {\n  return this.peekAt(i);\n};\n\n/**\n * Returns the first item in the list without removing it.\n * @returns {*}\n */\nDenque.prototype.peek = function peek() {\n  if (this._head === this._tail) return undefined;\n  return this._list[this._head];\n};\n\n/**\n * Alias for peek()\n * @returns {*}\n */\nDenque.prototype.peekFront = function peekFront() {\n  return this.peek();\n};\n\n/**\n * Returns the item that is at the back of the queue without removing it.\n * Uses peekAt(-1)\n */\nDenque.prototype.peekBack = function peekBack() {\n  return this.peekAt(-1);\n};\n\n/**\n * Returns the current length of the queue\n * @return {Number}\n */\nObject.defineProperty(Denque.prototype, 'length', {\n  get: function length() {\n    return this.size();\n  }\n});\n\n/**\n * Return the number of items on the list, or 0 if empty.\n * @returns {number}\n */\nDenque.prototype.size = function size() {\n  if (this._head === this._tail) return 0;\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Add an item at the beginning of the list.\n * @param item\n */\nDenque.prototype.unshift = function unshift(item) {\n  if (item === undefined) return this.length;\n  var len = this._list.length;\n  this._head = (this._head - 1 + len) & this._capacityMask;\n  this._list[this._head] = item;\n  if (this._tail === this._head) this._growArray();\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the first item on the list,\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.shift = function shift() {\n  var head = this._head;\n  if (head === this._tail) return undefined;\n  var item = this._list[head];\n  this._list[head] = undefined;\n  this._head = (head + 1) & this._capacityMask;\n  if (head < 2 && this._tail > 10000 && this._tail <= this._list.length >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Add an item to the bottom of the list.\n * @param item\n */\nDenque.prototype.push = function push(item) {\n  if (item === undefined) return this.length;\n  var tail = this._tail;\n  this._list[tail] = item;\n  this._tail = (tail + 1) & this._capacityMask;\n  if (this._tail === this._head) {\n    this._growArray();\n  }\n\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the last item on the list.\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.pop = function pop() {\n  var tail = this._tail;\n  if (tail === this._head) return undefined;\n  var len = this._list.length;\n  this._tail = (tail - 1 + len) & this._capacityMask;\n  var item = this._list[this._tail];\n  this._list[this._tail] = undefined;\n  if (this._head < 2 && tail > 10000 && tail <= len >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Remove and return the item at the specified index from the list.\n * Returns undefined if the list is empty.\n * @param index\n * @returns {*}\n */\nDenque.prototype.removeOne = function removeOne(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size) return void 0;\n  if (i < 0) i += size;\n  i = (this._head + i) & this._capacityMask;\n  var item = this._list[i];\n  var k;\n  if (index < size / 2) {\n    for (k = index; k > 0; k--) {\n      this._list[i] = this._list[i = (i - 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._head = (this._head + 1 + len) & this._capacityMask;\n  } else {\n    for (k = size - 1 - index; k > 0; k--) {\n      this._list[i] = this._list[i = ( i + 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._tail = (this._tail - 1 + len) & this._capacityMask;\n  }\n  return item;\n};\n\n/**\n * Remove number of items from the specified index from the list.\n * Returns array of removed items.\n * Returns undefined if the list is empty.\n * @param index\n * @param count\n * @returns {array}\n */\nDenque.prototype.remove = function remove(index, count) {\n  var i = index;\n  var removed;\n  var del_count = count;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size || count < 1) return void 0;\n  if (i < 0) i += size;\n  if (count === 1 || !count) {\n    removed = new Array(1);\n    removed[0] = this.removeOne(i);\n    return removed;\n  }\n  if (i === 0 && i + count >= size) {\n    removed = this.toArray();\n    this.clear();\n    return removed;\n  }\n  if (i + count > size) count = size - i;\n  var k;\n  removed = new Array(count);\n  for (k = 0; k < count; k++) {\n    removed[k] = this._list[(this._head + i + k) & this._capacityMask];\n  }\n  i = (this._head + i) & this._capacityMask;\n  if (index + count === size) {\n    this._tail = (this._tail - count + len) & this._capacityMask;\n    for (k = count; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (index === 0) {\n    this._head = (this._head + count + len) & this._capacityMask;\n    for (k = count - 1; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (index < size / 2) {\n    this._head = (this._head + index + count + len) & this._capacityMask;\n    for (k = index; k > 0; k--) {\n      this.unshift(this._list[i = (i - 1 + len) & this._capacityMask]);\n    }\n    i = (this._head - 1 + len) & this._capacityMask;\n    while (del_count > 0) {\n      this._list[i = (i - 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n  } else {\n    this._tail = i;\n    i = (i + count + len) & this._capacityMask;\n    for (k = size - (count + index); k > 0; k--) {\n      this.push(this._list[i++]);\n    }\n    i = this._tail;\n    while (del_count > 0) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n  }\n  if (this._head < 2 && this._tail > 10000 && this._tail <= len >>> 2) this._shrinkArray();\n  return removed;\n};\n\n/**\n * Native splice implementation.\n * Remove number of items from the specified index from the list and/or add new elements.\n * Returns array of removed items or empty array if count == 0.\n * Returns undefined if the list is empty.\n *\n * @param index\n * @param count\n * @param {...*} [elements]\n * @returns {array}\n */\nDenque.prototype.splice = function splice(index, count) {\n  var i = index;\n  var size = this.size();\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  if (i > size || i < -size) return void 0;\n  if (i === size && count != 0) return void 0;\n  if (i < 0) i += size;\n  if (arguments.length > 2) {\n    var k;\n    var temp;\n    var removed;\n    var arg_len = arguments.length;\n    var len = this._list.length;\n    var arguments_index = 2;\n    if (i < size / 2) {\n      temp = new Array(i);\n      for (k = 0; k < i; k++) {\n        temp[k] = this._list[(this._head + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i > 0) {\n          this._head = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._head = (this._head + i + len) & this._capacityMask;\n      }\n      while (arg_len > arguments_index) {\n        this.unshift(arguments[--arg_len]);\n      }\n      for (k = i; k > 0; k--) {\n        this.unshift(temp[k - 1]);\n      }\n    } else {\n      temp = new Array(size - (i + count));\n      var leng = temp.length;\n      for (k = 0; k < leng; k++) {\n        temp[k] = this._list[(this._head + i + count + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i != size) {\n          this._tail = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._tail = (this._tail - leng + len) & this._capacityMask;\n      }\n      while (arguments_index < arg_len) {\n        this.push(arguments[arguments_index++]);\n      }\n      for (k = 0; k < leng; k++) {\n        this.push(temp[k]);\n      }\n    }\n    return removed;\n  } else {\n    return this.remove(i, count);\n  }\n};\n\n/**\n * Soft clear - does not reset capacity.\n */\nDenque.prototype.clear = function clear() {\n  this._head = 0;\n  this._tail = 0;\n};\n\n/**\n * Returns true or false whether the list is empty.\n * @returns {boolean}\n */\nDenque.prototype.isEmpty = function isEmpty() {\n  return this._head === this._tail;\n};\n\n/**\n * Returns an array of all queue items.\n * @returns {Array}\n */\nDenque.prototype.toArray = function toArray() {\n  return this._copyArray(false);\n};\n\n/**\n * -------------\n *   INTERNALS\n * -------------\n */\n\n/**\n * Fills the queue with items from an array\n * For use in the constructor\n * @param array\n * @private\n */\nDenque.prototype._fromArray = function _fromArray(array) {\n  for (var i = 0; i < array.length; i++) this.push(array[i]);\n};\n\n/**\n *\n * @param fullCopy\n * @returns {Array}\n * @private\n */\nDenque.prototype._copyArray = function _copyArray(fullCopy) {\n  var newArray = [];\n  var list = this._list;\n  var len = list.length;\n  var i;\n  if (fullCopy || this._head > this._tail) {\n    for (i = this._head; i < len; i++) newArray.push(list[i]);\n    for (i = 0; i < this._tail; i++) newArray.push(list[i]);\n  } else {\n    for (i = this._head; i < this._tail; i++) newArray.push(list[i]);\n  }\n  return newArray;\n};\n\n/**\n * Grows the internal list array.\n * @private\n */\nDenque.prototype._growArray = function _growArray() {\n  if (this._head) {\n    // copy existing data, head to end, then beginning to tail.\n    this._list = this._copyArray(true);\n    this._head = 0;\n  }\n\n  // head is at 0 and array is now full, safe to extend\n  this._tail = this._list.length;\n\n  this._list.length *= 2;\n  this._capacityMask = (this._capacityMask << 1) | 1;\n};\n\n/**\n * Shrinks the internal list array.\n * @private\n */\nDenque.prototype._shrinkArray = function _shrinkArray() {\n  this._list.length >>>= 1;\n  this._capacityMask >>>= 1;\n};\n\n\nmodule.exports = Denque;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVucXVlL2luZGV4LmpzP2Y1Y2UiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEN1c3RvbSBpbXBsZW1lbnRhdGlvbiBvZiBhIGRvdWJsZSBlbmRlZCBxdWV1ZS5cbiAqL1xuZnVuY3Rpb24gRGVucXVlKGFycmF5KSB7XG4gIC8vIGNpcmN1bGFyIGJ1ZmZlclxuICB0aGlzLl9saXN0ID0gbmV3IEFycmF5KDQpO1xuICAvLyBiaXQgbWFza1xuICB0aGlzLl9jYXBhY2l0eU1hc2sgPSAweDM7XG4gIC8vIG5leHQgdW5yZWFkIGl0ZW1cbiAgdGhpcy5faGVhZCA9IDA7XG4gIC8vIG5leHQgZW1wdHkgc2xvdFxuICB0aGlzLl90YWlsID0gMDtcblxuICBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICB0aGlzLl9mcm9tQXJyYXkoYXJyYXkpO1xuICB9XG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLVxuICogIFBVQkxJQyBBUElcbiAqIC0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGl0ZW0gYXQgdGhlIHNwZWNpZmllZCBpbmRleCBmcm9tIHRoZSBsaXN0LlxuICogMCBpcyB0aGUgZmlyc3QgZWxlbWVudCwgMSBpcyB0aGUgc2Vjb25kLCBhbmQgc28gb24uLi5cbiAqIEVsZW1lbnRzIGF0IG5lZ2F0aXZlIHZhbHVlcyBhcmUgdGhhdCBtYW55IGZyb20gdGhlIGVuZDogLTEgaXMgb25lIGJlZm9yZSB0aGUgZW5kXG4gKiAodGhlIGxhc3QgZWxlbWVudCksIC0yIGlzIHR3byBiZWZvcmUgdGhlIGVuZCAob25lIGJlZm9yZSBsYXN0KSwgZXRjLlxuICogQHBhcmFtIGluZGV4XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuRGVucXVlLnByb3RvdHlwZS5wZWVrQXQgPSBmdW5jdGlvbiBwZWVrQXQoaW5kZXgpIHtcbiAgdmFyIGkgPSBpbmRleDtcbiAgLy8gZXhwZWN0IGEgbnVtYmVyIG9yIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKChpICE9PSAoaSB8IDApKSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgdmFyIGxlbiA9IHRoaXMuc2l6ZSgpO1xuICBpZiAoaSA+PSBsZW4gfHwgaSA8IC1sZW4pIHJldHVybiB1bmRlZmluZWQ7XG4gIGlmIChpIDwgMCkgaSArPSBsZW47XG4gIGkgPSAodGhpcy5faGVhZCArIGkpICYgdGhpcy5fY2FwYWNpdHlNYXNrO1xuICByZXR1cm4gdGhpcy5fbGlzdFtpXTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHBlYWtBdCgpXG4gKiBAcGFyYW0gaVxuICogQHJldHVybnMgeyp9XG4gKi9cbkRlbnF1ZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KGkpIHtcbiAgcmV0dXJuIHRoaXMucGVla0F0KGkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0IHdpdGhvdXQgcmVtb3ZpbmcgaXQuXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuRGVucXVlLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gcGVlaygpIHtcbiAgaWYgKHRoaXMuX2hlYWQgPT09IHRoaXMuX3RhaWwpIHJldHVybiB1bmRlZmluZWQ7XG4gIHJldHVybiB0aGlzLl9saXN0W3RoaXMuX2hlYWRdO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3IgcGVlaygpXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuRGVucXVlLnByb3RvdHlwZS5wZWVrRnJvbnQgPSBmdW5jdGlvbiBwZWVrRnJvbnQoKSB7XG4gIHJldHVybiB0aGlzLnBlZWsoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaXRlbSB0aGF0IGlzIGF0IHRoZSBiYWNrIG9mIHRoZSBxdWV1ZSB3aXRob3V0IHJlbW92aW5nIGl0LlxuICogVXNlcyBwZWVrQXQoLTEpXG4gKi9cbkRlbnF1ZS5wcm90b3R5cGUucGVla0JhY2sgPSBmdW5jdGlvbiBwZWVrQmFjaygpIHtcbiAgcmV0dXJuIHRoaXMucGVla0F0KC0xKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBsZW5ndGggb2YgdGhlIHF1ZXVlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZW5xdWUucHJvdG90eXBlLCAnbGVuZ3RoJywge1xuICBnZXQ6IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplKCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGl0ZW1zIG9uIHRoZSBsaXN0LCBvciAwIGlmIGVtcHR5LlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuRGVucXVlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSgpIHtcbiAgaWYgKHRoaXMuX2hlYWQgPT09IHRoaXMuX3RhaWwpIHJldHVybiAwO1xuICBpZiAodGhpcy5faGVhZCA8IHRoaXMuX3RhaWwpIHJldHVybiB0aGlzLl90YWlsIC0gdGhpcy5faGVhZDtcbiAgZWxzZSByZXR1cm4gdGhpcy5fY2FwYWNpdHlNYXNrICsgMSAtICh0aGlzLl9oZWFkIC0gdGhpcy5fdGFpbCk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBpdGVtIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3QuXG4gKiBAcGFyYW0gaXRlbVxuICovXG5EZW5xdWUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KGl0ZW0pIHtcbiAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICB2YXIgbGVuID0gdGhpcy5fbGlzdC5sZW5ndGg7XG4gIHRoaXMuX2hlYWQgPSAodGhpcy5faGVhZCAtIDEgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrO1xuICB0aGlzLl9saXN0W3RoaXMuX2hlYWRdID0gaXRlbTtcbiAgaWYgKHRoaXMuX3RhaWwgPT09IHRoaXMuX2hlYWQpIHRoaXMuX2dyb3dBcnJheSgpO1xuICBpZiAodGhpcy5faGVhZCA8IHRoaXMuX3RhaWwpIHJldHVybiB0aGlzLl90YWlsIC0gdGhpcy5faGVhZDtcbiAgZWxzZSByZXR1cm4gdGhpcy5fY2FwYWNpdHlNYXNrICsgMSAtICh0aGlzLl9oZWFkIC0gdGhpcy5fdGFpbCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbmQgcmV0dXJuIHRoZSBmaXJzdCBpdGVtIG9uIHRoZSBsaXN0LFxuICogUmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIGxpc3QgaXMgZW1wdHkuXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuRGVucXVlLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XG4gIGlmIChoZWFkID09PSB0aGlzLl90YWlsKSByZXR1cm4gdW5kZWZpbmVkO1xuICB2YXIgaXRlbSA9IHRoaXMuX2xpc3RbaGVhZF07XG4gIHRoaXMuX2xpc3RbaGVhZF0gPSB1bmRlZmluZWQ7XG4gIHRoaXMuX2hlYWQgPSAoaGVhZCArIDEpICYgdGhpcy5fY2FwYWNpdHlNYXNrO1xuICBpZiAoaGVhZCA8IDIgJiYgdGhpcy5fdGFpbCA+IDEwMDAwICYmIHRoaXMuX3RhaWwgPD0gdGhpcy5fbGlzdC5sZW5ndGggPj4+IDIpIHRoaXMuX3Nocmlua0FycmF5KCk7XG4gIHJldHVybiBpdGVtO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gaXRlbSB0byB0aGUgYm90dG9tIG9mIHRoZSBsaXN0LlxuICogQHBhcmFtIGl0ZW1cbiAqL1xuRGVucXVlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaChpdGVtKSB7XG4gIGlmIChpdGVtID09PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgdmFyIHRhaWwgPSB0aGlzLl90YWlsO1xuICB0aGlzLl9saXN0W3RhaWxdID0gaXRlbTtcbiAgdGhpcy5fdGFpbCA9ICh0YWlsICsgMSkgJiB0aGlzLl9jYXBhY2l0eU1hc2s7XG4gIGlmICh0aGlzLl90YWlsID09PSB0aGlzLl9oZWFkKSB7XG4gICAgdGhpcy5fZ3Jvd0FycmF5KCk7XG4gIH1cblxuICBpZiAodGhpcy5faGVhZCA8IHRoaXMuX3RhaWwpIHJldHVybiB0aGlzLl90YWlsIC0gdGhpcy5faGVhZDtcbiAgZWxzZSByZXR1cm4gdGhpcy5fY2FwYWNpdHlNYXNrICsgMSAtICh0aGlzLl9oZWFkIC0gdGhpcy5fdGFpbCk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbmQgcmV0dXJuIHRoZSBsYXN0IGl0ZW0gb24gdGhlIGxpc3QuXG4gKiBSZXR1cm5zIHVuZGVmaW5lZCBpZiB0aGUgbGlzdCBpcyBlbXB0eS5cbiAqIEByZXR1cm5zIHsqfVxuICovXG5EZW5xdWUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uIHBvcCgpIHtcbiAgdmFyIHRhaWwgPSB0aGlzLl90YWlsO1xuICBpZiAodGFpbCA9PT0gdGhpcy5faGVhZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgdmFyIGxlbiA9IHRoaXMuX2xpc3QubGVuZ3RoO1xuICB0aGlzLl90YWlsID0gKHRhaWwgLSAxICsgbGVuKSAmIHRoaXMuX2NhcGFjaXR5TWFzaztcbiAgdmFyIGl0ZW0gPSB0aGlzLl9saXN0W3RoaXMuX3RhaWxdO1xuICB0aGlzLl9saXN0W3RoaXMuX3RhaWxdID0gdW5kZWZpbmVkO1xuICBpZiAodGhpcy5faGVhZCA8IDIgJiYgdGFpbCA+IDEwMDAwICYmIHRhaWwgPD0gbGVuID4+PiAyKSB0aGlzLl9zaHJpbmtBcnJheSgpO1xuICByZXR1cm4gaXRlbTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuZCByZXR1cm4gdGhlIGl0ZW0gYXQgdGhlIHNwZWNpZmllZCBpbmRleCBmcm9tIHRoZSBsaXN0LlxuICogUmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIGxpc3QgaXMgZW1wdHkuXG4gKiBAcGFyYW0gaW5kZXhcbiAqIEByZXR1cm5zIHsqfVxuICovXG5EZW5xdWUucHJvdG90eXBlLnJlbW92ZU9uZSA9IGZ1bmN0aW9uIHJlbW92ZU9uZShpbmRleCkge1xuICB2YXIgaSA9IGluZGV4O1xuICAvLyBleHBlY3QgYSBudW1iZXIgb3IgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoKGkgIT09IChpIHwgMCkpKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAodGhpcy5faGVhZCA9PT0gdGhpcy5fdGFpbCkgcmV0dXJuIHZvaWQgMDtcbiAgdmFyIHNpemUgPSB0aGlzLnNpemUoKTtcbiAgdmFyIGxlbiA9IHRoaXMuX2xpc3QubGVuZ3RoO1xuICBpZiAoaSA+PSBzaXplIHx8IGkgPCAtc2l6ZSkgcmV0dXJuIHZvaWQgMDtcbiAgaWYgKGkgPCAwKSBpICs9IHNpemU7XG4gIGkgPSAodGhpcy5faGVhZCArIGkpICYgdGhpcy5fY2FwYWNpdHlNYXNrO1xuICB2YXIgaXRlbSA9IHRoaXMuX2xpc3RbaV07XG4gIHZhciBrO1xuICBpZiAoaW5kZXggPCBzaXplIC8gMikge1xuICAgIGZvciAoayA9IGluZGV4OyBrID4gMDsgay0tKSB7XG4gICAgICB0aGlzLl9saXN0W2ldID0gdGhpcy5fbGlzdFtpID0gKGkgLSAxICsgbGVuKSAmIHRoaXMuX2NhcGFjaXR5TWFza107XG4gICAgfVxuICAgIHRoaXMuX2xpc3RbaV0gPSB2b2lkIDA7XG4gICAgdGhpcy5faGVhZCA9ICh0aGlzLl9oZWFkICsgMSArIGxlbikgJiB0aGlzLl9jYXBhY2l0eU1hc2s7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChrID0gc2l6ZSAtIDEgLSBpbmRleDsgayA+IDA7IGstLSkge1xuICAgICAgdGhpcy5fbGlzdFtpXSA9IHRoaXMuX2xpc3RbaSA9ICggaSArIDEgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrXTtcbiAgICB9XG4gICAgdGhpcy5fbGlzdFtpXSA9IHZvaWQgMDtcbiAgICB0aGlzLl90YWlsID0gKHRoaXMuX3RhaWwgLSAxICsgbGVuKSAmIHRoaXMuX2NhcGFjaXR5TWFzaztcbiAgfVxuICByZXR1cm4gaXRlbTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIG51bWJlciBvZiBpdGVtcyBmcm9tIHRoZSBzcGVjaWZpZWQgaW5kZXggZnJvbSB0aGUgbGlzdC5cbiAqIFJldHVybnMgYXJyYXkgb2YgcmVtb3ZlZCBpdGVtcy5cbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBsaXN0IGlzIGVtcHR5LlxuICogQHBhcmFtIGluZGV4XG4gKiBAcGFyYW0gY291bnRcbiAqIEByZXR1cm5zIHthcnJheX1cbiAqL1xuRGVucXVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoaW5kZXgsIGNvdW50KSB7XG4gIHZhciBpID0gaW5kZXg7XG4gIHZhciByZW1vdmVkO1xuICB2YXIgZGVsX2NvdW50ID0gY291bnQ7XG4gIC8vIGV4cGVjdCBhIG51bWJlciBvciByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICgoaSAhPT0gKGkgfCAwKSkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmICh0aGlzLl9oZWFkID09PSB0aGlzLl90YWlsKSByZXR1cm4gdm9pZCAwO1xuICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZSgpO1xuICB2YXIgbGVuID0gdGhpcy5fbGlzdC5sZW5ndGg7XG4gIGlmIChpID49IHNpemUgfHwgaSA8IC1zaXplIHx8IGNvdW50IDwgMSkgcmV0dXJuIHZvaWQgMDtcbiAgaWYgKGkgPCAwKSBpICs9IHNpemU7XG4gIGlmIChjb3VudCA9PT0gMSB8fCAhY291bnQpIHtcbiAgICByZW1vdmVkID0gbmV3IEFycmF5KDEpO1xuICAgIHJlbW92ZWRbMF0gPSB0aGlzLnJlbW92ZU9uZShpKTtcbiAgICByZXR1cm4gcmVtb3ZlZDtcbiAgfVxuICBpZiAoaSA9PT0gMCAmJiBpICsgY291bnQgPj0gc2l6ZSkge1xuICAgIHJlbW92ZWQgPSB0aGlzLnRvQXJyYXkoKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgcmV0dXJuIHJlbW92ZWQ7XG4gIH1cbiAgaWYgKGkgKyBjb3VudCA+IHNpemUpIGNvdW50ID0gc2l6ZSAtIGk7XG4gIHZhciBrO1xuICByZW1vdmVkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgZm9yIChrID0gMDsgayA8IGNvdW50OyBrKyspIHtcbiAgICByZW1vdmVkW2tdID0gdGhpcy5fbGlzdFsodGhpcy5faGVhZCArIGkgKyBrKSAmIHRoaXMuX2NhcGFjaXR5TWFza107XG4gIH1cbiAgaSA9ICh0aGlzLl9oZWFkICsgaSkgJiB0aGlzLl9jYXBhY2l0eU1hc2s7XG4gIGlmIChpbmRleCArIGNvdW50ID09PSBzaXplKSB7XG4gICAgdGhpcy5fdGFpbCA9ICh0aGlzLl90YWlsIC0gY291bnQgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrO1xuICAgIGZvciAoayA9IGNvdW50OyBrID4gMDsgay0tKSB7XG4gICAgICB0aGlzLl9saXN0W2kgPSAoaSArIDEgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrXSA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIHJlbW92ZWQ7XG4gIH1cbiAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgdGhpcy5faGVhZCA9ICh0aGlzLl9oZWFkICsgY291bnQgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrO1xuICAgIGZvciAoayA9IGNvdW50IC0gMTsgayA+IDA7IGstLSkge1xuICAgICAgdGhpcy5fbGlzdFtpID0gKGkgKyAxICsgbGVuKSAmIHRoaXMuX2NhcGFjaXR5TWFza10gPSB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVkO1xuICB9XG4gIGlmIChpbmRleCA8IHNpemUgLyAyKSB7XG4gICAgdGhpcy5faGVhZCA9ICh0aGlzLl9oZWFkICsgaW5kZXggKyBjb3VudCArIGxlbikgJiB0aGlzLl9jYXBhY2l0eU1hc2s7XG4gICAgZm9yIChrID0gaW5kZXg7IGsgPiAwOyBrLS0pIHtcbiAgICAgIHRoaXMudW5zaGlmdCh0aGlzLl9saXN0W2kgPSAoaSAtIDEgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrXSk7XG4gICAgfVxuICAgIGkgPSAodGhpcy5faGVhZCAtIDEgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrO1xuICAgIHdoaWxlIChkZWxfY291bnQgPiAwKSB7XG4gICAgICB0aGlzLl9saXN0W2kgPSAoaSAtIDEgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrXSA9IHZvaWQgMDtcbiAgICAgIGRlbF9jb3VudC0tO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl90YWlsID0gaTtcbiAgICBpID0gKGkgKyBjb3VudCArIGxlbikgJiB0aGlzLl9jYXBhY2l0eU1hc2s7XG4gICAgZm9yIChrID0gc2l6ZSAtIChjb3VudCArIGluZGV4KTsgayA+IDA7IGstLSkge1xuICAgICAgdGhpcy5wdXNoKHRoaXMuX2xpc3RbaSsrXSk7XG4gICAgfVxuICAgIGkgPSB0aGlzLl90YWlsO1xuICAgIHdoaWxlIChkZWxfY291bnQgPiAwKSB7XG4gICAgICB0aGlzLl9saXN0W2kgPSAoaSArIDEgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrXSA9IHZvaWQgMDtcbiAgICAgIGRlbF9jb3VudC0tO1xuICAgIH1cbiAgfVxuICBpZiAodGhpcy5faGVhZCA8IDIgJiYgdGhpcy5fdGFpbCA+IDEwMDAwICYmIHRoaXMuX3RhaWwgPD0gbGVuID4+PiAyKSB0aGlzLl9zaHJpbmtBcnJheSgpO1xuICByZXR1cm4gcmVtb3ZlZDtcbn07XG5cbi8qKlxuICogTmF0aXZlIHNwbGljZSBpbXBsZW1lbnRhdGlvbi5cbiAqIFJlbW92ZSBudW1iZXIgb2YgaXRlbXMgZnJvbSB0aGUgc3BlY2lmaWVkIGluZGV4IGZyb20gdGhlIGxpc3QgYW5kL29yIGFkZCBuZXcgZWxlbWVudHMuXG4gKiBSZXR1cm5zIGFycmF5IG9mIHJlbW92ZWQgaXRlbXMgb3IgZW1wdHkgYXJyYXkgaWYgY291bnQgPT0gMC5cbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIHRoZSBsaXN0IGlzIGVtcHR5LlxuICpcbiAqIEBwYXJhbSBpbmRleFxuICogQHBhcmFtIGNvdW50XG4gKiBAcGFyYW0gey4uLip9IFtlbGVtZW50c11cbiAqIEByZXR1cm5zIHthcnJheX1cbiAqL1xuRGVucXVlLnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbiBzcGxpY2UoaW5kZXgsIGNvdW50KSB7XG4gIHZhciBpID0gaW5kZXg7XG4gIHZhciBzaXplID0gdGhpcy5zaXplKCk7XG4gIC8vIGV4cGVjdCBhIG51bWJlciBvciByZXR1cm4gdW5kZWZpbmVkXG4gIGlmICgoaSAhPT0gKGkgfCAwKSkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmICh0aGlzLl9oZWFkID09PSB0aGlzLl90YWlsKSByZXR1cm4gdm9pZCAwO1xuICBpZiAoaSA+IHNpemUgfHwgaSA8IC1zaXplKSByZXR1cm4gdm9pZCAwO1xuICBpZiAoaSA9PT0gc2l6ZSAmJiBjb3VudCAhPSAwKSByZXR1cm4gdm9pZCAwO1xuICBpZiAoaSA8IDApIGkgKz0gc2l6ZTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgdmFyIGs7XG4gICAgdmFyIHRlbXA7XG4gICAgdmFyIHJlbW92ZWQ7XG4gICAgdmFyIGFyZ19sZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBsZW4gPSB0aGlzLl9saXN0Lmxlbmd0aDtcbiAgICB2YXIgYXJndW1lbnRzX2luZGV4ID0gMjtcbiAgICBpZiAoaSA8IHNpemUgLyAyKSB7XG4gICAgICB0ZW1wID0gbmV3IEFycmF5KGkpO1xuICAgICAgZm9yIChrID0gMDsgayA8IGk7IGsrKykge1xuICAgICAgICB0ZW1wW2tdID0gdGhpcy5fbGlzdFsodGhpcy5faGVhZCArIGspICYgdGhpcy5fY2FwYWNpdHlNYXNrXTtcbiAgICAgIH1cbiAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICByZW1vdmVkID0gW107XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHRoaXMuX2hlYWQgPSAodGhpcy5faGVhZCArIGkgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVkID0gdGhpcy5yZW1vdmUoaSwgY291bnQpO1xuICAgICAgICB0aGlzLl9oZWFkID0gKHRoaXMuX2hlYWQgKyBpICsgbGVuKSAmIHRoaXMuX2NhcGFjaXR5TWFzaztcbiAgICAgIH1cbiAgICAgIHdoaWxlIChhcmdfbGVuID4gYXJndW1lbnRzX2luZGV4KSB7XG4gICAgICAgIHRoaXMudW5zaGlmdChhcmd1bWVudHNbLS1hcmdfbGVuXSk7XG4gICAgICB9XG4gICAgICBmb3IgKGsgPSBpOyBrID4gMDsgay0tKSB7XG4gICAgICAgIHRoaXMudW5zaGlmdCh0ZW1wW2sgLSAxXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXAgPSBuZXcgQXJyYXkoc2l6ZSAtIChpICsgY291bnQpKTtcbiAgICAgIHZhciBsZW5nID0gdGVtcC5sZW5ndGg7XG4gICAgICBmb3IgKGsgPSAwOyBrIDwgbGVuZzsgaysrKSB7XG4gICAgICAgIHRlbXBba10gPSB0aGlzLl9saXN0Wyh0aGlzLl9oZWFkICsgaSArIGNvdW50ICsgaykgJiB0aGlzLl9jYXBhY2l0eU1hc2tdO1xuICAgICAgfVxuICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgIHJlbW92ZWQgPSBbXTtcbiAgICAgICAgaWYgKGkgIT0gc2l6ZSkge1xuICAgICAgICAgIHRoaXMuX3RhaWwgPSAodGhpcy5faGVhZCArIGkgKyBsZW4pICYgdGhpcy5fY2FwYWNpdHlNYXNrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVkID0gdGhpcy5yZW1vdmUoaSwgY291bnQpO1xuICAgICAgICB0aGlzLl90YWlsID0gKHRoaXMuX3RhaWwgLSBsZW5nICsgbGVuKSAmIHRoaXMuX2NhcGFjaXR5TWFzaztcbiAgICAgIH1cbiAgICAgIHdoaWxlIChhcmd1bWVudHNfaW5kZXggPCBhcmdfbGVuKSB7XG4gICAgICAgIHRoaXMucHVzaChhcmd1bWVudHNbYXJndW1lbnRzX2luZGV4KytdKTtcbiAgICAgIH1cbiAgICAgIGZvciAoayA9IDA7IGsgPCBsZW5nOyBrKyspIHtcbiAgICAgICAgdGhpcy5wdXNoKHRlbXBba10pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVtb3ZlZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdmUoaSwgY291bnQpO1xuICB9XG59O1xuXG4vKipcbiAqIFNvZnQgY2xlYXIgLSBkb2VzIG5vdCByZXNldCBjYXBhY2l0eS5cbiAqL1xuRGVucXVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICB0aGlzLl9oZWFkID0gMDtcbiAgdGhpcy5fdGFpbCA9IDA7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSB3aGV0aGVyIHRoZSBsaXN0IGlzIGVtcHR5LlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkRlbnF1ZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gIHJldHVybiB0aGlzLl9oZWFkID09PSB0aGlzLl90YWlsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBxdWV1ZSBpdGVtcy5cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuRGVucXVlLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgcmV0dXJuIHRoaXMuX2NvcHlBcnJheShmYWxzZSk7XG59O1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS1cbiAqICAgSU5URVJOQUxTXG4gKiAtLS0tLS0tLS0tLS0tXG4gKi9cblxuLyoqXG4gKiBGaWxscyB0aGUgcXVldWUgd2l0aCBpdGVtcyBmcm9tIGFuIGFycmF5XG4gKiBGb3IgdXNlIGluIHRoZSBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGFycmF5XG4gKiBAcHJpdmF0ZVxuICovXG5EZW5xdWUucHJvdG90eXBlLl9mcm9tQXJyYXkgPSBmdW5jdGlvbiBfZnJvbUFycmF5KGFycmF5KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHRoaXMucHVzaChhcnJheVtpXSk7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gZnVsbENvcHlcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cbkRlbnF1ZS5wcm90b3R5cGUuX2NvcHlBcnJheSA9IGZ1bmN0aW9uIF9jb3B5QXJyYXkoZnVsbENvcHkpIHtcbiAgdmFyIG5ld0FycmF5ID0gW107XG4gIHZhciBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgaTtcbiAgaWYgKGZ1bGxDb3B5IHx8IHRoaXMuX2hlYWQgPiB0aGlzLl90YWlsKSB7XG4gICAgZm9yIChpID0gdGhpcy5faGVhZDsgaSA8IGxlbjsgaSsrKSBuZXdBcnJheS5wdXNoKGxpc3RbaV0pO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl90YWlsOyBpKyspIG5ld0FycmF5LnB1c2gobGlzdFtpXSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gdGhpcy5faGVhZDsgaSA8IHRoaXMuX3RhaWw7IGkrKykgbmV3QXJyYXkucHVzaChsaXN0W2ldKTtcbiAgfVxuICByZXR1cm4gbmV3QXJyYXk7XG59O1xuXG4vKipcbiAqIEdyb3dzIHRoZSBpbnRlcm5hbCBsaXN0IGFycmF5LlxuICogQHByaXZhdGVcbiAqL1xuRGVucXVlLnByb3RvdHlwZS5fZ3Jvd0FycmF5ID0gZnVuY3Rpb24gX2dyb3dBcnJheSgpIHtcbiAgaWYgKHRoaXMuX2hlYWQpIHtcbiAgICAvLyBjb3B5IGV4aXN0aW5nIGRhdGEsIGhlYWQgdG8gZW5kLCB0aGVuIGJlZ2lubmluZyB0byB0YWlsLlxuICAgIHRoaXMuX2xpc3QgPSB0aGlzLl9jb3B5QXJyYXkodHJ1ZSk7XG4gICAgdGhpcy5faGVhZCA9IDA7XG4gIH1cblxuICAvLyBoZWFkIGlzIGF0IDAgYW5kIGFycmF5IGlzIG5vdyBmdWxsLCBzYWZlIHRvIGV4dGVuZFxuICB0aGlzLl90YWlsID0gdGhpcy5fbGlzdC5sZW5ndGg7XG5cbiAgdGhpcy5fbGlzdC5sZW5ndGggKj0gMjtcbiAgdGhpcy5fY2FwYWNpdHlNYXNrID0gKHRoaXMuX2NhcGFjaXR5TWFzayA8PCAxKSB8IDE7XG59O1xuXG4vKipcbiAqIFNocmlua3MgdGhlIGludGVybmFsIGxpc3QgYXJyYXkuXG4gKiBAcHJpdmF0ZVxuICovXG5EZW5xdWUucHJvdG90eXBlLl9zaHJpbmtBcnJheSA9IGZ1bmN0aW9uIF9zaHJpbmtBcnJheSgpIHtcbiAgdGhpcy5fbGlzdC5sZW5ndGggPj4+PSAxO1xuICB0aGlzLl9jYXBhY2l0eU1hc2sgPj4+PSAxO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IERlbnF1ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2RlbnF1ZS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///28\n");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*    #######\n   ####     ####\n ####   ###   ####\n#####   ###########   sanctuary\n########   ########   noun\n###########   #####   1 [ mass noun ] refuge from unsafe JavaScript\n ####   ###   ####\n   ####     ####\n      #######    */\n\n//. # Sanctuary\n//.\n//. [![npm](https://img.shields.io/npm/v/sanctuary.svg)](https://www.npmjs.com/package/sanctuary)\n//. [![CircleCI](https://img.shields.io/circleci/project/github/sanctuary-js/sanctuary/master.svg)](https://circleci.com/gh/sanctuary-js/sanctuary/tree/master)\n//. [![Gitter](https://img.shields.io/gitter/room/badges/shields.svg)](https://gitter.im/sanctuary-js/sanctuary)\n//.\n//. Sanctuary is a JavaScript functional programming library inspired by\n//. [Haskell][] and [PureScript][]. It's stricter than [Ramda][], and\n//. provides a similar suite of functions.\n//.\n//. Sanctuary promotes programs composed of simple, pure functions. Such\n//. programs are easier to comprehend, test, and maintain &ndash; they are\n//. also a pleasure to write.\n//.\n//. Sanctuary provides two data types, [Maybe][] and [Either][], both of\n//. which are compatible with [Fantasy Land][]. Thanks to these data types\n//. even Sanctuary functions which may fail, such as [`head`](#head), are\n//. composable.\n//.\n//. Sanctuary makes it possible to write safe code without null checks.\n//. In JavaScript it's trivial to introduce a possible run-time type error:\n//.\n//.     words[0].toUpperCase()\n//.\n//. If `words` is `[]` we'll get a familiar error at run-time:\n//.\n//.     TypeError: Cannot read property 'toUpperCase' of undefined\n//.\n//. Sanctuary gives us a fighting chance of avoiding such errors. We might\n//. write:\n//.\n//.     S.map(S.toUpper, S.head(words))\n//.\n//. Sanctuary is designed to work in Node.js and in ES5-compatible browsers.\n//.\n//. ## Types\n//.\n//. Sanctuary uses Haskell-like type signatures to describe the types of\n//. values, including functions. `'foo'`, for example, is a member of `String`;\n//. `[1, 2, 3]` is a member of `Array Number`. The double colon (`::`) is used\n//. to mean \"is a member of\", so one could write:\n//.\n//.     'foo' :: String\n//.     [1, 2, 3] :: Array Number\n//.\n//. An identifier may appear to the left of the double colon:\n//.\n//.     Math.PI :: Number\n//.\n//. The arrow (`->`) is used to express a function's type:\n//.\n//.     Math.abs :: Number -> Number\n//.\n//. That states that `Math.abs` is a unary function which takes an argument\n//. of type `Number` and returns a value of type `Number`.\n//.\n//. Some functions are parametrically polymorphic: their types are not fixed.\n//. Type variables are used in the representations of such functions:\n//.\n//.     S.I :: a -> a\n//.\n//. `a` is a type variable. Type variables are not capitalized, so they\n//. are differentiable from type identifiers (which are always capitalized).\n//. By convention type variables have single-character names. The signature\n//. above states that `S.I` takes a value of any type and returns a value of\n//. the same type. Some signatures feature multiple type variables:\n//.\n//.     S.K :: a -> b -> a\n//.\n//. It must be possible to replace all occurrences of `a` with a concrete type.\n//. The same applies for each other type variable. For the function above, the\n//. types with which `a` and `b` are replaced may be different, but needn't be.\n//.\n//. Since all Sanctuary functions are curried (they accept their arguments\n//. one at a time), a binary function is represented as a unary function which\n//. returns a unary function: `* -> * -> *`. This aligns neatly with Haskell,\n//. which uses curried functions exclusively. In JavaScript, though, we may\n//. wish to represent the types of functions with arities less than or greater\n//. than one. The general form is `(<input-types>) -> <output-type>`, where\n//. `<input-types>` comprises zero or more commaspace (<code>, </code>)\n//. -separated type representations:\n//.\n//.   - `() -> String`\n//.   - `(a, b) -> a`\n//.   - `(a, b, c) -> d`\n//.\n//. `Number -> Number` can thus be seen as shorthand for `(Number) -> Number`.\n//.\n//. The question mark (`?`) is used to represent types which include `null`\n//. and `undefined` as members. `String?`, for example, represents the type\n//. comprising `null`, `undefined`, and all strings.\n//.\n//. Sanctuary embraces types. JavaScript doesn't support algebraic data types,\n//. but these can be simulated by providing a group of data constructors which\n//. return values with the same set of methods. A value of the Either type, for\n//. example, is created via the Left constructor or the Right constructor.\n//.\n//. It's necessary to extend Haskell's notation to describe implicit arguments\n//. to the *methods* provided by Sanctuary's types. In `x.map(y)`, for example,\n//. the `map` method takes an implicit argument `x` in addition to the explicit\n//. argument `y`. The type of the value upon which a method is invoked appears\n//. at the beginning of the signature, separated from the arguments and return\n//. value by a squiggly arrow (`~>`). The type of the `fantasy-land/map` method\n//. of the Maybe type is written `Maybe a ~> (a -> b) -> Maybe b`. One could\n//. read this as:\n//.\n//. _When the `fantasy-land/map` method is invoked on a value of type `Maybe a`\n//. (for any type `a`) with an argument of type `a -> b` (for any type `b`),\n//. it returns a value of type `Maybe b`._\n//.\n//. The squiggly arrow is also used when representing non-function properties.\n//. `Maybe a ~> Boolean`, for example, represents a Boolean property of a value\n//. of type `Maybe a`.\n//.\n//. Sanctuary supports type classes: constraints on type variables. Whereas\n//. `a -> a` implicitly supports every type, `Functor f => (a -> b) -> f a ->\n//. f b` requires that `f` be a type which satisfies the requirements of the\n//. Functor type class. Type-class constraints appear at the beginning of a\n//. type signature, separated from the rest of the signature by a fat arrow\n//. (`=>`).\n//.\n//. ### Type representatives\n//.\n//. What is the type of `Number`? One answer is `a -> Number`, since it's a\n//. function which takes an argument of any type and returns a Number value.\n//. When provided as the first argument to [`is`](#is), though, `Number` is\n//. really the value-level representative of the Number type.\n//.\n//. Sanctuary uses the TypeRep pseudotype to describe type representatives.\n//. For example:\n//.\n//.     Number :: TypeRep Number\n//.\n//. `Number` is the sole inhabitant of the TypeRep Number type.\n//.\n//. ## Type checking\n//.\n//. Sanctuary functions are defined via [sanctuary-def][] to provide run-time\n//. type checking. This is tremendously useful during development: type errors\n//. are reported immediately, avoiding circuitous stack traces (at best) and\n//. silent failures due to type coercion (at worst). For example:\n//.\n//. ```javascript\n//. S.add(2, true);\n//. // ! TypeError: Invalid value\n//. //\n//. //   add :: FiniteNumber -> FiniteNumber -> FiniteNumber\n//. //                          ^^^^^^^^^^^^\n//. //                               1\n//. //\n//. //   1)  true :: Boolean\n//. //\n//. //   The value at position 1 is not a member of FiniteNumber.\n//. //\n//. //   See v:sanctuary-js/sanctuary-def#FiniteNumber for information about the sanctuary-def/FiniteNumber type.\n//. ```\n//.\n//. Compare this to the behaviour of Ramda's unchecked equivalent:\n//.\n//. ```javascript\n//. R.add(2, true);\n//. // => 3\n//. ```\n//.\n//. There is a performance cost to run-time type checking. One may wish to\n//. disable type checking in certain contexts to avoid paying this cost.\n//. [`create`](#create) facilitates the creation of a Sanctuary module which\n//. does not perform type checking.\n//.\n//. In Node, one could use an environment variable to determine whether to\n//. perform type checking:\n//.\n//. ```javascript\n//. const {create, env} = require('sanctuary');\n//.\n//. const checkTypes = process.env.NODE_ENV !== 'production';\n//. const S = create({checkTypes, env});\n//. ```\n//.\n//. ## API\n\n(function(f) {\n\n  'use strict';\n\n  /* istanbul ignore else */\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = f(__webpack_require__(3),\n                       __webpack_require__(15),\n                       __webpack_require__(1));\n  } else if (\"function\" === 'function' && __webpack_require__(0) != null) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3),\n            __webpack_require__(15),\n            __webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {\n    self.sanctuary = f(self.sanctuaryDef,\n                       self.sanctuaryTypeClasses,\n                       self.sanctuaryTypeIdentifiers);\n  }\n\n}(function($, Z, type) {\n\n  'use strict';\n\n  //  Fn :: (Type, Type) -> Type\n  function Fn(x, y) { return $.Function([x, y]); }\n\n  //  flip$ :: ((a, b) -> c) -> b -> a -> c\n  function flip$(f) {\n    return function(x) {\n      return function(y) {\n        return f(y, x);\n      };\n    };\n  }\n\n  //  toObject :: a -> Object\n  function toObject(x) {\n    return x == null ? Object.create(null) : Object(x);\n  }\n\n  //  typeEq :: String -> a -> Boolean\n  function typeEq(typeIdent) {\n    return function(x) {\n      return type(x) === typeIdent;\n    };\n  }\n\n  //  uncurry2 :: (a -> b -> c) -> ((a, b) -> c)\n  function uncurry2(f) {\n    return function(x, y) {\n      return f(x)(y);\n    };\n  }\n\n  //  readmeUrl :: String -> String\n  function readmeUrl(id) {\n    var version = '0.14.1';  // updated programmatically\n    return 'https://github.com/sanctuary-js/sanctuary/tree/v' + version +\n           '#' + id;\n  }\n\n  //  :: Type\n  var a = $.TypeVariable('a');\n  var b = $.TypeVariable('b');\n  var c = $.TypeVariable('c');\n  var d = $.TypeVariable('d');\n  var e = $.TypeVariable('e');\n  var g = $.TypeVariable('g');\n  var l = $.TypeVariable('l');\n  var r = $.TypeVariable('r');\n\n  //  :: Type -> Type\n  var f = $.UnaryTypeVariable('f');\n  var m = $.UnaryTypeVariable('m');\n  var t = $.UnaryTypeVariable('t');\n  var w = $.UnaryTypeVariable('w');\n\n  //  :: Type -> Type -> Type\n  var p = $.BinaryTypeVariable('p');\n  var s = $.BinaryTypeVariable('s');\n\n  //  eitherTypeIdent :: String\n  var eitherTypeIdent = 'sanctuary/Either';\n\n  //  $Either :: Type -> Type -> Type\n  var $Either = $.BinaryType(\n    eitherTypeIdent,\n    readmeUrl('EitherType'),\n    typeEq(eitherTypeIdent),\n    function(either) { return either.isLeft ? [either.value] : []; },\n    function(either) { return either.isRight ? [either.value] : []; }\n  );\n\n  //  List :: Type -> Type\n  var List = $.UnaryType(\n    'sanctuary/List',\n    readmeUrl('list'),\n    function(x) { return $.String._test(x) || Array.isArray(x); },\n    function(list) { return $.String._test(list) ? [] : list; }\n  );\n\n  //  maybeTypeIdent :: String\n  var maybeTypeIdent = 'sanctuary/Maybe';\n\n  //  $Maybe :: Type -> Type\n  var $Maybe = $.UnaryType(\n    maybeTypeIdent,\n    readmeUrl('MaybeType'),\n    typeEq(maybeTypeIdent),\n    function(maybe) { return maybe.isJust ? [maybe.value] : []; }\n  );\n\n  //  TypeRep :: Type -> Type\n  var TypeRep = $.UnaryType(\n    'sanctuary/TypeRep',\n    readmeUrl('type-representatives'),\n    function(x) {\n      return $.AnyFunction._test(x) ||\n             x != null && $.String._test(x['@@type']);\n    },\n    function(typeRep) { return []; }\n  );\n\n  //  defaultEnv :: Array Type\n  var defaultEnv = Z.concat($.env, [\n    $.FiniteNumber,\n    $.NonZeroFiniteNumber,\n    $Either($.Unknown, $.Unknown),\n    Fn($.Unknown, $.Unknown),\n    $.GlobalRegExp,\n    $.NonGlobalRegExp,\n    $.Integer,\n    $.NonNegativeInteger,\n    $Maybe($.Unknown),\n    $.Pair($.Unknown, $.Unknown),\n    $.RegexFlags,\n    $.ValidDate,\n    $.ValidNumber\n  ]);\n\n  //  Options :: Type\n  var Options = $.RecordType({checkTypes: $.Boolean, env: $.Array($.Any)});\n\n  //  createSanctuary :: Options -> Module\n  function createSanctuary(opts) {\n\n  /* eslint-disable indent */\n\n  //  checkTypes :: Boolean\n  var checkTypes = opts.checkTypes;\n\n  //  env :: Array Type\n  var env = opts.env;\n\n  var S = {};\n\n  //# create :: { checkTypes :: Boolean, env :: Array Type } -> Module\n  //.\n  //. Takes an options record and returns a Sanctuary module. `checkTypes`\n  //. specifies whether to enable type checking. The module's polymorphic\n  //. functions (such as [`I`](#I)) require each value associated with a\n  //. type variable to be a member of at least one type in the environment.\n  //.\n  //. A well-typed application of a Sanctuary function will produce the same\n  //. result regardless of whether type checking is enabled. If type checking\n  //. is enabled, a badly typed application will produce an exception with a\n  //. descriptive error message.\n  //.\n  //. The following snippet demonstrates defining a custom type and using\n  //. `create` to produce a Sanctuary module which is aware of that type:\n  //.\n  //. ```javascript\n  //. const {create, env} = require('sanctuary');\n  //. const $ = require('sanctuary-def');\n  //. const type = require('sanctuary-type-identifiers');\n  //.\n  //. //    Identity :: a -> Identity a\n  //. const Identity = function Identity(x) {\n  //.   if (!(this instanceof Identity)) return new Identity(x);\n  //.   this.value = x;\n  //. };\n  //.\n  //. Identity['@@type'] = 'my-package/Identity@1';\n  //.\n  //. Identity.prototype['fantasy-land/map'] = function(f) {\n  //.   return Identity(f(this.value));\n  //. };\n  //.\n  //. //    IdentityType :: Type -> Type\n  //. const IdentityType = $.UnaryType(\n  //.   Identity['@@type'],\n  //.   'http://example.com/my-package#Identity',\n  //.   x => type(x) === Identity['@@type'],\n  //.   identity => [identity.value]\n  //. );\n  //.\n  //. const S = create({\n  //.   checkTypes: process.env.NODE_ENV !== 'production',\n  //.   env: env.concat([IdentityType($.Unknown)]),\n  //. });\n  //.\n  //. S.map(S.sub(1), Identity(43));\n  //. // => Identity(42)\n  //. ```\n  //.\n  //. See also [`env`](#env).\n  S.create =\n  $.create({checkTypes: checkTypes, env: defaultEnv})('create',\n                                                      {},\n                                                      [Options, $.Object],\n                                                      createSanctuary);\n\n  //# env :: Array Type\n  //.\n  //. The default environment, which may be used as is or as the basis of a\n  //. custom environment in conjunction with [`create`](#create).\n  S.env = defaultEnv;\n\n  /* istanbul ignore if */\n  if (typeof __doctest !== 'undefined') {\n    /* global __doctest:false */\n    /* eslint-disable no-unused-vars */\n    var _List = __doctest.require('./test/internal/List');\n    var Cons = _List.Cons;\n    var Nil = _List.Nil;\n    var Sum = __doctest.require('./test/internal/Sum');\n    /* eslint-enable no-unused-vars */\n    env = Z.concat(env, [_List.Type($.Unknown), Sum.Type]);\n  }\n\n  var def = $.create({checkTypes: checkTypes, env: env});\n\n  //. ### Placeholder\n  //.\n  //. Sanctuary functions are designed with partial application in mind.\n  //. In many cases one can define a more specific function in terms of\n  //. a more general one simply by applying the more general function to\n  //. some (but not all) of its arguments. For example, one could define\n  //. `sum :: Foldable f => f Number -> Number` as `S.reduce(S.add, 0)`.\n  //.\n  //. In some cases, though, there are multiple orders in which one may\n  //. wish to provide a function's arguments. `S.concat('prefix')` is a\n  //. function which prefixes its argument, but how would one define a\n  //. function which suffixes its argument? It's possible with the help\n  //. of [`__`](#__), the special placeholder value.\n  //.\n  //. The placeholder indicates a hole to be filled at some future time.\n  //. The following are all equivalent (`_` represents the placeholder):\n  //.\n  //.   - `f(x, y, z)`\n  //.   - `f(_, y, z)(x)`\n  //.   - `f(_, _, z)(x, y)`\n  //.   - `f(_, _, z)(_, y)(x)`\n\n  //# __ :: Placeholder\n  //.\n  //. The special [placeholder](#placeholder) value.\n  //.\n  //. ```javascript\n  //. > S.map(S.concat('@'), ['foo', 'bar', 'baz'])\n  //. ['@foo', '@bar', '@baz']\n  //.\n  //. > S.map(S.concat(S.__, '?'), ['foo', 'bar', 'baz'])\n  //. ['foo?', 'bar?', 'baz?']\n  //. ```\n  S.__ = $.__;\n\n  //. ### Classify\n\n  //# type :: Any -> { namespace :: Maybe String, name :: String, version :: NonNegativeInteger }\n  //.\n  //. Returns the result of parsing the [type identifier][] of the given value.\n  //.\n  //. ```javascript\n  //. > S.type(S.Just(42))\n  //. {namespace: Just('sanctuary'), name: 'Maybe', version: 0}\n  //.\n  //. > S.type([1, 2, 3])\n  //. {namespace: Nothing, name: 'Array', version: 0}\n  //. ```\n  S.type =\n  def('type',\n      {},\n      [$.Any,\n       $.RecordType({namespace: $Maybe($.String),\n                     name: $.String,\n                     version: $.NonNegativeInteger})],\n      function(x) {\n        var r = type.parse(type(x));\n        r.namespace = toMaybe(r.namespace);\n        return r;\n      });\n\n  //# is :: TypeRep a -> Any -> Boolean\n  //.\n  //. Takes a [type representative](#type-representatives) and a value of any\n  //. type and returns `true` [iff][] the given value is of the specified type.\n  //. Subtyping is not respected.\n  //.\n  //. ```javascript\n  //. > S.is(Number, 42)\n  //. true\n  //.\n  //. > S.is(Object, 42)\n  //. false\n  //.\n  //. > S.is(String, 42)\n  //. false\n  //. ```\n  function is(typeRep, x) {\n    var xType = type(x);\n    if ($.String._test(typeRep['@@type'])) {\n      return xType === typeRep['@@type'];\n    } else {\n      var match = /function (\\w*)/.exec(typeRep);\n      return match != null && match[1] === xType;\n    }\n  }\n  S.is = def('is', {}, [TypeRep(a), $.Any, $.Boolean], is);\n\n  //. ### Showable\n\n  //# toString :: Any -> String\n  //.\n  //. Alias of [`Z.toString`][].\n  //.\n  //. ```javascript\n  //. > S.toString(-0)\n  //. '-0'\n  //.\n  //. > S.toString(['foo', 'bar', 'baz'])\n  //. '[\"foo\", \"bar\", \"baz\"]'\n  //.\n  //. > S.toString({x: 1, y: 2, z: 3})\n  //. '{\"x\": 1, \"y\": 2, \"z\": 3}'\n  //.\n  //. > S.toString(S.Left(S.Right(S.Just(S.Nothing))))\n  //. 'Left(Right(Just(Nothing)))'\n  //. ```\n  S.toString = def('toString', {}, [$.Any, $.String], Z.toString);\n\n  //. ### Fantasy Land\n  //.\n  //. Sanctuary is compatible with the [Fantasy Land][] specification.\n\n  //# equals :: Setoid a => a -> a -> Boolean\n  //.\n  //. Curried version of [`Z.equals`][] which requires two arguments of the\n  //. same type.\n  //.\n  //. To compare values of different types first use [`create`](#create) to\n  //. create a Sanctuary module with type checking disabled, then use that\n  //. module's `equals` function.\n  //.\n  //. ```javascript\n  //. > S.equals(0, -0)\n  //. true\n  //.\n  //. > S.equals(NaN, NaN)\n  //. true\n  //.\n  //. > S.equals(S.Just([1, 2, 3]), S.Just([1, 2, 3]))\n  //. true\n  //.\n  //. > S.equals(S.Just([1, 2, 3]), S.Just([1, 2, 4]))\n  //. false\n  //. ```\n  S.equals = def('equals', {a: [Z.Setoid]}, [a, a, $.Boolean], Z.equals);\n\n  //# lt :: Ord a => a -> (a -> Boolean)\n  //.\n  //. Returns `true` [iff][] the *second* argument is less than the first\n  //. according to [`Z.lt`][]. The arguments must be provided one at a time.\n  //.\n  //. See also [`lt_`](#lt_).\n  //.\n  //. ```javascript\n  //. > S.filter(S.lt(3), [1, 2, 3, 4, 5])\n  //. [1, 2]\n  //. ```\n  S.lt = def('lt', {a: [Z.Ord]}, [a, $.Predicate(a)], flip$(Z.lt));\n\n  //# lt_ :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the first argument is less than the second\n  //. according to [`Z.lt`][].\n  //.\n  //. See also [`lt`](#lt).\n  //.\n  //. ```javascript\n  //. > S.lt_([1, 2, 3], [1, 2, 3])\n  //. false\n  //.\n  //. > S.lt_([1, 2, 3], [1, 2, 4])\n  //. true\n  //.\n  //. > S.lt_([1, 2, 3], [1, 2])\n  //. false\n  //. ```\n  S.lt_ = def('lt_', {a: [Z.Ord]}, [a, a, $.Boolean], Z.lt);\n\n  //# lte :: Ord a => a -> (a -> Boolean)\n  //.\n  //. Returns `true` [iff][] the *second* argument is less than or equal to\n  //. the first according to [`Z.lte`][]. The arguments must be provided one\n  //. at a time.\n  //.\n  //. See also [`lte_`](#lte_).\n  //.\n  //. ```javascript\n  //. > S.filter(S.lte(3), [1, 2, 3, 4, 5])\n  //. [1, 2, 3]\n  //. ```\n  S.lte = def('lte', {a: [Z.Ord]}, [a, $.Predicate(a)], flip$(Z.lte));\n\n  //# lte_ :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the first argument is less than or equal to the\n  //. second according to [`Z.lte`][].\n  //.\n  //. See also [`lte`](#lte).\n  //.\n  //. ```javascript\n  //. > S.lte_([1, 2, 3], [1, 2, 3])\n  //. true\n  //.\n  //. > S.lte_([1, 2, 3], [1, 2, 4])\n  //. true\n  //.\n  //. > S.lte_([1, 2, 3], [1, 2])\n  //. false\n  //. ```\n  S.lte_ = def('lte_', {a: [Z.Ord]}, [a, a, $.Boolean], Z.lte);\n\n  //# gt :: Ord a => a -> (a -> Boolean)\n  //.\n  //. Returns `true` [iff][] the *second* argument is greater than the first\n  //. according to [`Z.gt`][]. The arguments must be provided one at a time.\n  //.\n  //. See also [`gt_`](#gt_).\n  //.\n  //. ```javascript\n  //. > S.filter(S.gt(3), [1, 2, 3, 4, 5])\n  //. [4, 5]\n  //. ```\n  S.gt = def('gt', {a: [Z.Ord]}, [a, $.Predicate(a)], flip$(Z.gt));\n\n  //# gt_ :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the first argument is greater than the second\n  //. according to [`Z.gt`][].\n  //.\n  //. See also [`gt`](#gt).\n  //.\n  //. ```javascript\n  //. > S.gt_([1, 2, 3], [1, 2, 3])\n  //. false\n  //.\n  //. > S.gt_([1, 2, 3], [1, 2, 4])\n  //. false\n  //.\n  //. > S.gt_([1, 2, 3], [1, 2])\n  //. true\n  //. ```\n  S.gt_ = def('gt_', {a: [Z.Ord]}, [a, a, $.Boolean], Z.gt);\n\n  //# gte :: Ord a => a -> (a -> Boolean)\n  //.\n  //. Returns `true` [iff][] the *second* argument is greater than or equal\n  //. to the first according to [`Z.gte`][]. The arguments must be provided\n  //. one at a time.\n  //.\n  //. See also [`gte_`](#gte_).\n  //.\n  //. ```javascript\n  //. > S.filter(S.gte(3), [1, 2, 3, 4, 5])\n  //. [3, 4, 5]\n  //. ```\n  S.gte = def('gte', {a: [Z.Ord]}, [a, $.Predicate(a)], flip$(Z.gte));\n\n  //# gte_ :: Ord a => a -> a -> Boolean\n  //.\n  //. Returns `true` [iff][] the first argument is greater than or equal to\n  //. the second according to [`Z.gte`][].\n  //.\n  //. See also [`gte`](#gte).\n  //.\n  //. ```javascript\n  //. > S.gte_([1, 2, 3], [1, 2, 3])\n  //. true\n  //.\n  //. > S.gte_([1, 2, 3], [1, 2, 4])\n  //. false\n  //.\n  //. > S.gte_([1, 2, 3], [1, 2])\n  //. true\n  //. ```\n  S.gte_ = def('gte_', {a: [Z.Ord]}, [a, a, $.Boolean], Z.gte);\n\n  //# min :: Ord a => a -> a -> a\n  //.\n  //. Returns the smaller of its two arguments (according to [`Z.lte`][]).\n  //.\n  //. See also [`max`](#max).\n  //.\n  //. ```javascript\n  //. > S.min(10, 2)\n  //. 2\n  //.\n  //. > S.min(new Date('1999-12-31'), new Date('2000-01-01'))\n  //. new Date('1999-12-31')\n  //.\n  //. > S.min('10', '2')\n  //. '10'\n  //. ```\n  S.min = def('min', {a: [Z.Ord]}, [a, a, a], Z.min);\n\n  //# max :: Ord a => a -> a -> a\n  //.\n  //. Returns the larger of its two arguments (according to [`Z.lte`][]).\n  //.\n  //. See also [`min`](#min).\n  //.\n  //. ```javascript\n  //. > S.max(10, 2)\n  //. 10\n  //.\n  //. > S.max(new Date('1999-12-31'), new Date('2000-01-01'))\n  //. new Date('2000-01-01')\n  //.\n  //. > S.max('10', '2')\n  //. '2'\n  //. ```\n  S.max = def('max', {a: [Z.Ord]}, [a, a, a], Z.max);\n\n  //# id :: Category c => TypeRep c -> c\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.id`][].\n  //.\n  //. ```javascript\n  //. > S.id(Function)(42)\n  //. 42\n  //. ```\n  S.id = def('id', {c: [Z.Category]}, [TypeRep(c), c], Z.id);\n\n  //# concat :: Semigroup a => a -> a -> a\n  //.\n  //. Curried version of [`Z.concat`][].\n  //.\n  //. ```javascript\n  //. > S.concat('abc', 'def')\n  //. 'abcdef'\n  //.\n  //. > S.concat([1, 2, 3], [4, 5, 6])\n  //. [1, 2, 3, 4, 5, 6]\n  //.\n  //. > S.concat({x: 1, y: 2}, {y: 3, z: 4})\n  //. {x: 1, y: 3, z: 4}\n  //.\n  //. > S.concat(S.Just([1, 2, 3]), S.Just([4, 5, 6]))\n  //. Just([1, 2, 3, 4, 5, 6])\n  //.\n  //. > S.concat(Sum(18), Sum(24))\n  //. Sum(42)\n  //. ```\n  S.concat = def('concat', {a: [Z.Semigroup]}, [a, a, a], Z.concat);\n\n  //# empty :: Monoid a => TypeRep a -> a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.empty`][].\n  //.\n  //. ```javascript\n  //. > S.empty(String)\n  //. ''\n  //.\n  //. > S.empty(Array)\n  //. []\n  //.\n  //. > S.empty(Object)\n  //. {}\n  //.\n  //. > S.empty(Sum)\n  //. Sum(0)\n  //. ```\n  S.empty = def('empty', {a: [Z.Monoid]}, [TypeRep(a), a], Z.empty);\n\n  //# invert :: Group g => g -> g\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.invert`][].\n  //.\n  //. ```javascript\n  //. > S.invert(Sum(5))\n  //. Sum(-5)\n  //. ```\n  S.invert = def('invert', {g: [Z.Group]}, [g, g], Z.invert);\n\n  //# map :: Functor f => (a -> b) -> f a -> f b\n  //.\n  //. Curried version of [`Z.map`][].\n  //.\n  //. ```javascript\n  //. > S.map(Math.sqrt, [1, 4, 9])\n  //. [1, 2, 3]\n  //.\n  //. > S.map(Math.sqrt, {x: 1, y: 4, z: 9})\n  //. {x: 1, y: 2, z: 3}\n  //.\n  //. > S.map(Math.sqrt, S.Just(9))\n  //. Just(3)\n  //.\n  //. > S.map(Math.sqrt, S.Right(9))\n  //. Right(3)\n  //. ```\n  //.\n  //. Replacing `Functor f => f` with `Function x` produces the B combinator\n  //. from combinatory logic (i.e. [`compose`](#compose)):\n  //.\n  //.     Functor f => (a -> b) -> f a -> f b\n  //.     (a -> b) -> Function x a -> Function x b\n  //.     (a -> c) -> Function x a -> Function x c\n  //.     (b -> c) -> Function x b -> Function x c\n  //.     (b -> c) -> Function a b -> Function a c\n  //.     (b -> c) -> (a -> b) -> (a -> c)\n  //.\n  //. ```javascript\n  //. > S.map(Math.sqrt, S.add(1))(99)\n  //. 10\n  //. ```\n  S.map = def('map', {f: [Z.Functor]}, [Fn(a, b), f(a), f(b)], Z.map);\n\n  //# bimap :: Bifunctor f => (a -> b) -> (c -> d) -> f a c -> f b d\n  //.\n  //. Curried version of [`Z.bimap`][].\n  //.\n  //. ```javascript\n  //. > S.bimap(S.toUpper, Math.sqrt, S.Left('foo'))\n  //. Left('FOO')\n  //.\n  //. > S.bimap(S.toUpper, Math.sqrt, S.Right(64))\n  //. Right(8)\n  //. ```\n  S.bimap =\n  def('bimap',\n      {p: [Z.Bifunctor]},\n      [Fn(a, b), Fn(c, d), p(a, c), p(b, d)],\n      Z.bimap);\n\n  //# promap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d\n  //.\n  //. Curried version of [`Z.promap`][].\n  //.\n  //. ```javascript\n  //. > S.promap(Math.abs, S.add(1), Math.sqrt)(-100)\n  //. 11\n  //. ```\n  S.promap =\n  def('promap',\n      {p: [Z.Profunctor]},\n      [Fn(a, b), Fn(c, d), p(b, c), p(a, d)],\n      Z.promap);\n\n  //# alt :: Alt f => f a -> f a -> f a\n  //.\n  //. Curried version of [`Z.alt`][].\n  //.\n  //. ```javascript\n  //. > S.alt(S.Nothing, S.Just(1))\n  //. Just(1)\n  //.\n  //. > S.alt(S.Just(2), S.Just(3))\n  //. Just(2)\n  //.\n  //. > S.alt(S.Left('X'), S.Right(1))\n  //. Right(1)\n  //.\n  //. > S.alt(S.Right(2), S.Right(3))\n  //. Right(2)\n  //. ```\n  S.alt = def('alt', {f: [Z.Alt]}, [f(a), f(a), f(a)], Z.alt);\n\n  //# zero :: Plus f => TypeRep f -> f a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.zero`][].\n  //.\n  //. ```javascript\n  //. > S.zero(Array)\n  //. []\n  //.\n  //. > S.zero(Object)\n  //. {}\n  //.\n  //. > S.zero(S.Maybe)\n  //. Nothing\n  //. ```\n  S.zero =\n  def('zero', {f: [Z.Plus]}, [TypeRep($.TypeVariable('f')), f(a)], Z.zero);\n\n  //# reduce :: Foldable f => (b -> a -> b) -> b -> f a -> b\n  //.\n  //. Takes a curried binary function, an initial value, and a [Foldable][],\n  //. and applies the function to the initial value and the Foldable's first\n  //. value, then applies the function to the result of the previous\n  //. application and the Foldable's second value. Repeats this process\n  //. until each of the Foldable's values has been used. Returns the initial\n  //. value if the Foldable is empty; the result of the final application\n  //. otherwise.\n  //.\n  //. ```javascript\n  //. > S.reduce(S.add, 0, [1, 2, 3, 4, 5])\n  //. 15\n  //.\n  //. > S.reduce(xs => x => [x].concat(xs), [], [1, 2, 3, 4, 5])\n  //. [5, 4, 3, 2, 1]\n  //. ```\n  function reduce(f, initial, foldable) {\n    return Z.reduce(uncurry2(f), initial, foldable);\n  }\n  S.reduce =\n  def('reduce', {f: [Z.Foldable]}, [Fn(a, Fn(b, a)), a, f(b), a], reduce);\n\n  //# traverse :: (Applicative f, Traversable t) => TypeRep f -> (a -> f b) -> t a -> f (t b)\n  //.\n  //. Curried version of [`Z.traverse`][].\n  //.\n  //. ```javascript\n  //. > S.traverse(Array, S.words, S.Just('foo bar baz'))\n  //. [Just('foo'), Just('bar'), Just('baz')]\n  //.\n  //. > S.traverse(Array, S.words, S.Nothing)\n  //. [Nothing]\n  //.\n  //. > S.traverse(S.Maybe, S.parseInt(16), ['A', 'B', 'C'])\n  //. Just([10, 11, 12])\n  //.\n  //. > S.traverse(S.Maybe, S.parseInt(16), ['A', 'B', 'C', 'X'])\n  //. Nothing\n  //.\n  //. > S.traverse(S.Maybe, S.parseInt(16), {a: 'A', b: 'B', c: 'C'})\n  //. Just({a: 10, b: 11, c: 12})\n  //.\n  //. > S.traverse(S.Maybe, S.parseInt(16), {a: 'A', b: 'B', c: 'C', x: 'X'})\n  //. Nothing\n  //. ```\n  S.traverse =\n  def('traverse',\n      {f: [Z.Applicative], t: [Z.Traversable]},\n      [TypeRep($.TypeVariable('f')), Fn(a, f(b)), t(a), f(t(b))],\n      Z.traverse);\n\n  //# sequence :: (Applicative f, Traversable t) => TypeRep f -> t (f a) -> f (t a)\n  //.\n  //. Curried version of [`Z.sequence`][]. Inverts the given `t (f a)`\n  //. to produce an `f (t a)`.\n  //.\n  //. ```javascript\n  //. > S.sequence(Array, S.Just([1, 2, 3]))\n  //. [Just(1), Just(2), Just(3)]\n  //.\n  //. > S.sequence(S.Maybe, [S.Just(1), S.Just(2), S.Just(3)])\n  //. Just([1, 2, 3])\n  //.\n  //. > S.sequence(S.Maybe, [S.Just(1), S.Just(2), S.Nothing])\n  //. Nothing\n  //.\n  //. > S.sequence(S.Maybe, {a: S.Just(1), b: S.Just(2), c: S.Just(3)})\n  //. Just({a: 1, b: 2, c: 3})\n  //.\n  //. > S.sequence(S.Maybe, {a: S.Just(1), b: S.Just(2), c: S.Nothing})\n  //. Nothing\n  //. ```\n  S.sequence =\n  def('sequence',\n      {f: [Z.Applicative], t: [Z.Traversable]},\n      [TypeRep($.TypeVariable('f')), t(f(a)), f(t(a))],\n      Z.sequence);\n\n  //# ap :: Apply f => f (a -> b) -> f a -> f b\n  //.\n  //. Curried version of [`Z.ap`][].\n  //.\n  //. ```javascript\n  //. > S.ap([Math.sqrt, x => x * x], [1, 4, 9, 16, 25])\n  //. [1, 2, 3, 4, 5, 1, 16, 81, 256, 625]\n  //.\n  //. > S.ap({x: Math.sqrt, y: S.add(1), z: S.sub(1)}, {w: 4, x: 4, y: 4})\n  //. {x: 2, y: 5}\n  //.\n  //. > S.ap(S.Just(Math.sqrt), S.Just(64))\n  //. Just(8)\n  //. ```\n  //.\n  //. Replacing `Apply f => f` with `Function x` produces the S combinator\n  //. from combinatory logic:\n  //.\n  //.     Apply f => f (a -> b) -> f a -> f b\n  //.     Function x (a -> b) -> Function x a -> Function x b\n  //.     Function x (a -> c) -> Function x a -> Function x c\n  //.     Function x (b -> c) -> Function x b -> Function x c\n  //.     Function a (b -> c) -> Function a b -> Function a c\n  //.     (a -> b -> c) -> (a -> b) -> (a -> c)\n  //.\n  //. ```javascript\n  //. > S.ap(s => n => s.slice(0, n), s => Math.ceil(s.length / 2))('Haskell')\n  //. 'Hask'\n  //. ```\n  S.ap =\n  def('ap',\n      {f: [Z.Apply]},\n      [f(Fn(a, b)), f(a), f(b)],\n      Z.ap);\n\n  //# lift2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c\n  //.\n  //. Promotes a curried binary function to a function which operates on two\n  //. [Apply][]s.\n  //.\n  //. ```javascript\n  //. > S.lift2(S.add, S.Just(2), S.Just(3))\n  //. Just(5)\n  //.\n  //. > S.lift2(S.add, S.Just(2), S.Nothing)\n  //. Nothing\n  //.\n  //. > S.lift2(S.and, S.Just(true), S.Just(true))\n  //. Just(true)\n  //.\n  //. > S.lift2(S.and, S.Just(true), S.Just(false))\n  //. Just(false)\n  //. ```\n  S.lift2 =\n  def('lift2', {f: [Z.Apply]}, [Fn(a, Fn(b, c)), f(a), f(b), f(c)], Z.lift2);\n\n  //# lift3 :: Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n  //.\n  //. Promotes a curried ternary function to a function which operates on three\n  //. [Apply][]s.\n  //.\n  //. ```javascript\n  //. > S.lift3(S.reduce, S.Just(S.add), S.Just(0), S.Just([1, 2, 3]))\n  //. Just(6)\n  //.\n  //. > S.lift3(S.reduce, S.Just(S.add), S.Just(0), S.Nothing)\n  //. Nothing\n  //. ```\n  S.lift3 =\n  def('lift3',\n      {f: [Z.Apply]},\n      [Fn(a, Fn(b, Fn(c, d))), f(a), f(b), f(c), f(d)],\n      Z.lift3);\n\n  //# apFirst :: Apply f => f a -> f b -> f a\n  //.\n  //. Curried version of [`Z.apFirst`][]. Combines two effectful actions,\n  //. keeping only the result of the first. Equivalent to Haskell's `(<*)`\n  //. function.\n  //.\n  //. See also [`apSecond`](#apSecond).\n  //.\n  //. ```javascript\n  //. > S.apFirst([1, 2], [3, 4])\n  //. [1, 1, 2, 2]\n  //.\n  //. > S.apFirst(S.Just(1), S.Just(2))\n  //. Just(1)\n  //. ```\n  S.apFirst = def('apFirst', {f: [Z.Apply]}, [f(a), f(b), f(a)], Z.apFirst);\n\n  //# apSecond :: Apply f => f a -> f b -> f b\n  //.\n  //. Curried version of [`Z.apSecond`][]. Combines two effectful actions,\n  //. keeping only the result of the second. Equivalent to Haskell's `(*>)`\n  //. function.\n  //.\n  //. See also [`apFirst`](#apFirst).\n  //.\n  //. ```javascript\n  //. > S.apSecond([1, 2], [3, 4])\n  //. [3, 4, 3, 4]\n  //.\n  //. > S.apSecond(S.Just(1), S.Just(2))\n  //. Just(2)\n  //. ```\n  S.apSecond = def('apSecond', {f: [Z.Apply]}, [f(a), f(b), f(b)], Z.apSecond);\n\n  //# of :: Applicative f => TypeRep f -> a -> f a\n  //.\n  //. Curried version of [`Z.of`][].\n  //.\n  //. ```javascript\n  //. > S.of(Array, 42)\n  //. [42]\n  //.\n  //. > S.of(Function, 42)(null)\n  //. 42\n  //.\n  //. > S.of(S.Maybe, 42)\n  //. Just(42)\n  //.\n  //. > S.of(S.Either, 42)\n  //. Right(42)\n  //. ```\n  S.of =\n  def('of',\n      {f: [Z.Applicative]},\n      [TypeRep($.TypeVariable('f')), a, f(a)],\n      Z.of);\n\n  //# chain :: Chain m => (a -> m b) -> m a -> m b\n  //.\n  //. Curried version of [`Z.chain`][].\n  //.\n  //. ```javascript\n  //. > S.chain(x => [x, x], [1, 2, 3])\n  //. [1, 1, 2, 2, 3, 3]\n  //.\n  //. > S.chain(n => s => s.slice(0, n), s => Math.ceil(s.length / 2))('slice')\n  //. 'sli'\n  //.\n  //. > S.chain(S.parseInt(10), S.Just('123'))\n  //. Just(123)\n  //.\n  //. > S.chain(S.parseInt(10), S.Just('XXX'))\n  //. Nothing\n  //. ```\n  S.chain = def('chain', {m: [Z.Chain]}, [Fn(a, m(b)), m(a), m(b)], Z.chain);\n\n  //# join :: Chain m => m (m a) -> m a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.join`][].\n  //. Removes one level of nesting from a nested monadic structure.\n  //.\n  //. ```javascript\n  //. > S.join([[1], [2], [3]])\n  //. [1, 2, 3]\n  //.\n  //. > S.join([[[1, 2, 3]]])\n  //. [[1, 2, 3]]\n  //.\n  //. > S.join(S.Just(S.Just(1)))\n  //. S.Just(1)\n  //. ```\n  //.\n  //. Replacing `Chain m => m` with `Function x` produces the W combinator\n  //. from combinatory logic:\n  //.\n  //.     Chain m => m (m a) -> m a\n  //.     Function x (Function x a) -> Function x a\n  //.     (x -> x -> a) -> (x -> a)\n  //.\n  //. ```javascript\n  //. > S.join(S.concat)('abc')\n  //. 'abcabc'\n  //. ```\n  S.join = def('join', {m: [Z.Chain]}, [m(m(a)), m(a)], Z.join);\n\n  //# chainRec :: ChainRec m => TypeRep m -> (a -> m (Either a b)) -> a -> m b\n  //.\n  //. Performs a [`chain`](#chain)-like computation with constant stack usage.\n  //. Similar to [`Z.chainRec`][], but curried and more convenient due to the\n  //. use of the Either type to indicate completion (via a Right).\n  //.\n  //. ```javascript\n  //. > S.chainRec(Array,\n  //. .            s => s.length === 2 ? S.map(S.Right, [s + '!', s + '?'])\n  //. .                                : S.map(S.Left, [s + 'o', s + 'n']),\n  //. .            '')\n  //. ['oo!', 'oo?', 'on!', 'on?', 'no!', 'no?', 'nn!', 'nn?']\n  //. ```\n  function chainRec(typeRep, f, x) {\n    function step(next, done, x) {\n      return Z.map(function(e) { return either(next, done, e); }, f(x));\n    }\n    return Z.chainRec(typeRep, step, x);\n  }\n  S.chainRec =\n  def('chainRec',\n      {m: [Z.ChainRec]},\n      [TypeRep($.TypeVariable('m')), Fn(a, m($Either(a, b))), a, m(b)],\n      chainRec);\n\n  //# extend :: Extend w => (w a -> b) -> w a -> w b\n  //.\n  //. Curried version of [`Z.extend`][].\n  //.\n  //. ```javascript\n  //. > S.extend(S.joinWith(''), ['x', 'y', 'z'])\n  //. ['xyz', 'yz', 'z']\n  //. ```\n  S.extend =\n  def('extend', {w: [Z.Extend]}, [Fn(w(a), b), w(a), w(b)], Z.extend);\n\n  //# extract :: Comonad w => w a -> a\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.extract`][].\n  S.extract =\n  def('extract', {w: [Z.Comonad]}, [w(a), a], Z.extract);\n\n  //# contramap :: Contravariant f => (b -> a) -> f a -> f b\n  //.\n  //. [Type-safe][sanctuary-def] version of [`Z.contramap`][].\n  //.\n  //. ```javascript\n  //. > S.contramap(s => s.length, Math.sqrt)('Sanctuary')\n  //. 3\n  //. ```\n  S.contramap =\n  def('contramap',\n      {f: [Z.Contravariant]},\n      [Fn(b, a), f(a), f(b)],\n      Z.contramap);\n\n  //# filter :: (Applicative f, Foldable f, Monoid (f a)) => (a -> Boolean) -> f a -> f a\n  //.\n  //. Curried version of [`Z.filter`][]. Filters its second argument in\n  //. accordance with the given predicate.\n  //.\n  //. See also [`filterM`](#filterM).\n  //.\n  //. ```javascript\n  //. > S.filter(S.odd, [1, 2, 3, 4, 5])\n  //. [1, 3, 5]\n  //. ```\n  S.filter =\n  def('filter',\n      {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n      [$.Predicate(a), f(a), f(a)],\n      Z.filter);\n\n  //# filterM :: (Alternative m, Monad m) => (a -> Boolean) -> m a -> m a\n  //.\n  //. Curried version of [`Z.filterM`][]. Filters its second argument in\n  //. accordance with the given predicate.\n  //.\n  //. See also [`filter`](#filter).\n  //.\n  //. ```javascript\n  //. > S.filterM(S.odd, [1, 2, 3, 4, 5])\n  //. [1, 3, 5]\n  //.\n  //. > S.filterM(S.odd, S.Just(9))\n  //. Just(9)\n  //.\n  //. > S.filterM(S.odd, S.Just(4))\n  //. Nothing\n  //. ```\n  S.filterM =\n  def('filterM',\n      {m: [Z.Alternative, Z.Monad]},\n      [$.Predicate(a), m(a), m(a)],\n      Z.filterM);\n\n  //# takeWhile :: (Foldable f, Alternative f) => (a -> Boolean) -> f a -> f a\n  //.\n  //. Discards the first inner value which does not satisfy the predicate, and\n  //. all subsequent inner values.\n  //.\n  //. ```javascript\n  //. > S.takeWhile(S.odd, [3, 3, 3, 7, 6, 3, 5, 4])\n  //. [3, 3, 3, 7]\n  //.\n  //. > S.takeWhile(S.even, [3, 3, 3, 7, 6, 3, 5, 4])\n  //. []\n  //. ```\n  S.takeWhile =\n  def('takeWhile',\n      {f: [Z.Foldable, Z.Alternative]},\n      [$.Predicate(a), f(a), f(a)],\n      Z.takeWhile);\n\n  //# dropWhile :: (Foldable f, Alternative f) => (a -> Boolean) -> f a -> f a\n  //.\n  //. Retains the first inner value which does not satisfy the predicate, and\n  //. all subsequent inner values.\n  //.\n  //. ```javascript\n  //. > S.dropWhile(S.odd, [3, 3, 3, 7, 6, 3, 5, 4])\n  //. [6, 3, 5, 4]\n  //.\n  //. > S.dropWhile(S.even, [3, 3, 3, 7, 6, 3, 5, 4])\n  //. [3, 3, 3, 7, 6, 3, 5, 4]\n  //. ```\n  S.dropWhile =\n  def('dropWhile',\n      {f: [Z.Foldable, Z.Alternative]},\n      [$.Predicate(a), f(a), f(a)],\n      Z.dropWhile);\n\n  //. ### Combinator\n\n  //# I :: a -> a\n  //.\n  //. The I combinator. Returns its argument. Equivalent to Haskell's `id`\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.I('foo')\n  //. 'foo'\n  //. ```\n  function I(x) {\n    return x;\n  }\n  S.I = def('I', {}, [a, a], I);\n\n  //# K :: a -> b -> a\n  //.\n  //. The K combinator. Takes two values and returns the first. Equivalent to\n  //. Haskell's `const` function.\n  //.\n  //. ```javascript\n  //. > S.K('foo', 'bar')\n  //. 'foo'\n  //.\n  //. > S.map(S.K(42), S.range(0, 5))\n  //. [42, 42, 42, 42, 42]\n  //. ```\n  function K(x, y) {\n    return x;\n  }\n  S.K = def('K', {}, [a, b, a], K);\n\n  //# A :: (a -> b) -> a -> b\n  //.\n  //. The A combinator. Takes a function and a value, and returns the result\n  //. of applying the function to the value. Equivalent to Haskell's `($)`\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.A(S.add(1), 42)\n  //. 43\n  //.\n  //. > S.map(S.A(S.__, 100), [S.add(1), Math.sqrt])\n  //. [101, 10]\n  //. ```\n  function A(f, x) {\n    return f(x);\n  }\n  S.A = def('A', {}, [Fn(a, b), a, b], A);\n\n  //# T :: a -> (a -> b) -> b\n  //.\n  //. The T ([thrush][]) combinator. Takes a value and a function, and returns\n  //. the result of applying the function to the value. Equivalent to Haskell's\n  //. `(&)` function.\n  //.\n  //. ```javascript\n  //. > S.T(42, S.add(1))\n  //. 43\n  //.\n  //. > S.map(S.T(100), [S.add(1), Math.sqrt])\n  //. [101, 10]\n  //. ```\n  function T(x, f) {\n    return f(x);\n  }\n  S.T = def('T', {}, [a, Fn(a, b), b], T);\n\n  //. ### Function\n\n  //# curry2 :: ((a, b) -> c) -> a -> b -> c\n  //.\n  //. Curries the given binary function.\n  //.\n  //. ```javascript\n  //. > S.map(S.curry2(Math.pow)(10), [1, 2, 3])\n  //. [10, 100, 1000]\n  //.\n  //. > S.map(S.curry2(Math.pow, 10), [1, 2, 3])\n  //. [10, 100, 1000]\n  //. ```\n  function curry2(f, x, y) {\n    return f(x, y);\n  }\n  S.curry2 =\n  def('curry2',\n      {},\n      [$.Function([a, b, c]), a, b, c],\n      curry2);\n\n  //# curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d\n  //.\n  //. Curries the given ternary function.\n  //.\n  //. ```javascript\n  //. > global.replaceString = S.curry3((what, replacement, string) =>\n  //. .   string.replace(what, replacement)\n  //. . )\n  //. replaceString\n  //.\n  //. > replaceString('banana')('orange')('banana icecream')\n  //. 'orange icecream'\n  //.\n  //. > replaceString('banana', 'orange', 'banana icecream')\n  //. 'orange icecream'\n  //. ```\n  function curry3(f, x, y, z) {\n    return f(x, y, z);\n  }\n  S.curry3 =\n  def('curry3',\n      {},\n      [$.Function([a, b, c, d]), a, b, c, d],\n      curry3);\n\n  //# curry4 :: ((a, b, c, d) -> e) -> a -> b -> c -> d -> e\n  //.\n  //. Curries the given quaternary function.\n  //.\n  //. ```javascript\n  //. > global.createRect = S.curry4((x, y, width, height) =>\n  //. .   ({x, y, width, height})\n  //. . )\n  //. createRect\n  //.\n  //. > createRect(0)(0)(10)(10)\n  //. {x: 0, y: 0, width: 10, height: 10}\n  //.\n  //. > createRect(0, 0, 10, 10)\n  //. {x: 0, y: 0, width: 10, height: 10}\n  //. ```\n  function curry4(f, w, x, y, z) {\n    return f(w, x, y, z);\n  }\n  S.curry4 =\n  def('curry4',\n      {},\n      [$.Function([a, b, c, d, e]), a, b, c, d, e],\n      curry4);\n\n  //# curry5 :: ((a, b, c, d, e) -> f) -> a -> b -> c -> d -> e -> f\n  //.\n  //. Curries the given quinary function.\n  //.\n  //. ```javascript\n  //. > global.toUrl = S.curry5((protocol, creds, hostname, port, pathname) =>\n  //. .   protocol + '//' +\n  //. .   S.maybe('', _ => _.username + ':' + _.password + '@', creds) +\n  //. .   hostname +\n  //. .   S.maybe('', S.concat(':'), port) +\n  //. .   pathname\n  //. . )\n  //. toUrl\n  //.\n  //. > toUrl('https:')(S.Nothing)('example.com')(S.Just('443'))('/foo/bar')\n  //. 'https://example.com:443/foo/bar'\n  //.\n  //. > toUrl('https:', S.Nothing, 'example.com', S.Just('443'), '/foo/bar')\n  //. 'https://example.com:443/foo/bar'\n  //. ```\n  function curry5(f, v, w, x, y, z) {\n    return f(v, w, x, y, z);\n  }\n  S.curry5 =\n  def('curry5',\n      {},\n      [$.Function([a, b, c, d, e, r]), a, b, c, d, e, r],\n      curry5);\n\n  //# flip :: (a -> b -> c) -> b -> a -> c\n  //.\n  //. Takes a curried binary function and two values, and returns the\n  //. result of applying the function to the values in reverse order.\n  //.\n  //. This is the C combinator from combinatory logic.\n  //.\n  //. ```javascript\n  //. > S.flip(S.concat, 'foo', 'bar')\n  //. 'barfoo'\n  //. ```\n  function flip(f, x, y) {\n    return f(y)(x);\n  }\n  S.flip = def('flip', {}, [Fn(a, Fn(b, c)), b, a, c], flip);\n\n  //. ### Composition\n\n  //# compose :: Semigroupoid s => s b c -> s a b -> s a c\n  //.\n  //. Curried version of [`Z.compose`][].\n  //.\n  //. When specialized to Function, `compose` composes two unary functions,\n  //. from right to left (this is the B combinator from combinatory logic).\n  //.\n  //. The generalized type signature indicates that `compose` is compatible\n  //. with any [Semigroupoid][].\n  //.\n  //. See also [`pipe`](#pipe).\n  //.\n  //. ```javascript\n  //. > S.compose(Math.sqrt, S.add(1))(99)\n  //. 10\n  //. ```\n  S.compose =\n  def('compose',\n      {s: [Z.Semigroupoid]},\n      [s(b, c), s(a, b), s(a, c)],\n      Z.compose);\n\n  //# pipe :: [(a -> b), (b -> c), ..., (m -> n)] -> a -> n\n  //.\n  //. Takes an array of functions assumed to be unary and a value of any type,\n  //. and returns the result of applying the sequence of transformations to\n  //. the initial value.\n  //.\n  //. In general terms, `pipe` performs left-to-right composition of an array\n  //. of functions. `pipe([f, g, h], x)` is equivalent to `h(g(f(x)))`.\n  //.\n  //. ```javascript\n  //. > S.pipe([S.add(1), Math.sqrt, S.sub(1)], 99)\n  //. 9\n  //. ```\n  function pipe(fs, x) {\n    return Z.reduce(function(x, f) { return f(x); }, x, fs);\n  }\n  S.pipe = def('pipe', {}, [$.Array($.AnyFunction), a, b], pipe);\n\n  //# on :: (b -> b -> c) -> (a -> b) -> a -> a -> c\n  //.\n  //. Takes a binary function `f`, a unary function `g`, and two\n  //. values `x` and `y`. Returns `f(g(x))(g(y))`.\n  //.\n  //. This is the P combinator from combinatory logic.\n  //.\n  //. ```javascript\n  //. > S.on(S.concat, S.reverse, [1, 2, 3], [4, 5, 6])\n  //. [3, 2, 1, 6, 5, 4]\n  //. ```\n  function on(f, g, x, y) {\n    return f(g(x))(g(y));\n  }\n  S.on = def('on', {}, [Fn(b, Fn(b, c)), Fn(a, b), a, a, c], on);\n\n  //. ### Maybe type\n  //.\n  //. The Maybe type represents optional values: a value of type `Maybe a` is\n  //. either a Just whose value is of type `a` or Nothing (with no value).\n  //.\n  //. The Maybe type satisfies the [Ord][], [Monoid][], [Monad][],\n  //. [Alternative][], [Traversable][], and [Extend][] specifications.\n\n  //# MaybeType :: Type -> Type\n  //.\n  //. A [`UnaryType`][UnaryType] for use with [sanctuary-def][].\n  S.MaybeType = $Maybe;\n\n  //# Maybe :: TypeRep Maybe\n  //.\n  //. The [type representative](#type-representatives) for the Maybe type.\n  var Maybe = S.Maybe = {prototype: _Maybe.prototype};\n\n  Maybe.prototype.constructor = Maybe;\n\n  function _Maybe(tag, value) {\n    this.isNothing = tag === 'Nothing';\n    this.isJust = tag === 'Just';\n    if (this.isJust) this.value = value;\n\n    //  Add \"fantasy-land/concat\" method conditionally so that Just('abc')\n    //  satisfies the requirements of Semigroup but Just(123) does not.\n    if (this.isNothing || Z.Semigroup.test(this.value)) {\n      this['fantasy-land/concat'] = Maybe$prototype$concat;\n    }\n\n    if (this.isNothing || Z.Setoid.test(this.value)) {\n      this['fantasy-land/equals'] = Maybe$prototype$equals;\n    }\n\n    if (this.isNothing || Z.Ord.test(this.value)) {\n      this['fantasy-land/lte'] = Maybe$prototype$lte;\n    }\n  }\n\n  //# Nothing :: Maybe a\n  //.\n  //. Nothing.\n  //.\n  //. ```javascript\n  //. > S.Nothing\n  //. Nothing\n  //. ```\n  var Nothing = S.Nothing = new _Maybe('Nothing');\n\n  //# Just :: a -> Maybe a\n  //.\n  //. Takes a value of any type and returns a Just with the given value.\n  //.\n  //. ```javascript\n  //. > S.Just(42)\n  //. Just(42)\n  //. ```\n  function Just(x) {\n    return new _Maybe('Just', x);\n  }\n  S.Just = def('Just', {}, [a, $Maybe(a)], Just);\n\n  //# Maybe.@@type :: String\n  //.\n  //. Maybe type identifier, `'sanctuary/Maybe'`.\n  Maybe['@@type'] = maybeTypeIdent;\n\n  //# Maybe.fantasy-land/empty :: () -> Maybe a\n  //.\n  //. Returns Nothing.\n  //.\n  //. It is idiomatic to use [`empty`](#empty) rather than use this function\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.empty(S.Maybe)\n  //. Nothing\n  //. ```\n  Maybe['fantasy-land/empty'] = function() { return Nothing; };\n\n  //# Maybe.fantasy-land/of :: a -> Maybe a\n  //.\n  //. Takes a value of any type and returns a Just with the given value.\n  //.\n  //. It is idiomatic to use [`of`](#of) rather than use this function\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.of(S.Maybe, 42)\n  //. Just(42)\n  //. ```\n  Maybe['fantasy-land/of'] = Just;\n\n  //# Maybe.fantasy-land/zero :: () -> Maybe a\n  //.\n  //. Returns Nothing.\n  //.\n  //. It is idiomatic to use [`zero`](#zero) rather than use this function\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.zero(S.Maybe)\n  //. Nothing\n  //. ```\n  Maybe['fantasy-land/zero'] = function() { return Nothing; };\n\n  //# Maybe#isNothing :: Maybe a ~> Boolean\n  //.\n  //. `true` if `this` is Nothing; `false` if `this` is a Just.\n  //.\n  //. ```javascript\n  //. > S.Nothing.isNothing\n  //. true\n  //.\n  //. > S.Just(42).isNothing\n  //. false\n  //. ```\n\n  //# Maybe#isJust :: Maybe a ~> Boolean\n  //.\n  //. `true` if `this` is a Just; `false` if `this` is Nothing.\n  //.\n  //. ```javascript\n  //. > S.Just(42).isJust\n  //. true\n  //.\n  //. > S.Nothing.isJust\n  //. false\n  //. ```\n\n  //# Maybe#toString :: Maybe a ~> () -> String\n  //.\n  //. Returns the string representation of the Maybe.\n  //.\n  //. ```javascript\n  //. > S.toString(S.Nothing)\n  //. 'Nothing'\n  //.\n  //. > S.toString(S.Just([1, 2, 3]))\n  //. 'Just([1, 2, 3])'\n  //. ```\n  Maybe.prototype.toString = function() {\n    return this.isJust ? 'Just(' + Z.toString(this.value) + ')' : 'Nothing';\n  };\n\n  //# Maybe#inspect :: Maybe a ~> () -> String\n  //.\n  //. Returns the string representation of the Maybe. This method is used by\n  //. `util.inspect` and the REPL to format a Maybe for display.\n  //.\n  //. See also [`Maybe#toString`][].\n  //.\n  //. ```javascript\n  //. > S.Nothing.inspect()\n  //. 'Nothing'\n  //.\n  //. > S.Just([1, 2, 3]).inspect()\n  //. 'Just([1, 2, 3])'\n  //. ```\n  Maybe.prototype.inspect = function() { return this.toString(); };\n\n  //# Maybe#fantasy-land/equals :: Setoid a => Maybe a ~> Maybe a -> Boolean\n  //.\n  //. Takes a value `m` of the same type and returns `true` if:\n  //.\n  //.   - `this` and `m` are both Nothing; or\n  //.\n  //.   - `this` and `m` are both Justs, and their values are equal according\n  //.     to [`Z.equals`][].\n  //.\n  //. It is idiomatic to use [`equals`](#equals) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.equals(S.Nothing, S.Nothing)\n  //. true\n  //.\n  //. > S.equals(S.Just([1, 2, 3]), S.Just([1, 2, 3]))\n  //. true\n  //.\n  //. > S.equals(S.Just([1, 2, 3]), S.Just([3, 2, 1]))\n  //. false\n  //.\n  //. > S.equals(S.Just([1, 2, 3]), S.Nothing)\n  //. false\n  //. ```\n  function Maybe$prototype$equals(other) {\n    return this.isNothing ? other.isNothing\n                          : other.isJust && Z.equals(this.value, other.value);\n  }\n\n  //# Maybe#fantasy-land/lte :: Ord a => Maybe a ~> Maybe a -> Boolean\n  //.\n  //. Takes a value `m` of the same type and returns `true` if:\n  //.\n  //.   - `this` is Nothing; or\n  //.\n  //.   - `this` and `m` are both Justs and the value of `this` is less than\n  //.     or equal to the value of `m` according to [`Z.lte`][].\n  //.\n  //. It is idiomatic to use [`lte`](#lte) or [`lte_`](#lte_) rather than use\n  //. this method directly.\n  //.\n  //. ```javascript\n  //. > S.lte_(S.Nothing, S.Nothing)\n  //. true\n  //.\n  //. > S.lte_(S.Nothing, S.Just(0))\n  //. true\n  //.\n  //. > S.lte_(S.Just(0), S.Nothing)\n  //. false\n  //.\n  //. > S.lte_(S.Just(0), S.Just(1))\n  //. true\n  //.\n  //. > S.lte_(S.Just(1), S.Just(0))\n  //. false\n  //. ```\n  function Maybe$prototype$lte(other) {\n    return this.isNothing || other.isJust && Z.lte(this.value, other.value);\n  }\n\n  //# Maybe#fantasy-land/concat :: Semigroup a => Maybe a ~> Maybe a -> Maybe a\n  //.\n  //. Returns the result of concatenating two Maybe values of the same type.\n  //. `a` must have a [Semigroup][].\n  //.\n  //. If `this` is Nothing and the argument is Nothing, this method returns\n  //. Nothing.\n  //.\n  //. If `this` is a Just and the argument is a Just, this method returns a\n  //. Just whose value is the result of concatenating this Just's value and\n  //. the given Just's value.\n  //.\n  //. Otherwise, this method returns the Just.\n  //.\n  //. It is idiomatic to use [`concat`](#concat) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.concat(S.Nothing, S.Nothing)\n  //. Nothing\n  //.\n  //. > S.concat(S.Just([1, 2, 3]), S.Just([4, 5, 6]))\n  //. Just([1, 2, 3, 4, 5, 6])\n  //.\n  //. > S.concat(S.Nothing, S.Just([1, 2, 3]))\n  //. Just([1, 2, 3])\n  //.\n  //. > S.concat(S.Just([1, 2, 3]), S.Nothing)\n  //. Just([1, 2, 3])\n  //. ```\n  function Maybe$prototype$concat(other) {\n    return this.isNothing ?\n      other :\n      other.isNothing ? this : Just(Z.concat(this.value, other.value));\n  }\n\n  //# Maybe#fantasy-land/map :: Maybe a ~> (a -> b) -> Maybe b\n  //.\n  //. Takes a function and returns `this` if `this` is Nothing; otherwise\n  //. it returns a Just whose value is the result of applying the function\n  //. to this Just's value.\n  //.\n  //. It is idiomatic to use [`map`](#map) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.map(Math.sqrt, S.Nothing)\n  //. Nothing\n  //.\n  //. > S.map(Math.sqrt, S.Just(9))\n  //. Just(3)\n  //. ```\n  Maybe.prototype['fantasy-land/map'] = function(f) {\n    return this.isJust ? Just(f(this.value)) : this;\n  };\n\n  //# Maybe#fantasy-land/ap :: Maybe a ~> Maybe (a -> b) -> Maybe b\n  //.\n  //. Takes a Maybe and returns Nothing unless `this` is a Just *and* the\n  //. argument is a Just, in which case it returns a Just whose value is\n  //. the result of applying the given Just's value to this Just's value.\n  //.\n  //. It is idiomatic to use [`ap`](#ap) rather than use this method directly.\n  //.\n  //. ```javascript\n  //. > S.ap(S.Nothing, S.Nothing)\n  //. Nothing\n  //.\n  //. > S.ap(S.Nothing, S.Just(9))\n  //. Nothing\n  //.\n  //. > S.ap(S.Just(Math.sqrt), S.Nothing)\n  //. Nothing\n  //.\n  //. > S.ap(S.Just(Math.sqrt), S.Just(9))\n  //. Just(3)\n  //. ```\n  Maybe.prototype['fantasy-land/ap'] = function(other) {\n    return other.isJust ? Z.map(other.value, this) : other;\n  };\n\n  //# Maybe#fantasy-land/chain :: Maybe a ~> (a -> Maybe b) -> Maybe b\n  //.\n  //. Takes a function and returns `this` if `this` is Nothing; otherwise\n  //. it returns the result of applying the function to this Just's value.\n  //.\n  //. It is idiomatic to use [`chain`](#chain) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.chain(S.parseFloat, S.Nothing)\n  //. Nothing\n  //.\n  //. > S.chain(S.parseFloat, S.Just('xxx'))\n  //. Nothing\n  //.\n  //. > S.chain(S.parseFloat, S.Just('12.34'))\n  //. Just(12.34)\n  //. ```\n  Maybe.prototype['fantasy-land/chain'] = function(f) {\n    return this.isJust ? f(this.value) : this;\n  };\n\n  //# Maybe#fantasy-land/alt :: Maybe a ~> Maybe a -> Maybe a\n  //.\n  //. Chooses between `this` and the other Maybe provided as an argument.\n  //. Returns `this` if `this` is a Just; the other Maybe otherwise.\n  //.\n  //. It is idiomatic to use [`alt`](#alt) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.alt(S.Nothing, S.Nothing)\n  //. Nothing\n  //.\n  //. > S.alt(S.Nothing, S.Just(1))\n  //. Just(1)\n  //.\n  //. > S.alt(S.Just(2), S.Nothing)\n  //. Just(2)\n  //.\n  //. > S.alt(S.Just(3), S.Just(4))\n  //. Just(3)\n  //. ```\n  Maybe.prototype['fantasy-land/alt'] = function(other) {\n    return this.isJust ? this : other;\n  };\n\n  //# Maybe#fantasy-land/reduce :: Maybe a ~> ((b, a) -> b, b) -> b\n  //.\n  //. Takes a function and an initial value of any type, and returns:\n  //.\n  //.   - the initial value if `this` is Nothing; otherwise\n  //.\n  //.   - the result of applying the function to the initial value and this\n  //.     Just's value.\n  //.\n  //. It is idiomatic to use [`reduce`](#reduce) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.reduce(S.curry2(Math.pow), 10, S.Nothing)\n  //. 10\n  //.\n  //. > S.reduce(S.curry2(Math.pow), 10, S.Just(3))\n  //. 1000\n  //. ```\n  Maybe.prototype['fantasy-land/reduce'] = function(f, x) {\n    return this.isJust ? f(x, this.value) : x;\n  };\n\n  //# Maybe#fantasy-land/traverse :: Applicative f => Maybe a ~> (TypeRep f, a -> f b) -> f (Maybe b)\n  //.\n  //. Takes the type representative of some [Applicative][] and a function\n  //. which returns a value of that Applicative, and returns:\n  //.\n  //.   - the result of applying the type representative's [`of`][] function to\n  //.     `this` if `this` is Nothing; otherwise\n  //.\n  //.   - the result of mapping [`Just`](#Just) over the result of applying the\n  //.     first function to this Just's value.\n  //.\n  //. It is idiomatic to use [`traverse`](#traverse) rather than use this\n  //. method directly.\n  //.\n  //. ```javascript\n  //. > S.traverse(Array, S.words, S.Nothing)\n  //. [Nothing]\n  //.\n  //. > S.traverse(Array, S.words, S.Just('foo bar baz'))\n  //. [Just('foo'), Just('bar'), Just('baz')]\n  //. ```\n  Maybe.prototype['fantasy-land/traverse'] = function(typeRep, f) {\n    return this.isJust ? Z.map(Just, f(this.value)) : Z.of(typeRep, this);\n  };\n\n  //# Maybe#fantasy-land/extend :: Maybe a ~> (Maybe a -> b) -> Maybe b\n  //.\n  //. Takes a function and returns `this` if `this` is Nothing; otherwise\n  //. it returns a Just whose value is the result of applying the function\n  //. to `this`.\n  //.\n  //. It is idiomatic to use [`extend`](#extend) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.extend(x => x.value + 1, S.Nothing)\n  //. Nothing\n  //.\n  //. > S.extend(x => x.value + 1, S.Just(42))\n  //. Just(43)\n  //. ```\n  Maybe.prototype['fantasy-land/extend'] = function(f) {\n    return this.isJust ? Just(f(this)) : this;\n  };\n\n  //# isNothing :: Maybe a -> Boolean\n  //.\n  //. Returns `true` if the given Maybe is Nothing; `false` if it is a Just.\n  //.\n  //. ```javascript\n  //. > S.isNothing(S.Nothing)\n  //. true\n  //.\n  //. > S.isNothing(S.Just(42))\n  //. false\n  //. ```\n  function isNothing(maybe) {\n    return maybe.isNothing;\n  }\n  S.isNothing = def('isNothing', {}, [$Maybe(a), $.Boolean], isNothing);\n\n  //# isJust :: Maybe a -> Boolean\n  //.\n  //. Returns `true` if the given Maybe is a Just; `false` if it is Nothing.\n  //.\n  //. ```javascript\n  //. > S.isJust(S.Just(42))\n  //. true\n  //.\n  //. > S.isJust(S.Nothing)\n  //. false\n  //. ```\n  function isJust(maybe) {\n    return maybe.isJust;\n  }\n  S.isJust = def('isJust', {}, [$Maybe(a), $.Boolean], isJust);\n\n  //# fromMaybe :: a -> Maybe a -> a\n  //.\n  //. Takes a default value and a Maybe, and returns the Maybe's value\n  //. if the Maybe is a Just; the default value otherwise.\n  //.\n  //. See also [`fromMaybe_`](#fromMaybe_) and\n  //. [`maybeToNullable`](#maybeToNullable).\n  //.\n  //. ```javascript\n  //. > S.fromMaybe(0, S.Just(42))\n  //. 42\n  //.\n  //. > S.fromMaybe(0, S.Nothing)\n  //. 0\n  //. ```\n  function fromMaybe(x, maybe) {\n    return maybe.isJust ? maybe.value : x;\n  }\n  S.fromMaybe = def('fromMaybe', {}, [a, $Maybe(a), a], fromMaybe);\n\n  //# fromMaybe_ :: (() -> a) -> Maybe a -> a\n  //.\n  //. Variant of [`fromMaybe`](#fromMaybe) which takes a thunk so the default\n  //. value is only computed if required.\n  //.\n  //. ```javascript\n  //. > function fib(n) { return n <= 1 ? n : fib(n - 2) + fib(n - 1); }\n  //.\n  //. > S.fromMaybe_(() => fib(30), S.Just(1000000))\n  //. 1000000\n  //.\n  //. > S.fromMaybe_(() => fib(30), S.Nothing)\n  //. 832040\n  //. ```\n  function fromMaybe_(thunk, maybe) {\n    return maybe.isJust ? maybe.value : thunk();\n  }\n  S.fromMaybe_ = def('fromMaybe_', {}, [$.Thunk(a), $Maybe(a), a], fromMaybe_);\n\n  //# maybeToNullable :: Maybe a -> Nullable a\n  //.\n  //. Returns the given Maybe's value if the Maybe is a Just; `null` otherwise.\n  //. [Nullable][] is defined in [sanctuary-def][].\n  //.\n  //. See also [`fromMaybe`](#fromMaybe).\n  //.\n  //. ```javascript\n  //. > S.maybeToNullable(S.Just(42))\n  //. 42\n  //.\n  //. > S.maybeToNullable(S.Nothing)\n  //. null\n  //. ```\n  function maybeToNullable(maybe) {\n    return maybe.isJust ? maybe.value : null;\n  }\n  S.maybeToNullable =\n  def('maybeToNullable', {}, [$Maybe(a), $.Nullable(a)], maybeToNullable);\n\n  //# toMaybe :: a? -> Maybe a\n  //.\n  //. Takes a value and returns Nothing if the value is `null` or `undefined`;\n  //. Just the value otherwise.\n  //.\n  //. ```javascript\n  //. > S.toMaybe(null)\n  //. Nothing\n  //.\n  //. > S.toMaybe(42)\n  //. Just(42)\n  //. ```\n  function toMaybe(x) {\n    return x == null ? Nothing : Just(x);\n  }\n  S.toMaybe = def('toMaybe', {}, [a, $Maybe(a)], toMaybe);\n\n  //# maybe :: b -> (a -> b) -> Maybe a -> b\n  //.\n  //. Takes a value of any type, a function, and a Maybe. If the Maybe is\n  //. a Just, the return value is the result of applying the function to\n  //. the Just's value. Otherwise, the first argument is returned.\n  //.\n  //. See also [`maybe_`](#maybe_).\n  //.\n  //. ```javascript\n  //. > S.maybe(0, S.prop('length'), S.Just('refuge'))\n  //. 6\n  //.\n  //. > S.maybe(0, S.prop('length'), S.Nothing)\n  //. 0\n  //. ```\n  function maybe(x, f, maybe) {\n    return fromMaybe(x, Z.map(f, maybe));\n  }\n  S.maybe = def('maybe', {}, [b, Fn(a, b), $Maybe(a), b], maybe);\n\n  //# maybe_ :: (() -> b) -> (a -> b) -> Maybe a -> b\n  //.\n  //. Variant of [`maybe`](#maybe) which takes a thunk so the default value\n  //. is only computed if required.\n  //.\n  //. ```javascript\n  //. > function fib(n) { return n <= 1 ? n : fib(n - 2) + fib(n - 1); }\n  //.\n  //. > S.maybe_(() => fib(30), Math.sqrt, S.Just(1000000))\n  //. 1000\n  //.\n  //. > S.maybe_(() => fib(30), Math.sqrt, S.Nothing)\n  //. 832040\n  //. ```\n  function maybe_(thunk, f, maybe) {\n    return maybe.isJust ? f(maybe.value) : thunk();\n  }\n  S.maybe_ = def('maybe_', {}, [$.Thunk(b), Fn(a, b), $Maybe(a), b], maybe_);\n\n  //# justs :: Array (Maybe a) -> Array a\n  //.\n  //. Takes an array of Maybes and returns an array containing each Just's\n  //. value. Equivalent to Haskell's `catMaybes` function.\n  //.\n  //. See also [`lefts`](#lefts) and [`rights`](#rights).\n  //.\n  //. ```javascript\n  //. > S.justs([S.Just('foo'), S.Nothing, S.Just('baz')])\n  //. ['foo', 'baz']\n  //. ```\n  function justs(maybes) {\n    return Z.reduce(function(xs, maybe) {\n      if (maybe.isJust) xs.push(maybe.value);\n      return xs;\n    }, [], maybes);\n  }\n  S.justs = def('justs', {}, [$.Array($Maybe(a)), $.Array(a)], justs);\n\n  //# mapMaybe :: (a -> Maybe b) -> Array a -> Array b\n  //.\n  //. Takes a function and an array, applies the function to each element of\n  //. the array, and returns an array of \"successful\" results. If the result of\n  //. applying the function to an element of the array is Nothing, the result\n  //. is discarded; if the result is a Just, the Just's value is included in\n  //. the output array.\n  //.\n  //. In general terms, `mapMaybe` filters an array while mapping over it.\n  //.\n  //. ```javascript\n  //. > S.mapMaybe(S.head, [[], [1, 2, 3], [], [4, 5, 6], []])\n  //. [1, 4]\n  //. ```\n  function mapMaybe(f, xs) {\n    return justs(Z.map(f, xs));\n  }\n  S.mapMaybe =\n  def('mapMaybe', {}, [Fn(a, $Maybe(b)), $.Array(a), $.Array(b)], mapMaybe);\n\n  //# encase :: (a -> b) -> a -> Maybe b\n  //.\n  //. Takes a unary function `f` which may throw and a value `x` of any type,\n  //. and applies `f` to `x` inside a `try` block. If an exception is caught,\n  //. the return value is Nothing; otherwise the return value is Just the\n  //. result of applying `f` to `x`.\n  //.\n  //. See also [`encaseEither`](#encaseEither).\n  //.\n  //. ```javascript\n  //. > S.encase(eval, '1 + 1')\n  //. Just(2)\n  //.\n  //. > S.encase(eval, '1 +')\n  //. Nothing\n  //. ```\n  function encase(f, x) {\n    try {\n      return Just(f(x));\n    } catch (err) {\n      return Nothing;\n    }\n  }\n  S.encase = def('encase', {}, [Fn(a, b), a, $Maybe(b)], encase);\n\n  //# encase2 :: (a -> b -> c) -> a -> b -> Maybe c\n  //.\n  //. Binary version of [`encase`](#encase).\n  function encase2(f, x, y) {\n    try {\n      return Just(f(x)(y));\n    } catch (err) {\n      return Nothing;\n    }\n  }\n  S.encase2 = def('encase2', {}, [Fn(a, Fn(b, c)), a, b, $Maybe(c)], encase2);\n\n  //# encase3 :: (a -> b -> c -> d) -> a -> b -> c -> Maybe d\n  //.\n  //. Ternary version of [`encase`](#encase).\n  function encase3(f, x, y, z) {\n    try {\n      return Just(f(x)(y)(z));\n    } catch (err) {\n      return Nothing;\n    }\n  }\n  S.encase3 =\n  def('encase3', {}, [Fn(a, Fn(b, Fn(c, d))), a, b, c, $Maybe(d)], encase3);\n\n  //# maybeToEither :: a -> Maybe b -> Either a b\n  //.\n  //. Converts a Maybe to an Either. Nothing becomes a Left (containing the\n  //. first argument); a Just becomes a Right.\n  //.\n  //. See also [`eitherToMaybe`](#eitherToMaybe).\n  //.\n  //. ```javascript\n  //. > S.maybeToEither('Expecting an integer', S.parseInt(10, 'xyz'))\n  //. Left('Expecting an integer')\n  //.\n  //. > S.maybeToEither('Expecting an integer', S.parseInt(10, '42'))\n  //. Right(42)\n  //. ```\n  function maybeToEither(x, maybe) {\n    return maybe.isNothing ? Left(x) : Right(maybe.value);\n  }\n  S.maybeToEither =\n  def('maybeToEither', {}, [a, $Maybe(b), $Either(a, b)], maybeToEither);\n\n  //. ### Either type\n  //.\n  //. The Either type represents values with two possibilities: a value of type\n  //. `Either a b` is either a Left whose value is of type `a` or a Right whose\n  //. value is of type `b`.\n  //.\n  //. The Either type satisfies the [Ord][], [Semigroup][], [Monad][],\n  //. [Alt][], [Traversable][], [Extend][], and [Bifunctor][] specifications.\n\n  //# EitherType :: Type -> Type -> Type\n  //.\n  //. A [`BinaryType`][BinaryType] for use with [sanctuary-def][].\n  S.EitherType = $Either;\n\n  //# Either :: TypeRep Either\n  //.\n  //. The [type representative](#type-representatives) for the Either type.\n  var Either = S.Either = {prototype: _Either.prototype};\n\n  Either.prototype.constructor = Either;\n\n  function _Either(tag, value) {\n    this.isLeft = tag === 'Left';\n    this.isRight = tag === 'Right';\n    this.value = value;\n\n    //  Add \"fantasy-land/concat\" method conditionally so that Left('abc')\n    //  and Right('abc') satisfy the requirements of Semigroup but Left(123)\n    //  and Right(123) do not.\n    if (Z.Semigroup.test(this.value)) {\n      this['fantasy-land/concat'] = Either$prototype$concat;\n    }\n\n    if (Z.Setoid.test(this.value)) {\n      this['fantasy-land/equals'] = Either$prototype$equals;\n    }\n\n    if (Z.Ord.test(this.value)) {\n      this['fantasy-land/lte'] = Either$prototype$lte;\n    }\n  }\n\n  //# Left :: a -> Either a b\n  //.\n  //. Takes a value of any type and returns a Left with the given value.\n  //.\n  //. ```javascript\n  //. > S.Left('Cannot divide by zero')\n  //. Left('Cannot divide by zero')\n  //. ```\n  function Left(x) {\n    return new _Either('Left', x);\n  }\n  S.Left = def('Left', {}, [a, $Either(a, b)], Left);\n\n  //# Right :: b -> Either a b\n  //.\n  //. Takes a value of any type and returns a Right with the given value.\n  //.\n  //. ```javascript\n  //. > S.Right(42)\n  //. Right(42)\n  //. ```\n  function Right(x) {\n    return new _Either('Right', x);\n  }\n  S.Right = def('Right', {}, [b, $Either(a, b)], Right);\n\n  //# Either.@@type :: String\n  //.\n  //. Either type identifier, `'sanctuary/Either'`.\n  Either['@@type'] = eitherTypeIdent;\n\n  //# Either.fantasy-land/of :: b -> Either a b\n  //.\n  //. Takes a value of any type and returns a Right with the given value.\n  //.\n  //. It is idiomatic to use [`of`](#of) rather than use this function\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.of(S.Either, 42)\n  //. Right(42)\n  //. ```\n  Either['fantasy-land/of'] = Right;\n\n  //# Either#isLeft :: Either a b ~> Boolean\n  //.\n  //. `true` if `this` is a Left; `false` if `this` is a Right.\n  //.\n  //. ```javascript\n  //. > S.Left('Cannot divide by zero').isLeft\n  //. true\n  //.\n  //. > S.Right(42).isLeft\n  //. false\n  //. ```\n\n  //# Either#isRight :: Either a b ~> Boolean\n  //.\n  //. `true` if `this` is a Right; `false` if `this` is a Left.\n  //.\n  //. ```javascript\n  //. > S.Right(42).isRight\n  //. true\n  //.\n  //. > S.Left('Cannot divide by zero').isRight\n  //. false\n  //. ```\n\n  //# Either#toString :: Either a b ~> () -> String\n  //.\n  //. Returns the string representation of the Either.\n  //.\n  //. ```javascript\n  //. > S.toString(S.Left('Cannot divide by zero'))\n  //. 'Left(\"Cannot divide by zero\")'\n  //.\n  //. > S.toString(S.Right([1, 2, 3]))\n  //. 'Right([1, 2, 3])'\n  //. ```\n  Either.prototype.toString = function() {\n    return (this.isLeft ? 'Left' : 'Right') +\n           '(' + Z.toString(this.value) + ')';\n  };\n\n  //# Either#inspect :: Either a b ~> () -> String\n  //.\n  //. Returns the string representation of the Either. This method is used by\n  //. `util.inspect` and the REPL to format a Either for display.\n  //.\n  //. See also [`Either#toString`][].\n  //.\n  //. ```javascript\n  //. > S.Left('Cannot divide by zero').inspect()\n  //. 'Left(\"Cannot divide by zero\")'\n  //.\n  //. > S.Right([1, 2, 3]).inspect()\n  //. 'Right([1, 2, 3])'\n  //. ```\n  Either.prototype.inspect = function() { return this.toString(); };\n\n  //# Either#fantasy-land/equals :: (Setoid a, Setoid b) => Either a b ~> Either a b -> Boolean\n  //.\n  //. Takes a value `e` of the same type and returns `true` if:\n  //.\n  //.   - `this` and `e` are both Lefts or both Rights, and their values are\n  //.     equal according to [`Z.equals`][].\n  //.\n  //. It is idiomatic to use [`equals`](#equals) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.equals(S.Right([1, 2, 3]), S.Right([1, 2, 3]))\n  //. true\n  //.\n  //. > S.equals(S.Right([1, 2, 3]), S.Left([1, 2, 3]))\n  //. false\n  //. ```\n  function Either$prototype$equals(other) {\n    return this.isLeft === other.isLeft && Z.equals(this.value, other.value);\n  }\n\n  //# Either#fantasy-land/lte :: (Ord a, Ord b) => Either a b ~> Either a b -> Boolean\n  //.\n  //. Takes a value `e` of the same type and returns `true` if:\n  //.\n  //.   - `this` is a Left and `e` is a Right; or\n  //.\n  //.   - `this` and `e` are both Lefts or both Rights, and the value of `this`\n  //.     is less than or equal to the value of `e` according to [`Z.lte`][].\n  //.\n  //. It is idiomatic to use [`lte`](#lte) or [`lte_`](#lte_) rather than use\n  //. this method directly.\n  //.\n  //. ```javascript\n  //. > S.lte_(S.Left(10), S.Right(0))\n  //. true\n  //.\n  //. > S.lte_(S.Right(0), S.Left(10))\n  //. false\n  //.\n  //. > S.lte_(S.Right(0), S.Right(1))\n  //. true\n  //.\n  //. > S.lte_(S.Right(1), S.Right(0))\n  //. false\n  //. ```\n  function Either$prototype$lte(other) {\n    return this.isLeft === other.isLeft ?\n      Z.lte(this.value, other.value) :\n      this.isLeft;\n  }\n\n  //# Either#fantasy-land/concat :: (Semigroup a, Semigroup b) => Either a b ~> Either a b -> Either a b\n  //.\n  //. Returns the result of concatenating two Either values of the same type.\n  //. `a` must have a [Semigroup][], as must `b`.\n  //.\n  //. If `this` is a Left and the argument is a Left, this method returns a\n  //. Left whose value is the result of concatenating this Left's value and\n  //. the given Left's value.\n  //.\n  //. If `this` is a Right and the argument is a Right, this method returns a\n  //. Right whose value is the result of concatenating this Right's value and\n  //. the given Right's value.\n  //.\n  //. Otherwise, this method returns the Right.\n  //.\n  //. It is idiomatic to use [`concat`](#concat) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.concat(S.Left('abc'), S.Left('def'))\n  //. Left('abcdef')\n  //.\n  //. > S.concat(S.Right([1, 2, 3]), S.Right([4, 5, 6]))\n  //. Right([1, 2, 3, 4, 5, 6])\n  //.\n  //. > S.concat(S.Left('abc'), S.Right([1, 2, 3]))\n  //. Right([1, 2, 3])\n  //.\n  //. > S.concat(S.Right([1, 2, 3]), S.Left('abc'))\n  //. Right([1, 2, 3])\n  //. ```\n  function Either$prototype$concat(other) {\n    return this.isLeft ?\n      other.isLeft ? Left(Z.concat(this.value, other.value)) : other :\n      other.isLeft ? this : Right(Z.concat(this.value, other.value));\n  }\n\n  //# Either#fantasy-land/map :: Either a b ~> (b -> c) -> Either a c\n  //.\n  //. Takes a function and returns `this` if `this` is a Left; otherwise it\n  //. returns a Right whose value is the result of applying the function to\n  //. this Right's value.\n  //.\n  //. It is idiomatic to use [`map`](#map) rather than use this method\n  //. directly.\n  //.\n  //. See also [`Either#fantasy-land/bimap`][].\n  //.\n  //. ```javascript\n  //. > S.map(Math.sqrt, S.Left('Cannot divide by zero'))\n  //. Left('Cannot divide by zero')\n  //.\n  //. > S.map(Math.sqrt, S.Right(9))\n  //. Right(3)\n  //. ```\n  Either.prototype['fantasy-land/map'] = function(f) {\n    return this.isRight ? Right(f(this.value)) : this;\n  };\n\n  //# Either#fantasy-land/bimap :: Either a b ~> (a -> c, b -> d) -> Either c d\n  //.\n  //. Takes two functions and returns:\n  //.\n  //.   - a Left whose value is the result of applying the first function\n  //.     to this Left's value if `this` is a Left; otherwise\n  //.\n  //.   - a Right whose value is the result of applying the second function\n  //.     to this Right's value.\n  //.\n  //. Similar to [`Either#fantasy-land/map`][], but supports mapping over the\n  //. left side as well as the right side.\n  //.\n  //. It is idiomatic to use [`bimap`](#bimap) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.bimap(S.toUpper, S.add(1), S.Left('abc'))\n  //. Left('ABC')\n  //.\n  //. > S.bimap(S.toUpper, S.add(1), S.Right(42))\n  //. Right(43)\n  //. ```\n  Either.prototype['fantasy-land/bimap'] = function(f, g) {\n    return this.isLeft ? Left(f(this.value)) : Right(g(this.value));\n  };\n\n  //# Either#fantasy-land/ap :: Either a b ~> Either a (b -> c) -> Either a c\n  //.\n  //. Takes an Either and returns a Left unless `this` is a Right *and* the\n  //. argument is a Right, in which case it returns a Right whose value is\n  //. the result of applying the given Right's value to this Right's value.\n  //.\n  //. It is idiomatic to use [`ap`](#ap) rather than use this method directly.\n  //.\n  //. ```javascript\n  //. > S.ap(S.Left('No such function'), S.Left('Cannot divide by zero'))\n  //. Left('No such function')\n  //.\n  //. > S.ap(S.Left('No such function'), S.Right(9))\n  //. Left('No such function')\n  //.\n  //. > S.ap(S.Right(Math.sqrt), S.Left('Cannot divide by zero'))\n  //. Left('Cannot divide by zero')\n  //.\n  //. > S.ap(S.Right(Math.sqrt), S.Right(9))\n  //. Right(3)\n  //. ```\n  Either.prototype['fantasy-land/ap'] = function(other) {\n    return other.isRight ? Z.map(other.value, this) : other;\n  };\n\n  //# Either#fantasy-land/chain :: Either a b ~> (b -> Either a c) -> Either a c\n  //.\n  //. Takes a function and returns `this` if `this` is a Left; otherwise\n  //. it returns the result of applying the function to this Right's value.\n  //.\n  //. It is idiomatic to use [`chain`](#chain) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > global.sqrt = n =>\n  //. .   n < 0 ? S.Left('Cannot represent square root of negative number')\n  //. .         : S.Right(Math.sqrt(n))\n  //. sqrt\n  //.\n  //. > S.chain(sqrt, S.Left('Cannot divide by zero'))\n  //. Left('Cannot divide by zero')\n  //.\n  //. > S.chain(sqrt, S.Right(-1))\n  //. Left('Cannot represent square root of negative number')\n  //.\n  //. > S.chain(sqrt, S.Right(25))\n  //. Right(5)\n  //. ```\n  Either.prototype['fantasy-land/chain'] = function(f) {\n    return this.isRight ? f(this.value) : this;\n  };\n\n  //# Either#fantasy-land/alt :: Either a b ~> Either a b -> Either a b\n  //.\n  //. Chooses between `this` and the other Either provided as an argument.\n  //. Returns `this` if `this` is a Right; the other Either otherwise.\n  //.\n  //. It is idiomatic to use [`alt`](#alt) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.alt(S.Left('A'), S.Left('B'))\n  //. Left('B')\n  //.\n  //. > S.alt(S.Left('C'), S.Right(1))\n  //. Right(1)\n  //.\n  //. > S.alt(S.Right(2), S.Left('D'))\n  //. Right(2)\n  //.\n  //. > S.alt(S.Right(3), S.Right(4))\n  //. Right(3)\n  //. ```\n  Either.prototype['fantasy-land/alt'] = function(other) {\n    return this.isRight ? this : other;\n  };\n\n  //# Either#fantasy-land/reduce :: Either a b ~> ((c, b) -> c, c) -> c\n  //.\n  //. Takes a function and an initial value of any type, and returns:\n  //.\n  //.   - the initial value if `this` is a Left; otherwise\n  //.\n  //.   - the result of applying the function to the initial value and this\n  //.     Right's value.\n  //.\n  //. It is idiomatic to use [`reduce`](#reduce) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.reduce(S.curry2(Math.pow), 10, S.Left('Cannot divide by zero'))\n  //. 10\n  //.\n  //. > S.reduce(S.curry2(Math.pow), 10, S.Right(3))\n  //. 1000\n  //. ```\n  Either.prototype['fantasy-land/reduce'] = function(f, x) {\n    return this.isRight ? f(x, this.value) : x;\n  };\n\n  //# Either#fantasy-land/traverse :: Applicative f => Either a b ~> (TypeRep f, b -> f c) -> f (Either a c)\n  //.\n  //. Takes the type representative of some [Applicative][] and a function\n  //. which returns a value of that Applicative, and returns:\n  //.\n  //.   - the result of applying the type representative's [`of`][] function to\n  //.     `this` if `this` is a Left; otherwise\n  //.\n  //.   - the result of mapping [`Right`](#Right) over the result of applying\n  //.     the first function to this Right's value.\n  //.\n  //. It is idiomatic to use [`traverse`](#traverse) rather than use this\n  //. method directly.\n  //.\n  //. ```javascript\n  //. > S.traverse(Array, S.words, S.Left('Request failed'))\n  //. [Left('Request failed')]\n  //.\n  //. > S.traverse(Array, S.words, S.Right('foo bar baz'))\n  //. [Right('foo'), Right('bar'), Right('baz')]\n  //. ```\n  Either.prototype['fantasy-land/traverse'] = function(typeRep, f) {\n    return this.isRight ? Z.map(Right, f(this.value)) : Z.of(typeRep, this);\n  };\n\n  //# Either#fantasy-land/extend :: Either a b ~> (Either a b -> c) -> Either a c\n  //.\n  //. Takes a function and returns `this` if `this` is a Left; otherwise it\n  //. returns a Right whose value is the result of applying the function to\n  //. `this`.\n  //.\n  //. It is idiomatic to use [`extend`](#extend) rather than use this method\n  //. directly.\n  //.\n  //. ```javascript\n  //. > S.extend(x => x.value + 1, S.Left('Cannot divide by zero'))\n  //. Left('Cannot divide by zero')\n  //.\n  //. > S.extend(x => x.value + 1, S.Right(42))\n  //. Right(43)\n  //. ```\n  Either.prototype['fantasy-land/extend'] = function(f) {\n    return this.isLeft ? this : Right(f(this));\n  };\n\n  //# isLeft :: Either a b -> Boolean\n  //.\n  //. Returns `true` if the given Either is a Left; `false` if it is a Right.\n  //.\n  //. ```javascript\n  //. > S.isLeft(S.Left('Cannot divide by zero'))\n  //. true\n  //.\n  //. > S.isLeft(S.Right(42))\n  //. false\n  //. ```\n  function isLeft(either) {\n    return either.isLeft;\n  }\n  S.isLeft = def('isLeft', {}, [$Either(a, b), $.Boolean], isLeft);\n\n  //# isRight :: Either a b -> Boolean\n  //.\n  //. Returns `true` if the given Either is a Right; `false` if it is a Left.\n  //.\n  //. ```javascript\n  //. > S.isRight(S.Right(42))\n  //. true\n  //.\n  //. > S.isRight(S.Left('Cannot divide by zero'))\n  //. false\n  //. ```\n  function isRight(either) {\n    return either.isRight;\n  }\n  S.isRight = def('isRight', {}, [$Either(a, b), $.Boolean], isRight);\n\n  //# fromEither :: b -> Either a b -> b\n  //.\n  //. Takes a default value and an Either, and returns the Right value\n  //. if the Either is a Right; the default value otherwise.\n  //.\n  //. ```javascript\n  //. > S.fromEither(0, S.Right(42))\n  //. 42\n  //.\n  //. > S.fromEither(0, S.Left(42))\n  //. 0\n  //. ```\n  function fromEither(x, either) {\n    return either.isRight ? either.value : x;\n  }\n  S.fromEither = def('fromEither', {}, [b, $Either(a, b), b], fromEither);\n\n  //# toEither :: a -> b? -> Either a b\n  //.\n  //. Converts an arbitrary value to an Either: a Left if the value is `null`\n  //. or `undefined`; a Right otherwise. The first argument specifies the\n  //. value of the Left in the \"failure\" case.\n  //.\n  //. ```javascript\n  //. > S.toEither('XYZ', null)\n  //. Left('XYZ')\n  //.\n  //. > S.toEither('XYZ', 'ABC')\n  //. Right('ABC')\n  //.\n  //. > S.map(S.prop('0'), S.toEither('Invalid protocol', 'ftp://example.com/'.match(/^https?:/)))\n  //. Left('Invalid protocol')\n  //.\n  //. > S.map(S.prop('0'), S.toEither('Invalid protocol', 'https://example.com/'.match(/^https?:/)))\n  //. Right('https:')\n  //. ```\n  function toEither(x, y) {\n    return y == null ? Left(x) : Right(y);\n  }\n  S.toEither = def('toEither', {}, [a, b, $Either(a, b)], toEither);\n\n  //# either :: (a -> c) -> (b -> c) -> Either a b -> c\n  //.\n  //. Takes two functions and an Either, and returns the result of\n  //. applying the first function to the Left's value, if the Either\n  //. is a Left, or the result of applying the second function to the\n  //. Right's value, if the Either is a Right.\n  //.\n  //. ```javascript\n  //. > S.either(S.toUpper, S.toString, S.Left('Cannot divide by zero'))\n  //. 'CANNOT DIVIDE BY ZERO'\n  //.\n  //. > S.either(S.toUpper, S.toString, S.Right(42))\n  //. '42'\n  //. ```\n  function either(l, r, either) {\n    return either.isLeft ? l(either.value) : r(either.value);\n  }\n  S.either = def('either', {}, [Fn(a, c), Fn(b, c), $Either(a, b), c], either);\n\n  //# lefts :: Array (Either a b) -> Array a\n  //.\n  //. Takes an array of Eithers and returns an array containing each Left's\n  //. value.\n  //.\n  //. See also [`rights`](#rights).\n  //.\n  //. ```javascript\n  //. > S.lefts([S.Right(20), S.Left('foo'), S.Right(10), S.Left('bar')])\n  //. ['foo', 'bar']\n  //. ```\n  function lefts(eithers) {\n    return Z.reduce(function(xs, either) {\n      if (either.isLeft) xs.push(either.value);\n      return xs;\n    }, [], eithers);\n  }\n  S.lefts = def('lefts', {}, [$.Array($Either(a, b)), $.Array(a)], lefts);\n\n  //# rights :: Array (Either a b) -> Array b\n  //.\n  //. Takes an array of Eithers and returns an array containing each Right's\n  //. value.\n  //.\n  //. See also [`lefts`](#lefts).\n  //.\n  //. ```javascript\n  //. > S.rights([S.Right(20), S.Left('foo'), S.Right(10), S.Left('bar')])\n  //. [20, 10]\n  //. ```\n  function rights(eithers) {\n    return Z.reduce(function(xs, either) {\n      if (either.isRight) xs.push(either.value);\n      return xs;\n    }, [], eithers);\n  }\n  S.rights = def('rights', {}, [$.Array($Either(a, b)), $.Array(b)], rights);\n\n  //# tagBy :: (a -> Boolean) -> a -> Either a a\n  //.\n  //. Takes a predicate and a value, and returns a Right of the value if it\n  //. satisfies the predicate; a Left of the value otherwise.\n  //.\n  //. ```javascript\n  //. > S.tagBy(S.odd, 0)\n  //. Left(0)\n  //\n  //. > S.tagBy(S.odd, 1)\n  //. Right(1)\n  //. ```\n  function tagBy(pred, a) {\n    return pred(a) ? Right(a) : Left(a);\n  }\n  S.tagBy = def('tagBy', {}, [$.Predicate(a), a, $Either(a, a)], tagBy);\n\n  //# encaseEither :: (Error -> l) -> (a -> r) -> a -> Either l r\n  //.\n  //. Takes two unary functions, `f` and `g`, the second of which may throw,\n  //. and a value `x` of any type. Applies `g` to `x` inside a `try` block.\n  //. If an exception is caught, the return value is a Left containing the\n  //. result of applying `f` to the caught Error object; otherwise the return\n  //. value is a Right containing the result of applying `g` to `x`.\n  //.\n  //. See also [`encase`](#encase).\n  //.\n  //. ```javascript\n  //. > S.encaseEither(S.I, JSON.parse, '[\"foo\",\"bar\",\"baz\"]')\n  //. Right(['foo', 'bar', 'baz'])\n  //.\n  //. > S.encaseEither(S.I, JSON.parse, '[')\n  //. Left(new SyntaxError('Unexpected end of JSON input'))\n  //.\n  //. > S.encaseEither(S.prop('message'), JSON.parse, '[')\n  //. Left('Unexpected end of JSON input')\n  //. ```\n  function encaseEither(f, g, x) {\n    try {\n      return Right(g(x));\n    } catch (err) {\n      return Left(f(err));\n    }\n  }\n  S.encaseEither =\n  def('encaseEither',\n      {},\n      [Fn($.Error, l), Fn(a, r), a, $Either(l, r)],\n      encaseEither);\n\n  //# encaseEither2 :: (Error -> l) -> (a -> b -> r) -> a -> b -> Either l r\n  //.\n  //. Binary version of [`encaseEither`](#encaseEither).\n  function encaseEither2(f, g, x, y) {\n    try {\n      return Right(g(x)(y));\n    } catch (err) {\n      return Left(f(err));\n    }\n  }\n  S.encaseEither2 =\n  def('encaseEither2',\n      {},\n      [Fn($.Error, l), Fn(a, Fn(b, r)), a, b, $Either(l, r)],\n      encaseEither2);\n\n  //# encaseEither3 :: (Error -> l) -> (a -> b -> c -> r) -> a -> b -> c -> Either l r\n  //.\n  //. Ternary version of [`encaseEither`](#encaseEither).\n  function encaseEither3(f, g, x, y, z) {\n    try {\n      return Right(g(x)(y)(z));\n    } catch (err) {\n      return Left(f(err));\n    }\n  }\n  S.encaseEither3 =\n  def('encaseEither3',\n      {},\n      [Fn($.Error, l), Fn(a, Fn(b, Fn(c, r))), a, b, c, $Either(l, r)],\n      encaseEither3);\n\n  //# eitherToMaybe :: Either a b -> Maybe b\n  //.\n  //. Converts an Either to a Maybe. A Left becomes Nothing; a Right becomes\n  //. a Just.\n  //.\n  //. See also [`maybeToEither`](#maybeToEither).\n  //.\n  //. ```javascript\n  //. > S.eitherToMaybe(S.Left('Cannot divide by zero'))\n  //. Nothing\n  //.\n  //. > S.eitherToMaybe(S.Right(42))\n  //. Just(42)\n  //. ```\n  function eitherToMaybe(either) {\n    return either.isLeft ? Nothing : Just(either.value);\n  }\n  S.eitherToMaybe =\n  def('eitherToMaybe', {}, [$Either(a, b), $Maybe(b)], eitherToMaybe);\n\n  //. ### Logic\n\n  //# and :: Boolean -> Boolean -> Boolean\n  //.\n  //. Boolean \"and\".\n  //.\n  //. ```javascript\n  //. > S.and(false, false)\n  //. false\n  //.\n  //. > S.and(false, true)\n  //. false\n  //.\n  //. > S.and(true, false)\n  //. false\n  //.\n  //. > S.and(true, true)\n  //. true\n  //. ```\n  function and(x, y) {\n    return x.valueOf() && y.valueOf();\n  }\n  S.and = def('and', {}, [$.Boolean, $.Boolean, $.Boolean], and);\n\n  //# or :: Boolean -> Boolean -> Boolean\n  //.\n  //. Boolean \"or\".\n  //.\n  //. ```javascript\n  //. > S.or(false, false)\n  //. false\n  //.\n  //. > S.or(false, true)\n  //. true\n  //.\n  //. > S.or(true, false)\n  //. true\n  //.\n  //. > S.or(true, true)\n  //. true\n  //. ```\n  function or(x, y) {\n    return x.valueOf() || y.valueOf();\n  }\n  S.or = def('or', {}, [$.Boolean, $.Boolean, $.Boolean], or);\n\n  //# not :: Boolean -> Boolean\n  //.\n  //. Boolean \"not\".\n  //.\n  //. See also [`complement`](#complement).\n  //.\n  //. ```javascript\n  //. > S.not(false)\n  //. true\n  //.\n  //. > S.not(true)\n  //. false\n  //. ```\n  function not(x) {\n    return !x.valueOf();\n  }\n  S.not = def('not', {}, [$.Boolean, $.Boolean], not);\n\n  //# complement :: (a -> Boolean) -> a -> Boolean\n  //.\n  //. Takes a unary predicate and a value of any type, and returns the logical\n  //. negation of applying the predicate to the value.\n  //.\n  //. See also [`not`](#not).\n  //.\n  //. ```javascript\n  //. > Number.isInteger(42)\n  //. true\n  //.\n  //. > S.complement(Number.isInteger, 42)\n  //. false\n  //. ```\n  function complement(pred, x) {\n    return !pred(x);\n  }\n  S.complement =\n  def('complement', {}, [$.Predicate(a), a, $.Boolean], complement);\n\n  //# ifElse :: (a -> Boolean) -> (a -> b) -> (a -> b) -> a -> b\n  //.\n  //. Takes a unary predicate, a unary \"if\" function, a unary \"else\"\n  //. function, and a value of any type, and returns the result of\n  //. applying the \"if\" function to the value if the value satisfies\n  //. the predicate; the result of applying the \"else\" function to the\n  //. value otherwise.\n  //.\n  //. See also [`when`](#when) and [`unless`](#unless).\n  //.\n  //. ```javascript\n  //. > S.ifElse(x => x < 0, Math.abs, Math.sqrt, -1)\n  //. 1\n  //.\n  //. > S.ifElse(x => x < 0, Math.abs, Math.sqrt, 16)\n  //. 4\n  //. ```\n  function ifElse(pred, f, g, x) {\n    return pred(x) ? f(x) : g(x);\n  }\n  S.ifElse =\n  def('ifElse', {}, [$.Predicate(a), Fn(a, b), Fn(a, b), a, b], ifElse);\n\n  //# when :: (a -> Boolean) -> (a -> a) -> a -> a\n  //.\n  //. Takes a unary predicate, a unary function, and a value of any type, and\n  //. returns the result of applying the function to the value if the value\n  //. satisfies the predicate; the value otherwise.\n  //.\n  //. See also [`unless`](#unless) and [`ifElse`](#ifElse).\n  //.\n  //. ```javascript\n  //. > S.when(x => x >= 0, Math.sqrt, 16)\n  //. 4\n  //.\n  //. > S.when(x => x >= 0, Math.sqrt, -1)\n  //. -1\n  //. ```\n  function when(pred, f, x) {\n    return ifElse(pred, f, I, x);\n  }\n  S.when = def('when', {}, [$.Predicate(a), Fn(a, a), a, a], when);\n\n  //# unless :: (a -> Boolean) -> (a -> a) -> a -> a\n  //.\n  //. Takes a unary predicate, a unary function, and a value of any type, and\n  //. returns the result of applying the function to the value if the value\n  //. does not satisfy the predicate; the value otherwise.\n  //.\n  //. See also [`when`](#when) and [`ifElse`](#ifElse).\n  //.\n  //. ```javascript\n  //. > S.unless(x => x < 0, Math.sqrt, 16)\n  //. 4\n  //.\n  //. > S.unless(x => x < 0, Math.sqrt, -1)\n  //. -1\n  //. ```\n  function unless(pred, f, x) {\n    return ifElse(pred, I, f, x);\n  }\n  S.unless = def('unless', {}, [$.Predicate(a), Fn(a, a), a, a], unless);\n\n  //# allPass :: Foldable f => f (a -> Boolean) -> a -> Boolean\n  //.\n  //. Takes a structure containing zero or more predicates, and a value\n  //. of any type. Returns `true` [iff][] the value satisfies all of the\n  //. predicates. None of the subsequent predicates will be applied after\n  //. the first predicate not satisfied.\n  //.\n  //. ```javascript\n  //. > S.allPass([S.test(/q/), S.test(/u/), S.test(/i/)], 'quiessence')\n  //. true\n  //.\n  //. > S.allPass([S.test(/q/), S.test(/u/), S.test(/i/)], 'fissiparous')\n  //. false\n  //. ```\n  function allPass(preds, x) {\n    return Z.reduce(function(b, p) { return b && p(x); }, true, preds);\n  }\n  S.allPass =\n  def('allPass',\n      {f: [Z.Foldable]},\n      [f($.Predicate(a)), a, $.Boolean],\n      allPass);\n\n  //# anyPass :: Foldable f => f (a -> Boolean) -> a -> Boolean\n  //.\n  //. Takes a structure containing zero or more predicates, and a value\n  //. of any type. Returns `true` [iff][] the value satisfies any of the\n  //. predicates. None of the subsequent predicates will be applied after\n  //. the first predicate satisfied.\n  //.\n  //. ```javascript\n  //. > S.anyPass([S.test(/q/), S.test(/u/), S.test(/i/)], 'incandescent')\n  //. true\n  //.\n  //. > S.anyPass([S.test(/q/), S.test(/u/), S.test(/i/)], 'empathy')\n  //. false\n  //. ```\n  function anyPass(preds, x) {\n    return Z.reduce(function(b, p) { return b || p(x); }, false, preds);\n  }\n  S.anyPass =\n  def('anyPass',\n      {f: [Z.Foldable]},\n      [f($.Predicate(a)), a, $.Boolean],\n      anyPass);\n\n  //. ### List\n  //.\n  //. The List type constructor enables type signatures to describe ad hoc\n  //. polymorphic functions which operate on either [`Array`][$.Array] or\n  //. [`String`][$.String] values.\n  //.\n  //. Mental gymnastics are required to treat arrays and strings similarly.\n  //. `[1, 2, 3]` is a list containing `1`, `2`, and `3`. `'abc'` is a list\n  //. containing `'a'`, `'b'`, and `'c'`. But what is the type of `'a'`?\n  //. `String`, since JavaScript has no Char type! Thus:\n  //.\n  //.     'abc' :: String, List String, List (List String), ...\n  //.\n  //. Every member of `String` is also a member of `List String`!\n\n  //# slice :: Integer -> Integer -> List a -> Maybe (List a)\n  //.\n  //. Returns Just a list containing the elements from the supplied list\n  //. from a beginning index (inclusive) to an end index (exclusive).\n  //. Returns Nothing unless the start interval is less than or equal to\n  //. the end interval, and the list contains both (half-open) intervals.\n  //. Accepts negative indices, which indicate an offset from the end of\n  //. the list.\n  //.\n  //. See also [`take`](#take), [`drop`](#drop), [`takeLast`](#takeLast),\n  //. and [`dropLast`](#dropLast).\n  //.\n  //. ```javascript\n  //. > S.slice(1, 3, ['a', 'b', 'c', 'd', 'e'])\n  //. Just(['b', 'c'])\n  //.\n  //. > S.slice(-3, -1, ['a', 'b', 'c', 'd', 'e'])\n  //. Just(['c', 'd'])\n  //.\n  //. > S.slice(1, 6, ['a', 'b', 'c', 'd', 'e'])\n  //. Nothing\n  //.\n  //. > S.slice(2, 6, 'banana')\n  //. Just('nana')\n  //. ```\n  function slice(start, end, xs) {\n    var len = xs.length;\n    var fromIdx = start < 0 ? start + len : start;\n    var toIdx = end < 0 ? end + len : end;\n\n    return Math.abs(start) <= len && Math.abs(end) <= len && fromIdx <= toIdx ?\n      Just(xs.slice(fromIdx, toIdx)) :\n      Nothing;\n  }\n  S.slice =\n  def('slice', {}, [$.Integer, $.Integer, List(a), $Maybe(List(a))], slice);\n\n  //# at :: Integer -> List a -> Maybe a\n  //.\n  //. Takes an index and a list and returns Just the element of the list at\n  //. the index if the index is within the list's bounds; Nothing otherwise.\n  //. A negative index represents an offset from the length of the list.\n  //.\n  //. ```javascript\n  //. > S.at(2, ['a', 'b', 'c', 'd', 'e'])\n  //. Just('c')\n  //.\n  //. > S.at(5, ['a', 'b', 'c', 'd', 'e'])\n  //. Nothing\n  //.\n  //. > S.at(-2, ['a', 'b', 'c', 'd', 'e'])\n  //. Just('d')\n  //. ```\n  function at(n, xs) {\n    var idx = n < 0 ? xs.length + n : n;\n    return idx < 0 || idx >= xs.length ? Nothing : Just(xs[idx]);\n  }\n  S.at = def('at', {}, [$.Integer, List(a), $Maybe(a)], at);\n\n  //# head :: List a -> Maybe a\n  //.\n  //. Takes a list and returns Just the first element of the list if the\n  //. list contains at least one element; Nothing if the list is empty.\n  //.\n  //. ```javascript\n  //. > S.head([1, 2, 3])\n  //. Just(1)\n  //.\n  //. > S.head([])\n  //. Nothing\n  //. ```\n  function head(xs) {\n    return at(0, xs);\n  }\n  S.head = def('head', {}, [List(a), $Maybe(a)], head);\n\n  //# last :: List a -> Maybe a\n  //.\n  //. Takes a list and returns Just the last element of the list if the\n  //. list contains at least one element; Nothing if the list is empty.\n  //.\n  //. ```javascript\n  //. > S.last([1, 2, 3])\n  //. Just(3)\n  //.\n  //. > S.last([])\n  //. Nothing\n  //. ```\n  function last(xs) {\n    return at(-1, xs);\n  }\n  S.last = def('last', {}, [List(a), $Maybe(a)], last);\n\n  //# tail :: List a -> Maybe (List a)\n  //.\n  //. Takes a list and returns Just a list containing all but the first\n  //. of the list's elements if the list contains at least one element;\n  //. Nothing if the list is empty.\n  //.\n  //. ```javascript\n  //. > S.tail([1, 2, 3])\n  //. Just([2, 3])\n  //.\n  //. > S.tail([])\n  //. Nothing\n  //. ```\n  function tail(xs) {\n    return xs.length > 0 ? Just(xs.slice(1)) : Nothing;\n  }\n  S.tail = def('tail', {}, [List(a), $Maybe(List(a))], tail);\n\n  //# init :: List a -> Maybe (List a)\n  //.\n  //. Takes a list and returns Just a list containing all but the last\n  //. of the list's elements if the list contains at least one element;\n  //. Nothing if the list is empty.\n  //.\n  //. ```javascript\n  //. > S.init([1, 2, 3])\n  //. Just([1, 2])\n  //.\n  //. > S.init([])\n  //. Nothing\n  //. ```\n  function init(xs) {\n    return xs.length > 0 ? Just(xs.slice(0, -1)) : Nothing;\n  }\n  S.init = def('init', {}, [List(a), $Maybe(List(a))], init);\n\n  //# take :: Integer -> List a -> Maybe (List a)\n  //.\n  //. Returns Just the first N elements of the given collection if N is\n  //. greater than or equal to zero and less than or equal to the length\n  //. of the collection; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.take(2, ['a', 'b', 'c', 'd', 'e'])\n  //. Just(['a', 'b'])\n  //.\n  //. > S.take(4, 'abcdefg')\n  //. Just('abcd')\n  //.\n  //. > S.take(4, ['a', 'b', 'c'])\n  //. Nothing\n  //. ```\n  function take(n, xs) {\n    return n < 0 || n > xs.length ? Nothing : Just(xs.slice(0, n));\n  }\n  S.take = def('take', {}, [$.Integer, List(a), $Maybe(List(a))], take);\n\n  //# takeLast :: Integer -> List a -> Maybe (List a)\n  //.\n  //. Returns Just the last N elements of the given collection if N is\n  //. greater than or equal to zero and less than or equal to the length\n  //. of the collection; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.takeLast(2, ['a', 'b', 'c', 'd', 'e'])\n  //. Just(['d', 'e'])\n  //.\n  //. > S.takeLast(4, 'abcdefg')\n  //. Just('defg')\n  //.\n  //. > S.takeLast(4, ['a', 'b', 'c'])\n  //. Nothing\n  //. ```\n  function takeLast(n, xs) {\n    return n < 0 || n > xs.length ? Nothing : Just(xs.slice(xs.length - n));\n  }\n  S.takeLast =\n  def('takeLast', {}, [$.Integer, List(a), $Maybe(List(a))], takeLast);\n\n  //# drop :: Integer -> List a -> Maybe (List a)\n  //.\n  //. Returns Just all but the first N elements of the given collection\n  //. if N is greater than or equal to zero and less than or equal to the\n  //. length of the collection; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.drop(2, ['a', 'b', 'c', 'd', 'e'])\n  //. Just(['c', 'd', 'e'])\n  //.\n  //. > S.drop(4, 'abcdefg')\n  //. Just('efg')\n  //.\n  //. > S.drop(4, 'abc')\n  //. Nothing\n  //. ```\n  function drop(n, xs) {\n    return n < 0 || n > xs.length ? Nothing : Just(xs.slice(n));\n  }\n  S.drop = def('drop', {}, [$.Integer, List(a), $Maybe(List(a))], drop);\n\n  //# dropLast :: Integer -> List a -> Maybe (List a)\n  //.\n  //. Returns Just all but the last N elements of the given collection\n  //. if N is greater than or equal to zero and less than or equal to the\n  //. length of the collection; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.dropLast(2, ['a', 'b', 'c', 'd', 'e'])\n  //. Just(['a', 'b', 'c'])\n  //.\n  //. > S.dropLast(4, 'abcdefg')\n  //. Just('abc')\n  //.\n  //. > S.dropLast(4, 'abc')\n  //. Nothing\n  //. ```\n  function dropLast(n, xs) {\n    return n < 0 || n > xs.length ? Nothing : Just(xs.slice(0, xs.length - n));\n  }\n  S.dropLast =\n  def('dropLast', {}, [$.Integer, List(a), $Maybe(List(a))], dropLast);\n\n  //. ### Array\n\n  //# size :: Foldable f => f a -> Integer\n  //.\n  //. Returns the number of elements of the given structure.\n  //.\n  //. ```javascript\n  //. > S.size([])\n  //. 0\n  //.\n  //. > S.size(['foo', 'bar', 'baz'])\n  //. 3\n  //.\n  //. > S.size(Nil)\n  //. 0\n  //.\n  //. > S.size(Cons('foo', Cons('bar', Cons('baz', Nil))))\n  //. 3\n  //.\n  //. > S.size(S.Nothing)\n  //. 0\n  //.\n  //. > S.size(S.Just('quux'))\n  //. 1\n  //. ```\n  S.size = def('size', {f: [Z.Foldable]}, [f(a), $.Integer], Z.size);\n\n  //# append :: (Applicative f, Semigroup (f a)) => a -> f a -> f a\n  //.\n  //. Returns the result of appending the first argument to the second.\n  //.\n  //. See also [`prepend`](#prepend).\n  //.\n  //. ```javascript\n  //. > S.append(3, [1, 2])\n  //. [1, 2, 3]\n  //.\n  //. > S.append(3, Cons(1, Cons(2, Nil)))\n  //. Cons(1, Cons(2, Cons(3, Nil)))\n  //.\n  //. > S.append([1], S.Nothing)\n  //. Just([1])\n  //.\n  //. > S.append([3], S.Just([1, 2]))\n  //. Just([1, 2, 3])\n  //. ```\n  S.append =\n  def('append',\n      {f: [Z.Applicative, Z.Semigroup]},\n      [a, f(a), f(a)],\n      Z.append);\n\n  //# prepend :: (Applicative f, Semigroup (f a)) => a -> f a -> f a\n  //.\n  //. Returns the result of prepending the first argument to the second.\n  //.\n  //. See also [`append`](#append).\n  //.\n  //. ```javascript\n  //. > S.prepend(1, [2, 3])\n  //. [1, 2, 3]\n  //.\n  //. > S.prepend(1, Cons(2, Cons(3, Nil)))\n  //. Cons(1, Cons(2, Cons(3, Nil)))\n  //.\n  //. > S.prepend([1], S.Nothing)\n  //. Just([1])\n  //.\n  //. > S.prepend([1], S.Just([2, 3]))\n  //. Just([1, 2, 3])\n  //. ```\n  S.prepend =\n  def('prepend',\n      {f: [Z.Applicative, Z.Semigroup]},\n      [a, f(a), f(a)],\n      Z.prepend);\n\n  //# joinWith :: String -> Array String -> String\n  //.\n  //. Joins the strings of the second argument separated by the first argument.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall s :: String, t :: String. S.joinWith(s, S.splitOn(s, t)) = t`\n  //.\n  //. See also [`splitOn`](#splitOn).\n  //.\n  //. ```javascript\n  //. > S.joinWith(':', ['foo', 'bar', 'baz'])\n  //. 'foo:bar:baz'\n  //. ```\n  function joinWith(separator, ss) {\n    return ss.join(separator);\n  }\n  S.joinWith =\n  def('joinWith', {}, [$.String, $.Array($.String), $.String], joinWith);\n\n  //# elem :: (Setoid a, Foldable f) => a -> f a -> Boolean\n  //.\n  //. Takes a value and a structure and returns `true` [iff][] the value is an\n  //. element of the structure.\n  //.\n  //. See also [`find`](#find).\n  //.\n  //. ```javascript\n  //. > S.elem('c', ['a', 'b', 'c'])\n  //. true\n  //.\n  //. > S.elem('x', ['a', 'b', 'c'])\n  //. false\n  //.\n  //. > S.elem(3, {x: 1, y: 2, z: 3})\n  //. true\n  //.\n  //. > S.elem(8, {x: 1, y: 2, z: 3})\n  //. false\n  //.\n  //. > S.elem(0, S.Just(0))\n  //. true\n  //.\n  //. > S.elem(0, S.Just(1))\n  //. false\n  //.\n  //. > S.elem(0, S.Nothing)\n  //. false\n  //. ```\n  S.elem =\n  def('elem', {a: [Z.Setoid], f: [Z.Foldable]}, [a, f(a), $.Boolean], Z.elem);\n\n  //# find :: Foldable f => (a -> Boolean) -> f a -> Maybe a\n  //.\n  //. Takes a predicate and a structure and returns Just the leftmost element\n  //. of the structure which satisfies the predicate; Nothing if there is no\n  //. such element.\n  //.\n  //. See also [`elem`](#elem).\n  //.\n  //. ```javascript\n  //. > S.find(n => n < 0, [1, -2, 3, -4, 5])\n  //. Just(-2)\n  //.\n  //. > S.find(n => n < 0, [1, 2, 3, 4, 5])\n  //. Nothing\n  //. ```\n  function find(pred, xs) {\n    return Z.reduce(\n      function(m, x) { return m.isJust ? m : pred(x) ? Just(x) : Nothing; },\n      Nothing,\n      xs\n    );\n  }\n  S.find =\n  def('find', {f: [Z.Foldable]}, [$.Predicate(a), f(a), $Maybe(a)], find);\n\n  //# pluck :: Functor f => String -> f a -> f b\n  //.\n  //. Combines [`map`](#map) and [`prop`](#prop). `pluck(k, xs)` is equivalent\n  //. to `map(prop(k), xs)`.\n  //.\n  //. ```javascript\n  //. > S.pluck('x', [{x: 1}, {x: 2}, {x: 3}])\n  //. [1, 2, 3]\n  //.\n  //. > S.pluck('x', S.Just({x: 1, y: 2, z: 3}))\n  //. Just(1)\n  //. ```\n  function pluck(key, xs) {\n    return Z.map(function(x) {\n      var obj = toObject(x);\n      if (key in obj) return obj[key];\n      throw new TypeError('pluck expected object to have a property named ' +\n                          '' + key + '; ' + Z.toString(x) + ' does not');\n    }, xs);\n  }\n  S.pluck = def('pluck', {f: [Z.Functor]}, [$.String, f(a), f(b)], pluck);\n\n  //# unfoldr :: (b -> Maybe (Pair a b)) -> b -> Array a\n  //.\n  //. Takes a function and a seed value, and returns an array generated by\n  //. applying the function repeatedly. The array is initially empty. The\n  //. function is initially applied to the seed value. Each application\n  //. of the function should result in either:\n  //.\n  //.   - Nothing, in which case the array is returned; or\n  //.\n  //.   - Just a pair, in which case the first element is appended to\n  //.     the array and the function is applied to the second element.\n  //.\n  //. ```javascript\n  //. > S.unfoldr(n => n < 5 ? S.Just([n, n + 1]) : S.Nothing, 1)\n  //. [1, 2, 3, 4]\n  //. ```\n  function unfoldr(f, x) {\n    var result = [];\n    for (var m = f(x); m.isJust; m = f(m.value[1])) result.push(m.value[0]);\n    return result;\n  }\n  S.unfoldr =\n  def('unfoldr', {}, [Fn(b, $Maybe($.Pair(a, b))), b, $.Array(a)], unfoldr);\n\n  //# range :: Integer -> Integer -> Array Integer\n  //.\n  //. Returns an array of consecutive integers starting with the first argument\n  //. and ending with the second argument minus one. Returns `[]` if the second\n  //. argument is less than or equal to the first argument.\n  //.\n  //. ```javascript\n  //. > S.range(0, 10)\n  //. [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n  //.\n  //. > S.range(-5, 0)\n  //. [-5, -4, -3, -2, -1]\n  //.\n  //. > S.range(0, -5)\n  //. []\n  //. ```\n  function range(from, to) {\n    var result = [];\n    for (var n = from; n < to; n += 1) result.push(n);\n    return result;\n  }\n  S.range =\n  def('range', {}, [$.Integer, $.Integer, $.Array($.Integer)], range);\n\n  //# groupBy :: (a -> a -> Boolean) -> Array a -> Array (Array a)\n  //.\n  //. Splits its array argument into an array of arrays of equal,\n  //. adjacent elements. Equality is determined by the function\n  //. provided as the first argument. Its behaviour can be surprising\n  //. for functions that aren't reflexive, transitive, and symmetric\n  //. (see [equivalence][] relation).\n  //.\n  //. Properties:\n  //.\n  //.   - `forall f :: a -> a -> Boolean, xs :: Array a.\n  //.      S.join(S.groupBy(f, xs)) = xs`\n  //.\n  //. ```javascript\n  //. > S.groupBy(S.equals, [1, 1, 2, 1, 1])\n  //. [[1, 1], [2], [1, 1]]\n  //.\n  //. > S.groupBy(x => y => x + y === 0, [2, -3, 3, 3, 3, 4, -4, 4])\n  //. [[2], [-3, 3, 3, 3], [4, -4], [4]]\n  //. ```\n  function groupBy(f, xs) {\n    if (xs.length === 0) return [];\n    var x0 = xs[0];         // :: a\n    var active = [x0];      // :: Array a\n    var result = [active];  // :: Array (Array a)\n    for (var idx = 1; idx < xs.length; idx += 1) {\n      var x = xs[idx];\n      if (f(x0)(x)) active.push(x); else result.push(active = [x0 = x]);\n    }\n    return result;\n  }\n  S.groupBy =\n  def('groupBy',\n      {},\n      [Fn(a, $.Predicate(a)), $.Array(a), $.Array($.Array(a))],\n      groupBy);\n\n  //# reverse :: (Applicative f, Foldable f, Monoid (f a)) => f a -> f a\n  //.\n  //. Reverses the elements of the given structure.\n  //.\n  //. ```javascript\n  //. > S.reverse([1, 2, 3])\n  //. [3, 2, 1]\n  //.\n  //. > S.reverse(Cons(1, Cons(2, Cons(3, Nil))))\n  //. Cons(3, Cons(2, Cons(1, Nil)))\n  //.\n  //. > S.pipe([S.splitOn(''), S.reverse, S.joinWith('')], 'abc')\n  //. 'cba'\n  //. ```\n  S.reverse =\n  def('reverse',\n      {f: [Z.Applicative, Z.Foldable, Z.Monoid]},\n      [f(a), f(a)],\n      Z.reverse);\n\n  //# sort :: (Ord a, Applicative m, Foldable m, Monoid (m a)) => m a -> m a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure, using\n  //. [`Z.lte`][] for comparisons.\n  //.\n  //. Properties:\n  //.\n  //.   - `S.sort(S.sort(m)) = S.sort(m)` (idempotence)\n  //.\n  //. See also [`sortBy`](#sortBy).\n  //.\n  //. ```javascript\n  //. > S.sort(['foo', 'bar', 'baz'])\n  //. ['bar', 'baz', 'foo']\n  //.\n  //. > S.sort([S.Left(4), S.Right(3), S.Left(2), S.Right(1)])\n  //. [Left(2), Left(4), Right(1), Right(3)]\n  //. ```\n  S.sort =\n  def('sort',\n      {a: [Z.Ord], m: [Z.Applicative, Z.Foldable, Z.Monoid]},\n      [m(a), m(a)],\n      Z.sort);\n\n  //# sortBy :: (Ord b, Applicative m, Foldable m, Monoid (m a)) => (a -> b) -> m a -> m a\n  //.\n  //. Performs a [stable sort][] of the elements of the given structure, using\n  //. [`Z.lte`][] to compare the values produced by applying the given function\n  //. to each element of the structure.\n  //.\n  //. Properties:\n  //.\n  //.   - `S.sortBy(f, S.sortBy(f, m)) = S.sortBy(f, m)` (idempotence)\n  //.\n  //. See also [`sort`](#sort).\n  //.\n  //. ```javascript\n  //. > S.sortBy(S.prop('rank'), [\n  //. .   {rank: 7, suit: 'spades'},\n  //. .   {rank: 5, suit: 'hearts'},\n  //. .   {rank: 2, suit: 'hearts'},\n  //. .   {rank: 5, suit: 'spades'},\n  //. . ])\n  //. [ {rank: 2, suit: 'hearts'},\n  //. . {rank: 5, suit: 'hearts'},\n  //. . {rank: 5, suit: 'spades'},\n  //. . {rank: 7, suit: 'spades'} ]\n  //.\n  //. > S.sortBy(S.prop('suit'), [\n  //. .   {rank: 7, suit: 'spades'},\n  //. .   {rank: 5, suit: 'hearts'},\n  //. .   {rank: 2, suit: 'hearts'},\n  //. .   {rank: 5, suit: 'spades'},\n  //. . ])\n  //. [ {rank: 5, suit: 'hearts'},\n  //. . {rank: 2, suit: 'hearts'},\n  //. . {rank: 7, suit: 'spades'},\n  //. . {rank: 5, suit: 'spades'} ]\n  //. ```\n  S.sortBy =\n  def('sortBy',\n      {b: [Z.Ord], m: [Z.Applicative, Z.Foldable, Z.Monoid]},\n      [Fn(a, b), m(a), m(a)],\n      Z.sortBy);\n\n  //. ### Object\n\n  //# prop :: String -> a -> b\n  //.\n  //. Takes a property name and an object with known properties and returns\n  //. the value of the specified property. If for some reason the object\n  //. lacks the specified property, a type error is thrown.\n  //.\n  //. For accessing properties of uncertain objects, use [`get`](#get) instead.\n  //.\n  //. See also [`pluck`](#pluck).\n  //.\n  //. ```javascript\n  //. > S.prop('a', {a: 1, b: 2})\n  //. 1\n  //. ```\n  function prop(key, x) {\n    var obj = toObject(x);\n    if (key in obj) return obj[key];\n    throw new TypeError('prop expected object to have a property named ' +\n                        key + '; ' + Z.toString(x) + ' does not');\n  }\n  S.prop = def('prop', {}, [$.String, a, b], prop);\n\n  //# props :: Array String -> a -> b\n  //.\n  //. Takes a property path (an array of property names) and an object with\n  //. known structure and returns the value at the given path. If for some\n  //. reason the path does not exist, a type error is thrown.\n  //.\n  //. For accessing property paths of uncertain objects, use [`gets`](#gets)\n  //. instead.\n  //.\n  //. ```javascript\n  //. > S.props(['a', 'b', 'c'], {a: {b: {c: 1}}})\n  //. 1\n  //. ```\n  function props(path, x) {\n    return path.reduce(function(x, key) {\n      var obj = toObject(x);\n      if (key in obj) return obj[key];\n      throw new TypeError('props expected object to have a property at ' +\n                          Z.toString(path) + '; ' +\n                          Z.toString(x) + ' does not');\n    }, x);\n  }\n  S.props = def('props', {}, [$.Array($.String), a, b], props);\n\n  //# get :: (Any -> Boolean) -> String -> a -> Maybe b\n  //.\n  //. Takes a predicate, a property name, and an object and returns Just the\n  //. value of the specified object property if it exists and the value\n  //. satisfies the given predicate; Nothing otherwise.\n  //.\n  //. See also [`gets`](#gets) and [`prop`](#prop).\n  //.\n  //. ```javascript\n  //. > S.get(S.is(Number), 'x', {x: 1, y: 2})\n  //. Just(1)\n  //.\n  //. > S.get(S.is(Number), 'x', {x: '1', y: '2'})\n  //. Nothing\n  //.\n  //. > S.get(S.is(Number), 'x', {})\n  //. Nothing\n  //.\n  //. > S.get($.test([], $.Array($.Number)), 'x', {x: [1, 2, 3]})\n  //. Just([1, 2, 3])\n  //.\n  //. > S.get($.test([], $.Array($.Number)), 'x', {x: [1, 2, 3, null]})\n  //. Nothing\n  //. ```\n  function get(pred, key, x) {\n    var obj = toObject(x);\n    if (key in obj) {\n      var val = obj[key];\n      if (pred(val)) return Just(val);\n    }\n    return Nothing;\n  }\n  S.get = def('get', {}, [$.Predicate($.Any), $.String, a, $Maybe(b)], get);\n\n  //# gets :: (Any -> Boolean) -> Array String -> a -> Maybe b\n  //.\n  //. Takes a predicate, a property path (an array of property names), and\n  //. an object and returns Just the value at the given path if such a path\n  //. exists and the value satisfies the given predicate; Nothing otherwise.\n  //.\n  //. See also [`get`](#get).\n  //.\n  //. ```javascript\n  //. > S.gets(S.is(Number), ['a', 'b', 'c'], {a: {b: {c: 42}}})\n  //. Just(42)\n  //.\n  //. > S.gets(S.is(Number), ['a', 'b', 'c'], {a: {b: {c: '42'}}})\n  //. Nothing\n  //.\n  //. > S.gets(S.is(Number), ['a', 'b', 'c'], {})\n  //. Nothing\n  //. ```\n  function gets(pred, keys, x) {\n    return Z.filter(pred, Z.reduce(function(m, key) {\n      return Z.chain(function(x) {\n        var obj = toObject(x);\n        return key in obj ? Just(obj[key]) : Nothing;\n      }, m);\n    }, Just(x), keys));\n  }\n  S.gets =\n  def('gets', {}, [$.Predicate($.Any), $.Array($.String), a, $Maybe(b)], gets);\n\n  //. ### StrMap\n  //.\n  //. StrMap is an abbreviation of _string map_. A string map is an object,\n  //. such as `{foo: 1, bar: 2, baz: 3}`, whose values are all members of\n  //. the same type. Formally, a value is a member of type `StrMap a` if its\n  //. [type identifier][] is `'Object'` and the values of its enumerable own\n  //. properties are all members of type `a`.\n\n  //# singleton :: String -> a -> StrMap a\n  //.\n  //. Takes a string and a value of any type, and returns a string map with\n  //. a single entry (mapping the key to the value).\n  //.\n  //. ```javascript\n  //. > S.singleton('foo', 42)\n  //. {foo: 42}\n  //. ```\n  function singleton(key, val) {\n    var strMap = {};\n    strMap[key] = val;\n    return strMap;\n  }\n  S.singleton = def('singleton', {}, [$.String, a, $.StrMap(a)], singleton);\n\n  //# insert :: String -> a -> StrMap a -> StrMap a\n  //.\n  //. Takes a string, a value of any type, and a string map, and returns a\n  //. string map comprising all the entries of the given string map plus the\n  //. entry specified by the first two arguments (which takes precedence).\n  //.\n  //. Equivalent to Haskell's `insert` function. Similar to Clojure's `assoc`\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.insert('c', 3, {a: 1, b: 2})\n  //. {a: 1, b: 2, c: 3}\n  //.\n  //. > S.insert('a', 4, {a: 1, b: 2})\n  //. {a: 4, b: 2}\n  //. ```\n  function insert(key, val, strMap) {\n    return Z.concat(strMap, singleton(key, val));\n  }\n  S.insert =\n  def('insert', {}, [$.String, a, $.StrMap(a), $.StrMap(a)], insert);\n\n  //# remove :: String -> StrMap a -> StrMap a\n  //.\n  //. Takes a string and a string map, and returns a string map comprising all\n  //. the entries of the given string map except the one whose key matches the\n  //. given string (if such a key exists).\n  //.\n  //. Equivalent to Haskell's `delete` function. Similar to Clojure's `dissoc`\n  //. function.\n  //.\n  //. ```javascript\n  //. > S.remove('c', {a: 1, b: 2, c: 3})\n  //. {a: 1, b: 2}\n  //.\n  //. > S.remove('c', {})\n  //. {}\n  //. ```\n  function remove(key, strMap) {\n    var result = Z.concat(strMap, {});\n    delete result[key];\n    return result;\n  }\n  S.remove = def('remove', {}, [$.String, $.StrMap(a), $.StrMap(a)], remove);\n\n  //# keys :: StrMap a -> Array String\n  //.\n  //. Returns the keys of the given string map, in arbitrary order.\n  //.\n  //. ```javascript\n  //. > S.keys({b: 2, c: 3, a: 1}).sort()\n  //. ['a', 'b', 'c']\n  //. ```\n  S.keys = def('keys', {}, [$.StrMap(a), $.Array($.String)], Object.keys);\n\n  //# values :: StrMap a -> Array a\n  //.\n  //. Returns the values of the given string map, in arbitrary order.\n  //.\n  //. ```javascript\n  //. > S.values({a: 1, c: 3, b: 2}).sort()\n  //. [1, 2, 3]\n  //. ```\n  function values(strMap) {\n    return Z.map(function(k) { return strMap[k]; }, Object.keys(strMap));\n  }\n  S.values = def('values', {}, [$.StrMap(a), $.Array(a)], values);\n\n  //# pairs :: StrMap a -> Array (Pair String a)\n  //.\n  //. Returns the keyvalue pairs of the given string map, in arbitrary order.\n  //.\n  //. ```javascript\n  //. > S.pairs({b: 2, a: 1, c: 3}).sort()\n  //. [['a', 1], ['b', 2], ['c', 3]]\n  //. ```\n  function pairs(strMap) {\n    return Z.map(function(k) { return [k, strMap[k]]; }, Object.keys(strMap));\n  }\n  S.pairs =\n  def('pairs', {}, [$.StrMap(a), $.Array($.Pair($.String, a))], pairs);\n\n  //# fromPairs :: Foldable f => f (Pair String a) -> StrMap a\n  //.\n  //. Returns a string map containing the keyvalue pairs specified by the\n  //. given [Foldable][]. If a key appears in multiple pairs, the rightmost\n  //. pair takes precedence.\n  //.\n  //. ```javascript\n  //. > S.fromPairs([['a', 1], ['b', 2], ['c', 3]])\n  //. {a: 1, b: 2, c: 3}\n  //.\n  //. > S.fromPairs([['x', 1], ['x', 2]])\n  //. {x: 2}\n  //. ```\n  function fromPairs(pairs) {\n    return Z.reduce(function(strMap, pair) {\n      strMap[pair[0]] = pair[1];\n      return strMap;\n    }, {}, pairs);\n  }\n  S.fromPairs =\n  def('fromPairs',\n      {f: [Z.Foldable]},\n      [f($.Pair($.String, a)), $.StrMap(a)],\n      fromPairs);\n\n  //. ### Number\n\n  //# negate :: ValidNumber -> ValidNumber\n  //.\n  //. Negates its argument.\n  //.\n  //. ```javascript\n  //. > S.negate(12.5)\n  //. -12.5\n  //.\n  //. > S.negate(-42)\n  //. 42\n  //. ```\n  function negate(n) {\n    return -n;\n  }\n  S.negate = def('negate', {}, [$.ValidNumber, $.ValidNumber], negate);\n\n  //# add :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the sum of two (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.add(1, 1)\n  //. 2\n  //. ```\n  function add(x, y) {\n    return x + y;\n  }\n  S.add =\n  def('add', {}, [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber], add);\n\n  //# sum :: Foldable f => f FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the sum of the given array of (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.sum([1, 2, 3, 4, 5])\n  //. 15\n  //.\n  //. > S.sum([])\n  //. 0\n  //.\n  //. > S.sum(S.Just(42))\n  //. 42\n  //.\n  //. > S.sum(S.Nothing)\n  //. 0\n  //. ```\n  function sum(foldable) {\n    return Z.reduce(add, 0, foldable);\n  }\n  S.sum =\n  def('sum', {f: [Z.Foldable]}, [f($.FiniteNumber), $.FiniteNumber], sum);\n\n  //# sub :: FiniteNumber -> (FiniteNumber -> FiniteNumber)\n  //.\n  //. Takes a finite number `n` and returns the _subtract `n`_ function.\n  //.\n  //. See also [`sub_`](#sub_).\n  //.\n  //. ```javascript\n  //. > S.map(S.sub(1), [1, 2, 3])\n  //. [0, 1, 2]\n  //. ```\n  S.sub =\n  def('sub',\n      {},\n      [$.FiniteNumber, Fn($.FiniteNumber, $.FiniteNumber)],\n      flip$(sub_));\n\n  //# sub_ :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the difference between two (finite) numbers.\n  //.\n  //. See also [`sub`](#sub).\n  //.\n  //. ```javascript\n  //. > S.sub_(4, 2)\n  //. 2\n  //. ```\n  function sub_(x, y) {\n    return x - y;\n  }\n  S.sub_ =\n  def('sub_', {}, [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber], sub_);\n\n  //# mult :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the product of two (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.mult(4, 2)\n  //. 8\n  //. ```\n  function mult(x, y) {\n    return x * y;\n  }\n  S.mult =\n  def('mult', {}, [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber], mult);\n\n  //# product :: Foldable f => f FiniteNumber -> FiniteNumber\n  //.\n  //. Returns the product of the given array of (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.product([1, 2, 3, 4, 5])\n  //. 120\n  //.\n  //. > S.product([])\n  //. 1\n  //.\n  //. > S.product(S.Just(42))\n  //. 42\n  //.\n  //. > S.product(S.Nothing)\n  //. 1\n  //. ```\n  function product(foldable) {\n    return Z.reduce(mult, 1, foldable);\n  }\n  S.product =\n  def('product',\n      {f: [Z.Foldable]},\n      [f($.FiniteNumber), $.FiniteNumber],\n      product);\n\n  //# div :: NonZeroFiniteNumber -> (FiniteNumber -> FiniteNumber)\n  //.\n  //. Takes a non-zero finite number `n` and returns the _divide by `n`_\n  //. function.\n  //.\n  //. See also [`div_`](#div_).\n  //.\n  //. ```javascript\n  //. > S.map(S.div(2), [0, 1, 2, 3])\n  //. [0, 0.5, 1, 1.5]\n  //. ```\n  S.div =\n  def('div',\n      {},\n      [$.NonZeroFiniteNumber, Fn($.FiniteNumber, $.FiniteNumber)],\n      flip$(div_));\n\n  //# div_ :: FiniteNumber -> NonZeroFiniteNumber -> FiniteNumber\n  //.\n  //. Returns the result of dividing its first argument (a finite number) by\n  //. its second argument (a non-zero finite number).\n  //.\n  //. See also [`div`](#div).\n  //.\n  //. ```javascript\n  //. > S.div_(7, 2)\n  //. 3.5\n  //.\n  //. > S.map(S.div_(24), [1, 2, 3, 4])\n  //. [24, 12, 8, 6]\n  //. ```\n  function div_(x, y) {\n    return x / y;\n  }\n  S.div_ =\n  def('div_',\n      {},\n      [$.FiniteNumber, $.NonZeroFiniteNumber, $.FiniteNumber],\n      div_);\n\n  //# pow :: FiniteNumber -> (FiniteNumber -> FiniteNumber)\n  //.\n  //. Takes a finite number `n` and returns the _power of `n`_ function.\n  //.\n  //. See also [`pow_`](#pow_).\n  //.\n  //. ```javascript\n  //. > S.map(S.pow(2), [-3, -2, -1, 0, 1, 2, 3])\n  //. [9, 4, 1, 0, 1, 4, 9]\n  //.\n  //. > S.map(S.pow(0.5), [1, 4, 9, 16, 25])\n  //. [1, 2, 3, 4, 5]\n  //. ```\n  S.pow =\n  def('pow',\n      {},\n      [$.FiniteNumber, Fn($.FiniteNumber, $.FiniteNumber)],\n      flip$(Math.pow));\n\n  //# pow_ :: FiniteNumber -> FiniteNumber -> FiniteNumber\n  //.\n  //. Curried version of [`Math.pow`][].\n  //.\n  //. See also [`pow`](#pow).\n  //.\n  //. ```javascript\n  //. > S.map(S.pow_(10), [-3, -2, -1, 0, 1, 2, 3])\n  //. [0.001, 0.01, 0.1, 1, 10, 100, 1000]\n  //. ```\n  S.pow_ =\n  def('pow_', {}, [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber], Math.pow);\n\n  //# mean :: Foldable f => f FiniteNumber -> Maybe FiniteNumber\n  //.\n  //. Returns the mean of the given array of (finite) numbers.\n  //.\n  //. ```javascript\n  //. > S.mean([1, 2, 3, 4, 5])\n  //. Just(3)\n  //.\n  //. > S.mean([])\n  //. Nothing\n  //.\n  //. > S.mean(S.Just(42))\n  //. Just(42)\n  //.\n  //. > S.mean(S.Nothing)\n  //. Nothing\n  //. ```\n  function mean(foldable) {\n    var result = Z.reduce(\n      function(acc, n) {\n        acc.total += n;\n        acc.count += 1;\n        return acc;\n      },\n      {total: 0, count: 0},\n      foldable\n    );\n    return result.count > 0 ? Just(result.total / result.count) : Nothing;\n  }\n  S.mean =\n  def('mean',\n      {f: [Z.Foldable]},\n      [f($.FiniteNumber), $Maybe($.FiniteNumber)],\n      mean);\n\n  //. ### Integer\n\n  //# even :: Integer -> Boolean\n  //.\n  //. Returns `true` if the given integer is even; `false` if it is odd.\n  //.\n  //. ```javascript\n  //. > S.even(42)\n  //. true\n  //.\n  //. > S.even(99)\n  //. false\n  //. ```\n  function even(n) {\n    return n % 2 === 0;\n  }\n  S.even = def('even', {}, [$.Integer, $.Boolean], even);\n\n  //# odd :: Integer -> Boolean\n  //.\n  //. Returns `true` if the given integer is odd; `false` if it is even.\n  //.\n  //. ```javascript\n  //. > S.odd(99)\n  //. true\n  //.\n  //. > S.odd(42)\n  //. false\n  //. ```\n  function odd(n) {\n    return n % 2 !== 0;\n  }\n  S.odd = def('odd', {}, [$.Integer, $.Boolean], odd);\n\n  //. ### Parse\n\n  //# parseDate :: String -> Maybe ValidDate\n  //.\n  //. Takes a string and returns Just the date represented by the string\n  //. if it does in fact represent a date; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.parseDate('2011-01-19T17:40:00Z')\n  //. Just(new Date('2011-01-19T17:40:00.000Z'))\n  //.\n  //. > S.parseDate('today')\n  //. Nothing\n  //. ```\n  function parseDate(s) {\n    var date = new Date(s);\n    return isNaN(date.valueOf()) ? Nothing : Just(date);\n  }\n  S.parseDate =\n  def('parseDate', {}, [$.String, $Maybe($.ValidDate)], parseDate);\n\n  //  requiredNonCapturingGroup :: Array String -> String\n  function requiredNonCapturingGroup(xs) {\n    return '(?:' + xs.join('|') + ')';\n  }\n\n  //  optionalNonCapturingGroup :: Array String -> String\n  function optionalNonCapturingGroup(xs) {\n    return requiredNonCapturingGroup(xs) + '?';\n  }\n\n  //  validFloatRepr :: RegExp\n  var validFloatRepr = new RegExp(\n    '^' +                     // start-of-string anchor\n    '\\\\s*' +                  // any number of leading whitespace characters\n    '[+-]?' +                 // optional sign\n    requiredNonCapturingGroup([\n      'Infinity',             // \"Infinity\"\n      'NaN',                  // \"NaN\"\n      requiredNonCapturingGroup([\n        '[0-9]+',             // number\n        '[0-9]+[.][0-9]+',    // number with interior decimal point\n        '[0-9]+[.]',          // number with trailing decimal point\n        '[.][0-9]+'           // number with leading decimal point\n      ]) +\n      optionalNonCapturingGroup([\n        '[Ee]' +              // \"E\" or \"e\"\n        '[+-]?' +             // optional sign\n        '[0-9]+'              // exponent\n      ])\n    ]) +\n    '\\\\s*' +                  // any number of trailing whitespace characters\n    '$'                       // end-of-string anchor\n  );\n\n  //# parseFloat :: String -> Maybe Number\n  //.\n  //. Takes a string and returns Just the number represented by the string\n  //. if it does in fact represent a number; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.parseFloat('-123.45')\n  //. Just(-123.45)\n  //.\n  //. > S.parseFloat('foo.bar')\n  //. Nothing\n  //. ```\n  function parseFloat_(s) {\n    return validFloatRepr.test(s) ? Just(parseFloat(s)) : Nothing;\n  }\n  S.parseFloat =\n  def('parseFloat', {}, [$.String, $Maybe($.Number)], parseFloat_);\n\n  //  Radix :: Type\n  var Radix = $.NullaryType(\n    'sanctuary/Radix',\n    '',\n    function(x) { return $.Integer._test(x) && x >= 2 && x <= 36; }\n  );\n\n  //# parseInt :: Radix -> String -> Maybe Integer\n  //.\n  //. Takes a radix (an integer between 2 and 36 inclusive) and a string,\n  //. and returns Just the number represented by the string if it does in\n  //. fact represent a number in the base specified by the radix; Nothing\n  //. otherwise.\n  //.\n  //. This function is stricter than [`parseInt`][parseInt]: a string\n  //. is considered to represent an integer only if all its non-prefix\n  //. characters are members of the character set specified by the radix.\n  //.\n  //. ```javascript\n  //. > S.parseInt(10, '-42')\n  //. Just(-42)\n  //.\n  //. > S.parseInt(16, '0xFF')\n  //. Just(255)\n  //.\n  //. > S.parseInt(16, '0xGG')\n  //. Nothing\n  //. ```\n  function parseInt_(radix, s) {\n    var charset = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.slice(0, radix);\n    var pattern = new RegExp('^[' + charset + ']+$', 'i');\n\n    var t = s.replace(/^[+-]/, '');\n    if (pattern.test(radix === 16 ? t.replace(/^0x/i, '') : t)) {\n      var n = parseInt(s, radix);\n      if ($.Integer._test(n)) return Just(n);\n    }\n    return Nothing;\n  }\n  S.parseInt =\n  def('parseInt', {}, [Radix, $.String, $Maybe($.Integer)], parseInt_);\n\n  //# parseJson :: (Any -> Boolean) -> String -> Maybe a\n  //.\n  //. Takes a predicate and a string which may or may not be valid JSON, and\n  //. returns Just the result of applying `JSON.parse` to the string *if* the\n  //. result satisfies the predicate; Nothing otherwise.\n  //.\n  //. ```javascript\n  //. > S.parseJson($.test([], $.Array($.Integer)), '[')\n  //. Nothing\n  //.\n  //. > S.parseJson($.test([], $.Array($.Integer)), '[\"1\",\"2\",\"3\"]')\n  //. Nothing\n  //.\n  //. > S.parseJson($.test([], $.Array($.Integer)), '[0,1.5,3,4.5]')\n  //. Nothing\n  //.\n  //. > S.parseJson($.test([], $.Array($.Integer)), '[1,2,3]')\n  //. Just([1, 2, 3])\n  //. ```\n  function parseJson(pred, s) {\n    return Z.filter(pred, encase(JSON.parse, s));\n  }\n  S.parseJson =\n  def('parseJson', {}, [$.Predicate($.Any), $.String, $Maybe(a)], parseJson);\n\n  //. ### RegExp\n\n  //  Match :: Type\n  var Match = $.RecordType({\n    match: $.String,\n    groups: $.Array($Maybe($.String))\n  });\n\n  //  toMatch :: Array String? -> Match\n  function toMatch(ss) {\n    return {match: ss[0], groups: ss.slice(1).map(toMaybe)};\n  }\n\n  //  withRegex :: (RegExp, () -> a) -> a\n  function withRegex(pattern, thunk) {\n    var lastIndex = pattern.lastIndex;\n    var result = thunk();\n    pattern.lastIndex = lastIndex;\n    return result;\n  }\n\n  //# regex :: RegexFlags -> String -> RegExp\n  //.\n  //. Takes a [RegexFlags][] and a pattern, and returns a RegExp.\n  //.\n  //. ```javascript\n  //. > S.regex('g', ':\\\\d+:')\n  //. /:\\d+:/g\n  //. ```\n  function regex(flags, source) {\n    return new RegExp(source, flags);\n  }\n  S.regex = def('regex', {}, [$.RegexFlags, $.String, $.RegExp], regex);\n\n  //# regexEscape :: String -> String\n  //.\n  //. Takes a string which may contain regular expression metacharacters,\n  //. and returns a string with those metacharacters escaped.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall s :: String. S.test(S.regex('', S.regexEscape(s)), s) = true`\n  //.\n  //. ```javascript\n  //. > S.regexEscape('-=*{XYZ}*=-')\n  //. '\\\\-=\\\\*\\\\{XYZ\\\\}\\\\*=\\\\-'\n  //. ```\n  function regexEscape(s) {\n    return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n  }\n  S.regexEscape = def('regexEscape', {}, [$.String, $.String], regexEscape);\n\n  //# test :: RegExp -> String -> Boolean\n  //.\n  //. Takes a pattern and a string, and returns `true` [iff][] the pattern\n  //. matches the string.\n  //.\n  //. ```javascript\n  //. > S.test(/^a/, 'abacus')\n  //. true\n  //.\n  //. > S.test(/^a/, 'banana')\n  //. false\n  //. ```\n  function test(pattern, s) {\n    return withRegex(pattern, function() { return pattern.test(s); });\n  }\n  S.test = def('test', {}, [$.RegExp, $.String, $.Boolean], test);\n\n  //# match :: NonGlobalRegExp -> String -> Maybe { match :: String, groups :: Array (Maybe String) }\n  //.\n  //. Takes a pattern and a string, and returns Just a match record if the\n  //. pattern matches the string; Nothing otherwise.\n  //.\n  //. `groups :: Array (Maybe String)` acknowledges the existence of optional\n  //. capturing groups.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall p :: Pattern, s :: String.\n  //.      S.head(S.matchAll(S.regex('g', p), s)) = S.match(S.regex('', p), s)`\n  //.\n  //. See also [`matchAll`](#matchAll).\n  //.\n  //. ```javascript\n  //. > S.match(/(good)?bye/, 'goodbye')\n  //. Just({match: 'goodbye', groups: [Just('good')]})\n  //.\n  //. > S.match(/(good)?bye/, 'bye')\n  //. Just({match: 'bye', groups: [Nothing]})\n  //. ```\n  function match(pattern, s) {\n    return Z.map(toMatch, toMaybe(s.match(pattern)));\n  }\n  S.match =\n  def('match', {}, [$.NonGlobalRegExp, $.String, $Maybe(Match)], match);\n\n  //# matchAll :: GlobalRegExp -> String -> Array { match :: String, groups :: Array (Maybe String) }\n  //.\n  //. Takes a pattern and a string, and returns an array of match records.\n  //.\n  //. `groups :: Array (Maybe String)` acknowledges the existence of optional\n  //. capturing groups.\n  //.\n  //. See also [`match`](#match).\n  //.\n  //. ```javascript\n  //. > S.matchAll(/@([a-z]+)/g, 'Hello, world!')\n  //. []\n  //.\n  //. > S.matchAll(/@([a-z]+)/g, 'Hello, @foo! Hello, @bar! Hello, @baz!')\n  //. [ {match: '@foo', groups: [Just('foo')]},\n  //. . {match: '@bar', groups: [Just('bar')]},\n  //. . {match: '@baz', groups: [Just('baz')]} ]\n  //. ```\n  function matchAll(pattern, s) {\n    return withRegex(pattern, function() {\n      return unfoldr(function(_) {\n        return Z.map(function(ss) {\n          return [toMatch(ss), null];\n        }, toMaybe(pattern.exec(s)));\n      }, []);\n    });\n  }\n  S.matchAll =\n  def('matchAll', {}, [$.GlobalRegExp, $.String, $.Array(Match)], matchAll);\n\n  //. ### String\n\n  //# toUpper :: String -> String\n  //.\n  //. Returns the upper-case equivalent of its argument.\n  //.\n  //. See also [`toLower`](#toLower).\n  //.\n  //. ```javascript\n  //. > S.toUpper('ABC def 123')\n  //. 'ABC DEF 123'\n  //. ```\n  function toUpper(s) {\n    return s.toUpperCase();\n  }\n  S.toUpper = def('toUpper', {}, [$.String, $.String], toUpper);\n\n  //# toLower :: String -> String\n  //.\n  //. Returns the lower-case equivalent of its argument.\n  //.\n  //. See also [`toUpper`](#toUpper).\n  //.\n  //. ```javascript\n  //. > S.toLower('ABC def 123')\n  //. 'abc def 123'\n  //. ```\n  function toLower(s) {\n    return s.toLowerCase();\n  }\n  S.toLower = def('toLower', {}, [$.String, $.String], toLower);\n\n  //# trim :: String -> String\n  //.\n  //. Strips leading and trailing whitespace characters.\n  //.\n  //. ```javascript\n  //. > S.trim('\\t\\t foo bar \\n')\n  //. 'foo bar'\n  //. ```\n  function trim(s) {\n    return s.trim();\n  }\n  S.trim = def('trim', {}, [$.String, $.String], trim);\n\n  //# stripPrefix :: String -> String -> Maybe String\n  //.\n  //. Returns Just the portion of the given string (the second argument) left\n  //. after removing the given prefix (the first argument) if the string starts\n  //. with the prefix; Nothing otherwise.\n  //.\n  //. See also [`stripSuffix`](#stripSuffix).\n  //.\n  //. ```javascript\n  //. > S.stripPrefix('https://', 'https://sanctuary.js.org')\n  //. Just('sanctuary.js.org')\n  //.\n  //. > S.stripPrefix('https://', 'http://sanctuary.js.org')\n  //. Nothing\n  //. ```\n  function stripPrefix(prefix, s) {\n    var idx = prefix.length;\n    return s.slice(0, idx) === prefix ? Just(s.slice(idx)) : Nothing;\n  }\n  S.stripPrefix =\n  def('stripPrefix', {}, [$.String, $.String, $Maybe($.String)], stripPrefix);\n\n  //# stripSuffix :: String -> String -> Maybe String\n  //.\n  //. Returns Just the portion of the given string (the second argument) left\n  //. after removing the given suffix (the first argument) if the string ends\n  //. with the suffix; Nothing otherwise.\n  //.\n  //. See also [`stripPrefix`](#stripPrefix).\n  //.\n  //. ```javascript\n  //. > S.stripSuffix('.md', 'README.md')\n  //. Just('README')\n  //.\n  //. > S.stripSuffix('.md', 'README')\n  //. Nothing\n  //. ```\n  function stripSuffix(suffix, s) {\n    var idx = s.length - suffix.length;  // value may be negative\n    return s.slice(idx) === suffix ? Just(s.slice(0, idx)) : Nothing;\n  }\n  S.stripSuffix =\n  def('stripSuffix', {}, [$.String, $.String, $Maybe($.String)], stripSuffix);\n\n  //# words :: String -> Array String\n  //.\n  //. Takes a string and returns the array of words the string contains\n  //. (words are delimited by whitespace characters).\n  //.\n  //. See also [`unwords`](#unwords).\n  //.\n  //. ```javascript\n  //. > S.words(' foo bar baz ')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  function words(s) {\n    var words = s.split(/\\s+/);\n    return words.slice(words[0] === '' ? 1 : 0,\n                       words[words.length - 1] === '' ? -1 : Infinity);\n  }\n  S.words = def('words', {}, [$.String, $.Array($.String)], words);\n\n  //# unwords :: Array String -> String\n  //.\n  //. Takes an array of words and returns the result of joining the words\n  //. with separating spaces.\n  //.\n  //. See also [`words`](#words).\n  //.\n  //. ```javascript\n  //. > S.unwords(['foo', 'bar', 'baz'])\n  //. 'foo bar baz'\n  //. ```\n  function unwords(xs) {\n    return xs.join(' ');\n  }\n  S.unwords = def('unwords', {}, [$.Array($.String), $.String], unwords);\n\n  //# lines :: String -> Array String\n  //.\n  //. Takes a string and returns the array of lines the string contains\n  //. (lines are delimited by newlines: `'\\n'` or `'\\r\\n'` or `'\\r'`).\n  //. The resulting strings do not contain newlines.\n  //.\n  //. See also [`unlines`](#unlines).\n  //.\n  //. ```javascript\n  //. > S.lines('foo\\nbar\\nbaz\\n')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  function lines(s) {\n    var match = s.replace(/\\r\\n?/g, '\\n').match(/^(?=[\\s\\S]).*/gm);\n    return match == null ? [] : match;\n  }\n  S.lines = def('lines', {}, [$.String, $.Array($.String)], lines);\n\n  //# unlines :: Array String -> String\n  //.\n  //. Takes an array of lines and returns the result of joining the lines\n  //. after appending a terminating line feed (`'\\n'`) to each.\n  //.\n  //. See also [`lines`](#lines).\n  //.\n  //. ```javascript\n  //. > S.unlines(['foo', 'bar', 'baz'])\n  //. 'foo\\nbar\\nbaz\\n'\n  //. ```\n  function unlines(xs) {\n    return Z.reduce(function(s, x) { return s + x + '\\n'; }, '', xs);\n  }\n  S.unlines = def('unlines', {}, [$.Array($.String), $.String], unlines);\n\n  //# splitOn :: String -> String -> Array String\n  //.\n  //. Returns the substrings of its second argument separated by occurrences\n  //. of its first argument.\n  //.\n  //. See also [`joinWith`](#joinWith) and [`splitOnRegex`](#splitOnRegex).\n  //.\n  //. ```javascript\n  //. > S.splitOn('::', 'foo::bar::baz')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  function splitOn(separator, s) {\n    return s.split(separator);\n  }\n  S.splitOn =\n  def('splitOn', {}, [$.String, $.String, $.Array($.String)], splitOn);\n\n  //# splitOnRegex :: GlobalRegExp -> String -> Array String\n  //.\n  //. Takes a pattern and a string, and returns the result of splitting the\n  //. string at every non-overlapping occurrence of the pattern.\n  //.\n  //. Properties:\n  //.\n  //.   - `forall s :: String, t :: String.\n  //.      S.joinWith(s, S.splitOnRegex(S.regex('g', S.regexEscape(s)), t))\n  //.      = t`\n  //.\n  //. See also [`splitOn`](#splitOn).\n  //.\n  //. ```javascript\n  //. > S.splitOnRegex(/[,;][ ]*/g, 'foo, bar, baz')\n  //. ['foo', 'bar', 'baz']\n  //.\n  //. > S.splitOnRegex(/[,;][ ]*/g, 'foo;bar;baz')\n  //. ['foo', 'bar', 'baz']\n  //. ```\n  function splitOnRegex(pattern, s) {\n    return withRegex(pattern, function() {\n      var result = [];\n      var lastIndex = 0;\n      var match;\n      while ((match = pattern.exec(s)) != null) {\n        if (pattern.lastIndex === lastIndex && match[0] === '') {\n          if (pattern.lastIndex === s.length) return result;\n          pattern.lastIndex += 1;\n        } else {\n          result.push(s.slice(lastIndex, match.index));\n          lastIndex = match.index + match[0].length;\n        }\n      }\n      result.push(s.slice(lastIndex));\n      return result;\n    });\n  }\n  S.splitOnRegex =\n  def('splitOnRegex',\n      {},\n      [$.GlobalRegExp, $.String, $.Array($.String)],\n      splitOnRegex);\n\n  return S;\n\n  /* eslint-enable indent */\n\n  }\n\n  return createSanctuary({checkTypes: true, env: defaultEnv});\n\n}));\n\n//. [$.Array]:          v:sanctuary-js/sanctuary-def#Array\n//. [$.String]:         v:sanctuary-js/sanctuary-def#String\n//. [Alt]:              v:fantasyland/fantasy-land#alt\n//. [Alternative]:      v:fantasyland/fantasy-land#alternative\n//. [Applicative]:      v:fantasyland/fantasy-land#applicative\n//. [Apply]:            v:fantasyland/fantasy-land#apply\n//. [Bifunctor]:        v:fantasyland/fantasy-land#bifunctor\n//. [BinaryType]:       v:sanctuary-js/sanctuary-def#BinaryType\n//. [Either]:           #either-type\n//. [Extend]:           v:fantasyland/fantasy-land#extend\n//. [Fantasy Land]:     v:fantasyland/fantasy-land\n//. [Foldable]:         v:fantasyland/fantasy-land#foldable\n//. [Haskell]:          https://www.haskell.org/\n//. [Maybe]:            #maybe-type\n//. [Monad]:            v:fantasyland/fantasy-land#monad\n//. [Monoid]:           v:fantasyland/fantasy-land#monoid\n//. [Nullable]:         v:sanctuary-js/sanctuary-def#Nullable\n//. [Ord]:              v:fantasyland/fantasy-land#ord\n//. [PureScript]:       http://www.purescript.org/\n//. [Ramda]:            http://ramdajs.com/\n//. [RegexFlags]:       v:sanctuary-js/sanctuary-def#RegexFlags\n//. [Semigroup]:        v:fantasyland/fantasy-land#semigroup\n//. [Semigroupoid]:     v:fantasyland/fantasy-land#semigroupoid\n//. [Traversable]:      v:fantasyland/fantasy-land#traversable\n//. [UnaryType]:        v:sanctuary-js/sanctuary-def#UnaryType\n//. [`Math.pow`]:       https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/pow\n//. [`Z.alt`]:          v:sanctuary-js/sanctuary-type-classes#alt\n//. [`Z.ap`]:           v:sanctuary-js/sanctuary-type-classes#ap\n//. [`Z.apFirst`]:      v:sanctuary-js/sanctuary-type-classes#apFirst\n//. [`Z.apSecond`]:     v:sanctuary-js/sanctuary-type-classes#apSecond\n//. [`Z.bimap`]:        v:sanctuary-js/sanctuary-type-classes#bimap\n//. [`Z.chain`]:        v:sanctuary-js/sanctuary-type-classes#chain\n//. [`Z.chainRec`]:     v:sanctuary-js/sanctuary-type-classes#chainRec\n//. [`Z.compose`]:      v:sanctuary-js/sanctuary-type-classes#compose\n//. [`Z.concat`]:       v:sanctuary-js/sanctuary-type-classes#concat\n//. [`Z.contramap`]:    v:sanctuary-js/sanctuary-type-classes#contramap\n//. [`Z.empty`]:        v:sanctuary-js/sanctuary-type-classes#empty\n//. [`Z.equals`]:       v:sanctuary-js/sanctuary-type-classes#equals\n//. [`Z.extend`]:       v:sanctuary-js/sanctuary-type-classes#extend\n//. [`Z.extract`]:      v:sanctuary-js/sanctuary-type-classes#extract\n//. [`Z.filter`]:       v:sanctuary-js/sanctuary-type-classes#filter\n//. [`Z.filterM`]:      v:sanctuary-js/sanctuary-type-classes#filterM\n//. [`Z.gt`]:           v:sanctuary-js/sanctuary-type-classes#gt\n//. [`Z.gte`]:          v:sanctuary-js/sanctuary-type-classes#gte\n//. [`Z.id`]:           v:sanctuary-js/sanctuary-type-classes#id\n//. [`Z.invert`]:       v:sanctuary-js/sanctuary-type-classes#invert\n//. [`Z.join`]:         v:sanctuary-js/sanctuary-type-classes#join\n//. [`Z.lt`]:           v:sanctuary-js/sanctuary-type-classes#lt\n//. [`Z.lte`]:          v:sanctuary-js/sanctuary-type-classes#lte\n//. [`Z.map`]:          v:sanctuary-js/sanctuary-type-classes#map\n//. [`Z.of`]:           v:sanctuary-js/sanctuary-type-classes#of\n//. [`Z.promap`]:       v:sanctuary-js/sanctuary-type-classes#promap\n//. [`Z.sequence`]:     v:sanctuary-js/sanctuary-type-classes#sequence\n//. [`Z.toString`]:     v:sanctuary-js/sanctuary-type-classes#toString\n//. [`Z.traverse`]:     v:sanctuary-js/sanctuary-type-classes#traverse\n//. [`Z.zero`]:         v:sanctuary-js/sanctuary-type-classes#zero\n//. [`of`]:             v:fantasyland/fantasy-land#of-method\n//. [equivalence]:      https://en.wikipedia.org/wiki/Equivalence_relation\n//. [iff]:              https://en.wikipedia.org/wiki/If_and_only_if\n//. [parseInt]:         https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n//. [sanctuary-def]:    v:sanctuary-js/sanctuary-def\n//. [stable sort]:      https://en.wikipedia.org/wiki/Sorting_algorithm#Stability\n//. [thrush]:           https://github.com/raganwald-deprecated/homoiconic/blob/master/2008-10-30/thrush.markdown\n//. [type identifier]:  v:sanctuary-js/sanctuary-type-identifiers\n//.\n//. [`Either#fantasy-land/bimap`]:      #Either.prototype.fantasy-land/bimap\n//. [`Either#fantasy-land/map`]:        #Either.prototype.fantasy-land/map\n//. [`Either#toString`]:                #Either.prototype.toString\n//. [`Maybe#toString`]:                 #Maybe.prototype.toString\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5L2luZGV4LmpzP2UwZTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogICAgIyMjIyMjI1xuICAgIyMjIyAgICAgIyMjI1xuICMjIyMgICAjIyMgICAjIyMjXG4jIyMjIyAgICMjIyMjIyMjIyMjICAgc2FuY3R1YXJ5XG4jIyMjIyMjIyAgICMjIyMjIyMjICAgbm91blxuIyMjIyMjIyMjIyMgICAjIyMjIyAgIDEgWyBtYXNzIG5vdW4gXSByZWZ1Z2UgZnJvbSB1bnNhZmUgSmF2YVNjcmlwdFxuICMjIyMgICAjIyMgICAjIyMjXG4gICAjIyMjICAgICAjIyMjXG4gICAgICAjIyMjIyMjICAgICovXG5cbi8vLiAjIFNhbmN0dWFyeVxuLy8uXG4vLy4gWyFbbnBtXShodHRwczovL2ltZy5zaGllbGRzLmlvL25wbS92L3NhbmN0dWFyeS5zdmcpXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9zYW5jdHVhcnkpXG4vLy4gWyFbQ2lyY2xlQ0ldKGh0dHBzOi8vaW1nLnNoaWVsZHMuaW8vY2lyY2xlY2kvcHJvamVjdC9naXRodWIvc2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS9tYXN0ZXIuc3ZnKV0oaHR0cHM6Ly9jaXJjbGVjaS5jb20vZ2gvc2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS90cmVlL21hc3Rlcilcbi8vLiBbIVtHaXR0ZXJdKGh0dHBzOi8vaW1nLnNoaWVsZHMuaW8vZ2l0dGVyL3Jvb20vYmFkZ2VzL3NoaWVsZHMuc3ZnKV0oaHR0cHM6Ly9naXR0ZXIuaW0vc2FuY3R1YXJ5LWpzL3NhbmN0dWFyeSlcbi8vLlxuLy8uIFNhbmN0dWFyeSBpcyBhIEphdmFTY3JpcHQgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBsaWJyYXJ5IGluc3BpcmVkIGJ5XG4vLy4gW0hhc2tlbGxdW10gYW5kIFtQdXJlU2NyaXB0XVtdLiBJdCdzIHN0cmljdGVyIHRoYW4gW1JhbWRhXVtdLCBhbmRcbi8vLiBwcm92aWRlcyBhIHNpbWlsYXIgc3VpdGUgb2YgZnVuY3Rpb25zLlxuLy8uXG4vLy4gU2FuY3R1YXJ5IHByb21vdGVzIHByb2dyYW1zIGNvbXBvc2VkIG9mIHNpbXBsZSwgcHVyZSBmdW5jdGlvbnMuIFN1Y2hcbi8vLiBwcm9ncmFtcyBhcmUgZWFzaWVyIHRvIGNvbXByZWhlbmQsIHRlc3QsIGFuZCBtYWludGFpbiAmbmRhc2g7IHRoZXkgYXJlXG4vLy4gYWxzbyBhIHBsZWFzdXJlIHRvIHdyaXRlLlxuLy8uXG4vLy4gU2FuY3R1YXJ5IHByb3ZpZGVzIHR3byBkYXRhIHR5cGVzLCBbTWF5YmVdW10gYW5kIFtFaXRoZXJdW10sIGJvdGggb2Zcbi8vLiB3aGljaCBhcmUgY29tcGF0aWJsZSB3aXRoIFtGYW50YXN5IExhbmRdW10uIFRoYW5rcyB0byB0aGVzZSBkYXRhIHR5cGVzXG4vLy4gZXZlbiBTYW5jdHVhcnkgZnVuY3Rpb25zIHdoaWNoIG1heSBmYWlsLCBzdWNoIGFzIFtgaGVhZGBdKCNoZWFkKSwgYXJlXG4vLy4gY29tcG9zYWJsZS5cbi8vLlxuLy8uIFNhbmN0dWFyeSBtYWtlcyBpdCBwb3NzaWJsZSB0byB3cml0ZSBzYWZlIGNvZGUgd2l0aG91dCBudWxsIGNoZWNrcy5cbi8vLiBJbiBKYXZhU2NyaXB0IGl0J3MgdHJpdmlhbCB0byBpbnRyb2R1Y2UgYSBwb3NzaWJsZSBydW4tdGltZSB0eXBlIGVycm9yOlxuLy8uXG4vLy4gICAgIHdvcmRzWzBdLnRvVXBwZXJDYXNlKClcbi8vLlxuLy8uIElmIGB3b3Jkc2AgaXMgYFtdYCB3ZSdsbCBnZXQgYSBmYW1pbGlhciBlcnJvciBhdCBydW4tdGltZTpcbi8vLlxuLy8uICAgICBUeXBlRXJyb3I6IENhbm5vdCByZWFkIHByb3BlcnR5ICd0b1VwcGVyQ2FzZScgb2YgdW5kZWZpbmVkXG4vLy5cbi8vLiBTYW5jdHVhcnkgZ2l2ZXMgdXMgYSBmaWdodGluZyBjaGFuY2Ugb2YgYXZvaWRpbmcgc3VjaCBlcnJvcnMuIFdlIG1pZ2h0XG4vLy4gd3JpdGU6XG4vLy5cbi8vLiAgICAgUy5tYXAoUy50b1VwcGVyLCBTLmhlYWQod29yZHMpKVxuLy8uXG4vLy4gU2FuY3R1YXJ5IGlzIGRlc2lnbmVkIHRvIHdvcmsgaW4gTm9kZS5qcyBhbmQgaW4gRVM1LWNvbXBhdGlibGUgYnJvd3NlcnMuXG4vLy5cbi8vLiAjIyBUeXBlc1xuLy8uXG4vLy4gU2FuY3R1YXJ5IHVzZXMgSGFza2VsbC1saWtlIHR5cGUgc2lnbmF0dXJlcyB0byBkZXNjcmliZSB0aGUgdHlwZXMgb2Zcbi8vLiB2YWx1ZXMsIGluY2x1ZGluZyBmdW5jdGlvbnMuIGAnZm9vJ2AsIGZvciBleGFtcGxlLCBpcyBhIG1lbWJlciBvZiBgU3RyaW5nYDtcbi8vLiBgWzEsIDIsIDNdYCBpcyBhIG1lbWJlciBvZiBgQXJyYXkgTnVtYmVyYC4gVGhlIGRvdWJsZSBjb2xvbiAoYDo6YCkgaXMgdXNlZFxuLy8uIHRvIG1lYW4gXCJpcyBhIG1lbWJlciBvZlwiLCBzbyBvbmUgY291bGQgd3JpdGU6XG4vLy5cbi8vLiAgICAgJ2ZvbycgOjogU3RyaW5nXG4vLy4gICAgIFsxLCAyLCAzXSA6OiBBcnJheSBOdW1iZXJcbi8vLlxuLy8uIEFuIGlkZW50aWZpZXIgbWF5IGFwcGVhciB0byB0aGUgbGVmdCBvZiB0aGUgZG91YmxlIGNvbG9uOlxuLy8uXG4vLy4gICAgIE1hdGguUEkgOjogTnVtYmVyXG4vLy5cbi8vLiBUaGUgYXJyb3cgKGAtPmApIGlzIHVzZWQgdG8gZXhwcmVzcyBhIGZ1bmN0aW9uJ3MgdHlwZTpcbi8vLlxuLy8uICAgICBNYXRoLmFicyA6OiBOdW1iZXIgLT4gTnVtYmVyXG4vLy5cbi8vLiBUaGF0IHN0YXRlcyB0aGF0IGBNYXRoLmFic2AgaXMgYSB1bmFyeSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhbiBhcmd1bWVudFxuLy8uIG9mIHR5cGUgYE51bWJlcmAgYW5kIHJldHVybnMgYSB2YWx1ZSBvZiB0eXBlIGBOdW1iZXJgLlxuLy8uXG4vLy4gU29tZSBmdW5jdGlvbnMgYXJlIHBhcmFtZXRyaWNhbGx5IHBvbHltb3JwaGljOiB0aGVpciB0eXBlcyBhcmUgbm90IGZpeGVkLlxuLy8uIFR5cGUgdmFyaWFibGVzIGFyZSB1c2VkIGluIHRoZSByZXByZXNlbnRhdGlvbnMgb2Ygc3VjaCBmdW5jdGlvbnM6XG4vLy5cbi8vLiAgICAgUy5JIDo6IGEgLT4gYVxuLy8uXG4vLy4gYGFgIGlzIGEgdHlwZSB2YXJpYWJsZS4gVHlwZSB2YXJpYWJsZXMgYXJlIG5vdCBjYXBpdGFsaXplZCwgc28gdGhleVxuLy8uIGFyZSBkaWZmZXJlbnRpYWJsZSBmcm9tIHR5cGUgaWRlbnRpZmllcnMgKHdoaWNoIGFyZSBhbHdheXMgY2FwaXRhbGl6ZWQpLlxuLy8uIEJ5IGNvbnZlbnRpb24gdHlwZSB2YXJpYWJsZXMgaGF2ZSBzaW5nbGUtY2hhcmFjdGVyIG5hbWVzLiBUaGUgc2lnbmF0dXJlXG4vLy4gYWJvdmUgc3RhdGVzIHRoYXQgYFMuSWAgdGFrZXMgYSB2YWx1ZSBvZiBhbnkgdHlwZSBhbmQgcmV0dXJucyBhIHZhbHVlIG9mXG4vLy4gdGhlIHNhbWUgdHlwZS4gU29tZSBzaWduYXR1cmVzIGZlYXR1cmUgbXVsdGlwbGUgdHlwZSB2YXJpYWJsZXM6XG4vLy5cbi8vLiAgICAgUy5LIDo6IGEgLT4gYiAtPiBhXG4vLy5cbi8vLiBJdCBtdXN0IGJlIHBvc3NpYmxlIHRvIHJlcGxhY2UgYWxsIG9jY3VycmVuY2VzIG9mIGBhYCB3aXRoIGEgY29uY3JldGUgdHlwZS5cbi8vLiBUaGUgc2FtZSBhcHBsaWVzIGZvciBlYWNoIG90aGVyIHR5cGUgdmFyaWFibGUuIEZvciB0aGUgZnVuY3Rpb24gYWJvdmUsIHRoZVxuLy8uIHR5cGVzIHdpdGggd2hpY2ggYGFgIGFuZCBgYmAgYXJlIHJlcGxhY2VkIG1heSBiZSBkaWZmZXJlbnQsIGJ1dCBuZWVkbid0IGJlLlxuLy8uXG4vLy4gU2luY2UgYWxsIFNhbmN0dWFyeSBmdW5jdGlvbnMgYXJlIGN1cnJpZWQgKHRoZXkgYWNjZXB0IHRoZWlyIGFyZ3VtZW50c1xuLy8uIG9uZSBhdCBhIHRpbWUpLCBhIGJpbmFyeSBmdW5jdGlvbiBpcyByZXByZXNlbnRlZCBhcyBhIHVuYXJ5IGZ1bmN0aW9uIHdoaWNoXG4vLy4gcmV0dXJucyBhIHVuYXJ5IGZ1bmN0aW9uOiBgKiAtPiAqIC0+ICpgLiBUaGlzIGFsaWducyBuZWF0bHkgd2l0aCBIYXNrZWxsLFxuLy8uIHdoaWNoIHVzZXMgY3VycmllZCBmdW5jdGlvbnMgZXhjbHVzaXZlbHkuIEluIEphdmFTY3JpcHQsIHRob3VnaCwgd2UgbWF5XG4vLy4gd2lzaCB0byByZXByZXNlbnQgdGhlIHR5cGVzIG9mIGZ1bmN0aW9ucyB3aXRoIGFyaXRpZXMgbGVzcyB0aGFuIG9yIGdyZWF0ZXJcbi8vLiB0aGFuIG9uZS4gVGhlIGdlbmVyYWwgZm9ybSBpcyBgKDxpbnB1dC10eXBlcz4pIC0+IDxvdXRwdXQtdHlwZT5gLCB3aGVyZVxuLy8uIGA8aW5wdXQtdHlwZXM+YCBjb21wcmlzZXMgemVybyBvciBtb3JlIGNvbW1h4oCTc3BhY2UgKDxjb2RlPiwgPC9jb2RlPilcbi8vLiAtc2VwYXJhdGVkIHR5cGUgcmVwcmVzZW50YXRpb25zOlxuLy8uXG4vLy4gICAtIGAoKSAtPiBTdHJpbmdgXG4vLy4gICAtIGAoYSwgYikgLT4gYWBcbi8vLiAgIC0gYChhLCBiLCBjKSAtPiBkYFxuLy8uXG4vLy4gYE51bWJlciAtPiBOdW1iZXJgIGNhbiB0aHVzIGJlIHNlZW4gYXMgc2hvcnRoYW5kIGZvciBgKE51bWJlcikgLT4gTnVtYmVyYC5cbi8vLlxuLy8uIFRoZSBxdWVzdGlvbiBtYXJrIChgP2ApIGlzIHVzZWQgdG8gcmVwcmVzZW50IHR5cGVzIHdoaWNoIGluY2x1ZGUgYG51bGxgXG4vLy4gYW5kIGB1bmRlZmluZWRgIGFzIG1lbWJlcnMuIGBTdHJpbmc/YCwgZm9yIGV4YW1wbGUsIHJlcHJlc2VudHMgdGhlIHR5cGVcbi8vLiBjb21wcmlzaW5nIGBudWxsYCwgYHVuZGVmaW5lZGAsIGFuZCBhbGwgc3RyaW5ncy5cbi8vLlxuLy8uIFNhbmN0dWFyeSBlbWJyYWNlcyB0eXBlcy4gSmF2YVNjcmlwdCBkb2Vzbid0IHN1cHBvcnQgYWxnZWJyYWljIGRhdGEgdHlwZXMsXG4vLy4gYnV0IHRoZXNlIGNhbiBiZSBzaW11bGF0ZWQgYnkgcHJvdmlkaW5nIGEgZ3JvdXAgb2YgZGF0YSBjb25zdHJ1Y3RvcnMgd2hpY2hcbi8vLiByZXR1cm4gdmFsdWVzIHdpdGggdGhlIHNhbWUgc2V0IG9mIG1ldGhvZHMuIEEgdmFsdWUgb2YgdGhlIEVpdGhlciB0eXBlLCBmb3Jcbi8vLiBleGFtcGxlLCBpcyBjcmVhdGVkIHZpYSB0aGUgTGVmdCBjb25zdHJ1Y3RvciBvciB0aGUgUmlnaHQgY29uc3RydWN0b3IuXG4vLy5cbi8vLiBJdCdzIG5lY2Vzc2FyeSB0byBleHRlbmQgSGFza2VsbCdzIG5vdGF0aW9uIHRvIGRlc2NyaWJlIGltcGxpY2l0IGFyZ3VtZW50c1xuLy8uIHRvIHRoZSAqbWV0aG9kcyogcHJvdmlkZWQgYnkgU2FuY3R1YXJ5J3MgdHlwZXMuIEluIGB4Lm1hcCh5KWAsIGZvciBleGFtcGxlLFxuLy8uIHRoZSBgbWFwYCBtZXRob2QgdGFrZXMgYW4gaW1wbGljaXQgYXJndW1lbnQgYHhgIGluIGFkZGl0aW9uIHRvIHRoZSBleHBsaWNpdFxuLy8uIGFyZ3VtZW50IGB5YC4gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHVwb24gd2hpY2ggYSBtZXRob2QgaXMgaW52b2tlZCBhcHBlYXJzXG4vLy4gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2lnbmF0dXJlLCBzZXBhcmF0ZWQgZnJvbSB0aGUgYXJndW1lbnRzIGFuZCByZXR1cm5cbi8vLiB2YWx1ZSBieSBhIHNxdWlnZ2x5IGFycm93IChgfj5gKS4gVGhlIHR5cGUgb2YgdGhlIGBmYW50YXN5LWxhbmQvbWFwYCBtZXRob2Rcbi8vLiBvZiB0aGUgTWF5YmUgdHlwZSBpcyB3cml0dGVuIGBNYXliZSBhIH4+IChhIC0+IGIpIC0+IE1heWJlIGJgLiBPbmUgY291bGRcbi8vLiByZWFkIHRoaXMgYXM6XG4vLy5cbi8vLiBfV2hlbiB0aGUgYGZhbnRhc3ktbGFuZC9tYXBgIG1ldGhvZCBpcyBpbnZva2VkIG9uIGEgdmFsdWUgb2YgdHlwZSBgTWF5YmUgYWBcbi8vLiAoZm9yIGFueSB0eXBlIGBhYCkgd2l0aCBhbiBhcmd1bWVudCBvZiB0eXBlIGBhIC0+IGJgIChmb3IgYW55IHR5cGUgYGJgKSxcbi8vLiBpdCByZXR1cm5zIGEgdmFsdWUgb2YgdHlwZSBgTWF5YmUgYmAuX1xuLy8uXG4vLy4gVGhlIHNxdWlnZ2x5IGFycm93IGlzIGFsc28gdXNlZCB3aGVuIHJlcHJlc2VudGluZyBub24tZnVuY3Rpb24gcHJvcGVydGllcy5cbi8vLiBgTWF5YmUgYSB+PiBCb29sZWFuYCwgZm9yIGV4YW1wbGUsIHJlcHJlc2VudHMgYSBCb29sZWFuIHByb3BlcnR5IG9mIGEgdmFsdWVcbi8vLiBvZiB0eXBlIGBNYXliZSBhYC5cbi8vLlxuLy8uIFNhbmN0dWFyeSBzdXBwb3J0cyB0eXBlIGNsYXNzZXM6IGNvbnN0cmFpbnRzIG9uIHR5cGUgdmFyaWFibGVzLiBXaGVyZWFzXG4vLy4gYGEgLT4gYWAgaW1wbGljaXRseSBzdXBwb3J0cyBldmVyeSB0eXBlLCBgRnVuY3RvciBmID0+IChhIC0+IGIpIC0+IGYgYSAtPlxuLy8uIGYgYmAgcmVxdWlyZXMgdGhhdCBgZmAgYmUgYSB0eXBlIHdoaWNoIHNhdGlzZmllcyB0aGUgcmVxdWlyZW1lbnRzIG9mIHRoZVxuLy8uIEZ1bmN0b3IgdHlwZSBjbGFzcy4gVHlwZS1jbGFzcyBjb25zdHJhaW50cyBhcHBlYXIgYXQgdGhlIGJlZ2lubmluZyBvZiBhXG4vLy4gdHlwZSBzaWduYXR1cmUsIHNlcGFyYXRlZCBmcm9tIHRoZSByZXN0IG9mIHRoZSBzaWduYXR1cmUgYnkgYSBmYXQgYXJyb3dcbi8vLiAoYD0+YCkuXG4vLy5cbi8vLiAjIyMgVHlwZSByZXByZXNlbnRhdGl2ZXNcbi8vLlxuLy8uIFdoYXQgaXMgdGhlIHR5cGUgb2YgYE51bWJlcmA/IE9uZSBhbnN3ZXIgaXMgYGEgLT4gTnVtYmVyYCwgc2luY2UgaXQncyBhXG4vLy4gZnVuY3Rpb24gd2hpY2ggdGFrZXMgYW4gYXJndW1lbnQgb2YgYW55IHR5cGUgYW5kIHJldHVybnMgYSBOdW1iZXIgdmFsdWUuXG4vLy4gV2hlbiBwcm92aWRlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gW2Bpc2BdKCNpcyksIHRob3VnaCwgYE51bWJlcmAgaXNcbi8vLiByZWFsbHkgdGhlIHZhbHVlLWxldmVsIHJlcHJlc2VudGF0aXZlIG9mIHRoZSBOdW1iZXIgdHlwZS5cbi8vLlxuLy8uIFNhbmN0dWFyeSB1c2VzIHRoZSBUeXBlUmVwIHBzZXVkb3R5cGUgdG8gZGVzY3JpYmUgdHlwZSByZXByZXNlbnRhdGl2ZXMuXG4vLy4gRm9yIGV4YW1wbGU6XG4vLy5cbi8vLiAgICAgTnVtYmVyIDo6IFR5cGVSZXAgTnVtYmVyXG4vLy5cbi8vLiBgTnVtYmVyYCBpcyB0aGUgc29sZSBpbmhhYml0YW50IG9mIHRoZSBUeXBlUmVwIE51bWJlciB0eXBlLlxuLy8uXG4vLy4gIyMgVHlwZSBjaGVja2luZ1xuLy8uXG4vLy4gU2FuY3R1YXJ5IGZ1bmN0aW9ucyBhcmUgZGVmaW5lZCB2aWEgW3NhbmN0dWFyeS1kZWZdW10gdG8gcHJvdmlkZSBydW4tdGltZVxuLy8uIHR5cGUgY2hlY2tpbmcuIFRoaXMgaXMgdHJlbWVuZG91c2x5IHVzZWZ1bCBkdXJpbmcgZGV2ZWxvcG1lbnQ6IHR5cGUgZXJyb3JzXG4vLy4gYXJlIHJlcG9ydGVkIGltbWVkaWF0ZWx5LCBhdm9pZGluZyBjaXJjdWl0b3VzIHN0YWNrIHRyYWNlcyAoYXQgYmVzdCkgYW5kXG4vLy4gc2lsZW50IGZhaWx1cmVzIGR1ZSB0byB0eXBlIGNvZXJjaW9uIChhdCB3b3JzdCkuIEZvciBleGFtcGxlOlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIFMuYWRkKDIsIHRydWUpO1xuLy8uIC8vICEgVHlwZUVycm9yOiBJbnZhbGlkIHZhbHVlXG4vLy4gLy9cbi8vLiAvLyAgIGFkZCA6OiBGaW5pdGVOdW1iZXIgLT4gRmluaXRlTnVtYmVyIC0+IEZpbml0ZU51bWJlclxuLy8uIC8vICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eXl5eXl5cbi8vLiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxXG4vLy4gLy9cbi8vLiAvLyAgIDEpICB0cnVlIDo6IEJvb2xlYW5cbi8vLiAvL1xuLy8uIC8vICAgVGhlIHZhbHVlIGF0IHBvc2l0aW9uIDEgaXMgbm90IGEgbWVtYmVyIG9mIOKAmEZpbml0ZU51bWJlcuKAmS5cbi8vLiAvL1xuLy8uIC8vICAgU2VlIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS1kZWYjRmluaXRlTnVtYmVyIGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc2FuY3R1YXJ5LWRlZi9GaW5pdGVOdW1iZXIgdHlwZS5cbi8vLiBgYGBcbi8vLlxuLy8uIENvbXBhcmUgdGhpcyB0byB0aGUgYmVoYXZpb3VyIG9mIFJhbWRhJ3MgdW5jaGVja2VkIGVxdWl2YWxlbnQ6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gUi5hZGQoMiwgdHJ1ZSk7XG4vLy4gLy8gPT4gM1xuLy8uIGBgYFxuLy8uXG4vLy4gVGhlcmUgaXMgYSBwZXJmb3JtYW5jZSBjb3N0IHRvIHJ1bi10aW1lIHR5cGUgY2hlY2tpbmcuIE9uZSBtYXkgd2lzaCB0b1xuLy8uIGRpc2FibGUgdHlwZSBjaGVja2luZyBpbiBjZXJ0YWluIGNvbnRleHRzIHRvIGF2b2lkIHBheWluZyB0aGlzIGNvc3QuXG4vLy4gW2BjcmVhdGVgXSgjY3JlYXRlKSBmYWNpbGl0YXRlcyB0aGUgY3JlYXRpb24gb2YgYSBTYW5jdHVhcnkgbW9kdWxlIHdoaWNoXG4vLy4gZG9lcyBub3QgcGVyZm9ybSB0eXBlIGNoZWNraW5nLlxuLy8uXG4vLy4gSW4gTm9kZSwgb25lIGNvdWxkIHVzZSBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZSB0byBkZXRlcm1pbmUgd2hldGhlciB0b1xuLy8uIHBlcmZvcm0gdHlwZSBjaGVja2luZzpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiBjb25zdCB7Y3JlYXRlLCBlbnZ9ID0gcmVxdWlyZSgnc2FuY3R1YXJ5Jyk7XG4vLy5cbi8vLiBjb25zdCBjaGVja1R5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJztcbi8vLiBjb25zdCBTID0gY3JlYXRlKHtjaGVja1R5cGVzLCBlbnZ9KTtcbi8vLiBgYGBcbi8vLlxuLy8uICMjIEFQSVxuXG4oZnVuY3Rpb24oZikge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZihyZXF1aXJlKCdzYW5jdHVhcnktZGVmJyksXG4gICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJ3NhbmN0dWFyeS10eXBlLWNsYXNzZXMnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMnKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICE9IG51bGwpIHtcbiAgICBkZWZpbmUoWydzYW5jdHVhcnktZGVmJyxcbiAgICAgICAgICAgICdzYW5jdHVhcnktdHlwZS1jbGFzc2VzJyxcbiAgICAgICAgICAgICdzYW5jdHVhcnktdHlwZS1pZGVudGlmaWVycyddLFxuICAgICAgICAgICBmKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnNhbmN0dWFyeSA9IGYoc2VsZi5zYW5jdHVhcnlEZWYsXG4gICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2FuY3R1YXJ5VHlwZUNsYXNzZXMsXG4gICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2FuY3R1YXJ5VHlwZUlkZW50aWZpZXJzKTtcbiAgfVxuXG59KGZ1bmN0aW9uKCQsIFosIHR5cGUpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gIEZuIDo6IChUeXBlLCBUeXBlKSAtPiBUeXBlXG4gIGZ1bmN0aW9uIEZuKHgsIHkpIHsgcmV0dXJuICQuRnVuY3Rpb24oW3gsIHldKTsgfVxuXG4gIC8vICBmbGlwJCA6OiAoKGEsIGIpIC0+IGMpIC0+IGIgLT4gYSAtPiBjXG4gIGZ1bmN0aW9uIGZsaXAkKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIGYoeSwgeCk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICAvLyAgdG9PYmplY3QgOjogYSAtPiBPYmplY3RcbiAgZnVuY3Rpb24gdG9PYmplY3QoeCkge1xuICAgIHJldHVybiB4ID09IG51bGwgPyBPYmplY3QuY3JlYXRlKG51bGwpIDogT2JqZWN0KHgpO1xuICB9XG5cbiAgLy8gIHR5cGVFcSA6OiBTdHJpbmcgLT4gYSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIHR5cGVFcSh0eXBlSWRlbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHR5cGUoeCkgPT09IHR5cGVJZGVudDtcbiAgICB9O1xuICB9XG5cbiAgLy8gIHVuY3VycnkyIDo6IChhIC0+IGIgLT4gYykgLT4gKChhLCBiKSAtPiBjKVxuICBmdW5jdGlvbiB1bmN1cnJ5MihmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHJldHVybiBmKHgpKHkpO1xuICAgIH07XG4gIH1cblxuICAvLyAgcmVhZG1lVXJsIDo6IFN0cmluZyAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gcmVhZG1lVXJsKGlkKSB7XG4gICAgdmFyIHZlcnNpb24gPSAnMC4xNC4xJzsgIC8vIHVwZGF0ZWQgcHJvZ3JhbW1hdGljYWxseVxuICAgIHJldHVybiAnaHR0cHM6Ly9naXRodWIuY29tL3NhbmN0dWFyeS1qcy9zYW5jdHVhcnkvdHJlZS92JyArIHZlcnNpb24gK1xuICAgICAgICAgICAnIycgKyBpZDtcbiAgfVxuXG4gIC8vICA6OiBUeXBlXG4gIHZhciBhID0gJC5UeXBlVmFyaWFibGUoJ2EnKTtcbiAgdmFyIGIgPSAkLlR5cGVWYXJpYWJsZSgnYicpO1xuICB2YXIgYyA9ICQuVHlwZVZhcmlhYmxlKCdjJyk7XG4gIHZhciBkID0gJC5UeXBlVmFyaWFibGUoJ2QnKTtcbiAgdmFyIGUgPSAkLlR5cGVWYXJpYWJsZSgnZScpO1xuICB2YXIgZyA9ICQuVHlwZVZhcmlhYmxlKCdnJyk7XG4gIHZhciBsID0gJC5UeXBlVmFyaWFibGUoJ2wnKTtcbiAgdmFyIHIgPSAkLlR5cGVWYXJpYWJsZSgncicpO1xuXG4gIC8vICA6OiBUeXBlIC0+IFR5cGVcbiAgdmFyIGYgPSAkLlVuYXJ5VHlwZVZhcmlhYmxlKCdmJyk7XG4gIHZhciBtID0gJC5VbmFyeVR5cGVWYXJpYWJsZSgnbScpO1xuICB2YXIgdCA9ICQuVW5hcnlUeXBlVmFyaWFibGUoJ3QnKTtcbiAgdmFyIHcgPSAkLlVuYXJ5VHlwZVZhcmlhYmxlKCd3Jyk7XG5cbiAgLy8gIDo6IFR5cGUgLT4gVHlwZSAtPiBUeXBlXG4gIHZhciBwID0gJC5CaW5hcnlUeXBlVmFyaWFibGUoJ3AnKTtcbiAgdmFyIHMgPSAkLkJpbmFyeVR5cGVWYXJpYWJsZSgncycpO1xuXG4gIC8vICBlaXRoZXJUeXBlSWRlbnQgOjogU3RyaW5nXG4gIHZhciBlaXRoZXJUeXBlSWRlbnQgPSAnc2FuY3R1YXJ5L0VpdGhlcic7XG5cbiAgLy8gICRFaXRoZXIgOjogVHlwZSAtPiBUeXBlIC0+IFR5cGVcbiAgdmFyICRFaXRoZXIgPSAkLkJpbmFyeVR5cGUoXG4gICAgZWl0aGVyVHlwZUlkZW50LFxuICAgIHJlYWRtZVVybCgnRWl0aGVyVHlwZScpLFxuICAgIHR5cGVFcShlaXRoZXJUeXBlSWRlbnQpLFxuICAgIGZ1bmN0aW9uKGVpdGhlcikgeyByZXR1cm4gZWl0aGVyLmlzTGVmdCA/IFtlaXRoZXIudmFsdWVdIDogW107IH0sXG4gICAgZnVuY3Rpb24oZWl0aGVyKSB7IHJldHVybiBlaXRoZXIuaXNSaWdodCA/IFtlaXRoZXIudmFsdWVdIDogW107IH1cbiAgKTtcblxuICAvLyAgTGlzdCA6OiBUeXBlIC0+IFR5cGVcbiAgdmFyIExpc3QgPSAkLlVuYXJ5VHlwZShcbiAgICAnc2FuY3R1YXJ5L0xpc3QnLFxuICAgIHJlYWRtZVVybCgnbGlzdCcpLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuICQuU3RyaW5nLl90ZXN0KHgpIHx8IEFycmF5LmlzQXJyYXkoeCk7IH0sXG4gICAgZnVuY3Rpb24obGlzdCkgeyByZXR1cm4gJC5TdHJpbmcuX3Rlc3QobGlzdCkgPyBbXSA6IGxpc3Q7IH1cbiAgKTtcblxuICAvLyAgbWF5YmVUeXBlSWRlbnQgOjogU3RyaW5nXG4gIHZhciBtYXliZVR5cGVJZGVudCA9ICdzYW5jdHVhcnkvTWF5YmUnO1xuXG4gIC8vICAkTWF5YmUgOjogVHlwZSAtPiBUeXBlXG4gIHZhciAkTWF5YmUgPSAkLlVuYXJ5VHlwZShcbiAgICBtYXliZVR5cGVJZGVudCxcbiAgICByZWFkbWVVcmwoJ01heWJlVHlwZScpLFxuICAgIHR5cGVFcShtYXliZVR5cGVJZGVudCksXG4gICAgZnVuY3Rpb24obWF5YmUpIHsgcmV0dXJuIG1heWJlLmlzSnVzdCA/IFttYXliZS52YWx1ZV0gOiBbXTsgfVxuICApO1xuXG4gIC8vICBUeXBlUmVwIDo6IFR5cGUgLT4gVHlwZVxuICB2YXIgVHlwZVJlcCA9ICQuVW5hcnlUeXBlKFxuICAgICdzYW5jdHVhcnkvVHlwZVJlcCcsXG4gICAgcmVhZG1lVXJsKCd0eXBlLXJlcHJlc2VudGF0aXZlcycpLFxuICAgIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiAkLkFueUZ1bmN0aW9uLl90ZXN0KHgpIHx8XG4gICAgICAgICAgICAgeCAhPSBudWxsICYmICQuU3RyaW5nLl90ZXN0KHhbJ0BAdHlwZSddKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uKHR5cGVSZXApIHsgcmV0dXJuIFtdOyB9XG4gICk7XG5cbiAgLy8gIGRlZmF1bHRFbnYgOjogQXJyYXkgVHlwZVxuICB2YXIgZGVmYXVsdEVudiA9IFouY29uY2F0KCQuZW52LCBbXG4gICAgJC5GaW5pdGVOdW1iZXIsXG4gICAgJC5Ob25aZXJvRmluaXRlTnVtYmVyLFxuICAgICRFaXRoZXIoJC5Vbmtub3duLCAkLlVua25vd24pLFxuICAgIEZuKCQuVW5rbm93biwgJC5Vbmtub3duKSxcbiAgICAkLkdsb2JhbFJlZ0V4cCxcbiAgICAkLk5vbkdsb2JhbFJlZ0V4cCxcbiAgICAkLkludGVnZXIsXG4gICAgJC5Ob25OZWdhdGl2ZUludGVnZXIsXG4gICAgJE1heWJlKCQuVW5rbm93biksXG4gICAgJC5QYWlyKCQuVW5rbm93biwgJC5Vbmtub3duKSxcbiAgICAkLlJlZ2V4RmxhZ3MsXG4gICAgJC5WYWxpZERhdGUsXG4gICAgJC5WYWxpZE51bWJlclxuICBdKTtcblxuICAvLyAgT3B0aW9ucyA6OiBUeXBlXG4gIHZhciBPcHRpb25zID0gJC5SZWNvcmRUeXBlKHtjaGVja1R5cGVzOiAkLkJvb2xlYW4sIGVudjogJC5BcnJheSgkLkFueSl9KTtcblxuICAvLyAgY3JlYXRlU2FuY3R1YXJ5IDo6IE9wdGlvbnMgLT4gTW9kdWxlXG4gIGZ1bmN0aW9uIGNyZWF0ZVNhbmN0dWFyeShvcHRzKSB7XG5cbiAgLyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG5cbiAgLy8gIGNoZWNrVHlwZXMgOjogQm9vbGVhblxuICB2YXIgY2hlY2tUeXBlcyA9IG9wdHMuY2hlY2tUeXBlcztcblxuICAvLyAgZW52IDo6IEFycmF5IFR5cGVcbiAgdmFyIGVudiA9IG9wdHMuZW52O1xuXG4gIHZhciBTID0ge307XG5cbiAgLy8jIGNyZWF0ZSA6OiB7IGNoZWNrVHlwZXMgOjogQm9vbGVhbiwgZW52IDo6IEFycmF5IFR5cGUgfSAtPiBNb2R1bGVcbiAgLy8uXG4gIC8vLiBUYWtlcyBhbiBvcHRpb25zIHJlY29yZCBhbmQgcmV0dXJucyBhIFNhbmN0dWFyeSBtb2R1bGUuIGBjaGVja1R5cGVzYFxuICAvLy4gc3BlY2lmaWVzIHdoZXRoZXIgdG8gZW5hYmxlIHR5cGUgY2hlY2tpbmcuIFRoZSBtb2R1bGUncyBwb2x5bW9ycGhpY1xuICAvLy4gZnVuY3Rpb25zIChzdWNoIGFzIFtgSWBdKCNJKSkgcmVxdWlyZSBlYWNoIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhXG4gIC8vLiB0eXBlIHZhcmlhYmxlIHRvIGJlIGEgbWVtYmVyIG9mIGF0IGxlYXN0IG9uZSB0eXBlIGluIHRoZSBlbnZpcm9ubWVudC5cbiAgLy8uXG4gIC8vLiBBIHdlbGwtdHlwZWQgYXBwbGljYXRpb24gb2YgYSBTYW5jdHVhcnkgZnVuY3Rpb24gd2lsbCBwcm9kdWNlIHRoZSBzYW1lXG4gIC8vLiByZXN1bHQgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHR5cGUgY2hlY2tpbmcgaXMgZW5hYmxlZC4gSWYgdHlwZSBjaGVja2luZ1xuICAvLy4gaXMgZW5hYmxlZCwgYSBiYWRseSB0eXBlZCBhcHBsaWNhdGlvbiB3aWxsIHByb2R1Y2UgYW4gZXhjZXB0aW9uIHdpdGggYVxuICAvLy4gZGVzY3JpcHRpdmUgZXJyb3IgbWVzc2FnZS5cbiAgLy8uXG4gIC8vLiBUaGUgZm9sbG93aW5nIHNuaXBwZXQgZGVtb25zdHJhdGVzIGRlZmluaW5nIGEgY3VzdG9tIHR5cGUgYW5kIHVzaW5nXG4gIC8vLiBgY3JlYXRlYCB0byBwcm9kdWNlIGEgU2FuY3R1YXJ5IG1vZHVsZSB3aGljaCBpcyBhd2FyZSBvZiB0aGF0IHR5cGU6XG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gY29uc3Qge2NyZWF0ZSwgZW52fSA9IHJlcXVpcmUoJ3NhbmN0dWFyeScpO1xuICAvLy4gY29uc3QgJCA9IHJlcXVpcmUoJ3NhbmN0dWFyeS1kZWYnKTtcbiAgLy8uIGNvbnN0IHR5cGUgPSByZXF1aXJlKCdzYW5jdHVhcnktdHlwZS1pZGVudGlmaWVycycpO1xuICAvLy5cbiAgLy8uIC8vICAgIElkZW50aXR5IDo6IGEgLT4gSWRlbnRpdHkgYVxuICAvLy4gY29uc3QgSWRlbnRpdHkgPSBmdW5jdGlvbiBJZGVudGl0eSh4KSB7XG4gIC8vLiAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJZGVudGl0eSkpIHJldHVybiBuZXcgSWRlbnRpdHkoeCk7XG4gIC8vLiAgIHRoaXMudmFsdWUgPSB4O1xuICAvLy4gfTtcbiAgLy8uXG4gIC8vLiBJZGVudGl0eVsnQEB0eXBlJ10gPSAnbXktcGFja2FnZS9JZGVudGl0eUAxJztcbiAgLy8uXG4gIC8vLiBJZGVudGl0eS5wcm90b3R5cGVbJ2ZhbnRhc3ktbGFuZC9tYXAnXSA9IGZ1bmN0aW9uKGYpIHtcbiAgLy8uICAgcmV0dXJuIElkZW50aXR5KGYodGhpcy52YWx1ZSkpO1xuICAvLy4gfTtcbiAgLy8uXG4gIC8vLiAvLyAgICBJZGVudGl0eVR5cGUgOjogVHlwZSAtPiBUeXBlXG4gIC8vLiBjb25zdCBJZGVudGl0eVR5cGUgPSAkLlVuYXJ5VHlwZShcbiAgLy8uICAgSWRlbnRpdHlbJ0BAdHlwZSddLFxuICAvLy4gICAnaHR0cDovL2V4YW1wbGUuY29tL215LXBhY2thZ2UjSWRlbnRpdHknLFxuICAvLy4gICB4ID0+IHR5cGUoeCkgPT09IElkZW50aXR5WydAQHR5cGUnXSxcbiAgLy8uICAgaWRlbnRpdHkgPT4gW2lkZW50aXR5LnZhbHVlXVxuICAvLy4gKTtcbiAgLy8uXG4gIC8vLiBjb25zdCBTID0gY3JlYXRlKHtcbiAgLy8uICAgY2hlY2tUeXBlczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcbiAgLy8uICAgZW52OiBlbnYuY29uY2F0KFtJZGVudGl0eVR5cGUoJC5Vbmtub3duKV0pLFxuICAvLy4gfSk7XG4gIC8vLlxuICAvLy4gUy5tYXAoUy5zdWIoMSksIElkZW50aXR5KDQzKSk7XG4gIC8vLiAvLyA9PiBJZGVudGl0eSg0MilcbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZW52YF0oI2VudikuXG4gIFMuY3JlYXRlID1cbiAgJC5jcmVhdGUoe2NoZWNrVHlwZXM6IGNoZWNrVHlwZXMsIGVudjogZGVmYXVsdEVudn0pKCdjcmVhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbT3B0aW9ucywgJC5PYmplY3RdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlU2FuY3R1YXJ5KTtcblxuICAvLyMgZW52IDo6IEFycmF5IFR5cGVcbiAgLy8uXG4gIC8vLiBUaGUgZGVmYXVsdCBlbnZpcm9ubWVudCwgd2hpY2ggbWF5IGJlIHVzZWQgYXMgaXMgb3IgYXMgdGhlIGJhc2lzIG9mIGFcbiAgLy8uIGN1c3RvbSBlbnZpcm9ubWVudCBpbiBjb25qdW5jdGlvbiB3aXRoIFtgY3JlYXRlYF0oI2NyZWF0ZSkuXG4gIFMuZW52ID0gZGVmYXVsdEVudjtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBfX2RvY3Rlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLyogZ2xvYmFsIF9fZG9jdGVzdDpmYWxzZSAqL1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgdmFyIF9MaXN0ID0gX19kb2N0ZXN0LnJlcXVpcmUoJy4vdGVzdC9pbnRlcm5hbC9MaXN0Jyk7XG4gICAgdmFyIENvbnMgPSBfTGlzdC5Db25zO1xuICAgIHZhciBOaWwgPSBfTGlzdC5OaWw7XG4gICAgdmFyIFN1bSA9IF9fZG9jdGVzdC5yZXF1aXJlKCcuL3Rlc3QvaW50ZXJuYWwvU3VtJyk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgIGVudiA9IFouY29uY2F0KGVudiwgW19MaXN0LlR5cGUoJC5Vbmtub3duKSwgU3VtLlR5cGVdKTtcbiAgfVxuXG4gIHZhciBkZWYgPSAkLmNyZWF0ZSh7Y2hlY2tUeXBlczogY2hlY2tUeXBlcywgZW52OiBlbnZ9KTtcblxuICAvLy4gIyMjIFBsYWNlaG9sZGVyXG4gIC8vLlxuICAvLy4gU2FuY3R1YXJ5IGZ1bmN0aW9ucyBhcmUgZGVzaWduZWQgd2l0aCBwYXJ0aWFsIGFwcGxpY2F0aW9uIGluIG1pbmQuXG4gIC8vLiBJbiBtYW55IGNhc2VzIG9uZSBjYW4gZGVmaW5lIGEgbW9yZSBzcGVjaWZpYyBmdW5jdGlvbiBpbiB0ZXJtcyBvZlxuICAvLy4gYSBtb3JlIGdlbmVyYWwgb25lIHNpbXBseSBieSBhcHBseWluZyB0aGUgbW9yZSBnZW5lcmFsIGZ1bmN0aW9uIHRvXG4gIC8vLiBzb21lIChidXQgbm90IGFsbCkgb2YgaXRzIGFyZ3VtZW50cy4gRm9yIGV4YW1wbGUsIG9uZSBjb3VsZCBkZWZpbmVcbiAgLy8uIGBzdW0gOjogRm9sZGFibGUgZiA9PiBmIE51bWJlciAtPiBOdW1iZXJgIGFzIGBTLnJlZHVjZShTLmFkZCwgMClgLlxuICAvLy5cbiAgLy8uIEluIHNvbWUgY2FzZXMsIHRob3VnaCwgdGhlcmUgYXJlIG11bHRpcGxlIG9yZGVycyBpbiB3aGljaCBvbmUgbWF5XG4gIC8vLiB3aXNoIHRvIHByb3ZpZGUgYSBmdW5jdGlvbidzIGFyZ3VtZW50cy4gYFMuY29uY2F0KCdwcmVmaXgnKWAgaXMgYVxuICAvLy4gZnVuY3Rpb24gd2hpY2ggcHJlZml4ZXMgaXRzIGFyZ3VtZW50LCBidXQgaG93IHdvdWxkIG9uZSBkZWZpbmUgYVxuICAvLy4gZnVuY3Rpb24gd2hpY2ggc3VmZml4ZXMgaXRzIGFyZ3VtZW50PyBJdCdzIHBvc3NpYmxlIHdpdGggdGhlIGhlbHBcbiAgLy8uIG9mIFtgX19gXSgjX18pLCB0aGUgc3BlY2lhbCBwbGFjZWhvbGRlciB2YWx1ZS5cbiAgLy8uXG4gIC8vLiBUaGUgcGxhY2Vob2xkZXIgaW5kaWNhdGVzIGEgaG9sZSB0byBiZSBmaWxsZWQgYXQgc29tZSBmdXR1cmUgdGltZS5cbiAgLy8uIFRoZSBmb2xsb3dpbmcgYXJlIGFsbCBlcXVpdmFsZW50IChgX2AgcmVwcmVzZW50cyB0aGUgcGxhY2Vob2xkZXIpOlxuICAvLy5cbiAgLy8uICAgLSBgZih4LCB5LCB6KWBcbiAgLy8uICAgLSBgZihfLCB5LCB6KSh4KWBcbiAgLy8uICAgLSBgZihfLCBfLCB6KSh4LCB5KWBcbiAgLy8uICAgLSBgZihfLCBfLCB6KShfLCB5KSh4KWBcblxuICAvLyMgX18gOjogUGxhY2Vob2xkZXJcbiAgLy8uXG4gIC8vLiBUaGUgc3BlY2lhbCBbcGxhY2Vob2xkZXJdKCNwbGFjZWhvbGRlcikgdmFsdWUuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1hcChTLmNvbmNhdCgnQCcpLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pXG4gIC8vLiBbJ0Bmb28nLCAnQGJhcicsICdAYmF6J11cbiAgLy8uXG4gIC8vLiA+IFMubWFwKFMuY29uY2F0KFMuX18sICc/JyksIFsnZm9vJywgJ2JhcicsICdiYXonXSlcbiAgLy8uIFsnZm9vPycsICdiYXI/JywgJ2Jhej8nXVxuICAvLy4gYGBgXG4gIFMuX18gPSAkLl9fO1xuXG4gIC8vLiAjIyMgQ2xhc3NpZnlcblxuICAvLyMgdHlwZSA6OiBBbnkgLT4geyBuYW1lc3BhY2UgOjogTWF5YmUgU3RyaW5nLCBuYW1lIDo6IFN0cmluZywgdmVyc2lvbiA6OiBOb25OZWdhdGl2ZUludGVnZXIgfVxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIHRoZSBbdHlwZSBpZGVudGlmaWVyXVtdIG9mIHRoZSBnaXZlbiB2YWx1ZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMudHlwZShTLkp1c3QoNDIpKVxuICAvLy4ge25hbWVzcGFjZTogSnVzdCgnc2FuY3R1YXJ5JyksIG5hbWU6ICdNYXliZScsIHZlcnNpb246IDB9XG4gIC8vLlxuICAvLy4gPiBTLnR5cGUoWzEsIDIsIDNdKVxuICAvLy4ge25hbWVzcGFjZTogTm90aGluZywgbmFtZTogJ0FycmF5JywgdmVyc2lvbjogMH1cbiAgLy8uIGBgYFxuICBTLnR5cGUgPVxuICBkZWYoJ3R5cGUnLFxuICAgICAge30sXG4gICAgICBbJC5BbnksXG4gICAgICAgJC5SZWNvcmRUeXBlKHtuYW1lc3BhY2U6ICRNYXliZSgkLlN0cmluZyksXG4gICAgICAgICAgICAgICAgICAgICBuYW1lOiAkLlN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgIHZlcnNpb246ICQuTm9uTmVnYXRpdmVJbnRlZ2VyfSldLFxuICAgICAgZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgciA9IHR5cGUucGFyc2UodHlwZSh4KSk7XG4gICAgICAgIHIubmFtZXNwYWNlID0gdG9NYXliZShyLm5hbWVzcGFjZSk7XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSk7XG5cbiAgLy8jIGlzIDo6IFR5cGVSZXAgYSAtPiBBbnkgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFRha2VzIGEgW3R5cGUgcmVwcmVzZW50YXRpdmVdKCN0eXBlLXJlcHJlc2VudGF0aXZlcykgYW5kIGEgdmFsdWUgb2YgYW55XG4gIC8vLiB0eXBlIGFuZCByZXR1cm5zIGB0cnVlYCBbaWZmXVtdIHRoZSBnaXZlbiB2YWx1ZSBpcyBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuXG4gIC8vLiBTdWJ0eXBpbmcgaXMgbm90IHJlc3BlY3RlZC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuaXMoTnVtYmVyLCA0MilcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMuaXMoT2JqZWN0LCA0MilcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBTLmlzKFN0cmluZywgNDIpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGlzKHR5cGVSZXAsIHgpIHtcbiAgICB2YXIgeFR5cGUgPSB0eXBlKHgpO1xuICAgIGlmICgkLlN0cmluZy5fdGVzdCh0eXBlUmVwWydAQHR5cGUnXSkpIHtcbiAgICAgIHJldHVybiB4VHlwZSA9PT0gdHlwZVJlcFsnQEB0eXBlJ107XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXRjaCA9IC9mdW5jdGlvbiAoXFx3KikvLmV4ZWModHlwZVJlcCk7XG4gICAgICByZXR1cm4gbWF0Y2ggIT0gbnVsbCAmJiBtYXRjaFsxXSA9PT0geFR5cGU7XG4gICAgfVxuICB9XG4gIFMuaXMgPSBkZWYoJ2lzJywge30sIFtUeXBlUmVwKGEpLCAkLkFueSwgJC5Cb29sZWFuXSwgaXMpO1xuXG4gIC8vLiAjIyMgU2hvd2FibGVcblxuICAvLyMgdG9TdHJpbmcgOjogQW55IC0+IFN0cmluZ1xuICAvLy5cbiAgLy8uIEFsaWFzIG9mIFtgWi50b1N0cmluZ2BdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRvU3RyaW5nKC0wKVxuICAvLy4gJy0wJ1xuICAvLy5cbiAgLy8uID4gUy50b1N0cmluZyhbJ2ZvbycsICdiYXInLCAnYmF6J10pXG4gIC8vLiAnW1wiZm9vXCIsIFwiYmFyXCIsIFwiYmF6XCJdJ1xuICAvLy5cbiAgLy8uID4gUy50b1N0cmluZyh7eDogMSwgeTogMiwgejogM30pXG4gIC8vLiAne1wieFwiOiAxLCBcInlcIjogMiwgXCJ6XCI6IDN9J1xuICAvLy5cbiAgLy8uID4gUy50b1N0cmluZyhTLkxlZnQoUy5SaWdodChTLkp1c3QoUy5Ob3RoaW5nKSkpKVxuICAvLy4gJ0xlZnQoUmlnaHQoSnVzdChOb3RoaW5nKSkpJ1xuICAvLy4gYGBgXG4gIFMudG9TdHJpbmcgPSBkZWYoJ3RvU3RyaW5nJywge30sIFskLkFueSwgJC5TdHJpbmddLCBaLnRvU3RyaW5nKTtcblxuICAvLy4gIyMjIEZhbnRhc3kgTGFuZFxuICAvLy5cbiAgLy8uIFNhbmN0dWFyeSBpcyBjb21wYXRpYmxlIHdpdGggdGhlIFtGYW50YXN5IExhbmRdW10gc3BlY2lmaWNhdGlvbi5cblxuICAvLyMgZXF1YWxzIDo6IFNldG9pZCBhID0+IGEgLT4gYSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gQ3VycmllZCB2ZXJzaW9uIG9mIFtgWi5lcXVhbHNgXVtdIHdoaWNoIHJlcXVpcmVzIHR3byBhcmd1bWVudHMgb2YgdGhlXG4gIC8vLiBzYW1lIHR5cGUuXG4gIC8vLlxuICAvLy4gVG8gY29tcGFyZSB2YWx1ZXMgb2YgZGlmZmVyZW50IHR5cGVzIGZpcnN0IHVzZSBbYGNyZWF0ZWBdKCNjcmVhdGUpIHRvXG4gIC8vLiBjcmVhdGUgYSBTYW5jdHVhcnkgbW9kdWxlIHdpdGggdHlwZSBjaGVja2luZyBkaXNhYmxlZCwgdGhlbiB1c2UgdGhhdFxuICAvLy4gbW9kdWxlJ3MgYGVxdWFsc2AgZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmVxdWFscygwLCAtMClcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMuZXF1YWxzKE5hTiwgTmFOKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5lcXVhbHMoUy5KdXN0KFsxLCAyLCAzXSksIFMuSnVzdChbMSwgMiwgM10pKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5lcXVhbHMoUy5KdXN0KFsxLCAyLCAzXSksIFMuSnVzdChbMSwgMiwgNF0pKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICBTLmVxdWFscyA9IGRlZignZXF1YWxzJywge2E6IFtaLlNldG9pZF19LCBbYSwgYSwgJC5Cb29sZWFuXSwgWi5lcXVhbHMpO1xuXG4gIC8vIyBsdCA6OiBPcmQgYSA9PiBhIC0+IChhIC0+IEJvb2xlYW4pXG4gIC8vLlxuICAvLy4gUmV0dXJucyBgdHJ1ZWAgW2lmZl1bXSB0aGUgKnNlY29uZCogYXJndW1lbnQgaXMgbGVzcyB0aGFuIHRoZSBmaXJzdFxuICAvLy4gYWNjb3JkaW5nIHRvIFtgWi5sdGBdW10uIFRoZSBhcmd1bWVudHMgbXVzdCBiZSBwcm92aWRlZCBvbmUgYXQgYSB0aW1lLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbHRfYF0oI2x0XykuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmZpbHRlcihTLmx0KDMpLCBbMSwgMiwgMywgNCwgNV0pXG4gIC8vLiBbMSwgMl1cbiAgLy8uIGBgYFxuICBTLmx0ID0gZGVmKCdsdCcsIHthOiBbWi5PcmRdfSwgW2EsICQuUHJlZGljYXRlKGEpXSwgZmxpcCQoWi5sdCkpO1xuXG4gIC8vIyBsdF8gOjogT3JkIGEgPT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBbaWZmXVtdIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBsZXNzIHRoYW4gdGhlIHNlY29uZFxuICAvLy4gYWNjb3JkaW5nIHRvIFtgWi5sdGBdW10uXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BsdGBdKCNsdCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmx0XyhbMSwgMiwgM10sIFsxLCAyLCAzXSlcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBTLmx0XyhbMSwgMiwgM10sIFsxLCAyLCA0XSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMubHRfKFsxLCAyLCAzXSwgWzEsIDJdKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICBTLmx0XyA9IGRlZignbHRfJywge2E6IFtaLk9yZF19LCBbYSwgYSwgJC5Cb29sZWFuXSwgWi5sdCk7XG5cbiAgLy8jIGx0ZSA6OiBPcmQgYSA9PiBhIC0+IChhIC0+IEJvb2xlYW4pXG4gIC8vLlxuICAvLy4gUmV0dXJucyBgdHJ1ZWAgW2lmZl1bXSB0aGUgKnNlY29uZCogYXJndW1lbnQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvXG4gIC8vLiB0aGUgZmlyc3QgYWNjb3JkaW5nIHRvIFtgWi5sdGVgXVtdLiBUaGUgYXJndW1lbnRzIG11c3QgYmUgcHJvdmlkZWQgb25lXG4gIC8vLiBhdCBhIHRpbWUuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BsdGVfYF0oI2x0ZV8pLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5maWx0ZXIoUy5sdGUoMyksIFsxLCAyLCAzLCA0LCA1XSlcbiAgLy8uIFsxLCAyLCAzXVxuICAvLy4gYGBgXG4gIFMubHRlID0gZGVmKCdsdGUnLCB7YTogW1ouT3JkXX0sIFthLCAkLlByZWRpY2F0ZShhKV0sIGZsaXAkKFoubHRlKSk7XG5cbiAgLy8jIGx0ZV8gOjogT3JkIGEgPT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBbaWZmXVtdIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlXG4gIC8vLiBzZWNvbmQgYWNjb3JkaW5nIHRvIFtgWi5sdGVgXVtdLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbHRlYF0oI2x0ZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmx0ZV8oWzEsIDIsIDNdLCBbMSwgMiwgM10pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLmx0ZV8oWzEsIDIsIDNdLCBbMSwgMiwgNF0pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLmx0ZV8oWzEsIDIsIDNdLCBbMSwgMl0pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIFMubHRlXyA9IGRlZignbHRlXycsIHthOiBbWi5PcmRdfSwgW2EsIGEsICQuQm9vbGVhbl0sIFoubHRlKTtcblxuICAvLyMgZ3QgOjogT3JkIGEgPT4gYSAtPiAoYSAtPiBCb29sZWFuKVxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIFtpZmZdW10gdGhlICpzZWNvbmQqIGFyZ3VtZW50IGlzIGdyZWF0ZXIgdGhhbiB0aGUgZmlyc3RcbiAgLy8uIGFjY29yZGluZyB0byBbYFouZ3RgXVtdLiBUaGUgYXJndW1lbnRzIG11c3QgYmUgcHJvdmlkZWQgb25lIGF0IGEgdGltZS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGd0X2BdKCNndF8pLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5maWx0ZXIoUy5ndCgzKSwgWzEsIDIsIDMsIDQsIDVdKVxuICAvLy4gWzQsIDVdXG4gIC8vLiBgYGBcbiAgUy5ndCA9IGRlZignZ3QnLCB7YTogW1ouT3JkXX0sIFthLCAkLlByZWRpY2F0ZShhKV0sIGZsaXAkKFouZ3QpKTtcblxuICAvLyMgZ3RfIDo6IE9yZCBhID0+IGEgLT4gYSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gUmV0dXJucyBgdHJ1ZWAgW2lmZl1bXSB0aGUgZmlyc3QgYXJndW1lbnQgaXMgZ3JlYXRlciB0aGFuIHRoZSBzZWNvbmRcbiAgLy8uIGFjY29yZGluZyB0byBbYFouZ3RgXVtdLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZ3RgXSgjZ3QpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5ndF8oWzEsIDIsIDNdLCBbMSwgMiwgM10pXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gUy5ndF8oWzEsIDIsIDNdLCBbMSwgMiwgNF0pXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gUy5ndF8oWzEsIDIsIDNdLCBbMSwgMl0pXG4gIC8vLiB0cnVlXG4gIC8vLiBgYGBcbiAgUy5ndF8gPSBkZWYoJ2d0XycsIHthOiBbWi5PcmRdfSwgW2EsIGEsICQuQm9vbGVhbl0sIFouZ3QpO1xuXG4gIC8vIyBndGUgOjogT3JkIGEgPT4gYSAtPiAoYSAtPiBCb29sZWFuKVxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIFtpZmZdW10gdGhlICpzZWNvbmQqIGFyZ3VtZW50IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbFxuICAvLy4gdG8gdGhlIGZpcnN0IGFjY29yZGluZyB0byBbYFouZ3RlYF1bXS4gVGhlIGFyZ3VtZW50cyBtdXN0IGJlIHByb3ZpZGVkXG4gIC8vLiBvbmUgYXQgYSB0aW1lLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZ3RlX2BdKCNndGVfKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZmlsdGVyKFMuZ3RlKDMpLCBbMSwgMiwgMywgNCwgNV0pXG4gIC8vLiBbMywgNCwgNV1cbiAgLy8uIGBgYFxuICBTLmd0ZSA9IGRlZignZ3RlJywge2E6IFtaLk9yZF19LCBbYSwgJC5QcmVkaWNhdGUoYSldLCBmbGlwJChaLmd0ZSkpO1xuXG4gIC8vIyBndGVfIDo6IE9yZCBhID0+IGEgLT4gYSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gUmV0dXJucyBgdHJ1ZWAgW2lmZl1bXSB0aGUgZmlyc3QgYXJndW1lbnQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvXG4gIC8vLiB0aGUgc2Vjb25kIGFjY29yZGluZyB0byBbYFouZ3RlYF1bXS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGd0ZWBdKCNndGUpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5ndGVfKFsxLCAyLCAzXSwgWzEsIDIsIDNdKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5ndGVfKFsxLCAyLCAzXSwgWzEsIDIsIDRdKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IFMuZ3RlXyhbMSwgMiwgM10sIFsxLCAyXSlcbiAgLy8uIHRydWVcbiAgLy8uIGBgYFxuICBTLmd0ZV8gPSBkZWYoJ2d0ZV8nLCB7YTogW1ouT3JkXX0sIFthLCBhLCAkLkJvb2xlYW5dLCBaLmd0ZSk7XG5cbiAgLy8jIG1pbiA6OiBPcmQgYSA9PiBhIC0+IGEgLT4gYVxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIHNtYWxsZXIgb2YgaXRzIHR3byBhcmd1bWVudHMgKGFjY29yZGluZyB0byBbYFoubHRlYF1bXSkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BtYXhgXSgjbWF4KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWluKDEwLCAyKVxuICAvLy4gMlxuICAvLy5cbiAgLy8uID4gUy5taW4obmV3IERhdGUoJzE5OTktMTItMzEnKSwgbmV3IERhdGUoJzIwMDAtMDEtMDEnKSlcbiAgLy8uIG5ldyBEYXRlKCcxOTk5LTEyLTMxJylcbiAgLy8uXG4gIC8vLiA+IFMubWluKCcxMCcsICcyJylcbiAgLy8uICcxMCdcbiAgLy8uIGBgYFxuICBTLm1pbiA9IGRlZignbWluJywge2E6IFtaLk9yZF19LCBbYSwgYSwgYV0sIFoubWluKTtcblxuICAvLyMgbWF4IDo6IE9yZCBhID0+IGEgLT4gYSAtPiBhXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgbGFyZ2VyIG9mIGl0cyB0d28gYXJndW1lbnRzIChhY2NvcmRpbmcgdG8gW2BaLmx0ZWBdW10pLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbWluYF0oI21pbikuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1heCgxMCwgMilcbiAgLy8uIDEwXG4gIC8vLlxuICAvLy4gPiBTLm1heChuZXcgRGF0ZSgnMTk5OS0xMi0zMScpLCBuZXcgRGF0ZSgnMjAwMC0wMS0wMScpKVxuICAvLy4gbmV3IERhdGUoJzIwMDAtMDEtMDEnKVxuICAvLy5cbiAgLy8uID4gUy5tYXgoJzEwJywgJzInKVxuICAvLy4gJzInXG4gIC8vLiBgYGBcbiAgUy5tYXggPSBkZWYoJ21heCcsIHthOiBbWi5PcmRdfSwgW2EsIGEsIGFdLCBaLm1heCk7XG5cbiAgLy8jIGlkIDo6IENhdGVnb3J5IGMgPT4gVHlwZVJlcCBjIC0+IGNcbiAgLy8uXG4gIC8vLiBbVHlwZS1zYWZlXVtzYW5jdHVhcnktZGVmXSB2ZXJzaW9uIG9mIFtgWi5pZGBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmlkKEZ1bmN0aW9uKSg0MilcbiAgLy8uIDQyXG4gIC8vLiBgYGBcbiAgUy5pZCA9IGRlZignaWQnLCB7YzogW1ouQ2F0ZWdvcnldfSwgW1R5cGVSZXAoYyksIGNdLCBaLmlkKTtcblxuICAvLyMgY29uY2F0IDo6IFNlbWlncm91cCBhID0+IGEgLT4gYSAtPiBhXG4gIC8vLlxuICAvLy4gQ3VycmllZCB2ZXJzaW9uIG9mIFtgWi5jb25jYXRgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5jb25jYXQoJ2FiYycsICdkZWYnKVxuICAvLy4gJ2FiY2RlZidcbiAgLy8uXG4gIC8vLiA+IFMuY29uY2F0KFsxLCAyLCAzXSwgWzQsIDUsIDZdKVxuICAvLy4gWzEsIDIsIDMsIDQsIDUsIDZdXG4gIC8vLlxuICAvLy4gPiBTLmNvbmNhdCh7eDogMSwgeTogMn0sIHt5OiAzLCB6OiA0fSlcbiAgLy8uIHt4OiAxLCB5OiAzLCB6OiA0fVxuICAvLy5cbiAgLy8uID4gUy5jb25jYXQoUy5KdXN0KFsxLCAyLCAzXSksIFMuSnVzdChbNCwgNSwgNl0pKVxuICAvLy4gSnVzdChbMSwgMiwgMywgNCwgNSwgNl0pXG4gIC8vLlxuICAvLy4gPiBTLmNvbmNhdChTdW0oMTgpLCBTdW0oMjQpKVxuICAvLy4gU3VtKDQyKVxuICAvLy4gYGBgXG4gIFMuY29uY2F0ID0gZGVmKCdjb25jYXQnLCB7YTogW1ouU2VtaWdyb3VwXX0sIFthLCBhLCBhXSwgWi5jb25jYXQpO1xuXG4gIC8vIyBlbXB0eSA6OiBNb25vaWQgYSA9PiBUeXBlUmVwIGEgLT4gYVxuICAvLy5cbiAgLy8uIFtUeXBlLXNhZmVdW3NhbmN0dWFyeS1kZWZdIHZlcnNpb24gb2YgW2BaLmVtcHR5YF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZW1wdHkoU3RyaW5nKVxuICAvLy4gJydcbiAgLy8uXG4gIC8vLiA+IFMuZW1wdHkoQXJyYXkpXG4gIC8vLiBbXVxuICAvLy5cbiAgLy8uID4gUy5lbXB0eShPYmplY3QpXG4gIC8vLiB7fVxuICAvLy5cbiAgLy8uID4gUy5lbXB0eShTdW0pXG4gIC8vLiBTdW0oMClcbiAgLy8uIGBgYFxuICBTLmVtcHR5ID0gZGVmKCdlbXB0eScsIHthOiBbWi5Nb25vaWRdfSwgW1R5cGVSZXAoYSksIGFdLCBaLmVtcHR5KTtcblxuICAvLyMgaW52ZXJ0IDo6IEdyb3VwIGcgPT4gZyAtPiBnXG4gIC8vLlxuICAvLy4gW1R5cGUtc2FmZV1bc2FuY3R1YXJ5LWRlZl0gdmVyc2lvbiBvZiBbYFouaW52ZXJ0YF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuaW52ZXJ0KFN1bSg1KSlcbiAgLy8uIFN1bSgtNSlcbiAgLy8uIGBgYFxuICBTLmludmVydCA9IGRlZignaW52ZXJ0Jywge2c6IFtaLkdyb3VwXX0sIFtnLCBnXSwgWi5pbnZlcnQpO1xuXG4gIC8vIyBtYXAgOjogRnVuY3RvciBmID0+IChhIC0+IGIpIC0+IGYgYSAtPiBmIGJcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLm1hcGBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1hcChNYXRoLnNxcnQsIFsxLCA0LCA5XSlcbiAgLy8uIFsxLCAyLCAzXVxuICAvLy5cbiAgLy8uID4gUy5tYXAoTWF0aC5zcXJ0LCB7eDogMSwgeTogNCwgejogOX0pXG4gIC8vLiB7eDogMSwgeTogMiwgejogM31cbiAgLy8uXG4gIC8vLiA+IFMubWFwKE1hdGguc3FydCwgUy5KdXN0KDkpKVxuICAvLy4gSnVzdCgzKVxuICAvLy5cbiAgLy8uID4gUy5tYXAoTWF0aC5zcXJ0LCBTLlJpZ2h0KDkpKVxuICAvLy4gUmlnaHQoMylcbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uIFJlcGxhY2luZyBgRnVuY3RvciBmID0+IGZgIHdpdGggYEZ1bmN0aW9uIHhgIHByb2R1Y2VzIHRoZSBCIGNvbWJpbmF0b3JcbiAgLy8uIGZyb20gY29tYmluYXRvcnkgbG9naWMgKGkuZS4gW2Bjb21wb3NlYF0oI2NvbXBvc2UpKTpcbiAgLy8uXG4gIC8vLiAgICAgRnVuY3RvciBmID0+IChhIC0+IGIpIC0+IGYgYSAtPiBmIGJcbiAgLy8uICAgICAoYSAtPiBiKSAtPiBGdW5jdGlvbiB4IGEgLT4gRnVuY3Rpb24geCBiXG4gIC8vLiAgICAgKGEgLT4gYykgLT4gRnVuY3Rpb24geCBhIC0+IEZ1bmN0aW9uIHggY1xuICAvLy4gICAgIChiIC0+IGMpIC0+IEZ1bmN0aW9uIHggYiAtPiBGdW5jdGlvbiB4IGNcbiAgLy8uICAgICAoYiAtPiBjKSAtPiBGdW5jdGlvbiBhIGIgLT4gRnVuY3Rpb24gYSBjXG4gIC8vLiAgICAgKGIgLT4gYykgLT4gKGEgLT4gYikgLT4gKGEgLT4gYylcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWFwKE1hdGguc3FydCwgUy5hZGQoMSkpKDk5KVxuICAvLy4gMTBcbiAgLy8uIGBgYFxuICBTLm1hcCA9IGRlZignbWFwJywge2Y6IFtaLkZ1bmN0b3JdfSwgW0ZuKGEsIGIpLCBmKGEpLCBmKGIpXSwgWi5tYXApO1xuXG4gIC8vIyBiaW1hcCA6OiBCaWZ1bmN0b3IgZiA9PiAoYSAtPiBiKSAtPiAoYyAtPiBkKSAtPiBmIGEgYyAtPiBmIGIgZFxuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFouYmltYXBgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5iaW1hcChTLnRvVXBwZXIsIE1hdGguc3FydCwgUy5MZWZ0KCdmb28nKSlcbiAgLy8uIExlZnQoJ0ZPTycpXG4gIC8vLlxuICAvLy4gPiBTLmJpbWFwKFMudG9VcHBlciwgTWF0aC5zcXJ0LCBTLlJpZ2h0KDY0KSlcbiAgLy8uIFJpZ2h0KDgpXG4gIC8vLiBgYGBcbiAgUy5iaW1hcCA9XG4gIGRlZignYmltYXAnLFxuICAgICAge3A6IFtaLkJpZnVuY3Rvcl19LFxuICAgICAgW0ZuKGEsIGIpLCBGbihjLCBkKSwgcChhLCBjKSwgcChiLCBkKV0sXG4gICAgICBaLmJpbWFwKTtcblxuICAvLyMgcHJvbWFwIDo6IFByb2Z1bmN0b3IgcCA9PiAoYSAtPiBiKSAtPiAoYyAtPiBkKSAtPiBwIGIgYyAtPiBwIGEgZFxuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFoucHJvbWFwYF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucHJvbWFwKE1hdGguYWJzLCBTLmFkZCgxKSwgTWF0aC5zcXJ0KSgtMTAwKVxuICAvLy4gMTFcbiAgLy8uIGBgYFxuICBTLnByb21hcCA9XG4gIGRlZigncHJvbWFwJyxcbiAgICAgIHtwOiBbWi5Qcm9mdW5jdG9yXX0sXG4gICAgICBbRm4oYSwgYiksIEZuKGMsIGQpLCBwKGIsIGMpLCBwKGEsIGQpXSxcbiAgICAgIFoucHJvbWFwKTtcblxuICAvLyMgYWx0IDo6IEFsdCBmID0+IGYgYSAtPiBmIGEgLT4gZiBhXG4gIC8vLlxuICAvLy4gQ3VycmllZCB2ZXJzaW9uIG9mIFtgWi5hbHRgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5hbHQoUy5Ob3RoaW5nLCBTLkp1c3QoMSkpXG4gIC8vLiBKdXN0KDEpXG4gIC8vLlxuICAvLy4gPiBTLmFsdChTLkp1c3QoMiksIFMuSnVzdCgzKSlcbiAgLy8uIEp1c3QoMilcbiAgLy8uXG4gIC8vLiA+IFMuYWx0KFMuTGVmdCgnWCcpLCBTLlJpZ2h0KDEpKVxuICAvLy4gUmlnaHQoMSlcbiAgLy8uXG4gIC8vLiA+IFMuYWx0KFMuUmlnaHQoMiksIFMuUmlnaHQoMykpXG4gIC8vLiBSaWdodCgyKVxuICAvLy4gYGBgXG4gIFMuYWx0ID0gZGVmKCdhbHQnLCB7ZjogW1ouQWx0XX0sIFtmKGEpLCBmKGEpLCBmKGEpXSwgWi5hbHQpO1xuXG4gIC8vIyB6ZXJvIDo6IFBsdXMgZiA9PiBUeXBlUmVwIGYgLT4gZiBhXG4gIC8vLlxuICAvLy4gW1R5cGUtc2FmZV1bc2FuY3R1YXJ5LWRlZl0gdmVyc2lvbiBvZiBbYFouemVyb2BdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnplcm8oQXJyYXkpXG4gIC8vLiBbXVxuICAvLy5cbiAgLy8uID4gUy56ZXJvKE9iamVjdClcbiAgLy8uIHt9XG4gIC8vLlxuICAvLy4gPiBTLnplcm8oUy5NYXliZSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBTLnplcm8gPVxuICBkZWYoJ3plcm8nLCB7ZjogW1ouUGx1c119LCBbVHlwZVJlcCgkLlR5cGVWYXJpYWJsZSgnZicpKSwgZihhKV0sIFouemVybyk7XG5cbiAgLy8jIHJlZHVjZSA6OiBGb2xkYWJsZSBmID0+IChiIC0+IGEgLT4gYikgLT4gYiAtPiBmIGEgLT4gYlxuICAvLy5cbiAgLy8uIFRha2VzIGEgY3VycmllZCBiaW5hcnkgZnVuY3Rpb24sIGFuIGluaXRpYWwgdmFsdWUsIGFuZCBhIFtGb2xkYWJsZV1bXSxcbiAgLy8uIGFuZCBhcHBsaWVzIHRoZSBmdW5jdGlvbiB0byB0aGUgaW5pdGlhbCB2YWx1ZSBhbmQgdGhlIEZvbGRhYmxlJ3MgZmlyc3RcbiAgLy8uIHZhbHVlLCB0aGVuIGFwcGxpZXMgdGhlIGZ1bmN0aW9uIHRvIHRoZSByZXN1bHQgb2YgdGhlIHByZXZpb3VzXG4gIC8vLiBhcHBsaWNhdGlvbiBhbmQgdGhlIEZvbGRhYmxlJ3Mgc2Vjb25kIHZhbHVlLiBSZXBlYXRzIHRoaXMgcHJvY2Vzc1xuICAvLy4gdW50aWwgZWFjaCBvZiB0aGUgRm9sZGFibGUncyB2YWx1ZXMgaGFzIGJlZW4gdXNlZC4gUmV0dXJucyB0aGUgaW5pdGlhbFxuICAvLy4gdmFsdWUgaWYgdGhlIEZvbGRhYmxlIGlzIGVtcHR5OyB0aGUgcmVzdWx0IG9mIHRoZSBmaW5hbCBhcHBsaWNhdGlvblxuICAvLy4gb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5yZWR1Y2UoUy5hZGQsIDAsIFsxLCAyLCAzLCA0LCA1XSlcbiAgLy8uIDE1XG4gIC8vLlxuICAvLy4gPiBTLnJlZHVjZSh4cyA9PiB4ID0+IFt4XS5jb25jYXQoeHMpLCBbXSwgWzEsIDIsIDMsIDQsIDVdKVxuICAvLy4gWzUsIDQsIDMsIDIsIDFdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcmVkdWNlKGYsIGluaXRpYWwsIGZvbGRhYmxlKSB7XG4gICAgcmV0dXJuIFoucmVkdWNlKHVuY3VycnkyKGYpLCBpbml0aWFsLCBmb2xkYWJsZSk7XG4gIH1cbiAgUy5yZWR1Y2UgPVxuICBkZWYoJ3JlZHVjZScsIHtmOiBbWi5Gb2xkYWJsZV19LCBbRm4oYSwgRm4oYiwgYSkpLCBhLCBmKGIpLCBhXSwgcmVkdWNlKTtcblxuICAvLyMgdHJhdmVyc2UgOjogKEFwcGxpY2F0aXZlIGYsIFRyYXZlcnNhYmxlIHQpID0+IFR5cGVSZXAgZiAtPiAoYSAtPiBmIGIpIC0+IHQgYSAtPiBmICh0IGIpXG4gIC8vLlxuICAvLy4gQ3VycmllZCB2ZXJzaW9uIG9mIFtgWi50cmF2ZXJzZWBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRyYXZlcnNlKEFycmF5LCBTLndvcmRzLCBTLkp1c3QoJ2ZvbyBiYXIgYmF6JykpXG4gIC8vLiBbSnVzdCgnZm9vJyksIEp1c3QoJ2JhcicpLCBKdXN0KCdiYXonKV1cbiAgLy8uXG4gIC8vLiA+IFMudHJhdmVyc2UoQXJyYXksIFMud29yZHMsIFMuTm90aGluZylcbiAgLy8uIFtOb3RoaW5nXVxuICAvLy5cbiAgLy8uID4gUy50cmF2ZXJzZShTLk1heWJlLCBTLnBhcnNlSW50KDE2KSwgWydBJywgJ0InLCAnQyddKVxuICAvLy4gSnVzdChbMTAsIDExLCAxMl0pXG4gIC8vLlxuICAvLy4gPiBTLnRyYXZlcnNlKFMuTWF5YmUsIFMucGFyc2VJbnQoMTYpLCBbJ0EnLCAnQicsICdDJywgJ1gnXSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMudHJhdmVyc2UoUy5NYXliZSwgUy5wYXJzZUludCgxNiksIHthOiAnQScsIGI6ICdCJywgYzogJ0MnfSlcbiAgLy8uIEp1c3Qoe2E6IDEwLCBiOiAxMSwgYzogMTJ9KVxuICAvLy5cbiAgLy8uID4gUy50cmF2ZXJzZShTLk1heWJlLCBTLnBhcnNlSW50KDE2KSwge2E6ICdBJywgYjogJ0InLCBjOiAnQycsIHg6ICdYJ30pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgUy50cmF2ZXJzZSA9XG4gIGRlZigndHJhdmVyc2UnLFxuICAgICAge2Y6IFtaLkFwcGxpY2F0aXZlXSwgdDogW1ouVHJhdmVyc2FibGVdfSxcbiAgICAgIFtUeXBlUmVwKCQuVHlwZVZhcmlhYmxlKCdmJykpLCBGbihhLCBmKGIpKSwgdChhKSwgZih0KGIpKV0sXG4gICAgICBaLnRyYXZlcnNlKTtcblxuICAvLyMgc2VxdWVuY2UgOjogKEFwcGxpY2F0aXZlIGYsIFRyYXZlcnNhYmxlIHQpID0+IFR5cGVSZXAgZiAtPiB0IChmIGEpIC0+IGYgKHQgYSlcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLnNlcXVlbmNlYF1bXS4gSW52ZXJ0cyB0aGUgZ2l2ZW4gYHQgKGYgYSlgXG4gIC8vLiB0byBwcm9kdWNlIGFuIGBmICh0IGEpYC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuc2VxdWVuY2UoQXJyYXksIFMuSnVzdChbMSwgMiwgM10pKVxuICAvLy4gW0p1c3QoMSksIEp1c3QoMiksIEp1c3QoMyldXG4gIC8vLlxuICAvLy4gPiBTLnNlcXVlbmNlKFMuTWF5YmUsIFtTLkp1c3QoMSksIFMuSnVzdCgyKSwgUy5KdXN0KDMpXSlcbiAgLy8uIEp1c3QoWzEsIDIsIDNdKVxuICAvLy5cbiAgLy8uID4gUy5zZXF1ZW5jZShTLk1heWJlLCBbUy5KdXN0KDEpLCBTLkp1c3QoMiksIFMuTm90aGluZ10pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLnNlcXVlbmNlKFMuTWF5YmUsIHthOiBTLkp1c3QoMSksIGI6IFMuSnVzdCgyKSwgYzogUy5KdXN0KDMpfSlcbiAgLy8uIEp1c3Qoe2E6IDEsIGI6IDIsIGM6IDN9KVxuICAvLy5cbiAgLy8uID4gUy5zZXF1ZW5jZShTLk1heWJlLCB7YTogUy5KdXN0KDEpLCBiOiBTLkp1c3QoMiksIGM6IFMuTm90aGluZ30pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgUy5zZXF1ZW5jZSA9XG4gIGRlZignc2VxdWVuY2UnLFxuICAgICAge2Y6IFtaLkFwcGxpY2F0aXZlXSwgdDogW1ouVHJhdmVyc2FibGVdfSxcbiAgICAgIFtUeXBlUmVwKCQuVHlwZVZhcmlhYmxlKCdmJykpLCB0KGYoYSkpLCBmKHQoYSkpXSxcbiAgICAgIFouc2VxdWVuY2UpO1xuXG4gIC8vIyBhcCA6OiBBcHBseSBmID0+IGYgKGEgLT4gYikgLT4gZiBhIC0+IGYgYlxuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFouYXBgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5hcChbTWF0aC5zcXJ0LCB4ID0+IHggKiB4XSwgWzEsIDQsIDksIDE2LCAyNV0pXG4gIC8vLiBbMSwgMiwgMywgNCwgNSwgMSwgMTYsIDgxLCAyNTYsIDYyNV1cbiAgLy8uXG4gIC8vLiA+IFMuYXAoe3g6IE1hdGguc3FydCwgeTogUy5hZGQoMSksIHo6IFMuc3ViKDEpfSwge3c6IDQsIHg6IDQsIHk6IDR9KVxuICAvLy4ge3g6IDIsIHk6IDV9XG4gIC8vLlxuICAvLy4gPiBTLmFwKFMuSnVzdChNYXRoLnNxcnQpLCBTLkp1c3QoNjQpKVxuICAvLy4gSnVzdCg4KVxuICAvLy4gYGBgXG4gIC8vLlxuICAvLy4gUmVwbGFjaW5nIGBBcHBseSBmID0+IGZgIHdpdGggYEZ1bmN0aW9uIHhgIHByb2R1Y2VzIHRoZSBTIGNvbWJpbmF0b3JcbiAgLy8uIGZyb20gY29tYmluYXRvcnkgbG9naWM6XG4gIC8vLlxuICAvLy4gICAgIEFwcGx5IGYgPT4gZiAoYSAtPiBiKSAtPiBmIGEgLT4gZiBiXG4gIC8vLiAgICAgRnVuY3Rpb24geCAoYSAtPiBiKSAtPiBGdW5jdGlvbiB4IGEgLT4gRnVuY3Rpb24geCBiXG4gIC8vLiAgICAgRnVuY3Rpb24geCAoYSAtPiBjKSAtPiBGdW5jdGlvbiB4IGEgLT4gRnVuY3Rpb24geCBjXG4gIC8vLiAgICAgRnVuY3Rpb24geCAoYiAtPiBjKSAtPiBGdW5jdGlvbiB4IGIgLT4gRnVuY3Rpb24geCBjXG4gIC8vLiAgICAgRnVuY3Rpb24gYSAoYiAtPiBjKSAtPiBGdW5jdGlvbiBhIGIgLT4gRnVuY3Rpb24gYSBjXG4gIC8vLiAgICAgKGEgLT4gYiAtPiBjKSAtPiAoYSAtPiBiKSAtPiAoYSAtPiBjKVxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5hcChzID0+IG4gPT4gcy5zbGljZSgwLCBuKSwgcyA9PiBNYXRoLmNlaWwocy5sZW5ndGggLyAyKSkoJ0hhc2tlbGwnKVxuICAvLy4gJ0hhc2snXG4gIC8vLiBgYGBcbiAgUy5hcCA9XG4gIGRlZignYXAnLFxuICAgICAge2Y6IFtaLkFwcGx5XX0sXG4gICAgICBbZihGbihhLCBiKSksIGYoYSksIGYoYildLFxuICAgICAgWi5hcCk7XG5cbiAgLy8jIGxpZnQyIDo6IEFwcGx5IGYgPT4gKGEgLT4gYiAtPiBjKSAtPiBmIGEgLT4gZiBiIC0+IGYgY1xuICAvLy5cbiAgLy8uIFByb21vdGVzIGEgY3VycmllZCBiaW5hcnkgZnVuY3Rpb24gdG8gYSBmdW5jdGlvbiB3aGljaCBvcGVyYXRlcyBvbiB0d29cbiAgLy8uIFtBcHBseV1bXXMuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmxpZnQyKFMuYWRkLCBTLkp1c3QoMiksIFMuSnVzdCgzKSlcbiAgLy8uIEp1c3QoNSlcbiAgLy8uXG4gIC8vLiA+IFMubGlmdDIoUy5hZGQsIFMuSnVzdCgyKSwgUy5Ob3RoaW5nKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5saWZ0MihTLmFuZCwgUy5KdXN0KHRydWUpLCBTLkp1c3QodHJ1ZSkpXG4gIC8vLiBKdXN0KHRydWUpXG4gIC8vLlxuICAvLy4gPiBTLmxpZnQyKFMuYW5kLCBTLkp1c3QodHJ1ZSksIFMuSnVzdChmYWxzZSkpXG4gIC8vLiBKdXN0KGZhbHNlKVxuICAvLy4gYGBgXG4gIFMubGlmdDIgPVxuICBkZWYoJ2xpZnQyJywge2Y6IFtaLkFwcGx5XX0sIFtGbihhLCBGbihiLCBjKSksIGYoYSksIGYoYiksIGYoYyldLCBaLmxpZnQyKTtcblxuICAvLyMgbGlmdDMgOjogQXBwbHkgZiA9PiAoYSAtPiBiIC0+IGMgLT4gZCkgLT4gZiBhIC0+IGYgYiAtPiBmIGMgLT4gZiBkXG4gIC8vLlxuICAvLy4gUHJvbW90ZXMgYSBjdXJyaWVkIHRlcm5hcnkgZnVuY3Rpb24gdG8gYSBmdW5jdGlvbiB3aGljaCBvcGVyYXRlcyBvbiB0aHJlZVxuICAvLy4gW0FwcGx5XVtdcy5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubGlmdDMoUy5yZWR1Y2UsIFMuSnVzdChTLmFkZCksIFMuSnVzdCgwKSwgUy5KdXN0KFsxLCAyLCAzXSkpXG4gIC8vLiBKdXN0KDYpXG4gIC8vLlxuICAvLy4gPiBTLmxpZnQzKFMucmVkdWNlLCBTLkp1c3QoUy5hZGQpLCBTLkp1c3QoMCksIFMuTm90aGluZylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBTLmxpZnQzID1cbiAgZGVmKCdsaWZ0MycsXG4gICAgICB7ZjogW1ouQXBwbHldfSxcbiAgICAgIFtGbihhLCBGbihiLCBGbihjLCBkKSkpLCBmKGEpLCBmKGIpLCBmKGMpLCBmKGQpXSxcbiAgICAgIFoubGlmdDMpO1xuXG4gIC8vIyBhcEZpcnN0IDo6IEFwcGx5IGYgPT4gZiBhIC0+IGYgYiAtPiBmIGFcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLmFwRmlyc3RgXVtdLiBDb21iaW5lcyB0d28gZWZmZWN0ZnVsIGFjdGlvbnMsXG4gIC8vLiBrZWVwaW5nIG9ubHkgdGhlIHJlc3VsdCBvZiB0aGUgZmlyc3QuIEVxdWl2YWxlbnQgdG8gSGFza2VsbCdzIGAoPCopYFxuICAvLy4gZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BhcFNlY29uZGBdKCNhcFNlY29uZCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmFwRmlyc3QoWzEsIDJdLCBbMywgNF0pXG4gIC8vLiBbMSwgMSwgMiwgMl1cbiAgLy8uXG4gIC8vLiA+IFMuYXBGaXJzdChTLkp1c3QoMSksIFMuSnVzdCgyKSlcbiAgLy8uIEp1c3QoMSlcbiAgLy8uIGBgYFxuICBTLmFwRmlyc3QgPSBkZWYoJ2FwRmlyc3QnLCB7ZjogW1ouQXBwbHldfSwgW2YoYSksIGYoYiksIGYoYSldLCBaLmFwRmlyc3QpO1xuXG4gIC8vIyBhcFNlY29uZCA6OiBBcHBseSBmID0+IGYgYSAtPiBmIGIgLT4gZiBiXG4gIC8vLlxuICAvLy4gQ3VycmllZCB2ZXJzaW9uIG9mIFtgWi5hcFNlY29uZGBdW10uIENvbWJpbmVzIHR3byBlZmZlY3RmdWwgYWN0aW9ucyxcbiAgLy8uIGtlZXBpbmcgb25seSB0aGUgcmVzdWx0IG9mIHRoZSBzZWNvbmQuIEVxdWl2YWxlbnQgdG8gSGFza2VsbCdzIGAoKj4pYFxuICAvLy4gZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BhcEZpcnN0YF0oI2FwRmlyc3QpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5hcFNlY29uZChbMSwgMl0sIFszLCA0XSlcbiAgLy8uIFszLCA0LCAzLCA0XVxuICAvLy5cbiAgLy8uID4gUy5hcFNlY29uZChTLkp1c3QoMSksIFMuSnVzdCgyKSlcbiAgLy8uIEp1c3QoMilcbiAgLy8uIGBgYFxuICBTLmFwU2Vjb25kID0gZGVmKCdhcFNlY29uZCcsIHtmOiBbWi5BcHBseV19LCBbZihhKSwgZihiKSwgZihiKV0sIFouYXBTZWNvbmQpO1xuXG4gIC8vIyBvZiA6OiBBcHBsaWNhdGl2ZSBmID0+IFR5cGVSZXAgZiAtPiBhIC0+IGYgYVxuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFoub2ZgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5vZihBcnJheSwgNDIpXG4gIC8vLiBbNDJdXG4gIC8vLlxuICAvLy4gPiBTLm9mKEZ1bmN0aW9uLCA0MikobnVsbClcbiAgLy8uIDQyXG4gIC8vLlxuICAvLy4gPiBTLm9mKFMuTWF5YmUsIDQyKVxuICAvLy4gSnVzdCg0MilcbiAgLy8uXG4gIC8vLiA+IFMub2YoUy5FaXRoZXIsIDQyKVxuICAvLy4gUmlnaHQoNDIpXG4gIC8vLiBgYGBcbiAgUy5vZiA9XG4gIGRlZignb2YnLFxuICAgICAge2Y6IFtaLkFwcGxpY2F0aXZlXX0sXG4gICAgICBbVHlwZVJlcCgkLlR5cGVWYXJpYWJsZSgnZicpKSwgYSwgZihhKV0sXG4gICAgICBaLm9mKTtcblxuICAvLyMgY2hhaW4gOjogQ2hhaW4gbSA9PiAoYSAtPiBtIGIpIC0+IG0gYSAtPiBtIGJcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLmNoYWluYF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuY2hhaW4oeCA9PiBbeCwgeF0sIFsxLCAyLCAzXSlcbiAgLy8uIFsxLCAxLCAyLCAyLCAzLCAzXVxuICAvLy5cbiAgLy8uID4gUy5jaGFpbihuID0+IHMgPT4gcy5zbGljZSgwLCBuKSwgcyA9PiBNYXRoLmNlaWwocy5sZW5ndGggLyAyKSkoJ3NsaWNlJylcbiAgLy8uICdzbGknXG4gIC8vLlxuICAvLy4gPiBTLmNoYWluKFMucGFyc2VJbnQoMTApLCBTLkp1c3QoJzEyMycpKVxuICAvLy4gSnVzdCgxMjMpXG4gIC8vLlxuICAvLy4gPiBTLmNoYWluKFMucGFyc2VJbnQoMTApLCBTLkp1c3QoJ1hYWCcpKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIFMuY2hhaW4gPSBkZWYoJ2NoYWluJywge206IFtaLkNoYWluXX0sIFtGbihhLCBtKGIpKSwgbShhKSwgbShiKV0sIFouY2hhaW4pO1xuXG4gIC8vIyBqb2luIDo6IENoYWluIG0gPT4gbSAobSBhKSAtPiBtIGFcbiAgLy8uXG4gIC8vLiBbVHlwZS1zYWZlXVtzYW5jdHVhcnktZGVmXSB2ZXJzaW9uIG9mIFtgWi5qb2luYF1bXS5cbiAgLy8uIFJlbW92ZXMgb25lIGxldmVsIG9mIG5lc3RpbmcgZnJvbSBhIG5lc3RlZCBtb25hZGljIHN0cnVjdHVyZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuam9pbihbWzFdLCBbMl0sIFszXV0pXG4gIC8vLiBbMSwgMiwgM11cbiAgLy8uXG4gIC8vLiA+IFMuam9pbihbW1sxLCAyLCAzXV1dKVxuICAvLy4gW1sxLCAyLCAzXV1cbiAgLy8uXG4gIC8vLiA+IFMuam9pbihTLkp1c3QoUy5KdXN0KDEpKSlcbiAgLy8uIFMuSnVzdCgxKVxuICAvLy4gYGBgXG4gIC8vLlxuICAvLy4gUmVwbGFjaW5nIGBDaGFpbiBtID0+IG1gIHdpdGggYEZ1bmN0aW9uIHhgIHByb2R1Y2VzIHRoZSBXIGNvbWJpbmF0b3JcbiAgLy8uIGZyb20gY29tYmluYXRvcnkgbG9naWM6XG4gIC8vLlxuICAvLy4gICAgIENoYWluIG0gPT4gbSAobSBhKSAtPiBtIGFcbiAgLy8uICAgICBGdW5jdGlvbiB4IChGdW5jdGlvbiB4IGEpIC0+IEZ1bmN0aW9uIHggYVxuICAvLy4gICAgICh4IC0+IHggLT4gYSkgLT4gKHggLT4gYSlcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuam9pbihTLmNvbmNhdCkoJ2FiYycpXG4gIC8vLiAnYWJjYWJjJ1xuICAvLy4gYGBgXG4gIFMuam9pbiA9IGRlZignam9pbicsIHttOiBbWi5DaGFpbl19LCBbbShtKGEpKSwgbShhKV0sIFouam9pbik7XG5cbiAgLy8jIGNoYWluUmVjIDo6IENoYWluUmVjIG0gPT4gVHlwZVJlcCBtIC0+IChhIC0+IG0gKEVpdGhlciBhIGIpKSAtPiBhIC0+IG0gYlxuICAvLy5cbiAgLy8uIFBlcmZvcm1zIGEgW2BjaGFpbmBdKCNjaGFpbiktbGlrZSBjb21wdXRhdGlvbiB3aXRoIGNvbnN0YW50IHN0YWNrIHVzYWdlLlxuICAvLy4gU2ltaWxhciB0byBbYFouY2hhaW5SZWNgXVtdLCBidXQgY3VycmllZCBhbmQgbW9yZSBjb252ZW5pZW50IGR1ZSB0byB0aGVcbiAgLy8uIHVzZSBvZiB0aGUgRWl0aGVyIHR5cGUgdG8gaW5kaWNhdGUgY29tcGxldGlvbiAodmlhIGEgUmlnaHQpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5jaGFpblJlYyhBcnJheSxcbiAgLy8uIC4gICAgICAgICAgICBzID0+IHMubGVuZ3RoID09PSAyID8gUy5tYXAoUy5SaWdodCwgW3MgKyAnIScsIHMgKyAnPyddKVxuICAvLy4gLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBTLm1hcChTLkxlZnQsIFtzICsgJ28nLCBzICsgJ24nXSksXG4gIC8vLiAuICAgICAgICAgICAgJycpXG4gIC8vLiBbJ29vIScsICdvbz8nLCAnb24hJywgJ29uPycsICdubyEnLCAnbm8/JywgJ25uIScsICdubj8nXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGNoYWluUmVjKHR5cGVSZXAsIGYsIHgpIHtcbiAgICBmdW5jdGlvbiBzdGVwKG5leHQsIGRvbmUsIHgpIHtcbiAgICAgIHJldHVybiBaLm1hcChmdW5jdGlvbihlKSB7IHJldHVybiBlaXRoZXIobmV4dCwgZG9uZSwgZSk7IH0sIGYoeCkpO1xuICAgIH1cbiAgICByZXR1cm4gWi5jaGFpblJlYyh0eXBlUmVwLCBzdGVwLCB4KTtcbiAgfVxuICBTLmNoYWluUmVjID1cbiAgZGVmKCdjaGFpblJlYycsXG4gICAgICB7bTogW1ouQ2hhaW5SZWNdfSxcbiAgICAgIFtUeXBlUmVwKCQuVHlwZVZhcmlhYmxlKCdtJykpLCBGbihhLCBtKCRFaXRoZXIoYSwgYikpKSwgYSwgbShiKV0sXG4gICAgICBjaGFpblJlYyk7XG5cbiAgLy8jIGV4dGVuZCA6OiBFeHRlbmQgdyA9PiAodyBhIC0+IGIpIC0+IHcgYSAtPiB3IGJcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLmV4dGVuZGBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmV4dGVuZChTLmpvaW5XaXRoKCcnKSwgWyd4JywgJ3knLCAneiddKVxuICAvLy4gWyd4eXonLCAneXonLCAneiddXG4gIC8vLiBgYGBcbiAgUy5leHRlbmQgPVxuICBkZWYoJ2V4dGVuZCcsIHt3OiBbWi5FeHRlbmRdfSwgW0ZuKHcoYSksIGIpLCB3KGEpLCB3KGIpXSwgWi5leHRlbmQpO1xuXG4gIC8vIyBleHRyYWN0IDo6IENvbW9uYWQgdyA9PiB3IGEgLT4gYVxuICAvLy5cbiAgLy8uIFtUeXBlLXNhZmVdW3NhbmN0dWFyeS1kZWZdIHZlcnNpb24gb2YgW2BaLmV4dHJhY3RgXVtdLlxuICBTLmV4dHJhY3QgPVxuICBkZWYoJ2V4dHJhY3QnLCB7dzogW1ouQ29tb25hZF19LCBbdyhhKSwgYV0sIFouZXh0cmFjdCk7XG5cbiAgLy8jIGNvbnRyYW1hcCA6OiBDb250cmF2YXJpYW50IGYgPT4gKGIgLT4gYSkgLT4gZiBhIC0+IGYgYlxuICAvLy5cbiAgLy8uIFtUeXBlLXNhZmVdW3NhbmN0dWFyeS1kZWZdIHZlcnNpb24gb2YgW2BaLmNvbnRyYW1hcGBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmNvbnRyYW1hcChzID0+IHMubGVuZ3RoLCBNYXRoLnNxcnQpKCdTYW5jdHVhcnknKVxuICAvLy4gM1xuICAvLy4gYGBgXG4gIFMuY29udHJhbWFwID1cbiAgZGVmKCdjb250cmFtYXAnLFxuICAgICAge2Y6IFtaLkNvbnRyYXZhcmlhbnRdfSxcbiAgICAgIFtGbihiLCBhKSwgZihhKSwgZihiKV0sXG4gICAgICBaLmNvbnRyYW1hcCk7XG5cbiAgLy8jIGZpbHRlciA6OiAoQXBwbGljYXRpdmUgZiwgRm9sZGFibGUgZiwgTW9ub2lkIChmIGEpKSA9PiAoYSAtPiBCb29sZWFuKSAtPiBmIGEgLT4gZiBhXG4gIC8vLlxuICAvLy4gQ3VycmllZCB2ZXJzaW9uIG9mIFtgWi5maWx0ZXJgXVtdLiBGaWx0ZXJzIGl0cyBzZWNvbmQgYXJndW1lbnQgaW5cbiAgLy8uIGFjY29yZGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gcHJlZGljYXRlLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZmlsdGVyTWBdKCNmaWx0ZXJNKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZmlsdGVyKFMub2RkLCBbMSwgMiwgMywgNCwgNV0pXG4gIC8vLiBbMSwgMywgNV1cbiAgLy8uIGBgYFxuICBTLmZpbHRlciA9XG4gIGRlZignZmlsdGVyJyxcbiAgICAgIHtmOiBbWi5BcHBsaWNhdGl2ZSwgWi5Gb2xkYWJsZSwgWi5Nb25vaWRdfSxcbiAgICAgIFskLlByZWRpY2F0ZShhKSwgZihhKSwgZihhKV0sXG4gICAgICBaLmZpbHRlcik7XG5cbiAgLy8jIGZpbHRlck0gOjogKEFsdGVybmF0aXZlIG0sIE1vbmFkIG0pID0+IChhIC0+IEJvb2xlYW4pIC0+IG0gYSAtPiBtIGFcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLmZpbHRlck1gXVtdLiBGaWx0ZXJzIGl0cyBzZWNvbmQgYXJndW1lbnQgaW5cbiAgLy8uIGFjY29yZGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gcHJlZGljYXRlLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZmlsdGVyYF0oI2ZpbHRlcikuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmZpbHRlck0oUy5vZGQsIFsxLCAyLCAzLCA0LCA1XSlcbiAgLy8uIFsxLCAzLCA1XVxuICAvLy5cbiAgLy8uID4gUy5maWx0ZXJNKFMub2RkLCBTLkp1c3QoOSkpXG4gIC8vLiBKdXN0KDkpXG4gIC8vLlxuICAvLy4gPiBTLmZpbHRlck0oUy5vZGQsIFMuSnVzdCg0KSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBTLmZpbHRlck0gPVxuICBkZWYoJ2ZpbHRlck0nLFxuICAgICAge206IFtaLkFsdGVybmF0aXZlLCBaLk1vbmFkXX0sXG4gICAgICBbJC5QcmVkaWNhdGUoYSksIG0oYSksIG0oYSldLFxuICAgICAgWi5maWx0ZXJNKTtcblxuICAvLyMgdGFrZVdoaWxlIDo6IChGb2xkYWJsZSBmLCBBbHRlcm5hdGl2ZSBmKSA9PiAoYSAtPiBCb29sZWFuKSAtPiBmIGEgLT4gZiBhXG4gIC8vLlxuICAvLy4gRGlzY2FyZHMgdGhlIGZpcnN0IGlubmVyIHZhbHVlIHdoaWNoIGRvZXMgbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZSwgYW5kXG4gIC8vLiBhbGwgc3Vic2VxdWVudCBpbm5lciB2YWx1ZXMuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRha2VXaGlsZShTLm9kZCwgWzMsIDMsIDMsIDcsIDYsIDMsIDUsIDRdKVxuICAvLy4gWzMsIDMsIDMsIDddXG4gIC8vLlxuICAvLy4gPiBTLnRha2VXaGlsZShTLmV2ZW4sIFszLCAzLCAzLCA3LCA2LCAzLCA1LCA0XSlcbiAgLy8uIFtdXG4gIC8vLiBgYGBcbiAgUy50YWtlV2hpbGUgPVxuICBkZWYoJ3Rha2VXaGlsZScsXG4gICAgICB7ZjogW1ouRm9sZGFibGUsIFouQWx0ZXJuYXRpdmVdfSxcbiAgICAgIFskLlByZWRpY2F0ZShhKSwgZihhKSwgZihhKV0sXG4gICAgICBaLnRha2VXaGlsZSk7XG5cbiAgLy8jIGRyb3BXaGlsZSA6OiAoRm9sZGFibGUgZiwgQWx0ZXJuYXRpdmUgZikgPT4gKGEgLT4gQm9vbGVhbikgLT4gZiBhIC0+IGYgYVxuICAvLy5cbiAgLy8uIFJldGFpbnMgdGhlIGZpcnN0IGlubmVyIHZhbHVlIHdoaWNoIGRvZXMgbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZSwgYW5kXG4gIC8vLiBhbGwgc3Vic2VxdWVudCBpbm5lciB2YWx1ZXMuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmRyb3BXaGlsZShTLm9kZCwgWzMsIDMsIDMsIDcsIDYsIDMsIDUsIDRdKVxuICAvLy4gWzYsIDMsIDUsIDRdXG4gIC8vLlxuICAvLy4gPiBTLmRyb3BXaGlsZShTLmV2ZW4sIFszLCAzLCAzLCA3LCA2LCAzLCA1LCA0XSlcbiAgLy8uIFszLCAzLCAzLCA3LCA2LCAzLCA1LCA0XVxuICAvLy4gYGBgXG4gIFMuZHJvcFdoaWxlID1cbiAgZGVmKCdkcm9wV2hpbGUnLFxuICAgICAge2Y6IFtaLkZvbGRhYmxlLCBaLkFsdGVybmF0aXZlXX0sXG4gICAgICBbJC5QcmVkaWNhdGUoYSksIGYoYSksIGYoYSldLFxuICAgICAgWi5kcm9wV2hpbGUpO1xuXG4gIC8vLiAjIyMgQ29tYmluYXRvclxuXG4gIC8vIyBJIDo6IGEgLT4gYVxuICAvLy5cbiAgLy8uIFRoZSBJIGNvbWJpbmF0b3IuIFJldHVybnMgaXRzIGFyZ3VtZW50LiBFcXVpdmFsZW50IHRvIEhhc2tlbGwncyBgaWRgXG4gIC8vLiBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuSSgnZm9vJylcbiAgLy8uICdmb28nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gSSh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cbiAgUy5JID0gZGVmKCdJJywge30sIFthLCBhXSwgSSk7XG5cbiAgLy8jIEsgOjogYSAtPiBiIC0+IGFcbiAgLy8uXG4gIC8vLiBUaGUgSyBjb21iaW5hdG9yLiBUYWtlcyB0d28gdmFsdWVzIGFuZCByZXR1cm5zIHRoZSBmaXJzdC4gRXF1aXZhbGVudCB0b1xuICAvLy4gSGFza2VsbCdzIGBjb25zdGAgZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLksoJ2ZvbycsICdiYXInKVxuICAvLy4gJ2ZvbydcbiAgLy8uXG4gIC8vLiA+IFMubWFwKFMuSyg0MiksIFMucmFuZ2UoMCwgNSkpXG4gIC8vLiBbNDIsIDQyLCA0MiwgNDIsIDQyXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIEsoeCwgeSkge1xuICAgIHJldHVybiB4O1xuICB9XG4gIFMuSyA9IGRlZignSycsIHt9LCBbYSwgYiwgYV0sIEspO1xuXG4gIC8vIyBBIDo6IChhIC0+IGIpIC0+IGEgLT4gYlxuICAvLy5cbiAgLy8uIFRoZSBBIGNvbWJpbmF0b3IuIFRha2VzIGEgZnVuY3Rpb24gYW5kIGEgdmFsdWUsIGFuZCByZXR1cm5zIHRoZSByZXN1bHRcbiAgLy8uIG9mIGFwcGx5aW5nIHRoZSBmdW5jdGlvbiB0byB0aGUgdmFsdWUuIEVxdWl2YWxlbnQgdG8gSGFza2VsbCdzIGAoJClgXG4gIC8vLiBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuQShTLmFkZCgxKSwgNDIpXG4gIC8vLiA0M1xuICAvLy5cbiAgLy8uID4gUy5tYXAoUy5BKFMuX18sIDEwMCksIFtTLmFkZCgxKSwgTWF0aC5zcXJ0XSlcbiAgLy8uIFsxMDEsIDEwXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIEEoZiwgeCkge1xuICAgIHJldHVybiBmKHgpO1xuICB9XG4gIFMuQSA9IGRlZignQScsIHt9LCBbRm4oYSwgYiksIGEsIGJdLCBBKTtcblxuICAvLyMgVCA6OiBhIC0+IChhIC0+IGIpIC0+IGJcbiAgLy8uXG4gIC8vLiBUaGUgVCAoW3RocnVzaF1bXSkgY29tYmluYXRvci4gVGFrZXMgYSB2YWx1ZSBhbmQgYSBmdW5jdGlvbiwgYW5kIHJldHVybnNcbiAgLy8uIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGZ1bmN0aW9uIHRvIHRoZSB2YWx1ZS4gRXF1aXZhbGVudCB0byBIYXNrZWxsJ3NcbiAgLy8uIGAoJilgIGZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5UKDQyLCBTLmFkZCgxKSlcbiAgLy8uIDQzXG4gIC8vLlxuICAvLy4gPiBTLm1hcChTLlQoMTAwKSwgW1MuYWRkKDEpLCBNYXRoLnNxcnRdKVxuICAvLy4gWzEwMSwgMTBdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gVCh4LCBmKSB7XG4gICAgcmV0dXJuIGYoeCk7XG4gIH1cbiAgUy5UID0gZGVmKCdUJywge30sIFthLCBGbihhLCBiKSwgYl0sIFQpO1xuXG4gIC8vLiAjIyMgRnVuY3Rpb25cblxuICAvLyMgY3VycnkyIDo6ICgoYSwgYikgLT4gYykgLT4gYSAtPiBiIC0+IGNcbiAgLy8uXG4gIC8vLiBDdXJyaWVzIHRoZSBnaXZlbiBiaW5hcnkgZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1hcChTLmN1cnJ5MihNYXRoLnBvdykoMTApLCBbMSwgMiwgM10pXG4gIC8vLiBbMTAsIDEwMCwgMTAwMF1cbiAgLy8uXG4gIC8vLiA+IFMubWFwKFMuY3VycnkyKE1hdGgucG93LCAxMCksIFsxLCAyLCAzXSlcbiAgLy8uIFsxMCwgMTAwLCAxMDAwXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGN1cnJ5MihmLCB4LCB5KSB7XG4gICAgcmV0dXJuIGYoeCwgeSk7XG4gIH1cbiAgUy5jdXJyeTIgPVxuICBkZWYoJ2N1cnJ5MicsXG4gICAgICB7fSxcbiAgICAgIFskLkZ1bmN0aW9uKFthLCBiLCBjXSksIGEsIGIsIGNdLFxuICAgICAgY3VycnkyKTtcblxuICAvLyMgY3VycnkzIDo6ICgoYSwgYiwgYykgLT4gZCkgLT4gYSAtPiBiIC0+IGMgLT4gZFxuICAvLy5cbiAgLy8uIEN1cnJpZXMgdGhlIGdpdmVuIHRlcm5hcnkgZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBnbG9iYWwucmVwbGFjZVN0cmluZyA9IFMuY3VycnkzKCh3aGF0LCByZXBsYWNlbWVudCwgc3RyaW5nKSA9PlxuICAvLy4gLiAgIHN0cmluZy5yZXBsYWNlKHdoYXQsIHJlcGxhY2VtZW50KVxuICAvLy4gLiApXG4gIC8vLiByZXBsYWNlU3RyaW5nXG4gIC8vLlxuICAvLy4gPiByZXBsYWNlU3RyaW5nKCdiYW5hbmEnKSgnb3JhbmdlJykoJ2JhbmFuYSBpY2VjcmVhbScpXG4gIC8vLiAnb3JhbmdlIGljZWNyZWFtJ1xuICAvLy5cbiAgLy8uID4gcmVwbGFjZVN0cmluZygnYmFuYW5hJywgJ29yYW5nZScsICdiYW5hbmEgaWNlY3JlYW0nKVxuICAvLy4gJ29yYW5nZSBpY2VjcmVhbSdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBjdXJyeTMoZiwgeCwgeSwgeikge1xuICAgIHJldHVybiBmKHgsIHksIHopO1xuICB9XG4gIFMuY3VycnkzID1cbiAgZGVmKCdjdXJyeTMnLFxuICAgICAge30sXG4gICAgICBbJC5GdW5jdGlvbihbYSwgYiwgYywgZF0pLCBhLCBiLCBjLCBkXSxcbiAgICAgIGN1cnJ5Myk7XG5cbiAgLy8jIGN1cnJ5NCA6OiAoKGEsIGIsIGMsIGQpIC0+IGUpIC0+IGEgLT4gYiAtPiBjIC0+IGQgLT4gZVxuICAvLy5cbiAgLy8uIEN1cnJpZXMgdGhlIGdpdmVuIHF1YXRlcm5hcnkgZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBnbG9iYWwuY3JlYXRlUmVjdCA9IFMuY3Vycnk0KCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSA9PlxuICAvLy4gLiAgICh7eCwgeSwgd2lkdGgsIGhlaWdodH0pXG4gIC8vLiAuIClcbiAgLy8uIGNyZWF0ZVJlY3RcbiAgLy8uXG4gIC8vLiA+IGNyZWF0ZVJlY3QoMCkoMCkoMTApKDEwKVxuICAvLy4ge3g6IDAsIHk6IDAsIHdpZHRoOiAxMCwgaGVpZ2h0OiAxMH1cbiAgLy8uXG4gIC8vLiA+IGNyZWF0ZVJlY3QoMCwgMCwgMTAsIDEwKVxuICAvLy4ge3g6IDAsIHk6IDAsIHdpZHRoOiAxMCwgaGVpZ2h0OiAxMH1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBjdXJyeTQoZiwgdywgeCwgeSwgeikge1xuICAgIHJldHVybiBmKHcsIHgsIHksIHopO1xuICB9XG4gIFMuY3Vycnk0ID1cbiAgZGVmKCdjdXJyeTQnLFxuICAgICAge30sXG4gICAgICBbJC5GdW5jdGlvbihbYSwgYiwgYywgZCwgZV0pLCBhLCBiLCBjLCBkLCBlXSxcbiAgICAgIGN1cnJ5NCk7XG5cbiAgLy8jIGN1cnJ5NSA6OiAoKGEsIGIsIGMsIGQsIGUpIC0+IGYpIC0+IGEgLT4gYiAtPiBjIC0+IGQgLT4gZSAtPiBmXG4gIC8vLlxuICAvLy4gQ3VycmllcyB0aGUgZ2l2ZW4gcXVpbmFyeSBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGdsb2JhbC50b1VybCA9IFMuY3Vycnk1KChwcm90b2NvbCwgY3JlZHMsIGhvc3RuYW1lLCBwb3J0LCBwYXRobmFtZSkgPT5cbiAgLy8uIC4gICBwcm90b2NvbCArICcvLycgK1xuICAvLy4gLiAgIFMubWF5YmUoJycsIF8gPT4gXy51c2VybmFtZSArICc6JyArIF8ucGFzc3dvcmQgKyAnQCcsIGNyZWRzKSArXG4gIC8vLiAuICAgaG9zdG5hbWUgK1xuICAvLy4gLiAgIFMubWF5YmUoJycsIFMuY29uY2F0KCc6JyksIHBvcnQpICtcbiAgLy8uIC4gICBwYXRobmFtZVxuICAvLy4gLiApXG4gIC8vLiB0b1VybFxuICAvLy5cbiAgLy8uID4gdG9VcmwoJ2h0dHBzOicpKFMuTm90aGluZykoJ2V4YW1wbGUuY29tJykoUy5KdXN0KCc0NDMnKSkoJy9mb28vYmFyJylcbiAgLy8uICdodHRwczovL2V4YW1wbGUuY29tOjQ0My9mb28vYmFyJ1xuICAvLy5cbiAgLy8uID4gdG9VcmwoJ2h0dHBzOicsIFMuTm90aGluZywgJ2V4YW1wbGUuY29tJywgUy5KdXN0KCc0NDMnKSwgJy9mb28vYmFyJylcbiAgLy8uICdodHRwczovL2V4YW1wbGUuY29tOjQ0My9mb28vYmFyJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGN1cnJ5NShmLCB2LCB3LCB4LCB5LCB6KSB7XG4gICAgcmV0dXJuIGYodiwgdywgeCwgeSwgeik7XG4gIH1cbiAgUy5jdXJyeTUgPVxuICBkZWYoJ2N1cnJ5NScsXG4gICAgICB7fSxcbiAgICAgIFskLkZ1bmN0aW9uKFthLCBiLCBjLCBkLCBlLCByXSksIGEsIGIsIGMsIGQsIGUsIHJdLFxuICAgICAgY3Vycnk1KTtcblxuICAvLyMgZmxpcCA6OiAoYSAtPiBiIC0+IGMpIC0+IGIgLT4gYSAtPiBjXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBjdXJyaWVkIGJpbmFyeSBmdW5jdGlvbiBhbmQgdHdvIHZhbHVlcywgYW5kIHJldHVybnMgdGhlXG4gIC8vLiByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGZ1bmN0aW9uIHRvIHRoZSB2YWx1ZXMgaW4gcmV2ZXJzZSBvcmRlci5cbiAgLy8uXG4gIC8vLiBUaGlzIGlzIHRoZSBDIGNvbWJpbmF0b3IgZnJvbSBjb21iaW5hdG9yeSBsb2dpYy5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZmxpcChTLmNvbmNhdCwgJ2ZvbycsICdiYXInKVxuICAvLy4gJ2JhcmZvbydcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBmbGlwKGYsIHgsIHkpIHtcbiAgICByZXR1cm4gZih5KSh4KTtcbiAgfVxuICBTLmZsaXAgPSBkZWYoJ2ZsaXAnLCB7fSwgW0ZuKGEsIEZuKGIsIGMpKSwgYiwgYSwgY10sIGZsaXApO1xuXG4gIC8vLiAjIyMgQ29tcG9zaXRpb25cblxuICAvLyMgY29tcG9zZSA6OiBTZW1pZ3JvdXBvaWQgcyA9PiBzIGIgYyAtPiBzIGEgYiAtPiBzIGEgY1xuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFouY29tcG9zZWBdW10uXG4gIC8vLlxuICAvLy4gV2hlbiBzcGVjaWFsaXplZCB0byBGdW5jdGlvbiwgYGNvbXBvc2VgIGNvbXBvc2VzIHR3byB1bmFyeSBmdW5jdGlvbnMsXG4gIC8vLiBmcm9tIHJpZ2h0IHRvIGxlZnQgKHRoaXMgaXMgdGhlIEIgY29tYmluYXRvciBmcm9tIGNvbWJpbmF0b3J5IGxvZ2ljKS5cbiAgLy8uXG4gIC8vLiBUaGUgZ2VuZXJhbGl6ZWQgdHlwZSBzaWduYXR1cmUgaW5kaWNhdGVzIHRoYXQgYGNvbXBvc2VgIGlzIGNvbXBhdGlibGVcbiAgLy8uIHdpdGggYW55IFtTZW1pZ3JvdXBvaWRdW10uXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BwaXBlYF0oI3BpcGUpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5jb21wb3NlKE1hdGguc3FydCwgUy5hZGQoMSkpKDk5KVxuICAvLy4gMTBcbiAgLy8uIGBgYFxuICBTLmNvbXBvc2UgPVxuICBkZWYoJ2NvbXBvc2UnLFxuICAgICAge3M6IFtaLlNlbWlncm91cG9pZF19LFxuICAgICAgW3MoYiwgYyksIHMoYSwgYiksIHMoYSwgYyldLFxuICAgICAgWi5jb21wb3NlKTtcblxuICAvLyMgcGlwZSA6OiBbKGEgLT4gYiksIChiIC0+IGMpLCAuLi4sIChtIC0+IG4pXSAtPiBhIC0+IG5cbiAgLy8uXG4gIC8vLiBUYWtlcyBhbiBhcnJheSBvZiBmdW5jdGlvbnMgYXNzdW1lZCB0byBiZSB1bmFyeSBhbmQgYSB2YWx1ZSBvZiBhbnkgdHlwZSxcbiAgLy8uIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIHNlcXVlbmNlIG9mIHRyYW5zZm9ybWF0aW9ucyB0b1xuICAvLy4gdGhlIGluaXRpYWwgdmFsdWUuXG4gIC8vLlxuICAvLy4gSW4gZ2VuZXJhbCB0ZXJtcywgYHBpcGVgIHBlcmZvcm1zIGxlZnQtdG8tcmlnaHQgY29tcG9zaXRpb24gb2YgYW4gYXJyYXlcbiAgLy8uIG9mIGZ1bmN0aW9ucy4gYHBpcGUoW2YsIGcsIGhdLCB4KWAgaXMgZXF1aXZhbGVudCB0byBgaChnKGYoeCkpKWAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnBpcGUoW1MuYWRkKDEpLCBNYXRoLnNxcnQsIFMuc3ViKDEpXSwgOTkpXG4gIC8vLiA5XG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcGlwZShmcywgeCkge1xuICAgIHJldHVybiBaLnJlZHVjZShmdW5jdGlvbih4LCBmKSB7IHJldHVybiBmKHgpOyB9LCB4LCBmcyk7XG4gIH1cbiAgUy5waXBlID0gZGVmKCdwaXBlJywge30sIFskLkFycmF5KCQuQW55RnVuY3Rpb24pLCBhLCBiXSwgcGlwZSk7XG5cbiAgLy8jIG9uIDo6IChiIC0+IGIgLT4gYykgLT4gKGEgLT4gYikgLT4gYSAtPiBhIC0+IGNcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIGJpbmFyeSBmdW5jdGlvbiBgZmAsIGEgdW5hcnkgZnVuY3Rpb24gYGdgLCBhbmQgdHdvXG4gIC8vLiB2YWx1ZXMgYHhgIGFuZCBgeWAuIFJldHVybnMgYGYoZyh4KSkoZyh5KSlgLlxuICAvLy5cbiAgLy8uIFRoaXMgaXMgdGhlIFAgY29tYmluYXRvciBmcm9tIGNvbWJpbmF0b3J5IGxvZ2ljLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5vbihTLmNvbmNhdCwgUy5yZXZlcnNlLCBbMSwgMiwgM10sIFs0LCA1LCA2XSlcbiAgLy8uIFszLCAyLCAxLCA2LCA1LCA0XVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG9uKGYsIGcsIHgsIHkpIHtcbiAgICByZXR1cm4gZihnKHgpKShnKHkpKTtcbiAgfVxuICBTLm9uID0gZGVmKCdvbicsIHt9LCBbRm4oYiwgRm4oYiwgYykpLCBGbihhLCBiKSwgYSwgYSwgY10sIG9uKTtcblxuICAvLy4gIyMjIE1heWJlIHR5cGVcbiAgLy8uXG4gIC8vLiBUaGUgTWF5YmUgdHlwZSByZXByZXNlbnRzIG9wdGlvbmFsIHZhbHVlczogYSB2YWx1ZSBvZiB0eXBlIGBNYXliZSBhYCBpc1xuICAvLy4gZWl0aGVyIGEgSnVzdCB3aG9zZSB2YWx1ZSBpcyBvZiB0eXBlIGBhYCBvciBOb3RoaW5nICh3aXRoIG5vIHZhbHVlKS5cbiAgLy8uXG4gIC8vLiBUaGUgTWF5YmUgdHlwZSBzYXRpc2ZpZXMgdGhlIFtPcmRdW10sIFtNb25vaWRdW10sIFtNb25hZF1bXSxcbiAgLy8uIFtBbHRlcm5hdGl2ZV1bXSwgW1RyYXZlcnNhYmxlXVtdLCBhbmQgW0V4dGVuZF1bXSBzcGVjaWZpY2F0aW9ucy5cblxuICAvLyMgTWF5YmVUeXBlIDo6IFR5cGUgLT4gVHlwZVxuICAvLy5cbiAgLy8uIEEgW2BVbmFyeVR5cGVgXVtVbmFyeVR5cGVdIGZvciB1c2Ugd2l0aCBbc2FuY3R1YXJ5LWRlZl1bXS5cbiAgUy5NYXliZVR5cGUgPSAkTWF5YmU7XG5cbiAgLy8jIE1heWJlIDo6IFR5cGVSZXAgTWF5YmVcbiAgLy8uXG4gIC8vLiBUaGUgW3R5cGUgcmVwcmVzZW50YXRpdmVdKCN0eXBlLXJlcHJlc2VudGF0aXZlcykgZm9yIHRoZSBNYXliZSB0eXBlLlxuICB2YXIgTWF5YmUgPSBTLk1heWJlID0ge3Byb3RvdHlwZTogX01heWJlLnByb3RvdHlwZX07XG5cbiAgTWF5YmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWF5YmU7XG5cbiAgZnVuY3Rpb24gX01heWJlKHRhZywgdmFsdWUpIHtcbiAgICB0aGlzLmlzTm90aGluZyA9IHRhZyA9PT0gJ05vdGhpbmcnO1xuICAgIHRoaXMuaXNKdXN0ID0gdGFnID09PSAnSnVzdCc7XG4gICAgaWYgKHRoaXMuaXNKdXN0KSB0aGlzLnZhbHVlID0gdmFsdWU7XG5cbiAgICAvLyAgQWRkIFwiZmFudGFzeS1sYW5kL2NvbmNhdFwiIG1ldGhvZCBjb25kaXRpb25hbGx5IHNvIHRoYXQgSnVzdCgnYWJjJylcbiAgICAvLyAgc2F0aXNmaWVzIHRoZSByZXF1aXJlbWVudHMgb2YgU2VtaWdyb3VwIGJ1dCBKdXN0KDEyMykgZG9lcyBub3QuXG4gICAgaWYgKHRoaXMuaXNOb3RoaW5nIHx8IFouU2VtaWdyb3VwLnRlc3QodGhpcy52YWx1ZSkpIHtcbiAgICAgIHRoaXNbJ2ZhbnRhc3ktbGFuZC9jb25jYXQnXSA9IE1heWJlJHByb3RvdHlwZSRjb25jYXQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNOb3RoaW5nIHx8IFouU2V0b2lkLnRlc3QodGhpcy52YWx1ZSkpIHtcbiAgICAgIHRoaXNbJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnXSA9IE1heWJlJHByb3RvdHlwZSRlcXVhbHM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNOb3RoaW5nIHx8IFouT3JkLnRlc3QodGhpcy52YWx1ZSkpIHtcbiAgICAgIHRoaXNbJ2ZhbnRhc3ktbGFuZC9sdGUnXSA9IE1heWJlJHByb3RvdHlwZSRsdGU7XG4gICAgfVxuICB9XG5cbiAgLy8jIE5vdGhpbmcgOjogTWF5YmUgYVxuICAvLy5cbiAgLy8uIE5vdGhpbmcuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLk5vdGhpbmdcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICB2YXIgTm90aGluZyA9IFMuTm90aGluZyA9IG5ldyBfTWF5YmUoJ05vdGhpbmcnKTtcblxuICAvLyMgSnVzdCA6OiBhIC0+IE1heWJlIGFcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHZhbHVlIG9mIGFueSB0eXBlIGFuZCByZXR1cm5zIGEgSnVzdCB3aXRoIHRoZSBnaXZlbiB2YWx1ZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuSnVzdCg0MilcbiAgLy8uIEp1c3QoNDIpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gSnVzdCh4KSB7XG4gICAgcmV0dXJuIG5ldyBfTWF5YmUoJ0p1c3QnLCB4KTtcbiAgfVxuICBTLkp1c3QgPSBkZWYoJ0p1c3QnLCB7fSwgW2EsICRNYXliZShhKV0sIEp1c3QpO1xuXG4gIC8vIyBNYXliZS5AQHR5cGUgOjogU3RyaW5nXG4gIC8vLlxuICAvLy4gTWF5YmUgdHlwZSBpZGVudGlmaWVyLCBgJ3NhbmN0dWFyeS9NYXliZSdgLlxuICBNYXliZVsnQEB0eXBlJ10gPSBtYXliZVR5cGVJZGVudDtcblxuICAvLyMgTWF5YmUuZmFudGFzeS1sYW5kL2VtcHR5IDo6ICgpIC0+IE1heWJlIGFcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIE5vdGhpbmcuXG4gIC8vLlxuICAvLy4gSXQgaXMgaWRpb21hdGljIHRvIHVzZSBbYGVtcHR5YF0oI2VtcHR5KSByYXRoZXIgdGhhbiB1c2UgdGhpcyBmdW5jdGlvblxuICAvLy4gZGlyZWN0bHkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmVtcHR5KFMuTWF5YmUpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgTWF5YmVbJ2ZhbnRhc3ktbGFuZC9lbXB0eSddID0gZnVuY3Rpb24oKSB7IHJldHVybiBOb3RoaW5nOyB9O1xuXG4gIC8vIyBNYXliZS5mYW50YXN5LWxhbmQvb2YgOjogYSAtPiBNYXliZSBhXG4gIC8vLlxuICAvLy4gVGFrZXMgYSB2YWx1ZSBvZiBhbnkgdHlwZSBhbmQgcmV0dXJucyBhIEp1c3Qgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuXG4gIC8vLlxuICAvLy4gSXQgaXMgaWRpb21hdGljIHRvIHVzZSBbYG9mYF0oI29mKSByYXRoZXIgdGhhbiB1c2UgdGhpcyBmdW5jdGlvblxuICAvLy4gZGlyZWN0bHkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm9mKFMuTWF5YmUsIDQyKVxuICAvLy4gSnVzdCg0MilcbiAgLy8uIGBgYFxuICBNYXliZVsnZmFudGFzeS1sYW5kL29mJ10gPSBKdXN0O1xuXG4gIC8vIyBNYXliZS5mYW50YXN5LWxhbmQvemVybyA6OiAoKSAtPiBNYXliZSBhXG4gIC8vLlxuICAvLy4gUmV0dXJucyBOb3RoaW5nLlxuICAvLy5cbiAgLy8uIEl0IGlzIGlkaW9tYXRpYyB0byB1c2UgW2B6ZXJvYF0oI3plcm8pIHJhdGhlciB0aGFuIHVzZSB0aGlzIGZ1bmN0aW9uXG4gIC8vLiBkaXJlY3RseS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuemVybyhTLk1heWJlKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIE1heWJlWydmYW50YXN5LWxhbmQvemVybyddID0gZnVuY3Rpb24oKSB7IHJldHVybiBOb3RoaW5nOyB9O1xuXG4gIC8vIyBNYXliZSNpc05vdGhpbmcgOjogTWF5YmUgYSB+PiBCb29sZWFuXG4gIC8vLlxuICAvLy4gYHRydWVgIGlmIGB0aGlzYCBpcyBOb3RoaW5nOyBgZmFsc2VgIGlmIGB0aGlzYCBpcyBhIEp1c3QuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLk5vdGhpbmcuaXNOb3RoaW5nXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLkp1c3QoNDIpLmlzTm90aGluZ1xuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuXG4gIC8vIyBNYXliZSNpc0p1c3QgOjogTWF5YmUgYSB+PiBCb29sZWFuXG4gIC8vLlxuICAvLy4gYHRydWVgIGlmIGB0aGlzYCBpcyBhIEp1c3Q7IGBmYWxzZWAgaWYgYHRoaXNgIGlzIE5vdGhpbmcuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLkp1c3QoNDIpLmlzSnVzdFxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5Ob3RoaW5nLmlzSnVzdFxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuXG4gIC8vIyBNYXliZSN0b1N0cmluZyA6OiBNYXliZSBhIH4+ICgpIC0+IFN0cmluZ1xuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgTWF5YmUuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRvU3RyaW5nKFMuTm90aGluZylcbiAgLy8uICdOb3RoaW5nJ1xuICAvLy5cbiAgLy8uID4gUy50b1N0cmluZyhTLkp1c3QoWzEsIDIsIDNdKSlcbiAgLy8uICdKdXN0KFsxLCAyLCAzXSknXG4gIC8vLiBgYGBcbiAgTWF5YmUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNKdXN0ID8gJ0p1c3QoJyArIFoudG9TdHJpbmcodGhpcy52YWx1ZSkgKyAnKScgOiAnTm90aGluZyc7XG4gIH07XG5cbiAgLy8jIE1heWJlI2luc3BlY3QgOjogTWF5YmUgYSB+PiAoKSAtPiBTdHJpbmdcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIE1heWJlLiBUaGlzIG1ldGhvZCBpcyB1c2VkIGJ5XG4gIC8vLiBgdXRpbC5pbnNwZWN0YCBhbmQgdGhlIFJFUEwgdG8gZm9ybWF0IGEgTWF5YmUgZm9yIGRpc3BsYXkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BNYXliZSN0b1N0cmluZ2BdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLk5vdGhpbmcuaW5zcGVjdCgpXG4gIC8vLiAnTm90aGluZydcbiAgLy8uXG4gIC8vLiA+IFMuSnVzdChbMSwgMiwgM10pLmluc3BlY3QoKVxuICAvLy4gJ0p1c3QoWzEsIDIsIDNdKSdcbiAgLy8uIGBgYFxuICBNYXliZS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50b1N0cmluZygpOyB9O1xuXG4gIC8vIyBNYXliZSNmYW50YXN5LWxhbmQvZXF1YWxzIDo6IFNldG9pZCBhID0+IE1heWJlIGEgfj4gTWF5YmUgYSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gVGFrZXMgYSB2YWx1ZSBgbWAgb2YgdGhlIHNhbWUgdHlwZSBhbmQgcmV0dXJucyBgdHJ1ZWAgaWY6XG4gIC8vLlxuICAvLy4gICAtIGB0aGlzYCBhbmQgYG1gIGFyZSBib3RoIE5vdGhpbmc7IG9yXG4gIC8vLlxuICAvLy4gICAtIGB0aGlzYCBhbmQgYG1gIGFyZSBib3RoIEp1c3RzLCBhbmQgdGhlaXIgdmFsdWVzIGFyZSBlcXVhbCBhY2NvcmRpbmdcbiAgLy8uICAgICB0byBbYFouZXF1YWxzYF1bXS5cbiAgLy8uXG4gIC8vLiBJdCBpcyBpZGlvbWF0aWMgdG8gdXNlIFtgZXF1YWxzYF0oI2VxdWFscykgcmF0aGVyIHRoYW4gdXNlIHRoaXMgbWV0aG9kXG4gIC8vLiBkaXJlY3RseS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZXF1YWxzKFMuTm90aGluZywgUy5Ob3RoaW5nKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5lcXVhbHMoUy5KdXN0KFsxLCAyLCAzXSksIFMuSnVzdChbMSwgMiwgM10pKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5lcXVhbHMoUy5KdXN0KFsxLCAyLCAzXSksIFMuSnVzdChbMywgMiwgMV0pKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IFMuZXF1YWxzKFMuSnVzdChbMSwgMiwgM10pLCBTLk5vdGhpbmcpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIE1heWJlJHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5pc05vdGhpbmcgPyBvdGhlci5pc05vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiBvdGhlci5pc0p1c3QgJiYgWi5lcXVhbHModGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpO1xuICB9XG5cbiAgLy8jIE1heWJlI2ZhbnRhc3ktbGFuZC9sdGUgOjogT3JkIGEgPT4gTWF5YmUgYSB+PiBNYXliZSBhIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHZhbHVlIGBtYCBvZiB0aGUgc2FtZSB0eXBlIGFuZCByZXR1cm5zIGB0cnVlYCBpZjpcbiAgLy8uXG4gIC8vLiAgIC0gYHRoaXNgIGlzIE5vdGhpbmc7IG9yXG4gIC8vLlxuICAvLy4gICAtIGB0aGlzYCBhbmQgYG1gIGFyZSBib3RoIEp1c3RzIGFuZCB0aGUgdmFsdWUgb2YgYHRoaXNgIGlzIGxlc3MgdGhhblxuICAvLy4gICAgIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBgbWAgYWNjb3JkaW5nIHRvIFtgWi5sdGVgXVtdLlxuICAvLy5cbiAgLy8uIEl0IGlzIGlkaW9tYXRpYyB0byB1c2UgW2BsdGVgXSgjbHRlKSBvciBbYGx0ZV9gXSgjbHRlXykgcmF0aGVyIHRoYW4gdXNlXG4gIC8vLiB0aGlzIG1ldGhvZCBkaXJlY3RseS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubHRlXyhTLk5vdGhpbmcsIFMuTm90aGluZylcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMubHRlXyhTLk5vdGhpbmcsIFMuSnVzdCgwKSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMubHRlXyhTLkp1c3QoMCksIFMuTm90aGluZylcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBTLmx0ZV8oUy5KdXN0KDApLCBTLkp1c3QoMSkpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLmx0ZV8oUy5KdXN0KDEpLCBTLkp1c3QoMCkpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIE1heWJlJHByb3RvdHlwZSRsdGUob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5pc05vdGhpbmcgfHwgb3RoZXIuaXNKdXN0ICYmIFoubHRlKHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKTtcbiAgfVxuXG4gIC8vIyBNYXliZSNmYW50YXN5LWxhbmQvY29uY2F0IDo6IFNlbWlncm91cCBhID0+IE1heWJlIGEgfj4gTWF5YmUgYSAtPiBNYXliZSBhXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGNvbmNhdGVuYXRpbmcgdHdvIE1heWJlIHZhbHVlcyBvZiB0aGUgc2FtZSB0eXBlLlxuICAvLy4gYGFgIG11c3QgaGF2ZSBhIFtTZW1pZ3JvdXBdW10uXG4gIC8vLlxuICAvLy4gSWYgYHRoaXNgIGlzIE5vdGhpbmcgYW5kIHRoZSBhcmd1bWVudCBpcyBOb3RoaW5nLCB0aGlzIG1ldGhvZCByZXR1cm5zXG4gIC8vLiBOb3RoaW5nLlxuICAvLy5cbiAgLy8uIElmIGB0aGlzYCBpcyBhIEp1c3QgYW5kIHRoZSBhcmd1bWVudCBpcyBhIEp1c3QsIHRoaXMgbWV0aG9kIHJldHVybnMgYVxuICAvLy4gSnVzdCB3aG9zZSB2YWx1ZSBpcyB0aGUgcmVzdWx0IG9mIGNvbmNhdGVuYXRpbmcgdGhpcyBKdXN0J3MgdmFsdWUgYW5kXG4gIC8vLiB0aGUgZ2l2ZW4gSnVzdCdzIHZhbHVlLlxuICAvLy5cbiAgLy8uIE90aGVyd2lzZSwgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgSnVzdC5cbiAgLy8uXG4gIC8vLiBJdCBpcyBpZGlvbWF0aWMgdG8gdXNlIFtgY29uY2F0YF0oI2NvbmNhdCkgcmF0aGVyIHRoYW4gdXNlIHRoaXMgbWV0aG9kXG4gIC8vLiBkaXJlY3RseS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuY29uY2F0KFMuTm90aGluZywgUy5Ob3RoaW5nKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5jb25jYXQoUy5KdXN0KFsxLCAyLCAzXSksIFMuSnVzdChbNCwgNSwgNl0pKVxuICAvLy4gSnVzdChbMSwgMiwgMywgNCwgNSwgNl0pXG4gIC8vLlxuICAvLy4gPiBTLmNvbmNhdChTLk5vdGhpbmcsIFMuSnVzdChbMSwgMiwgM10pKVxuICAvLy4gSnVzdChbMSwgMiwgM10pXG4gIC8vLlxuICAvLy4gPiBTLmNvbmNhdChTLkp1c3QoWzEsIDIsIDNdKSwgUy5Ob3RoaW5nKVxuICAvLy4gSnVzdChbMSwgMiwgM10pXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTWF5YmUkcHJvdG90eXBlJGNvbmNhdChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmlzTm90aGluZyA/XG4gICAgICBvdGhlciA6XG4gICAgICBvdGhlci5pc05vdGhpbmcgPyB0aGlzIDogSnVzdChaLmNvbmNhdCh0aGlzLnZhbHVlLCBvdGhlci52YWx1ZSkpO1xuICB9XG5cbiAgLy8jIE1heWJlI2ZhbnRhc3ktbGFuZC9tYXAgOjogTWF5YmUgYSB+PiAoYSAtPiBiKSAtPiBNYXliZSBiXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBmdW5jdGlvbiBhbmQgcmV0dXJucyBgdGhpc2AgaWYgYHRoaXNgIGlzIE5vdGhpbmc7IG90aGVyd2lzZVxuICAvLy4gaXQgcmV0dXJucyBhIEp1c3Qgd2hvc2UgdmFsdWUgaXMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgZnVuY3Rpb25cbiAgLy8uIHRvIHRoaXMgSnVzdCdzIHZhbHVlLlxuICAvLy5cbiAgLy8uIEl0IGlzIGlkaW9tYXRpYyB0byB1c2UgW2BtYXBgXSgjbWFwKSByYXRoZXIgdGhhbiB1c2UgdGhpcyBtZXRob2RcbiAgLy8uIGRpcmVjdGx5LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5tYXAoTWF0aC5zcXJ0LCBTLk5vdGhpbmcpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLm1hcChNYXRoLnNxcnQsIFMuSnVzdCg5KSlcbiAgLy8uIEp1c3QoMylcbiAgLy8uIGBgYFxuICBNYXliZS5wcm90b3R5cGVbJ2ZhbnRhc3ktbGFuZC9tYXAnXSA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gdGhpcy5pc0p1c3QgPyBKdXN0KGYodGhpcy52YWx1ZSkpIDogdGhpcztcbiAgfTtcblxuICAvLyMgTWF5YmUjZmFudGFzeS1sYW5kL2FwIDo6IE1heWJlIGEgfj4gTWF5YmUgKGEgLT4gYikgLT4gTWF5YmUgYlxuICAvLy5cbiAgLy8uIFRha2VzIGEgTWF5YmUgYW5kIHJldHVybnMgTm90aGluZyB1bmxlc3MgYHRoaXNgIGlzIGEgSnVzdCAqYW5kKiB0aGVcbiAgLy8uIGFyZ3VtZW50IGlzIGEgSnVzdCwgaW4gd2hpY2ggY2FzZSBpdCByZXR1cm5zIGEgSnVzdCB3aG9zZSB2YWx1ZSBpc1xuICAvLy4gdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgZ2l2ZW4gSnVzdCdzIHZhbHVlIHRvIHRoaXMgSnVzdCdzIHZhbHVlLlxuICAvLy5cbiAgLy8uIEl0IGlzIGlkaW9tYXRpYyB0byB1c2UgW2BhcGBdKCNhcCkgcmF0aGVyIHRoYW4gdXNlIHRoaXMgbWV0aG9kIGRpcmVjdGx5LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5hcChTLk5vdGhpbmcsIFMuTm90aGluZylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMuYXAoUy5Ob3RoaW5nLCBTLkp1c3QoOSkpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLmFwKFMuSnVzdChNYXRoLnNxcnQpLCBTLk5vdGhpbmcpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLmFwKFMuSnVzdChNYXRoLnNxcnQpLCBTLkp1c3QoOSkpXG4gIC8vLiBKdXN0KDMpXG4gIC8vLiBgYGBcbiAgTWF5YmUucHJvdG90eXBlWydmYW50YXN5LWxhbmQvYXAnXSA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLmlzSnVzdCA/IFoubWFwKG90aGVyLnZhbHVlLCB0aGlzKSA6IG90aGVyO1xuICB9O1xuXG4gIC8vIyBNYXliZSNmYW50YXN5LWxhbmQvY2hhaW4gOjogTWF5YmUgYSB+PiAoYSAtPiBNYXliZSBiKSAtPiBNYXliZSBiXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBmdW5jdGlvbiBhbmQgcmV0dXJucyBgdGhpc2AgaWYgYHRoaXNgIGlzIE5vdGhpbmc7IG90aGVyd2lzZVxuICAvLy4gaXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBmdW5jdGlvbiB0byB0aGlzIEp1c3QncyB2YWx1ZS5cbiAgLy8uXG4gIC8vLiBJdCBpcyBpZGlvbWF0aWMgdG8gdXNlIFtgY2hhaW5gXSgjY2hhaW4pIHJhdGhlciB0aGFuIHVzZSB0aGlzIG1ldGhvZFxuICAvLy4gZGlyZWN0bHkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmNoYWluKFMucGFyc2VGbG9hdCwgUy5Ob3RoaW5nKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5jaGFpbihTLnBhcnNlRmxvYXQsIFMuSnVzdCgneHh4JykpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLmNoYWluKFMucGFyc2VGbG9hdCwgUy5KdXN0KCcxMi4zNCcpKVxuICAvLy4gSnVzdCgxMi4zNClcbiAgLy8uIGBgYFxuICBNYXliZS5wcm90b3R5cGVbJ2ZhbnRhc3ktbGFuZC9jaGFpbiddID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB0aGlzLmlzSnVzdCA/IGYodGhpcy52YWx1ZSkgOiB0aGlzO1xuICB9O1xuXG4gIC8vIyBNYXliZSNmYW50YXN5LWxhbmQvYWx0IDo6IE1heWJlIGEgfj4gTWF5YmUgYSAtPiBNYXliZSBhXG4gIC8vLlxuICAvLy4gQ2hvb3NlcyBiZXR3ZWVuIGB0aGlzYCBhbmQgdGhlIG90aGVyIE1heWJlIHByb3ZpZGVkIGFzIGFuIGFyZ3VtZW50LlxuICAvLy4gUmV0dXJucyBgdGhpc2AgaWYgYHRoaXNgIGlzIGEgSnVzdDsgdGhlIG90aGVyIE1heWJlIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBJdCBpcyBpZGlvbWF0aWMgdG8gdXNlIFtgYWx0YF0oI2FsdCkgcmF0aGVyIHRoYW4gdXNlIHRoaXMgbWV0aG9kXG4gIC8vLiBkaXJlY3RseS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYWx0KFMuTm90aGluZywgUy5Ob3RoaW5nKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5hbHQoUy5Ob3RoaW5nLCBTLkp1c3QoMSkpXG4gIC8vLiBKdXN0KDEpXG4gIC8vLlxuICAvLy4gPiBTLmFsdChTLkp1c3QoMiksIFMuTm90aGluZylcbiAgLy8uIEp1c3QoMilcbiAgLy8uXG4gIC8vLiA+IFMuYWx0KFMuSnVzdCgzKSwgUy5KdXN0KDQpKVxuICAvLy4gSnVzdCgzKVxuICAvLy4gYGBgXG4gIE1heWJlLnByb3RvdHlwZVsnZmFudGFzeS1sYW5kL2FsdCddID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5pc0p1c3QgPyB0aGlzIDogb3RoZXI7XG4gIH07XG5cbiAgLy8jIE1heWJlI2ZhbnRhc3ktbGFuZC9yZWR1Y2UgOjogTWF5YmUgYSB+PiAoKGIsIGEpIC0+IGIsIGIpIC0+IGJcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIGZ1bmN0aW9uIGFuZCBhbiBpbml0aWFsIHZhbHVlIG9mIGFueSB0eXBlLCBhbmQgcmV0dXJuczpcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIGluaXRpYWwgdmFsdWUgaWYgYHRoaXNgIGlzIE5vdGhpbmc7IG90aGVyd2lzZVxuICAvLy5cbiAgLy8uICAgLSB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBmdW5jdGlvbiB0byB0aGUgaW5pdGlhbCB2YWx1ZSBhbmQgdGhpc1xuICAvLy4gICAgIEp1c3QncyB2YWx1ZS5cbiAgLy8uXG4gIC8vLiBJdCBpcyBpZGlvbWF0aWMgdG8gdXNlIFtgcmVkdWNlYF0oI3JlZHVjZSkgcmF0aGVyIHRoYW4gdXNlIHRoaXMgbWV0aG9kXG4gIC8vLiBkaXJlY3RseS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucmVkdWNlKFMuY3VycnkyKE1hdGgucG93KSwgMTAsIFMuTm90aGluZylcbiAgLy8uIDEwXG4gIC8vLlxuICAvLy4gPiBTLnJlZHVjZShTLmN1cnJ5MihNYXRoLnBvdyksIDEwLCBTLkp1c3QoMykpXG4gIC8vLiAxMDAwXG4gIC8vLiBgYGBcbiAgTWF5YmUucHJvdG90eXBlWydmYW50YXN5LWxhbmQvcmVkdWNlJ10gPSBmdW5jdGlvbihmLCB4KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNKdXN0ID8gZih4LCB0aGlzLnZhbHVlKSA6IHg7XG4gIH07XG5cbiAgLy8jIE1heWJlI2ZhbnRhc3ktbGFuZC90cmF2ZXJzZSA6OiBBcHBsaWNhdGl2ZSBmID0+IE1heWJlIGEgfj4gKFR5cGVSZXAgZiwgYSAtPiBmIGIpIC0+IGYgKE1heWJlIGIpXG4gIC8vLlxuICAvLy4gVGFrZXMgdGhlIHR5cGUgcmVwcmVzZW50YXRpdmUgb2Ygc29tZSBbQXBwbGljYXRpdmVdW10gYW5kIGEgZnVuY3Rpb25cbiAgLy8uIHdoaWNoIHJldHVybnMgYSB2YWx1ZSBvZiB0aGF0IEFwcGxpY2F0aXZlLCBhbmQgcmV0dXJuczpcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgdHlwZSByZXByZXNlbnRhdGl2ZSdzIFtgb2ZgXVtdIGZ1bmN0aW9uIHRvXG4gIC8vLiAgICAgYHRoaXNgIGlmIGB0aGlzYCBpcyBOb3RoaW5nOyBvdGhlcndpc2VcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIHJlc3VsdCBvZiBtYXBwaW5nIFtgSnVzdGBdKCNKdXN0KSBvdmVyIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlXG4gIC8vLiAgICAgZmlyc3QgZnVuY3Rpb24gdG8gdGhpcyBKdXN0J3MgdmFsdWUuXG4gIC8vLlxuICAvLy4gSXQgaXMgaWRpb21hdGljIHRvIHVzZSBbYHRyYXZlcnNlYF0oI3RyYXZlcnNlKSByYXRoZXIgdGhhbiB1c2UgdGhpc1xuICAvLy4gbWV0aG9kIGRpcmVjdGx5LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy50cmF2ZXJzZShBcnJheSwgUy53b3JkcywgUy5Ob3RoaW5nKVxuICAvLy4gW05vdGhpbmddXG4gIC8vLlxuICAvLy4gPiBTLnRyYXZlcnNlKEFycmF5LCBTLndvcmRzLCBTLkp1c3QoJ2ZvbyBiYXIgYmF6JykpXG4gIC8vLiBbSnVzdCgnZm9vJyksIEp1c3QoJ2JhcicpLCBKdXN0KCdiYXonKV1cbiAgLy8uIGBgYFxuICBNYXliZS5wcm90b3R5cGVbJ2ZhbnRhc3ktbGFuZC90cmF2ZXJzZSddID0gZnVuY3Rpb24odHlwZVJlcCwgZikge1xuICAgIHJldHVybiB0aGlzLmlzSnVzdCA/IFoubWFwKEp1c3QsIGYodGhpcy52YWx1ZSkpIDogWi5vZih0eXBlUmVwLCB0aGlzKTtcbiAgfTtcblxuICAvLyMgTWF5YmUjZmFudGFzeS1sYW5kL2V4dGVuZCA6OiBNYXliZSBhIH4+IChNYXliZSBhIC0+IGIpIC0+IE1heWJlIGJcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGB0aGlzYCBpZiBgdGhpc2AgaXMgTm90aGluZzsgb3RoZXJ3aXNlXG4gIC8vLiBpdCByZXR1cm5zIGEgSnVzdCB3aG9zZSB2YWx1ZSBpcyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBmdW5jdGlvblxuICAvLy4gdG8gYHRoaXNgLlxuICAvLy5cbiAgLy8uIEl0IGlzIGlkaW9tYXRpYyB0byB1c2UgW2BleHRlbmRgXSgjZXh0ZW5kKSByYXRoZXIgdGhhbiB1c2UgdGhpcyBtZXRob2RcbiAgLy8uIGRpcmVjdGx5LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5leHRlbmQoeCA9PiB4LnZhbHVlICsgMSwgUy5Ob3RoaW5nKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5leHRlbmQoeCA9PiB4LnZhbHVlICsgMSwgUy5KdXN0KDQyKSlcbiAgLy8uIEp1c3QoNDMpXG4gIC8vLiBgYGBcbiAgTWF5YmUucHJvdG90eXBlWydmYW50YXN5LWxhbmQvZXh0ZW5kJ10gPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNKdXN0ID8gSnVzdChmKHRoaXMpKSA6IHRoaXM7XG4gIH07XG5cbiAgLy8jIGlzTm90aGluZyA6OiBNYXliZSBhIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gTWF5YmUgaXMgTm90aGluZzsgYGZhbHNlYCBpZiBpdCBpcyBhIEp1c3QuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmlzTm90aGluZyhTLk5vdGhpbmcpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLmlzTm90aGluZyhTLkp1c3QoNDIpKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBpc05vdGhpbmcobWF5YmUpIHtcbiAgICByZXR1cm4gbWF5YmUuaXNOb3RoaW5nO1xuICB9XG4gIFMuaXNOb3RoaW5nID0gZGVmKCdpc05vdGhpbmcnLCB7fSwgWyRNYXliZShhKSwgJC5Cb29sZWFuXSwgaXNOb3RoaW5nKTtcblxuICAvLyMgaXNKdXN0IDo6IE1heWJlIGEgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBNYXliZSBpcyBhIEp1c3Q7IGBmYWxzZWAgaWYgaXQgaXMgTm90aGluZy5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuaXNKdXN0KFMuSnVzdCg0MikpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLmlzSnVzdChTLk5vdGhpbmcpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGlzSnVzdChtYXliZSkge1xuICAgIHJldHVybiBtYXliZS5pc0p1c3Q7XG4gIH1cbiAgUy5pc0p1c3QgPSBkZWYoJ2lzSnVzdCcsIHt9LCBbJE1heWJlKGEpLCAkLkJvb2xlYW5dLCBpc0p1c3QpO1xuXG4gIC8vIyBmcm9tTWF5YmUgOjogYSAtPiBNYXliZSBhIC0+IGFcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIGRlZmF1bHQgdmFsdWUgYW5kIGEgTWF5YmUsIGFuZCByZXR1cm5zIHRoZSBNYXliZSdzIHZhbHVlXG4gIC8vLiBpZiB0aGUgTWF5YmUgaXMgYSBKdXN0OyB0aGUgZGVmYXVsdCB2YWx1ZSBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2Bmcm9tTWF5YmVfYF0oI2Zyb21NYXliZV8pIGFuZFxuICAvLy4gW2BtYXliZVRvTnVsbGFibGVgXSgjbWF5YmVUb051bGxhYmxlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZnJvbU1heWJlKDAsIFMuSnVzdCg0MikpXG4gIC8vLiA0MlxuICAvLy5cbiAgLy8uID4gUy5mcm9tTWF5YmUoMCwgUy5Ob3RoaW5nKVxuICAvLy4gMFxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGZyb21NYXliZSh4LCBtYXliZSkge1xuICAgIHJldHVybiBtYXliZS5pc0p1c3QgPyBtYXliZS52YWx1ZSA6IHg7XG4gIH1cbiAgUy5mcm9tTWF5YmUgPSBkZWYoJ2Zyb21NYXliZScsIHt9LCBbYSwgJE1heWJlKGEpLCBhXSwgZnJvbU1heWJlKTtcblxuICAvLyMgZnJvbU1heWJlXyA6OiAoKCkgLT4gYSkgLT4gTWF5YmUgYSAtPiBhXG4gIC8vLlxuICAvLy4gVmFyaWFudCBvZiBbYGZyb21NYXliZWBdKCNmcm9tTWF5YmUpIHdoaWNoIHRha2VzIGEgdGh1bmsgc28gdGhlIGRlZmF1bHRcbiAgLy8uIHZhbHVlIGlzIG9ubHkgY29tcHV0ZWQgaWYgcmVxdWlyZWQuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBmdW5jdGlvbiBmaWIobikgeyByZXR1cm4gbiA8PSAxID8gbiA6IGZpYihuIC0gMikgKyBmaWIobiAtIDEpOyB9XG4gIC8vLlxuICAvLy4gPiBTLmZyb21NYXliZV8oKCkgPT4gZmliKDMwKSwgUy5KdXN0KDEwMDAwMDApKVxuICAvLy4gMTAwMDAwMFxuICAvLy5cbiAgLy8uID4gUy5mcm9tTWF5YmVfKCgpID0+IGZpYigzMCksIFMuTm90aGluZylcbiAgLy8uIDgzMjA0MFxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGZyb21NYXliZV8odGh1bmssIG1heWJlKSB7XG4gICAgcmV0dXJuIG1heWJlLmlzSnVzdCA/IG1heWJlLnZhbHVlIDogdGh1bmsoKTtcbiAgfVxuICBTLmZyb21NYXliZV8gPSBkZWYoJ2Zyb21NYXliZV8nLCB7fSwgWyQuVGh1bmsoYSksICRNYXliZShhKSwgYV0sIGZyb21NYXliZV8pO1xuXG4gIC8vIyBtYXliZVRvTnVsbGFibGUgOjogTWF5YmUgYSAtPiBOdWxsYWJsZSBhXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgZ2l2ZW4gTWF5YmUncyB2YWx1ZSBpZiB0aGUgTWF5YmUgaXMgYSBKdXN0OyBgbnVsbGAgb3RoZXJ3aXNlLlxuICAvLy4gW051bGxhYmxlXVtdIGlzIGRlZmluZWQgaW4gW3NhbmN0dWFyeS1kZWZdW10uXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2Bmcm9tTWF5YmVgXSgjZnJvbU1heWJlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWF5YmVUb051bGxhYmxlKFMuSnVzdCg0MikpXG4gIC8vLiA0MlxuICAvLy5cbiAgLy8uID4gUy5tYXliZVRvTnVsbGFibGUoUy5Ob3RoaW5nKVxuICAvLy4gbnVsbFxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG1heWJlVG9OdWxsYWJsZShtYXliZSkge1xuICAgIHJldHVybiBtYXliZS5pc0p1c3QgPyBtYXliZS52YWx1ZSA6IG51bGw7XG4gIH1cbiAgUy5tYXliZVRvTnVsbGFibGUgPVxuICBkZWYoJ21heWJlVG9OdWxsYWJsZScsIHt9LCBbJE1heWJlKGEpLCAkLk51bGxhYmxlKGEpXSwgbWF5YmVUb051bGxhYmxlKTtcblxuICAvLyMgdG9NYXliZSA6OiBhPyAtPiBNYXliZSBhXG4gIC8vLlxuICAvLy4gVGFrZXMgYSB2YWx1ZSBhbmQgcmV0dXJucyBOb3RoaW5nIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGA7XG4gIC8vLiBKdXN0IHRoZSB2YWx1ZSBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRvTWF5YmUobnVsbClcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMudG9NYXliZSg0MilcbiAgLy8uIEp1c3QoNDIpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gdG9NYXliZSh4KSB7XG4gICAgcmV0dXJuIHggPT0gbnVsbCA/IE5vdGhpbmcgOiBKdXN0KHgpO1xuICB9XG4gIFMudG9NYXliZSA9IGRlZigndG9NYXliZScsIHt9LCBbYSwgJE1heWJlKGEpXSwgdG9NYXliZSk7XG5cbiAgLy8jIG1heWJlIDo6IGIgLT4gKGEgLT4gYikgLT4gTWF5YmUgYSAtPiBiXG4gIC8vLlxuICAvLy4gVGFrZXMgYSB2YWx1ZSBvZiBhbnkgdHlwZSwgYSBmdW5jdGlvbiwgYW5kIGEgTWF5YmUuIElmIHRoZSBNYXliZSBpc1xuICAvLy4gYSBKdXN0LCB0aGUgcmV0dXJuIHZhbHVlIGlzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGZ1bmN0aW9uIHRvXG4gIC8vLiB0aGUgSnVzdCdzIHZhbHVlLiBPdGhlcndpc2UsIHRoZSBmaXJzdCBhcmd1bWVudCBpcyByZXR1cm5lZC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYG1heWJlX2BdKCNtYXliZV8pLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5tYXliZSgwLCBTLnByb3AoJ2xlbmd0aCcpLCBTLkp1c3QoJ3JlZnVnZScpKVxuICAvLy4gNlxuICAvLy5cbiAgLy8uID4gUy5tYXliZSgwLCBTLnByb3AoJ2xlbmd0aCcpLCBTLk5vdGhpbmcpXG4gIC8vLiAwXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbWF5YmUoeCwgZiwgbWF5YmUpIHtcbiAgICByZXR1cm4gZnJvbU1heWJlKHgsIFoubWFwKGYsIG1heWJlKSk7XG4gIH1cbiAgUy5tYXliZSA9IGRlZignbWF5YmUnLCB7fSwgW2IsIEZuKGEsIGIpLCAkTWF5YmUoYSksIGJdLCBtYXliZSk7XG5cbiAgLy8jIG1heWJlXyA6OiAoKCkgLT4gYikgLT4gKGEgLT4gYikgLT4gTWF5YmUgYSAtPiBiXG4gIC8vLlxuICAvLy4gVmFyaWFudCBvZiBbYG1heWJlYF0oI21heWJlKSB3aGljaCB0YWtlcyBhIHRodW5rIHNvIHRoZSBkZWZhdWx0IHZhbHVlXG4gIC8vLiBpcyBvbmx5IGNvbXB1dGVkIGlmIHJlcXVpcmVkLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZnVuY3Rpb24gZmliKG4pIHsgcmV0dXJuIG4gPD0gMSA/IG4gOiBmaWIobiAtIDIpICsgZmliKG4gLSAxKTsgfVxuICAvLy5cbiAgLy8uID4gUy5tYXliZV8oKCkgPT4gZmliKDMwKSwgTWF0aC5zcXJ0LCBTLkp1c3QoMTAwMDAwMCkpXG4gIC8vLiAxMDAwXG4gIC8vLlxuICAvLy4gPiBTLm1heWJlXygoKSA9PiBmaWIoMzApLCBNYXRoLnNxcnQsIFMuTm90aGluZylcbiAgLy8uIDgzMjA0MFxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG1heWJlXyh0aHVuaywgZiwgbWF5YmUpIHtcbiAgICByZXR1cm4gbWF5YmUuaXNKdXN0ID8gZihtYXliZS52YWx1ZSkgOiB0aHVuaygpO1xuICB9XG4gIFMubWF5YmVfID0gZGVmKCdtYXliZV8nLCB7fSwgWyQuVGh1bmsoYiksIEZuKGEsIGIpLCAkTWF5YmUoYSksIGJdLCBtYXliZV8pO1xuXG4gIC8vIyBqdXN0cyA6OiBBcnJheSAoTWF5YmUgYSkgLT4gQXJyYXkgYVxuICAvLy5cbiAgLy8uIFRha2VzIGFuIGFycmF5IG9mIE1heWJlcyBhbmQgcmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGVhY2ggSnVzdCdzXG4gIC8vLiB2YWx1ZS4gRXF1aXZhbGVudCB0byBIYXNrZWxsJ3MgYGNhdE1heWJlc2AgZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BsZWZ0c2BdKCNsZWZ0cykgYW5kIFtgcmlnaHRzYF0oI3JpZ2h0cykuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmp1c3RzKFtTLkp1c3QoJ2ZvbycpLCBTLk5vdGhpbmcsIFMuSnVzdCgnYmF6JyldKVxuICAvLy4gWydmb28nLCAnYmF6J11cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBqdXN0cyhtYXliZXMpIHtcbiAgICByZXR1cm4gWi5yZWR1Y2UoZnVuY3Rpb24oeHMsIG1heWJlKSB7XG4gICAgICBpZiAobWF5YmUuaXNKdXN0KSB4cy5wdXNoKG1heWJlLnZhbHVlKTtcbiAgICAgIHJldHVybiB4cztcbiAgICB9LCBbXSwgbWF5YmVzKTtcbiAgfVxuICBTLmp1c3RzID0gZGVmKCdqdXN0cycsIHt9LCBbJC5BcnJheSgkTWF5YmUoYSkpLCAkLkFycmF5KGEpXSwganVzdHMpO1xuXG4gIC8vIyBtYXBNYXliZSA6OiAoYSAtPiBNYXliZSBiKSAtPiBBcnJheSBhIC0+IEFycmF5IGJcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIGZ1bmN0aW9uIGFuZCBhbiBhcnJheSwgYXBwbGllcyB0aGUgZnVuY3Rpb24gdG8gZWFjaCBlbGVtZW50IG9mXG4gIC8vLiB0aGUgYXJyYXksIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIFwic3VjY2Vzc2Z1bFwiIHJlc3VsdHMuIElmIHRoZSByZXN1bHQgb2ZcbiAgLy8uIGFwcGx5aW5nIHRoZSBmdW5jdGlvbiB0byBhbiBlbGVtZW50IG9mIHRoZSBhcnJheSBpcyBOb3RoaW5nLCB0aGUgcmVzdWx0XG4gIC8vLiBpcyBkaXNjYXJkZWQ7IGlmIHRoZSByZXN1bHQgaXMgYSBKdXN0LCB0aGUgSnVzdCdzIHZhbHVlIGlzIGluY2x1ZGVkIGluXG4gIC8vLiB0aGUgb3V0cHV0IGFycmF5LlxuICAvLy5cbiAgLy8uIEluIGdlbmVyYWwgdGVybXMsIGBtYXBNYXliZWAgZmlsdGVycyBhbiBhcnJheSB3aGlsZSBtYXBwaW5nIG92ZXIgaXQuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1hcE1heWJlKFMuaGVhZCwgW1tdLCBbMSwgMiwgM10sIFtdLCBbNCwgNSwgNl0sIFtdXSlcbiAgLy8uIFsxLCA0XVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG1hcE1heWJlKGYsIHhzKSB7XG4gICAgcmV0dXJuIGp1c3RzKFoubWFwKGYsIHhzKSk7XG4gIH1cbiAgUy5tYXBNYXliZSA9XG4gIGRlZignbWFwTWF5YmUnLCB7fSwgW0ZuKGEsICRNYXliZShiKSksICQuQXJyYXkoYSksICQuQXJyYXkoYildLCBtYXBNYXliZSk7XG5cbiAgLy8jIGVuY2FzZSA6OiAoYSAtPiBiKSAtPiBhIC0+IE1heWJlIGJcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHVuYXJ5IGZ1bmN0aW9uIGBmYCB3aGljaCBtYXkgdGhyb3cgYW5kIGEgdmFsdWUgYHhgIG9mIGFueSB0eXBlLFxuICAvLy4gYW5kIGFwcGxpZXMgYGZgIHRvIGB4YCBpbnNpZGUgYSBgdHJ5YCBibG9jay4gSWYgYW4gZXhjZXB0aW9uIGlzIGNhdWdodCxcbiAgLy8uIHRoZSByZXR1cm4gdmFsdWUgaXMgTm90aGluZzsgb3RoZXJ3aXNlIHRoZSByZXR1cm4gdmFsdWUgaXMgSnVzdCB0aGVcbiAgLy8uIHJlc3VsdCBvZiBhcHBseWluZyBgZmAgdG8gYHhgLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZW5jYXNlRWl0aGVyYF0oI2VuY2FzZUVpdGhlcikuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmVuY2FzZShldmFsLCAnMSArIDEnKVxuICAvLy4gSnVzdCgyKVxuICAvLy5cbiAgLy8uID4gUy5lbmNhc2UoZXZhbCwgJzEgKycpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZW5jYXNlKGYsIHgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEp1c3QoZih4KSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gTm90aGluZztcbiAgICB9XG4gIH1cbiAgUy5lbmNhc2UgPSBkZWYoJ2VuY2FzZScsIHt9LCBbRm4oYSwgYiksIGEsICRNYXliZShiKV0sIGVuY2FzZSk7XG5cbiAgLy8jIGVuY2FzZTIgOjogKGEgLT4gYiAtPiBjKSAtPiBhIC0+IGIgLT4gTWF5YmUgY1xuICAvLy5cbiAgLy8uIEJpbmFyeSB2ZXJzaW9uIG9mIFtgZW5jYXNlYF0oI2VuY2FzZSkuXG4gIGZ1bmN0aW9uIGVuY2FzZTIoZiwgeCwgeSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSnVzdChmKHgpKHkpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBOb3RoaW5nO1xuICAgIH1cbiAgfVxuICBTLmVuY2FzZTIgPSBkZWYoJ2VuY2FzZTInLCB7fSwgW0ZuKGEsIEZuKGIsIGMpKSwgYSwgYiwgJE1heWJlKGMpXSwgZW5jYXNlMik7XG5cbiAgLy8jIGVuY2FzZTMgOjogKGEgLT4gYiAtPiBjIC0+IGQpIC0+IGEgLT4gYiAtPiBjIC0+IE1heWJlIGRcbiAgLy8uXG4gIC8vLiBUZXJuYXJ5IHZlcnNpb24gb2YgW2BlbmNhc2VgXSgjZW5jYXNlKS5cbiAgZnVuY3Rpb24gZW5jYXNlMyhmLCB4LCB5LCB6KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKdXN0KGYoeCkoeSkoeikpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIE5vdGhpbmc7XG4gICAgfVxuICB9XG4gIFMuZW5jYXNlMyA9XG4gIGRlZignZW5jYXNlMycsIHt9LCBbRm4oYSwgRm4oYiwgRm4oYywgZCkpKSwgYSwgYiwgYywgJE1heWJlKGQpXSwgZW5jYXNlMyk7XG5cbiAgLy8jIG1heWJlVG9FaXRoZXIgOjogYSAtPiBNYXliZSBiIC0+IEVpdGhlciBhIGJcbiAgLy8uXG4gIC8vLiBDb252ZXJ0cyBhIE1heWJlIHRvIGFuIEVpdGhlci4gTm90aGluZyBiZWNvbWVzIGEgTGVmdCAoY29udGFpbmluZyB0aGVcbiAgLy8uIGZpcnN0IGFyZ3VtZW50KTsgYSBKdXN0IGJlY29tZXMgYSBSaWdodC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGVpdGhlclRvTWF5YmVgXSgjZWl0aGVyVG9NYXliZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1heWJlVG9FaXRoZXIoJ0V4cGVjdGluZyBhbiBpbnRlZ2VyJywgUy5wYXJzZUludCgxMCwgJ3h5eicpKVxuICAvLy4gTGVmdCgnRXhwZWN0aW5nIGFuIGludGVnZXInKVxuICAvLy5cbiAgLy8uID4gUy5tYXliZVRvRWl0aGVyKCdFeHBlY3RpbmcgYW4gaW50ZWdlcicsIFMucGFyc2VJbnQoMTAsICc0MicpKVxuICAvLy4gUmlnaHQoNDIpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbWF5YmVUb0VpdGhlcih4LCBtYXliZSkge1xuICAgIHJldHVybiBtYXliZS5pc05vdGhpbmcgPyBMZWZ0KHgpIDogUmlnaHQobWF5YmUudmFsdWUpO1xuICB9XG4gIFMubWF5YmVUb0VpdGhlciA9XG4gIGRlZignbWF5YmVUb0VpdGhlcicsIHt9LCBbYSwgJE1heWJlKGIpLCAkRWl0aGVyKGEsIGIpXSwgbWF5YmVUb0VpdGhlcik7XG5cbiAgLy8uICMjIyBFaXRoZXIgdHlwZVxuICAvLy5cbiAgLy8uIFRoZSBFaXRoZXIgdHlwZSByZXByZXNlbnRzIHZhbHVlcyB3aXRoIHR3byBwb3NzaWJpbGl0aWVzOiBhIHZhbHVlIG9mIHR5cGVcbiAgLy8uIGBFaXRoZXIgYSBiYCBpcyBlaXRoZXIgYSBMZWZ0IHdob3NlIHZhbHVlIGlzIG9mIHR5cGUgYGFgIG9yIGEgUmlnaHQgd2hvc2VcbiAgLy8uIHZhbHVlIGlzIG9mIHR5cGUgYGJgLlxuICAvLy5cbiAgLy8uIFRoZSBFaXRoZXIgdHlwZSBzYXRpc2ZpZXMgdGhlIFtPcmRdW10sIFtTZW1pZ3JvdXBdW10sIFtNb25hZF1bXSxcbiAgLy8uIFtBbHRdW10sIFtUcmF2ZXJzYWJsZV1bXSwgW0V4dGVuZF1bXSwgYW5kIFtCaWZ1bmN0b3JdW10gc3BlY2lmaWNhdGlvbnMuXG5cbiAgLy8jIEVpdGhlclR5cGUgOjogVHlwZSAtPiBUeXBlIC0+IFR5cGVcbiAgLy8uXG4gIC8vLiBBIFtgQmluYXJ5VHlwZWBdW0JpbmFyeVR5cGVdIGZvciB1c2Ugd2l0aCBbc2FuY3R1YXJ5LWRlZl1bXS5cbiAgUy5FaXRoZXJUeXBlID0gJEVpdGhlcjtcblxuICAvLyMgRWl0aGVyIDo6IFR5cGVSZXAgRWl0aGVyXG4gIC8vLlxuICAvLy4gVGhlIFt0eXBlIHJlcHJlc2VudGF0aXZlXSgjdHlwZS1yZXByZXNlbnRhdGl2ZXMpIGZvciB0aGUgRWl0aGVyIHR5cGUuXG4gIHZhciBFaXRoZXIgPSBTLkVpdGhlciA9IHtwcm90b3R5cGU6IF9FaXRoZXIucHJvdG90eXBlfTtcblxuICBFaXRoZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRWl0aGVyO1xuXG4gIGZ1bmN0aW9uIF9FaXRoZXIodGFnLCB2YWx1ZSkge1xuICAgIHRoaXMuaXNMZWZ0ID0gdGFnID09PSAnTGVmdCc7XG4gICAgdGhpcy5pc1JpZ2h0ID0gdGFnID09PSAnUmlnaHQnO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICAgIC8vICBBZGQgXCJmYW50YXN5LWxhbmQvY29uY2F0XCIgbWV0aG9kIGNvbmRpdGlvbmFsbHkgc28gdGhhdCBMZWZ0KCdhYmMnKVxuICAgIC8vICBhbmQgUmlnaHQoJ2FiYycpIHNhdGlzZnkgdGhlIHJlcXVpcmVtZW50cyBvZiBTZW1pZ3JvdXAgYnV0IExlZnQoMTIzKVxuICAgIC8vICBhbmQgUmlnaHQoMTIzKSBkbyBub3QuXG4gICAgaWYgKFouU2VtaWdyb3VwLnRlc3QodGhpcy52YWx1ZSkpIHtcbiAgICAgIHRoaXNbJ2ZhbnRhc3ktbGFuZC9jb25jYXQnXSA9IEVpdGhlciRwcm90b3R5cGUkY29uY2F0O1xuICAgIH1cblxuICAgIGlmIChaLlNldG9pZC50ZXN0KHRoaXMudmFsdWUpKSB7XG4gICAgICB0aGlzWydmYW50YXN5LWxhbmQvZXF1YWxzJ10gPSBFaXRoZXIkcHJvdG90eXBlJGVxdWFscztcbiAgICB9XG5cbiAgICBpZiAoWi5PcmQudGVzdCh0aGlzLnZhbHVlKSkge1xuICAgICAgdGhpc1snZmFudGFzeS1sYW5kL2x0ZSddID0gRWl0aGVyJHByb3RvdHlwZSRsdGU7XG4gICAgfVxuICB9XG5cbiAgLy8jIExlZnQgOjogYSAtPiBFaXRoZXIgYSBiXG4gIC8vLlxuICAvLy4gVGFrZXMgYSB2YWx1ZSBvZiBhbnkgdHlwZSBhbmQgcmV0dXJucyBhIExlZnQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLkxlZnQoJ0Nhbm5vdCBkaXZpZGUgYnkgemVybycpXG4gIC8vLiBMZWZ0KCdDYW5ub3QgZGl2aWRlIGJ5IHplcm8nKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIExlZnQoeCkge1xuICAgIHJldHVybiBuZXcgX0VpdGhlcignTGVmdCcsIHgpO1xuICB9XG4gIFMuTGVmdCA9IGRlZignTGVmdCcsIHt9LCBbYSwgJEVpdGhlcihhLCBiKV0sIExlZnQpO1xuXG4gIC8vIyBSaWdodCA6OiBiIC0+IEVpdGhlciBhIGJcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHZhbHVlIG9mIGFueSB0eXBlIGFuZCByZXR1cm5zIGEgUmlnaHQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLlJpZ2h0KDQyKVxuICAvLy4gUmlnaHQoNDIpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gUmlnaHQoeCkge1xuICAgIHJldHVybiBuZXcgX0VpdGhlcignUmlnaHQnLCB4KTtcbiAgfVxuICBTLlJpZ2h0ID0gZGVmKCdSaWdodCcsIHt9LCBbYiwgJEVpdGhlcihhLCBiKV0sIFJpZ2h0KTtcblxuICAvLyMgRWl0aGVyLkBAdHlwZSA6OiBTdHJpbmdcbiAgLy8uXG4gIC8vLiBFaXRoZXIgdHlwZSBpZGVudGlmaWVyLCBgJ3NhbmN0dWFyeS9FaXRoZXInYC5cbiAgRWl0aGVyWydAQHR5cGUnXSA9IGVpdGhlclR5cGVJZGVudDtcblxuICAvLyMgRWl0aGVyLmZhbnRhc3ktbGFuZC9vZiA6OiBiIC0+IEVpdGhlciBhIGJcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHZhbHVlIG9mIGFueSB0eXBlIGFuZCByZXR1cm5zIGEgUmlnaHQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuXG4gIC8vLlxuICAvLy4gSXQgaXMgaWRpb21hdGljIHRvIHVzZSBbYG9mYF0oI29mKSByYXRoZXIgdGhhbiB1c2UgdGhpcyBmdW5jdGlvblxuICAvLy4gZGlyZWN0bHkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm9mKFMuRWl0aGVyLCA0MilcbiAgLy8uIFJpZ2h0KDQyKVxuICAvLy4gYGBgXG4gIEVpdGhlclsnZmFudGFzeS1sYW5kL29mJ10gPSBSaWdodDtcblxuICAvLyMgRWl0aGVyI2lzTGVmdCA6OiBFaXRoZXIgYSBiIH4+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBgdHJ1ZWAgaWYgYHRoaXNgIGlzIGEgTGVmdDsgYGZhbHNlYCBpZiBgdGhpc2AgaXMgYSBSaWdodC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuTGVmdCgnQ2Fubm90IGRpdmlkZSBieSB6ZXJvJykuaXNMZWZ0XG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLlJpZ2h0KDQyKS5pc0xlZnRcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcblxuICAvLyMgRWl0aGVyI2lzUmlnaHQgOjogRWl0aGVyIGEgYiB+PiBCb29sZWFuXG4gIC8vLlxuICAvLy4gYHRydWVgIGlmIGB0aGlzYCBpcyBhIFJpZ2h0OyBgZmFsc2VgIGlmIGB0aGlzYCBpcyBhIExlZnQuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLlJpZ2h0KDQyKS5pc1JpZ2h0XG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLkxlZnQoJ0Nhbm5vdCBkaXZpZGUgYnkgemVybycpLmlzUmlnaHRcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcblxuICAvLyMgRWl0aGVyI3RvU3RyaW5nIDo6IEVpdGhlciBhIGIgfj4gKCkgLT4gU3RyaW5nXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBFaXRoZXIuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRvU3RyaW5nKFMuTGVmdCgnQ2Fubm90IGRpdmlkZSBieSB6ZXJvJykpXG4gIC8vLiAnTGVmdChcIkNhbm5vdCBkaXZpZGUgYnkgemVyb1wiKSdcbiAgLy8uXG4gIC8vLiA+IFMudG9TdHJpbmcoUy5SaWdodChbMSwgMiwgM10pKVxuICAvLy4gJ1JpZ2h0KFsxLCAyLCAzXSknXG4gIC8vLiBgYGBcbiAgRWl0aGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5pc0xlZnQgPyAnTGVmdCcgOiAnUmlnaHQnKSArXG4gICAgICAgICAgICcoJyArIFoudG9TdHJpbmcodGhpcy52YWx1ZSkgKyAnKSc7XG4gIH07XG5cbiAgLy8jIEVpdGhlciNpbnNwZWN0IDo6IEVpdGhlciBhIGIgfj4gKCkgLT4gU3RyaW5nXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBFaXRoZXIuIFRoaXMgbWV0aG9kIGlzIHVzZWQgYnlcbiAgLy8uIGB1dGlsLmluc3BlY3RgIGFuZCB0aGUgUkVQTCB0byBmb3JtYXQgYSBFaXRoZXIgZm9yIGRpc3BsYXkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BFaXRoZXIjdG9TdHJpbmdgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5MZWZ0KCdDYW5ub3QgZGl2aWRlIGJ5IHplcm8nKS5pbnNwZWN0KClcbiAgLy8uICdMZWZ0KFwiQ2Fubm90IGRpdmlkZSBieSB6ZXJvXCIpJ1xuICAvLy5cbiAgLy8uID4gUy5SaWdodChbMSwgMiwgM10pLmluc3BlY3QoKVxuICAvLy4gJ1JpZ2h0KFsxLCAyLCAzXSknXG4gIC8vLiBgYGBcbiAgRWl0aGVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRvU3RyaW5nKCk7IH07XG5cbiAgLy8jIEVpdGhlciNmYW50YXN5LWxhbmQvZXF1YWxzIDo6IChTZXRvaWQgYSwgU2V0b2lkIGIpID0+IEVpdGhlciBhIGIgfj4gRWl0aGVyIGEgYiAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gVGFrZXMgYSB2YWx1ZSBgZWAgb2YgdGhlIHNhbWUgdHlwZSBhbmQgcmV0dXJucyBgdHJ1ZWAgaWY6XG4gIC8vLlxuICAvLy4gICAtIGB0aGlzYCBhbmQgYGVgIGFyZSBib3RoIExlZnRzIG9yIGJvdGggUmlnaHRzLCBhbmQgdGhlaXIgdmFsdWVzIGFyZVxuICAvLy4gICAgIGVxdWFsIGFjY29yZGluZyB0byBbYFouZXF1YWxzYF1bXS5cbiAgLy8uXG4gIC8vLiBJdCBpcyBpZGlvbWF0aWMgdG8gdXNlIFtgZXF1YWxzYF0oI2VxdWFscykgcmF0aGVyIHRoYW4gdXNlIHRoaXMgbWV0aG9kXG4gIC8vLiBkaXJlY3RseS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZXF1YWxzKFMuUmlnaHQoWzEsIDIsIDNdKSwgUy5SaWdodChbMSwgMiwgM10pKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5lcXVhbHMoUy5SaWdodChbMSwgMiwgM10pLCBTLkxlZnQoWzEsIDIsIDNdKSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gRWl0aGVyJHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5pc0xlZnQgPT09IG90aGVyLmlzTGVmdCAmJiBaLmVxdWFscyh0aGlzLnZhbHVlLCBvdGhlci52YWx1ZSk7XG4gIH1cblxuICAvLyMgRWl0aGVyI2ZhbnRhc3ktbGFuZC9sdGUgOjogKE9yZCBhLCBPcmQgYikgPT4gRWl0aGVyIGEgYiB+PiBFaXRoZXIgYSBiIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHZhbHVlIGBlYCBvZiB0aGUgc2FtZSB0eXBlIGFuZCByZXR1cm5zIGB0cnVlYCBpZjpcbiAgLy8uXG4gIC8vLiAgIC0gYHRoaXNgIGlzIGEgTGVmdCBhbmQgYGVgIGlzIGEgUmlnaHQ7IG9yXG4gIC8vLlxuICAvLy4gICAtIGB0aGlzYCBhbmQgYGVgIGFyZSBib3RoIExlZnRzIG9yIGJvdGggUmlnaHRzLCBhbmQgdGhlIHZhbHVlIG9mIGB0aGlzYFxuICAvLy4gICAgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2YgYGVgIGFjY29yZGluZyB0byBbYFoubHRlYF1bXS5cbiAgLy8uXG4gIC8vLiBJdCBpcyBpZGlvbWF0aWMgdG8gdXNlIFtgbHRlYF0oI2x0ZSkgb3IgW2BsdGVfYF0oI2x0ZV8pIHJhdGhlciB0aGFuIHVzZVxuICAvLy4gdGhpcyBtZXRob2QgZGlyZWN0bHkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmx0ZV8oUy5MZWZ0KDEwKSwgUy5SaWdodCgwKSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMubHRlXyhTLlJpZ2h0KDApLCBTLkxlZnQoMTApKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IFMubHRlXyhTLlJpZ2h0KDApLCBTLlJpZ2h0KDEpKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5sdGVfKFMuUmlnaHQoMSksIFMuUmlnaHQoMCkpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIEVpdGhlciRwcm90b3R5cGUkbHRlKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNMZWZ0ID09PSBvdGhlci5pc0xlZnQgP1xuICAgICAgWi5sdGUodGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpIDpcbiAgICAgIHRoaXMuaXNMZWZ0O1xuICB9XG5cbiAgLy8jIEVpdGhlciNmYW50YXN5LWxhbmQvY29uY2F0IDo6IChTZW1pZ3JvdXAgYSwgU2VtaWdyb3VwIGIpID0+IEVpdGhlciBhIGIgfj4gRWl0aGVyIGEgYiAtPiBFaXRoZXIgYSBiXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGNvbmNhdGVuYXRpbmcgdHdvIEVpdGhlciB2YWx1ZXMgb2YgdGhlIHNhbWUgdHlwZS5cbiAgLy8uIGBhYCBtdXN0IGhhdmUgYSBbU2VtaWdyb3VwXVtdLCBhcyBtdXN0IGBiYC5cbiAgLy8uXG4gIC8vLiBJZiBgdGhpc2AgaXMgYSBMZWZ0IGFuZCB0aGUgYXJndW1lbnQgaXMgYSBMZWZ0LCB0aGlzIG1ldGhvZCByZXR1cm5zIGFcbiAgLy8uIExlZnQgd2hvc2UgdmFsdWUgaXMgdGhlIHJlc3VsdCBvZiBjb25jYXRlbmF0aW5nIHRoaXMgTGVmdCdzIHZhbHVlIGFuZFxuICAvLy4gdGhlIGdpdmVuIExlZnQncyB2YWx1ZS5cbiAgLy8uXG4gIC8vLiBJZiBgdGhpc2AgaXMgYSBSaWdodCBhbmQgdGhlIGFyZ3VtZW50IGlzIGEgUmlnaHQsIHRoaXMgbWV0aG9kIHJldHVybnMgYVxuICAvLy4gUmlnaHQgd2hvc2UgdmFsdWUgaXMgdGhlIHJlc3VsdCBvZiBjb25jYXRlbmF0aW5nIHRoaXMgUmlnaHQncyB2YWx1ZSBhbmRcbiAgLy8uIHRoZSBnaXZlbiBSaWdodCdzIHZhbHVlLlxuICAvLy5cbiAgLy8uIE90aGVyd2lzZSwgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgUmlnaHQuXG4gIC8vLlxuICAvLy4gSXQgaXMgaWRpb21hdGljIHRvIHVzZSBbYGNvbmNhdGBdKCNjb25jYXQpIHJhdGhlciB0aGFuIHVzZSB0aGlzIG1ldGhvZFxuICAvLy4gZGlyZWN0bHkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmNvbmNhdChTLkxlZnQoJ2FiYycpLCBTLkxlZnQoJ2RlZicpKVxuICAvLy4gTGVmdCgnYWJjZGVmJylcbiAgLy8uXG4gIC8vLiA+IFMuY29uY2F0KFMuUmlnaHQoWzEsIDIsIDNdKSwgUy5SaWdodChbNCwgNSwgNl0pKVxuICAvLy4gUmlnaHQoWzEsIDIsIDMsIDQsIDUsIDZdKVxuICAvLy5cbiAgLy8uID4gUy5jb25jYXQoUy5MZWZ0KCdhYmMnKSwgUy5SaWdodChbMSwgMiwgM10pKVxuICAvLy4gUmlnaHQoWzEsIDIsIDNdKVxuICAvLy5cbiAgLy8uID4gUy5jb25jYXQoUy5SaWdodChbMSwgMiwgM10pLCBTLkxlZnQoJ2FiYycpKVxuICAvLy4gUmlnaHQoWzEsIDIsIDNdKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIEVpdGhlciRwcm90b3R5cGUkY29uY2F0KG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNMZWZ0ID9cbiAgICAgIG90aGVyLmlzTGVmdCA/IExlZnQoWi5jb25jYXQodGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpKSA6IG90aGVyIDpcbiAgICAgIG90aGVyLmlzTGVmdCA/IHRoaXMgOiBSaWdodChaLmNvbmNhdCh0aGlzLnZhbHVlLCBvdGhlci52YWx1ZSkpO1xuICB9XG5cbiAgLy8jIEVpdGhlciNmYW50YXN5LWxhbmQvbWFwIDo6IEVpdGhlciBhIGIgfj4gKGIgLT4gYykgLT4gRWl0aGVyIGEgY1xuICAvLy5cbiAgLy8uIFRha2VzIGEgZnVuY3Rpb24gYW5kIHJldHVybnMgYHRoaXNgIGlmIGB0aGlzYCBpcyBhIExlZnQ7IG90aGVyd2lzZSBpdFxuICAvLy4gcmV0dXJucyBhIFJpZ2h0IHdob3NlIHZhbHVlIGlzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGZ1bmN0aW9uIHRvXG4gIC8vLiB0aGlzIFJpZ2h0J3MgdmFsdWUuXG4gIC8vLlxuICAvLy4gSXQgaXMgaWRpb21hdGljIHRvIHVzZSBbYG1hcGBdKCNtYXApIHJhdGhlciB0aGFuIHVzZSB0aGlzIG1ldGhvZFxuICAvLy4gZGlyZWN0bHkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BFaXRoZXIjZmFudGFzeS1sYW5kL2JpbWFwYF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWFwKE1hdGguc3FydCwgUy5MZWZ0KCdDYW5ub3QgZGl2aWRlIGJ5IHplcm8nKSlcbiAgLy8uIExlZnQoJ0Nhbm5vdCBkaXZpZGUgYnkgemVybycpXG4gIC8vLlxuICAvLy4gPiBTLm1hcChNYXRoLnNxcnQsIFMuUmlnaHQoOSkpXG4gIC8vLiBSaWdodCgzKVxuICAvLy4gYGBgXG4gIEVpdGhlci5wcm90b3R5cGVbJ2ZhbnRhc3ktbGFuZC9tYXAnXSA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gdGhpcy5pc1JpZ2h0ID8gUmlnaHQoZih0aGlzLnZhbHVlKSkgOiB0aGlzO1xuICB9O1xuXG4gIC8vIyBFaXRoZXIjZmFudGFzeS1sYW5kL2JpbWFwIDo6IEVpdGhlciBhIGIgfj4gKGEgLT4gYywgYiAtPiBkKSAtPiBFaXRoZXIgYyBkXG4gIC8vLlxuICAvLy4gVGFrZXMgdHdvIGZ1bmN0aW9ucyBhbmQgcmV0dXJuczpcbiAgLy8uXG4gIC8vLiAgIC0gYSBMZWZ0IHdob3NlIHZhbHVlIGlzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGZpcnN0IGZ1bmN0aW9uXG4gIC8vLiAgICAgdG8gdGhpcyBMZWZ0J3MgdmFsdWUgaWYgYHRoaXNgIGlzIGEgTGVmdDsgb3RoZXJ3aXNlXG4gIC8vLlxuICAvLy4gICAtIGEgUmlnaHQgd2hvc2UgdmFsdWUgaXMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgc2Vjb25kIGZ1bmN0aW9uXG4gIC8vLiAgICAgdG8gdGhpcyBSaWdodCdzIHZhbHVlLlxuICAvLy5cbiAgLy8uIFNpbWlsYXIgdG8gW2BFaXRoZXIjZmFudGFzeS1sYW5kL21hcGBdW10sIGJ1dCBzdXBwb3J0cyBtYXBwaW5nIG92ZXIgdGhlXG4gIC8vLiBsZWZ0IHNpZGUgYXMgd2VsbCBhcyB0aGUgcmlnaHQgc2lkZS5cbiAgLy8uXG4gIC8vLiBJdCBpcyBpZGlvbWF0aWMgdG8gdXNlIFtgYmltYXBgXSgjYmltYXApIHJhdGhlciB0aGFuIHVzZSB0aGlzIG1ldGhvZFxuICAvLy4gZGlyZWN0bHkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmJpbWFwKFMudG9VcHBlciwgUy5hZGQoMSksIFMuTGVmdCgnYWJjJykpXG4gIC8vLiBMZWZ0KCdBQkMnKVxuICAvLy5cbiAgLy8uID4gUy5iaW1hcChTLnRvVXBwZXIsIFMuYWRkKDEpLCBTLlJpZ2h0KDQyKSlcbiAgLy8uIFJpZ2h0KDQzKVxuICAvLy4gYGBgXG4gIEVpdGhlci5wcm90b3R5cGVbJ2ZhbnRhc3ktbGFuZC9iaW1hcCddID0gZnVuY3Rpb24oZiwgZykge1xuICAgIHJldHVybiB0aGlzLmlzTGVmdCA/IExlZnQoZih0aGlzLnZhbHVlKSkgOiBSaWdodChnKHRoaXMudmFsdWUpKTtcbiAgfTtcblxuICAvLyMgRWl0aGVyI2ZhbnRhc3ktbGFuZC9hcCA6OiBFaXRoZXIgYSBiIH4+IEVpdGhlciBhIChiIC0+IGMpIC0+IEVpdGhlciBhIGNcbiAgLy8uXG4gIC8vLiBUYWtlcyBhbiBFaXRoZXIgYW5kIHJldHVybnMgYSBMZWZ0IHVubGVzcyBgdGhpc2AgaXMgYSBSaWdodCAqYW5kKiB0aGVcbiAgLy8uIGFyZ3VtZW50IGlzIGEgUmlnaHQsIGluIHdoaWNoIGNhc2UgaXQgcmV0dXJucyBhIFJpZ2h0IHdob3NlIHZhbHVlIGlzXG4gIC8vLiB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBnaXZlbiBSaWdodCdzIHZhbHVlIHRvIHRoaXMgUmlnaHQncyB2YWx1ZS5cbiAgLy8uXG4gIC8vLiBJdCBpcyBpZGlvbWF0aWMgdG8gdXNlIFtgYXBgXSgjYXApIHJhdGhlciB0aGFuIHVzZSB0aGlzIG1ldGhvZCBkaXJlY3RseS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYXAoUy5MZWZ0KCdObyBzdWNoIGZ1bmN0aW9uJyksIFMuTGVmdCgnQ2Fubm90IGRpdmlkZSBieSB6ZXJvJykpXG4gIC8vLiBMZWZ0KCdObyBzdWNoIGZ1bmN0aW9uJylcbiAgLy8uXG4gIC8vLiA+IFMuYXAoUy5MZWZ0KCdObyBzdWNoIGZ1bmN0aW9uJyksIFMuUmlnaHQoOSkpXG4gIC8vLiBMZWZ0KCdObyBzdWNoIGZ1bmN0aW9uJylcbiAgLy8uXG4gIC8vLiA+IFMuYXAoUy5SaWdodChNYXRoLnNxcnQpLCBTLkxlZnQoJ0Nhbm5vdCBkaXZpZGUgYnkgemVybycpKVxuICAvLy4gTGVmdCgnQ2Fubm90IGRpdmlkZSBieSB6ZXJvJylcbiAgLy8uXG4gIC8vLiA+IFMuYXAoUy5SaWdodChNYXRoLnNxcnQpLCBTLlJpZ2h0KDkpKVxuICAvLy4gUmlnaHQoMylcbiAgLy8uIGBgYFxuICBFaXRoZXIucHJvdG90eXBlWydmYW50YXN5LWxhbmQvYXAnXSA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLmlzUmlnaHQgPyBaLm1hcChvdGhlci52YWx1ZSwgdGhpcykgOiBvdGhlcjtcbiAgfTtcblxuICAvLyMgRWl0aGVyI2ZhbnRhc3ktbGFuZC9jaGFpbiA6OiBFaXRoZXIgYSBiIH4+IChiIC0+IEVpdGhlciBhIGMpIC0+IEVpdGhlciBhIGNcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGB0aGlzYCBpZiBgdGhpc2AgaXMgYSBMZWZ0OyBvdGhlcndpc2VcbiAgLy8uIGl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgZnVuY3Rpb24gdG8gdGhpcyBSaWdodCdzIHZhbHVlLlxuICAvLy5cbiAgLy8uIEl0IGlzIGlkaW9tYXRpYyB0byB1c2UgW2BjaGFpbmBdKCNjaGFpbikgcmF0aGVyIHRoYW4gdXNlIHRoaXMgbWV0aG9kXG4gIC8vLiBkaXJlY3RseS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGdsb2JhbC5zcXJ0ID0gbiA9PlxuICAvLy4gLiAgIG4gPCAwID8gUy5MZWZ0KCdDYW5ub3QgcmVwcmVzZW50IHNxdWFyZSByb290IG9mIG5lZ2F0aXZlIG51bWJlcicpXG4gIC8vLiAuICAgICAgICAgOiBTLlJpZ2h0KE1hdGguc3FydChuKSlcbiAgLy8uIHNxcnRcbiAgLy8uXG4gIC8vLiA+IFMuY2hhaW4oc3FydCwgUy5MZWZ0KCdDYW5ub3QgZGl2aWRlIGJ5IHplcm8nKSlcbiAgLy8uIExlZnQoJ0Nhbm5vdCBkaXZpZGUgYnkgemVybycpXG4gIC8vLlxuICAvLy4gPiBTLmNoYWluKHNxcnQsIFMuUmlnaHQoLTEpKVxuICAvLy4gTGVmdCgnQ2Fubm90IHJlcHJlc2VudCBzcXVhcmUgcm9vdCBvZiBuZWdhdGl2ZSBudW1iZXInKVxuICAvLy5cbiAgLy8uID4gUy5jaGFpbihzcXJ0LCBTLlJpZ2h0KDI1KSlcbiAgLy8uIFJpZ2h0KDUpXG4gIC8vLiBgYGBcbiAgRWl0aGVyLnByb3RvdHlwZVsnZmFudGFzeS1sYW5kL2NoYWluJ10gPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNSaWdodCA/IGYodGhpcy52YWx1ZSkgOiB0aGlzO1xuICB9O1xuXG4gIC8vIyBFaXRoZXIjZmFudGFzeS1sYW5kL2FsdCA6OiBFaXRoZXIgYSBiIH4+IEVpdGhlciBhIGIgLT4gRWl0aGVyIGEgYlxuICAvLy5cbiAgLy8uIENob29zZXMgYmV0d2VlbiBgdGhpc2AgYW5kIHRoZSBvdGhlciBFaXRoZXIgcHJvdmlkZWQgYXMgYW4gYXJndW1lbnQuXG4gIC8vLiBSZXR1cm5zIGB0aGlzYCBpZiBgdGhpc2AgaXMgYSBSaWdodDsgdGhlIG90aGVyIEVpdGhlciBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gSXQgaXMgaWRpb21hdGljIHRvIHVzZSBbYGFsdGBdKCNhbHQpIHJhdGhlciB0aGFuIHVzZSB0aGlzIG1ldGhvZFxuICAvLy4gZGlyZWN0bHkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmFsdChTLkxlZnQoJ0EnKSwgUy5MZWZ0KCdCJykpXG4gIC8vLiBMZWZ0KCdCJylcbiAgLy8uXG4gIC8vLiA+IFMuYWx0KFMuTGVmdCgnQycpLCBTLlJpZ2h0KDEpKVxuICAvLy4gUmlnaHQoMSlcbiAgLy8uXG4gIC8vLiA+IFMuYWx0KFMuUmlnaHQoMiksIFMuTGVmdCgnRCcpKVxuICAvLy4gUmlnaHQoMilcbiAgLy8uXG4gIC8vLiA+IFMuYWx0KFMuUmlnaHQoMyksIFMuUmlnaHQoNCkpXG4gIC8vLiBSaWdodCgzKVxuICAvLy4gYGBgXG4gIEVpdGhlci5wcm90b3R5cGVbJ2ZhbnRhc3ktbGFuZC9hbHQnXSA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNSaWdodCA/IHRoaXMgOiBvdGhlcjtcbiAgfTtcblxuICAvLyMgRWl0aGVyI2ZhbnRhc3ktbGFuZC9yZWR1Y2UgOjogRWl0aGVyIGEgYiB+PiAoKGMsIGIpIC0+IGMsIGMpIC0+IGNcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIGZ1bmN0aW9uIGFuZCBhbiBpbml0aWFsIHZhbHVlIG9mIGFueSB0eXBlLCBhbmQgcmV0dXJuczpcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIGluaXRpYWwgdmFsdWUgaWYgYHRoaXNgIGlzIGEgTGVmdDsgb3RoZXJ3aXNlXG4gIC8vLlxuICAvLy4gICAtIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGZ1bmN0aW9uIHRvIHRoZSBpbml0aWFsIHZhbHVlIGFuZCB0aGlzXG4gIC8vLiAgICAgUmlnaHQncyB2YWx1ZS5cbiAgLy8uXG4gIC8vLiBJdCBpcyBpZGlvbWF0aWMgdG8gdXNlIFtgcmVkdWNlYF0oI3JlZHVjZSkgcmF0aGVyIHRoYW4gdXNlIHRoaXMgbWV0aG9kXG4gIC8vLiBkaXJlY3RseS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucmVkdWNlKFMuY3VycnkyKE1hdGgucG93KSwgMTAsIFMuTGVmdCgnQ2Fubm90IGRpdmlkZSBieSB6ZXJvJykpXG4gIC8vLiAxMFxuICAvLy5cbiAgLy8uID4gUy5yZWR1Y2UoUy5jdXJyeTIoTWF0aC5wb3cpLCAxMCwgUy5SaWdodCgzKSlcbiAgLy8uIDEwMDBcbiAgLy8uIGBgYFxuICBFaXRoZXIucHJvdG90eXBlWydmYW50YXN5LWxhbmQvcmVkdWNlJ10gPSBmdW5jdGlvbihmLCB4KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNSaWdodCA/IGYoeCwgdGhpcy52YWx1ZSkgOiB4O1xuICB9O1xuXG4gIC8vIyBFaXRoZXIjZmFudGFzeS1sYW5kL3RyYXZlcnNlIDo6IEFwcGxpY2F0aXZlIGYgPT4gRWl0aGVyIGEgYiB+PiAoVHlwZVJlcCBmLCBiIC0+IGYgYykgLT4gZiAoRWl0aGVyIGEgYylcbiAgLy8uXG4gIC8vLiBUYWtlcyB0aGUgdHlwZSByZXByZXNlbnRhdGl2ZSBvZiBzb21lIFtBcHBsaWNhdGl2ZV1bXSBhbmQgYSBmdW5jdGlvblxuICAvLy4gd2hpY2ggcmV0dXJucyBhIHZhbHVlIG9mIHRoYXQgQXBwbGljYXRpdmUsIGFuZCByZXR1cm5zOlxuICAvLy5cbiAgLy8uICAgLSB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSB0eXBlIHJlcHJlc2VudGF0aXZlJ3MgW2BvZmBdW10gZnVuY3Rpb24gdG9cbiAgLy8uICAgICBgdGhpc2AgaWYgYHRoaXNgIGlzIGEgTGVmdDsgb3RoZXJ3aXNlXG4gIC8vLlxuICAvLy4gICAtIHRoZSByZXN1bHQgb2YgbWFwcGluZyBbYFJpZ2h0YF0oI1JpZ2h0KSBvdmVyIHRoZSByZXN1bHQgb2YgYXBwbHlpbmdcbiAgLy8uICAgICB0aGUgZmlyc3QgZnVuY3Rpb24gdG8gdGhpcyBSaWdodCdzIHZhbHVlLlxuICAvLy5cbiAgLy8uIEl0IGlzIGlkaW9tYXRpYyB0byB1c2UgW2B0cmF2ZXJzZWBdKCN0cmF2ZXJzZSkgcmF0aGVyIHRoYW4gdXNlIHRoaXNcbiAgLy8uIG1ldGhvZCBkaXJlY3RseS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMudHJhdmVyc2UoQXJyYXksIFMud29yZHMsIFMuTGVmdCgnUmVxdWVzdCBmYWlsZWQnKSlcbiAgLy8uIFtMZWZ0KCdSZXF1ZXN0IGZhaWxlZCcpXVxuICAvLy5cbiAgLy8uID4gUy50cmF2ZXJzZShBcnJheSwgUy53b3JkcywgUy5SaWdodCgnZm9vIGJhciBiYXonKSlcbiAgLy8uIFtSaWdodCgnZm9vJyksIFJpZ2h0KCdiYXInKSwgUmlnaHQoJ2JheicpXVxuICAvLy4gYGBgXG4gIEVpdGhlci5wcm90b3R5cGVbJ2ZhbnRhc3ktbGFuZC90cmF2ZXJzZSddID0gZnVuY3Rpb24odHlwZVJlcCwgZikge1xuICAgIHJldHVybiB0aGlzLmlzUmlnaHQgPyBaLm1hcChSaWdodCwgZih0aGlzLnZhbHVlKSkgOiBaLm9mKHR5cGVSZXAsIHRoaXMpO1xuICB9O1xuXG4gIC8vIyBFaXRoZXIjZmFudGFzeS1sYW5kL2V4dGVuZCA6OiBFaXRoZXIgYSBiIH4+IChFaXRoZXIgYSBiIC0+IGMpIC0+IEVpdGhlciBhIGNcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGB0aGlzYCBpZiBgdGhpc2AgaXMgYSBMZWZ0OyBvdGhlcndpc2UgaXRcbiAgLy8uIHJldHVybnMgYSBSaWdodCB3aG9zZSB2YWx1ZSBpcyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBmdW5jdGlvbiB0b1xuICAvLy4gYHRoaXNgLlxuICAvLy5cbiAgLy8uIEl0IGlzIGlkaW9tYXRpYyB0byB1c2UgW2BleHRlbmRgXSgjZXh0ZW5kKSByYXRoZXIgdGhhbiB1c2UgdGhpcyBtZXRob2RcbiAgLy8uIGRpcmVjdGx5LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5leHRlbmQoeCA9PiB4LnZhbHVlICsgMSwgUy5MZWZ0KCdDYW5ub3QgZGl2aWRlIGJ5IHplcm8nKSlcbiAgLy8uIExlZnQoJ0Nhbm5vdCBkaXZpZGUgYnkgemVybycpXG4gIC8vLlxuICAvLy4gPiBTLmV4dGVuZCh4ID0+IHgudmFsdWUgKyAxLCBTLlJpZ2h0KDQyKSlcbiAgLy8uIFJpZ2h0KDQzKVxuICAvLy4gYGBgXG4gIEVpdGhlci5wcm90b3R5cGVbJ2ZhbnRhc3ktbGFuZC9leHRlbmQnXSA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gdGhpcy5pc0xlZnQgPyB0aGlzIDogUmlnaHQoZih0aGlzKSk7XG4gIH07XG5cbiAgLy8jIGlzTGVmdCA6OiBFaXRoZXIgYSBiIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gRWl0aGVyIGlzIGEgTGVmdDsgYGZhbHNlYCBpZiBpdCBpcyBhIFJpZ2h0LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5pc0xlZnQoUy5MZWZ0KCdDYW5ub3QgZGl2aWRlIGJ5IHplcm8nKSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMuaXNMZWZ0KFMuUmlnaHQoNDIpKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBpc0xlZnQoZWl0aGVyKSB7XG4gICAgcmV0dXJuIGVpdGhlci5pc0xlZnQ7XG4gIH1cbiAgUy5pc0xlZnQgPSBkZWYoJ2lzTGVmdCcsIHt9LCBbJEVpdGhlcihhLCBiKSwgJC5Cb29sZWFuXSwgaXNMZWZ0KTtcblxuICAvLyMgaXNSaWdodCA6OiBFaXRoZXIgYSBiIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gRWl0aGVyIGlzIGEgUmlnaHQ7IGBmYWxzZWAgaWYgaXQgaXMgYSBMZWZ0LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5pc1JpZ2h0KFMuUmlnaHQoNDIpKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5pc1JpZ2h0KFMuTGVmdCgnQ2Fubm90IGRpdmlkZSBieSB6ZXJvJykpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGlzUmlnaHQoZWl0aGVyKSB7XG4gICAgcmV0dXJuIGVpdGhlci5pc1JpZ2h0O1xuICB9XG4gIFMuaXNSaWdodCA9IGRlZignaXNSaWdodCcsIHt9LCBbJEVpdGhlcihhLCBiKSwgJC5Cb29sZWFuXSwgaXNSaWdodCk7XG5cbiAgLy8jIGZyb21FaXRoZXIgOjogYiAtPiBFaXRoZXIgYSBiIC0+IGJcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIGRlZmF1bHQgdmFsdWUgYW5kIGFuIEVpdGhlciwgYW5kIHJldHVybnMgdGhlIFJpZ2h0IHZhbHVlXG4gIC8vLiBpZiB0aGUgRWl0aGVyIGlzIGEgUmlnaHQ7IHRoZSBkZWZhdWx0IHZhbHVlIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZnJvbUVpdGhlcigwLCBTLlJpZ2h0KDQyKSlcbiAgLy8uIDQyXG4gIC8vLlxuICAvLy4gPiBTLmZyb21FaXRoZXIoMCwgUy5MZWZ0KDQyKSlcbiAgLy8uIDBcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBmcm9tRWl0aGVyKHgsIGVpdGhlcikge1xuICAgIHJldHVybiBlaXRoZXIuaXNSaWdodCA/IGVpdGhlci52YWx1ZSA6IHg7XG4gIH1cbiAgUy5mcm9tRWl0aGVyID0gZGVmKCdmcm9tRWl0aGVyJywge30sIFtiLCAkRWl0aGVyKGEsIGIpLCBiXSwgZnJvbUVpdGhlcik7XG5cbiAgLy8jIHRvRWl0aGVyIDo6IGEgLT4gYj8gLT4gRWl0aGVyIGEgYlxuICAvLy5cbiAgLy8uIENvbnZlcnRzIGFuIGFyYml0cmFyeSB2YWx1ZSB0byBhbiBFaXRoZXI6IGEgTGVmdCBpZiB0aGUgdmFsdWUgaXMgYG51bGxgXG4gIC8vLiBvciBgdW5kZWZpbmVkYDsgYSBSaWdodCBvdGhlcndpc2UuIFRoZSBmaXJzdCBhcmd1bWVudCBzcGVjaWZpZXMgdGhlXG4gIC8vLiB2YWx1ZSBvZiB0aGUgTGVmdCBpbiB0aGUgXCJmYWlsdXJlXCIgY2FzZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMudG9FaXRoZXIoJ1hZWicsIG51bGwpXG4gIC8vLiBMZWZ0KCdYWVonKVxuICAvLy5cbiAgLy8uID4gUy50b0VpdGhlcignWFlaJywgJ0FCQycpXG4gIC8vLiBSaWdodCgnQUJDJylcbiAgLy8uXG4gIC8vLiA+IFMubWFwKFMucHJvcCgnMCcpLCBTLnRvRWl0aGVyKCdJbnZhbGlkIHByb3RvY29sJywgJ2Z0cDovL2V4YW1wbGUuY29tLycubWF0Y2goL15odHRwcz86LykpKVxuICAvLy4gTGVmdCgnSW52YWxpZCBwcm90b2NvbCcpXG4gIC8vLlxuICAvLy4gPiBTLm1hcChTLnByb3AoJzAnKSwgUy50b0VpdGhlcignSW52YWxpZCBwcm90b2NvbCcsICdodHRwczovL2V4YW1wbGUuY29tLycubWF0Y2goL15odHRwcz86LykpKVxuICAvLy4gUmlnaHQoJ2h0dHBzOicpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gdG9FaXRoZXIoeCwgeSkge1xuICAgIHJldHVybiB5ID09IG51bGwgPyBMZWZ0KHgpIDogUmlnaHQoeSk7XG4gIH1cbiAgUy50b0VpdGhlciA9IGRlZigndG9FaXRoZXInLCB7fSwgW2EsIGIsICRFaXRoZXIoYSwgYildLCB0b0VpdGhlcik7XG5cbiAgLy8jIGVpdGhlciA6OiAoYSAtPiBjKSAtPiAoYiAtPiBjKSAtPiBFaXRoZXIgYSBiIC0+IGNcbiAgLy8uXG4gIC8vLiBUYWtlcyB0d28gZnVuY3Rpb25zIGFuZCBhbiBFaXRoZXIsIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcbiAgLy8uIGFwcGx5aW5nIHRoZSBmaXJzdCBmdW5jdGlvbiB0byB0aGUgTGVmdCdzIHZhbHVlLCBpZiB0aGUgRWl0aGVyXG4gIC8vLiBpcyBhIExlZnQsIG9yIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIHNlY29uZCBmdW5jdGlvbiB0byB0aGVcbiAgLy8uIFJpZ2h0J3MgdmFsdWUsIGlmIHRoZSBFaXRoZXIgaXMgYSBSaWdodC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZWl0aGVyKFMudG9VcHBlciwgUy50b1N0cmluZywgUy5MZWZ0KCdDYW5ub3QgZGl2aWRlIGJ5IHplcm8nKSlcbiAgLy8uICdDQU5OT1QgRElWSURFIEJZIFpFUk8nXG4gIC8vLlxuICAvLy4gPiBTLmVpdGhlcihTLnRvVXBwZXIsIFMudG9TdHJpbmcsIFMuUmlnaHQoNDIpKVxuICAvLy4gJzQyJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGVpdGhlcihsLCByLCBlaXRoZXIpIHtcbiAgICByZXR1cm4gZWl0aGVyLmlzTGVmdCA/IGwoZWl0aGVyLnZhbHVlKSA6IHIoZWl0aGVyLnZhbHVlKTtcbiAgfVxuICBTLmVpdGhlciA9IGRlZignZWl0aGVyJywge30sIFtGbihhLCBjKSwgRm4oYiwgYyksICRFaXRoZXIoYSwgYiksIGNdLCBlaXRoZXIpO1xuXG4gIC8vIyBsZWZ0cyA6OiBBcnJheSAoRWl0aGVyIGEgYikgLT4gQXJyYXkgYVxuICAvLy5cbiAgLy8uIFRha2VzIGFuIGFycmF5IG9mIEVpdGhlcnMgYW5kIHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyBlYWNoIExlZnQnc1xuICAvLy4gdmFsdWUuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2ByaWdodHNgXSgjcmlnaHRzKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubGVmdHMoW1MuUmlnaHQoMjApLCBTLkxlZnQoJ2ZvbycpLCBTLlJpZ2h0KDEwKSwgUy5MZWZ0KCdiYXInKV0pXG4gIC8vLiBbJ2ZvbycsICdiYXInXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGxlZnRzKGVpdGhlcnMpIHtcbiAgICByZXR1cm4gWi5yZWR1Y2UoZnVuY3Rpb24oeHMsIGVpdGhlcikge1xuICAgICAgaWYgKGVpdGhlci5pc0xlZnQpIHhzLnB1c2goZWl0aGVyLnZhbHVlKTtcbiAgICAgIHJldHVybiB4cztcbiAgICB9LCBbXSwgZWl0aGVycyk7XG4gIH1cbiAgUy5sZWZ0cyA9IGRlZignbGVmdHMnLCB7fSwgWyQuQXJyYXkoJEVpdGhlcihhLCBiKSksICQuQXJyYXkoYSldLCBsZWZ0cyk7XG5cbiAgLy8jIHJpZ2h0cyA6OiBBcnJheSAoRWl0aGVyIGEgYikgLT4gQXJyYXkgYlxuICAvLy5cbiAgLy8uIFRha2VzIGFuIGFycmF5IG9mIEVpdGhlcnMgYW5kIHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyBlYWNoIFJpZ2h0J3NcbiAgLy8uIHZhbHVlLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbGVmdHNgXSgjbGVmdHMpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5yaWdodHMoW1MuUmlnaHQoMjApLCBTLkxlZnQoJ2ZvbycpLCBTLlJpZ2h0KDEwKSwgUy5MZWZ0KCdiYXInKV0pXG4gIC8vLiBbMjAsIDEwXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHJpZ2h0cyhlaXRoZXJzKSB7XG4gICAgcmV0dXJuIFoucmVkdWNlKGZ1bmN0aW9uKHhzLCBlaXRoZXIpIHtcbiAgICAgIGlmIChlaXRoZXIuaXNSaWdodCkgeHMucHVzaChlaXRoZXIudmFsdWUpO1xuICAgICAgcmV0dXJuIHhzO1xuICAgIH0sIFtdLCBlaXRoZXJzKTtcbiAgfVxuICBTLnJpZ2h0cyA9IGRlZigncmlnaHRzJywge30sIFskLkFycmF5KCRFaXRoZXIoYSwgYikpLCAkLkFycmF5KGIpXSwgcmlnaHRzKTtcblxuICAvLyMgdGFnQnkgOjogKGEgLT4gQm9vbGVhbikgLT4gYSAtPiBFaXRoZXIgYSBhXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBwcmVkaWNhdGUgYW5kIGEgdmFsdWUsIGFuZCByZXR1cm5zIGEgUmlnaHQgb2YgdGhlIHZhbHVlIGlmIGl0XG4gIC8vLiBzYXRpc2ZpZXMgdGhlIHByZWRpY2F0ZTsgYSBMZWZ0IG9mIHRoZSB2YWx1ZSBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRhZ0J5KFMub2RkLCAwKVxuICAvLy4gTGVmdCgwKVxuICAvL1xuICAvLy4gPiBTLnRhZ0J5KFMub2RkLCAxKVxuICAvLy4gUmlnaHQoMSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiB0YWdCeShwcmVkLCBhKSB7XG4gICAgcmV0dXJuIHByZWQoYSkgPyBSaWdodChhKSA6IExlZnQoYSk7XG4gIH1cbiAgUy50YWdCeSA9IGRlZigndGFnQnknLCB7fSwgWyQuUHJlZGljYXRlKGEpLCBhLCAkRWl0aGVyKGEsIGEpXSwgdGFnQnkpO1xuXG4gIC8vIyBlbmNhc2VFaXRoZXIgOjogKEVycm9yIC0+IGwpIC0+IChhIC0+IHIpIC0+IGEgLT4gRWl0aGVyIGwgclxuICAvLy5cbiAgLy8uIFRha2VzIHR3byB1bmFyeSBmdW5jdGlvbnMsIGBmYCBhbmQgYGdgLCB0aGUgc2Vjb25kIG9mIHdoaWNoIG1heSB0aHJvdyxcbiAgLy8uIGFuZCBhIHZhbHVlIGB4YCBvZiBhbnkgdHlwZS4gQXBwbGllcyBgZ2AgdG8gYHhgIGluc2lkZSBhIGB0cnlgIGJsb2NrLlxuICAvLy4gSWYgYW4gZXhjZXB0aW9uIGlzIGNhdWdodCwgdGhlIHJldHVybiB2YWx1ZSBpcyBhIExlZnQgY29udGFpbmluZyB0aGVcbiAgLy8uIHJlc3VsdCBvZiBhcHBseWluZyBgZmAgdG8gdGhlIGNhdWdodCBFcnJvciBvYmplY3Q7IG90aGVyd2lzZSB0aGUgcmV0dXJuXG4gIC8vLiB2YWx1ZSBpcyBhIFJpZ2h0IGNvbnRhaW5pbmcgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBgZ2AgdG8gYHhgLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZW5jYXNlYF0oI2VuY2FzZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmVuY2FzZUVpdGhlcihTLkksIEpTT04ucGFyc2UsICdbXCJmb29cIixcImJhclwiLFwiYmF6XCJdJylcbiAgLy8uIFJpZ2h0KFsnZm9vJywgJ2JhcicsICdiYXonXSlcbiAgLy8uXG4gIC8vLiA+IFMuZW5jYXNlRWl0aGVyKFMuSSwgSlNPTi5wYXJzZSwgJ1snKVxuICAvLy4gTGVmdChuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIEpTT04gaW5wdXQnKSlcbiAgLy8uXG4gIC8vLiA+IFMuZW5jYXNlRWl0aGVyKFMucHJvcCgnbWVzc2FnZScpLCBKU09OLnBhcnNlLCAnWycpXG4gIC8vLiBMZWZ0KCdVbmV4cGVjdGVkIGVuZCBvZiBKU09OIGlucHV0JylcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBlbmNhc2VFaXRoZXIoZiwgZywgeCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gUmlnaHQoZyh4KSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gTGVmdChmKGVycikpO1xuICAgIH1cbiAgfVxuICBTLmVuY2FzZUVpdGhlciA9XG4gIGRlZignZW5jYXNlRWl0aGVyJyxcbiAgICAgIHt9LFxuICAgICAgW0ZuKCQuRXJyb3IsIGwpLCBGbihhLCByKSwgYSwgJEVpdGhlcihsLCByKV0sXG4gICAgICBlbmNhc2VFaXRoZXIpO1xuXG4gIC8vIyBlbmNhc2VFaXRoZXIyIDo6IChFcnJvciAtPiBsKSAtPiAoYSAtPiBiIC0+IHIpIC0+IGEgLT4gYiAtPiBFaXRoZXIgbCByXG4gIC8vLlxuICAvLy4gQmluYXJ5IHZlcnNpb24gb2YgW2BlbmNhc2VFaXRoZXJgXSgjZW5jYXNlRWl0aGVyKS5cbiAgZnVuY3Rpb24gZW5jYXNlRWl0aGVyMihmLCBnLCB4LCB5KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBSaWdodChnKHgpKHkpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBMZWZ0KGYoZXJyKSk7XG4gICAgfVxuICB9XG4gIFMuZW5jYXNlRWl0aGVyMiA9XG4gIGRlZignZW5jYXNlRWl0aGVyMicsXG4gICAgICB7fSxcbiAgICAgIFtGbigkLkVycm9yLCBsKSwgRm4oYSwgRm4oYiwgcikpLCBhLCBiLCAkRWl0aGVyKGwsIHIpXSxcbiAgICAgIGVuY2FzZUVpdGhlcjIpO1xuXG4gIC8vIyBlbmNhc2VFaXRoZXIzIDo6IChFcnJvciAtPiBsKSAtPiAoYSAtPiBiIC0+IGMgLT4gcikgLT4gYSAtPiBiIC0+IGMgLT4gRWl0aGVyIGwgclxuICAvLy5cbiAgLy8uIFRlcm5hcnkgdmVyc2lvbiBvZiBbYGVuY2FzZUVpdGhlcmBdKCNlbmNhc2VFaXRoZXIpLlxuICBmdW5jdGlvbiBlbmNhc2VFaXRoZXIzKGYsIGcsIHgsIHksIHopIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIFJpZ2h0KGcoeCkoeSkoeikpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIExlZnQoZihlcnIpKTtcbiAgICB9XG4gIH1cbiAgUy5lbmNhc2VFaXRoZXIzID1cbiAgZGVmKCdlbmNhc2VFaXRoZXIzJyxcbiAgICAgIHt9LFxuICAgICAgW0ZuKCQuRXJyb3IsIGwpLCBGbihhLCBGbihiLCBGbihjLCByKSkpLCBhLCBiLCBjLCAkRWl0aGVyKGwsIHIpXSxcbiAgICAgIGVuY2FzZUVpdGhlcjMpO1xuXG4gIC8vIyBlaXRoZXJUb01heWJlIDo6IEVpdGhlciBhIGIgLT4gTWF5YmUgYlxuICAvLy5cbiAgLy8uIENvbnZlcnRzIGFuIEVpdGhlciB0byBhIE1heWJlLiBBIExlZnQgYmVjb21lcyBOb3RoaW5nOyBhIFJpZ2h0IGJlY29tZXNcbiAgLy8uIGEgSnVzdC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYG1heWJlVG9FaXRoZXJgXSgjbWF5YmVUb0VpdGhlcikuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmVpdGhlclRvTWF5YmUoUy5MZWZ0KCdDYW5ub3QgZGl2aWRlIGJ5IHplcm8nKSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMuZWl0aGVyVG9NYXliZShTLlJpZ2h0KDQyKSlcbiAgLy8uIEp1c3QoNDIpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZWl0aGVyVG9NYXliZShlaXRoZXIpIHtcbiAgICByZXR1cm4gZWl0aGVyLmlzTGVmdCA/IE5vdGhpbmcgOiBKdXN0KGVpdGhlci52YWx1ZSk7XG4gIH1cbiAgUy5laXRoZXJUb01heWJlID1cbiAgZGVmKCdlaXRoZXJUb01heWJlJywge30sIFskRWl0aGVyKGEsIGIpLCAkTWF5YmUoYildLCBlaXRoZXJUb01heWJlKTtcblxuICAvLy4gIyMjIExvZ2ljXG5cbiAgLy8jIGFuZCA6OiBCb29sZWFuIC0+IEJvb2xlYW4gLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIEJvb2xlYW4gXCJhbmRcIi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYW5kKGZhbHNlLCBmYWxzZSlcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBTLmFuZChmYWxzZSwgdHJ1ZSlcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBTLmFuZCh0cnVlLCBmYWxzZSlcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBTLmFuZCh0cnVlLCB0cnVlKVxuICAvLy4gdHJ1ZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGFuZCh4LCB5KSB7XG4gICAgcmV0dXJuIHgudmFsdWVPZigpICYmIHkudmFsdWVPZigpO1xuICB9XG4gIFMuYW5kID0gZGVmKCdhbmQnLCB7fSwgWyQuQm9vbGVhbiwgJC5Cb29sZWFuLCAkLkJvb2xlYW5dLCBhbmQpO1xuXG4gIC8vIyBvciA6OiBCb29sZWFuIC0+IEJvb2xlYW4gLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIEJvb2xlYW4gXCJvclwiLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5vcihmYWxzZSwgZmFsc2UpXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gUy5vcihmYWxzZSwgdHJ1ZSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMub3IodHJ1ZSwgZmFsc2UpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLm9yKHRydWUsIHRydWUpXG4gIC8vLiB0cnVlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gb3IoeCwgeSkge1xuICAgIHJldHVybiB4LnZhbHVlT2YoKSB8fCB5LnZhbHVlT2YoKTtcbiAgfVxuICBTLm9yID0gZGVmKCdvcicsIHt9LCBbJC5Cb29sZWFuLCAkLkJvb2xlYW4sICQuQm9vbGVhbl0sIG9yKTtcblxuICAvLyMgbm90IDo6IEJvb2xlYW4gLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIEJvb2xlYW4gXCJub3RcIi5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGNvbXBsZW1lbnRgXSgjY29tcGxlbWVudCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm5vdChmYWxzZSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMubm90KHRydWUpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG5vdCh4KSB7XG4gICAgcmV0dXJuICF4LnZhbHVlT2YoKTtcbiAgfVxuICBTLm5vdCA9IGRlZignbm90Jywge30sIFskLkJvb2xlYW4sICQuQm9vbGVhbl0sIG5vdCk7XG5cbiAgLy8jIGNvbXBsZW1lbnQgOjogKGEgLT4gQm9vbGVhbikgLT4gYSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gVGFrZXMgYSB1bmFyeSBwcmVkaWNhdGUgYW5kIGEgdmFsdWUgb2YgYW55IHR5cGUsIGFuZCByZXR1cm5zIHRoZSBsb2dpY2FsXG4gIC8vLiBuZWdhdGlvbiBvZiBhcHBseWluZyB0aGUgcHJlZGljYXRlIHRvIHRoZSB2YWx1ZS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYG5vdGBdKCNub3QpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gTnVtYmVyLmlzSW50ZWdlcig0MilcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMuY29tcGxlbWVudChOdW1iZXIuaXNJbnRlZ2VyLCA0MilcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gY29tcGxlbWVudChwcmVkLCB4KSB7XG4gICAgcmV0dXJuICFwcmVkKHgpO1xuICB9XG4gIFMuY29tcGxlbWVudCA9XG4gIGRlZignY29tcGxlbWVudCcsIHt9LCBbJC5QcmVkaWNhdGUoYSksIGEsICQuQm9vbGVhbl0sIGNvbXBsZW1lbnQpO1xuXG4gIC8vIyBpZkVsc2UgOjogKGEgLT4gQm9vbGVhbikgLT4gKGEgLT4gYikgLT4gKGEgLT4gYikgLT4gYSAtPiBiXG4gIC8vLlxuICAvLy4gVGFrZXMgYSB1bmFyeSBwcmVkaWNhdGUsIGEgdW5hcnkgXCJpZlwiIGZ1bmN0aW9uLCBhIHVuYXJ5IFwiZWxzZVwiXG4gIC8vLiBmdW5jdGlvbiwgYW5kIGEgdmFsdWUgb2YgYW55IHR5cGUsIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcbiAgLy8uIGFwcGx5aW5nIHRoZSBcImlmXCIgZnVuY3Rpb24gdG8gdGhlIHZhbHVlIGlmIHRoZSB2YWx1ZSBzYXRpc2ZpZXNcbiAgLy8uIHRoZSBwcmVkaWNhdGU7IHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIFwiZWxzZVwiIGZ1bmN0aW9uIHRvIHRoZVxuICAvLy4gdmFsdWUgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgd2hlbmBdKCN3aGVuKSBhbmQgW2B1bmxlc3NgXSgjdW5sZXNzKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuaWZFbHNlKHggPT4geCA8IDAsIE1hdGguYWJzLCBNYXRoLnNxcnQsIC0xKVxuICAvLy4gMVxuICAvLy5cbiAgLy8uID4gUy5pZkVsc2UoeCA9PiB4IDwgMCwgTWF0aC5hYnMsIE1hdGguc3FydCwgMTYpXG4gIC8vLiA0XG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gaWZFbHNlKHByZWQsIGYsIGcsIHgpIHtcbiAgICByZXR1cm4gcHJlZCh4KSA/IGYoeCkgOiBnKHgpO1xuICB9XG4gIFMuaWZFbHNlID1cbiAgZGVmKCdpZkVsc2UnLCB7fSwgWyQuUHJlZGljYXRlKGEpLCBGbihhLCBiKSwgRm4oYSwgYiksIGEsIGJdLCBpZkVsc2UpO1xuXG4gIC8vIyB3aGVuIDo6IChhIC0+IEJvb2xlYW4pIC0+IChhIC0+IGEpIC0+IGEgLT4gYVxuICAvLy5cbiAgLy8uIFRha2VzIGEgdW5hcnkgcHJlZGljYXRlLCBhIHVuYXJ5IGZ1bmN0aW9uLCBhbmQgYSB2YWx1ZSBvZiBhbnkgdHlwZSwgYW5kXG4gIC8vLiByZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGZ1bmN0aW9uIHRvIHRoZSB2YWx1ZSBpZiB0aGUgdmFsdWVcbiAgLy8uIHNhdGlzZmllcyB0aGUgcHJlZGljYXRlOyB0aGUgdmFsdWUgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgdW5sZXNzYF0oI3VubGVzcykgYW5kIFtgaWZFbHNlYF0oI2lmRWxzZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLndoZW4oeCA9PiB4ID49IDAsIE1hdGguc3FydCwgMTYpXG4gIC8vLiA0XG4gIC8vLlxuICAvLy4gPiBTLndoZW4oeCA9PiB4ID49IDAsIE1hdGguc3FydCwgLTEpXG4gIC8vLiAtMVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHdoZW4ocHJlZCwgZiwgeCkge1xuICAgIHJldHVybiBpZkVsc2UocHJlZCwgZiwgSSwgeCk7XG4gIH1cbiAgUy53aGVuID0gZGVmKCd3aGVuJywge30sIFskLlByZWRpY2F0ZShhKSwgRm4oYSwgYSksIGEsIGFdLCB3aGVuKTtcblxuICAvLyMgdW5sZXNzIDo6IChhIC0+IEJvb2xlYW4pIC0+IChhIC0+IGEpIC0+IGEgLT4gYVxuICAvLy5cbiAgLy8uIFRha2VzIGEgdW5hcnkgcHJlZGljYXRlLCBhIHVuYXJ5IGZ1bmN0aW9uLCBhbmQgYSB2YWx1ZSBvZiBhbnkgdHlwZSwgYW5kXG4gIC8vLiByZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGZ1bmN0aW9uIHRvIHRoZSB2YWx1ZSBpZiB0aGUgdmFsdWVcbiAgLy8uIGRvZXMgbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZTsgdGhlIHZhbHVlIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHdoZW5gXSgjd2hlbikgYW5kIFtgaWZFbHNlYF0oI2lmRWxzZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnVubGVzcyh4ID0+IHggPCAwLCBNYXRoLnNxcnQsIDE2KVxuICAvLy4gNFxuICAvLy5cbiAgLy8uID4gUy51bmxlc3MoeCA9PiB4IDwgMCwgTWF0aC5zcXJ0LCAtMSlcbiAgLy8uIC0xXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gdW5sZXNzKHByZWQsIGYsIHgpIHtcbiAgICByZXR1cm4gaWZFbHNlKHByZWQsIEksIGYsIHgpO1xuICB9XG4gIFMudW5sZXNzID0gZGVmKCd1bmxlc3MnLCB7fSwgWyQuUHJlZGljYXRlKGEpLCBGbihhLCBhKSwgYSwgYV0sIHVubGVzcyk7XG5cbiAgLy8jIGFsbFBhc3MgOjogRm9sZGFibGUgZiA9PiBmIChhIC0+IEJvb2xlYW4pIC0+IGEgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFRha2VzIGEgc3RydWN0dXJlIGNvbnRhaW5pbmcgemVybyBvciBtb3JlIHByZWRpY2F0ZXMsIGFuZCBhIHZhbHVlXG4gIC8vLiBvZiBhbnkgdHlwZS4gUmV0dXJucyBgdHJ1ZWAgW2lmZl1bXSB0aGUgdmFsdWUgc2F0aXNmaWVzIGFsbCBvZiB0aGVcbiAgLy8uIHByZWRpY2F0ZXMuIE5vbmUgb2YgdGhlIHN1YnNlcXVlbnQgcHJlZGljYXRlcyB3aWxsIGJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8uIHRoZSBmaXJzdCBwcmVkaWNhdGUgbm90IHNhdGlzZmllZC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYWxsUGFzcyhbUy50ZXN0KC9xLyksIFMudGVzdCgvdS8pLCBTLnRlc3QoL2kvKV0sICdxdWllc3NlbmNlJylcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMuYWxsUGFzcyhbUy50ZXN0KC9xLyksIFMudGVzdCgvdS8pLCBTLnRlc3QoL2kvKV0sICdmaXNzaXBhcm91cycpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGFsbFBhc3MocHJlZHMsIHgpIHtcbiAgICByZXR1cm4gWi5yZWR1Y2UoZnVuY3Rpb24oYiwgcCkgeyByZXR1cm4gYiAmJiBwKHgpOyB9LCB0cnVlLCBwcmVkcyk7XG4gIH1cbiAgUy5hbGxQYXNzID1cbiAgZGVmKCdhbGxQYXNzJyxcbiAgICAgIHtmOiBbWi5Gb2xkYWJsZV19LFxuICAgICAgW2YoJC5QcmVkaWNhdGUoYSkpLCBhLCAkLkJvb2xlYW5dLFxuICAgICAgYWxsUGFzcyk7XG5cbiAgLy8jIGFueVBhc3MgOjogRm9sZGFibGUgZiA9PiBmIChhIC0+IEJvb2xlYW4pIC0+IGEgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFRha2VzIGEgc3RydWN0dXJlIGNvbnRhaW5pbmcgemVybyBvciBtb3JlIHByZWRpY2F0ZXMsIGFuZCBhIHZhbHVlXG4gIC8vLiBvZiBhbnkgdHlwZS4gUmV0dXJucyBgdHJ1ZWAgW2lmZl1bXSB0aGUgdmFsdWUgc2F0aXNmaWVzIGFueSBvZiB0aGVcbiAgLy8uIHByZWRpY2F0ZXMuIE5vbmUgb2YgdGhlIHN1YnNlcXVlbnQgcHJlZGljYXRlcyB3aWxsIGJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8uIHRoZSBmaXJzdCBwcmVkaWNhdGUgc2F0aXNmaWVkLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5hbnlQYXNzKFtTLnRlc3QoL3EvKSwgUy50ZXN0KC91LyksIFMudGVzdCgvaS8pXSwgJ2luY2FuZGVzY2VudCcpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLmFueVBhc3MoW1MudGVzdCgvcS8pLCBTLnRlc3QoL3UvKSwgUy50ZXN0KC9pLyldLCAnZW1wYXRoeScpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGFueVBhc3MocHJlZHMsIHgpIHtcbiAgICByZXR1cm4gWi5yZWR1Y2UoZnVuY3Rpb24oYiwgcCkgeyByZXR1cm4gYiB8fCBwKHgpOyB9LCBmYWxzZSwgcHJlZHMpO1xuICB9XG4gIFMuYW55UGFzcyA9XG4gIGRlZignYW55UGFzcycsXG4gICAgICB7ZjogW1ouRm9sZGFibGVdfSxcbiAgICAgIFtmKCQuUHJlZGljYXRlKGEpKSwgYSwgJC5Cb29sZWFuXSxcbiAgICAgIGFueVBhc3MpO1xuXG4gIC8vLiAjIyMgTGlzdFxuICAvLy5cbiAgLy8uIFRoZSBMaXN0IHR5cGUgY29uc3RydWN0b3IgZW5hYmxlcyB0eXBlIHNpZ25hdHVyZXMgdG8gZGVzY3JpYmUgYWQgaG9jXG4gIC8vLiBwb2x5bW9ycGhpYyBmdW5jdGlvbnMgd2hpY2ggb3BlcmF0ZSBvbiBlaXRoZXIgW2BBcnJheWBdWyQuQXJyYXldIG9yXG4gIC8vLiBbYFN0cmluZ2BdWyQuU3RyaW5nXSB2YWx1ZXMuXG4gIC8vLlxuICAvLy4gTWVudGFsIGd5bW5hc3RpY3MgYXJlIHJlcXVpcmVkIHRvIHRyZWF0IGFycmF5cyBhbmQgc3RyaW5ncyBzaW1pbGFybHkuXG4gIC8vLiBgWzEsIDIsIDNdYCBpcyBhIGxpc3QgY29udGFpbmluZyBgMWAsIGAyYCwgYW5kIGAzYC4gYCdhYmMnYCBpcyBhIGxpc3RcbiAgLy8uIGNvbnRhaW5pbmcgYCdhJ2AsIGAnYidgLCBhbmQgYCdjJ2AuIEJ1dCB3aGF0IGlzIHRoZSB0eXBlIG9mIGAnYSdgP1xuICAvLy4gYFN0cmluZ2AsIHNpbmNlIEphdmFTY3JpcHQgaGFzIG5vIENoYXIgdHlwZSEgVGh1czpcbiAgLy8uXG4gIC8vLiAgICAgJ2FiYycgOjogU3RyaW5nLCBMaXN0IFN0cmluZywgTGlzdCAoTGlzdCBTdHJpbmcpLCAuLi5cbiAgLy8uXG4gIC8vLiBFdmVyeSBtZW1iZXIgb2YgYFN0cmluZ2AgaXMgYWxzbyBhIG1lbWJlciBvZiBgTGlzdCBTdHJpbmdgIVxuXG4gIC8vIyBzbGljZSA6OiBJbnRlZ2VyIC0+IEludGVnZXIgLT4gTGlzdCBhIC0+IE1heWJlIChMaXN0IGEpXG4gIC8vLlxuICAvLy4gUmV0dXJucyBKdXN0IGEgbGlzdCBjb250YWluaW5nIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBzdXBwbGllZCBsaXN0XG4gIC8vLiBmcm9tIGEgYmVnaW5uaW5nIGluZGV4IChpbmNsdXNpdmUpIHRvIGFuIGVuZCBpbmRleCAoZXhjbHVzaXZlKS5cbiAgLy8uIFJldHVybnMgTm90aGluZyB1bmxlc3MgdGhlIHN0YXJ0IGludGVydmFsIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0b1xuICAvLy4gdGhlIGVuZCBpbnRlcnZhbCwgYW5kIHRoZSBsaXN0IGNvbnRhaW5zIGJvdGggKGhhbGYtb3BlbikgaW50ZXJ2YWxzLlxuICAvLy4gQWNjZXB0cyBuZWdhdGl2ZSBpbmRpY2VzLCB3aGljaCBpbmRpY2F0ZSBhbiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mXG4gIC8vLiB0aGUgbGlzdC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHRha2VgXSgjdGFrZSksIFtgZHJvcGBdKCNkcm9wKSwgW2B0YWtlTGFzdGBdKCN0YWtlTGFzdCksXG4gIC8vLiBhbmQgW2Bkcm9wTGFzdGBdKCNkcm9wTGFzdCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnNsaWNlKDEsIDMsIFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10pXG4gIC8vLiBKdXN0KFsnYicsICdjJ10pXG4gIC8vLlxuICAvLy4gPiBTLnNsaWNlKC0zLCAtMSwgWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSlcbiAgLy8uIEp1c3QoWydjJywgJ2QnXSlcbiAgLy8uXG4gIC8vLiA+IFMuc2xpY2UoMSwgNiwgWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMuc2xpY2UoMiwgNiwgJ2JhbmFuYScpXG4gIC8vLiBKdXN0KCduYW5hJylcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kLCB4cykge1xuICAgIHZhciBsZW4gPSB4cy5sZW5ndGg7XG4gICAgdmFyIGZyb21JZHggPSBzdGFydCA8IDAgPyBzdGFydCArIGxlbiA6IHN0YXJ0O1xuICAgIHZhciB0b0lkeCA9IGVuZCA8IDAgPyBlbmQgKyBsZW4gOiBlbmQ7XG5cbiAgICByZXR1cm4gTWF0aC5hYnMoc3RhcnQpIDw9IGxlbiAmJiBNYXRoLmFicyhlbmQpIDw9IGxlbiAmJiBmcm9tSWR4IDw9IHRvSWR4ID9cbiAgICAgIEp1c3QoeHMuc2xpY2UoZnJvbUlkeCwgdG9JZHgpKSA6XG4gICAgICBOb3RoaW5nO1xuICB9XG4gIFMuc2xpY2UgPVxuICBkZWYoJ3NsaWNlJywge30sIFskLkludGVnZXIsICQuSW50ZWdlciwgTGlzdChhKSwgJE1heWJlKExpc3QoYSkpXSwgc2xpY2UpO1xuXG4gIC8vIyBhdCA6OiBJbnRlZ2VyIC0+IExpc3QgYSAtPiBNYXliZSBhXG4gIC8vLlxuICAvLy4gVGFrZXMgYW4gaW5kZXggYW5kIGEgbGlzdCBhbmQgcmV0dXJucyBKdXN0IHRoZSBlbGVtZW50IG9mIHRoZSBsaXN0IGF0XG4gIC8vLiB0aGUgaW5kZXggaWYgdGhlIGluZGV4IGlzIHdpdGhpbiB0aGUgbGlzdCdzIGJvdW5kczsgTm90aGluZyBvdGhlcndpc2UuXG4gIC8vLiBBIG5lZ2F0aXZlIGluZGV4IHJlcHJlc2VudHMgYW4gb2Zmc2V0IGZyb20gdGhlIGxlbmd0aCBvZiB0aGUgbGlzdC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYXQoMiwgWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSlcbiAgLy8uIEp1c3QoJ2MnKVxuICAvLy5cbiAgLy8uID4gUy5hdCg1LCBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5hdCgtMiwgWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSlcbiAgLy8uIEp1c3QoJ2QnKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGF0KG4sIHhzKSB7XG4gICAgdmFyIGlkeCA9IG4gPCAwID8geHMubGVuZ3RoICsgbiA6IG47XG4gICAgcmV0dXJuIGlkeCA8IDAgfHwgaWR4ID49IHhzLmxlbmd0aCA/IE5vdGhpbmcgOiBKdXN0KHhzW2lkeF0pO1xuICB9XG4gIFMuYXQgPSBkZWYoJ2F0Jywge30sIFskLkludGVnZXIsIExpc3QoYSksICRNYXliZShhKV0sIGF0KTtcblxuICAvLyMgaGVhZCA6OiBMaXN0IGEgLT4gTWF5YmUgYVxuICAvLy5cbiAgLy8uIFRha2VzIGEgbGlzdCBhbmQgcmV0dXJucyBKdXN0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBsaXN0IGlmIHRoZVxuICAvLy4gbGlzdCBjb250YWlucyBhdCBsZWFzdCBvbmUgZWxlbWVudDsgTm90aGluZyBpZiB0aGUgbGlzdCBpcyBlbXB0eS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuaGVhZChbMSwgMiwgM10pXG4gIC8vLiBKdXN0KDEpXG4gIC8vLlxuICAvLy4gPiBTLmhlYWQoW10pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gaGVhZCh4cykge1xuICAgIHJldHVybiBhdCgwLCB4cyk7XG4gIH1cbiAgUy5oZWFkID0gZGVmKCdoZWFkJywge30sIFtMaXN0KGEpLCAkTWF5YmUoYSldLCBoZWFkKTtcblxuICAvLyMgbGFzdCA6OiBMaXN0IGEgLT4gTWF5YmUgYVxuICAvLy5cbiAgLy8uIFRha2VzIGEgbGlzdCBhbmQgcmV0dXJucyBKdXN0IHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxpc3QgaWYgdGhlXG4gIC8vLiBsaXN0IGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBlbGVtZW50OyBOb3RoaW5nIGlmIHRoZSBsaXN0IGlzIGVtcHR5LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5sYXN0KFsxLCAyLCAzXSlcbiAgLy8uIEp1c3QoMylcbiAgLy8uXG4gIC8vLiA+IFMubGFzdChbXSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBsYXN0KHhzKSB7XG4gICAgcmV0dXJuIGF0KC0xLCB4cyk7XG4gIH1cbiAgUy5sYXN0ID0gZGVmKCdsYXN0Jywge30sIFtMaXN0KGEpLCAkTWF5YmUoYSldLCBsYXN0KTtcblxuICAvLyMgdGFpbCA6OiBMaXN0IGEgLT4gTWF5YmUgKExpc3QgYSlcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIGxpc3QgYW5kIHJldHVybnMgSnVzdCBhIGxpc3QgY29udGFpbmluZyBhbGwgYnV0IHRoZSBmaXJzdFxuICAvLy4gb2YgdGhlIGxpc3QncyBlbGVtZW50cyBpZiB0aGUgbGlzdCBjb250YWlucyBhdCBsZWFzdCBvbmUgZWxlbWVudDtcbiAgLy8uIE5vdGhpbmcgaWYgdGhlIGxpc3QgaXMgZW1wdHkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRhaWwoWzEsIDIsIDNdKVxuICAvLy4gSnVzdChbMiwgM10pXG4gIC8vLlxuICAvLy4gPiBTLnRhaWwoW10pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gdGFpbCh4cykge1xuICAgIHJldHVybiB4cy5sZW5ndGggPiAwID8gSnVzdCh4cy5zbGljZSgxKSkgOiBOb3RoaW5nO1xuICB9XG4gIFMudGFpbCA9IGRlZigndGFpbCcsIHt9LCBbTGlzdChhKSwgJE1heWJlKExpc3QoYSkpXSwgdGFpbCk7XG5cbiAgLy8jIGluaXQgOjogTGlzdCBhIC0+IE1heWJlIChMaXN0IGEpXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBsaXN0IGFuZCByZXR1cm5zIEp1c3QgYSBsaXN0IGNvbnRhaW5pbmcgYWxsIGJ1dCB0aGUgbGFzdFxuICAvLy4gb2YgdGhlIGxpc3QncyBlbGVtZW50cyBpZiB0aGUgbGlzdCBjb250YWlucyBhdCBsZWFzdCBvbmUgZWxlbWVudDtcbiAgLy8uIE5vdGhpbmcgaWYgdGhlIGxpc3QgaXMgZW1wdHkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmluaXQoWzEsIDIsIDNdKVxuICAvLy4gSnVzdChbMSwgMl0pXG4gIC8vLlxuICAvLy4gPiBTLmluaXQoW10pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gaW5pdCh4cykge1xuICAgIHJldHVybiB4cy5sZW5ndGggPiAwID8gSnVzdCh4cy5zbGljZSgwLCAtMSkpIDogTm90aGluZztcbiAgfVxuICBTLmluaXQgPSBkZWYoJ2luaXQnLCB7fSwgW0xpc3QoYSksICRNYXliZShMaXN0KGEpKV0sIGluaXQpO1xuXG4gIC8vIyB0YWtlIDo6IEludGVnZXIgLT4gTGlzdCBhIC0+IE1heWJlIChMaXN0IGEpXG4gIC8vLlxuICAvLy4gUmV0dXJucyBKdXN0IHRoZSBmaXJzdCBOIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBjb2xsZWN0aW9uIGlmIE4gaXNcbiAgLy8uIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGxlbmd0aFxuICAvLy4gb2YgdGhlIGNvbGxlY3Rpb247IE5vdGhpbmcgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy50YWtlKDIsIFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10pXG4gIC8vLiBKdXN0KFsnYScsICdiJ10pXG4gIC8vLlxuICAvLy4gPiBTLnRha2UoNCwgJ2FiY2RlZmcnKVxuICAvLy4gSnVzdCgnYWJjZCcpXG4gIC8vLlxuICAvLy4gPiBTLnRha2UoNCwgWydhJywgJ2InLCAnYyddKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHRha2UobiwgeHMpIHtcbiAgICByZXR1cm4gbiA8IDAgfHwgbiA+IHhzLmxlbmd0aCA/IE5vdGhpbmcgOiBKdXN0KHhzLnNsaWNlKDAsIG4pKTtcbiAgfVxuICBTLnRha2UgPSBkZWYoJ3Rha2UnLCB7fSwgWyQuSW50ZWdlciwgTGlzdChhKSwgJE1heWJlKExpc3QoYSkpXSwgdGFrZSk7XG5cbiAgLy8jIHRha2VMYXN0IDo6IEludGVnZXIgLT4gTGlzdCBhIC0+IE1heWJlIChMaXN0IGEpXG4gIC8vLlxuICAvLy4gUmV0dXJucyBKdXN0IHRoZSBsYXN0IE4gZWxlbWVudHMgb2YgdGhlIGdpdmVuIGNvbGxlY3Rpb24gaWYgTiBpc1xuICAvLy4gZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHplcm8gYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgbGVuZ3RoXG4gIC8vLiBvZiB0aGUgY29sbGVjdGlvbjsgTm90aGluZyBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRha2VMYXN0KDIsIFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10pXG4gIC8vLiBKdXN0KFsnZCcsICdlJ10pXG4gIC8vLlxuICAvLy4gPiBTLnRha2VMYXN0KDQsICdhYmNkZWZnJylcbiAgLy8uIEp1c3QoJ2RlZmcnKVxuICAvLy5cbiAgLy8uID4gUy50YWtlTGFzdCg0LCBbJ2EnLCAnYicsICdjJ10pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gdGFrZUxhc3QobiwgeHMpIHtcbiAgICByZXR1cm4gbiA8IDAgfHwgbiA+IHhzLmxlbmd0aCA/IE5vdGhpbmcgOiBKdXN0KHhzLnNsaWNlKHhzLmxlbmd0aCAtIG4pKTtcbiAgfVxuICBTLnRha2VMYXN0ID1cbiAgZGVmKCd0YWtlTGFzdCcsIHt9LCBbJC5JbnRlZ2VyLCBMaXN0KGEpLCAkTWF5YmUoTGlzdChhKSldLCB0YWtlTGFzdCk7XG5cbiAgLy8jIGRyb3AgOjogSW50ZWdlciAtPiBMaXN0IGEgLT4gTWF5YmUgKExpc3QgYSlcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIEp1c3QgYWxsIGJ1dCB0aGUgZmlyc3QgTiBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gY29sbGVjdGlvblxuICAvLy4gaWYgTiBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gemVybyBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZVxuICAvLy4gbGVuZ3RoIG9mIHRoZSBjb2xsZWN0aW9uOyBOb3RoaW5nIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZHJvcCgyLCBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddKVxuICAvLy4gSnVzdChbJ2MnLCAnZCcsICdlJ10pXG4gIC8vLlxuICAvLy4gPiBTLmRyb3AoNCwgJ2FiY2RlZmcnKVxuICAvLy4gSnVzdCgnZWZnJylcbiAgLy8uXG4gIC8vLiA+IFMuZHJvcCg0LCAnYWJjJylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBkcm9wKG4sIHhzKSB7XG4gICAgcmV0dXJuIG4gPCAwIHx8IG4gPiB4cy5sZW5ndGggPyBOb3RoaW5nIDogSnVzdCh4cy5zbGljZShuKSk7XG4gIH1cbiAgUy5kcm9wID0gZGVmKCdkcm9wJywge30sIFskLkludGVnZXIsIExpc3QoYSksICRNYXliZShMaXN0KGEpKV0sIGRyb3ApO1xuXG4gIC8vIyBkcm9wTGFzdCA6OiBJbnRlZ2VyIC0+IExpc3QgYSAtPiBNYXliZSAoTGlzdCBhKVxuICAvLy5cbiAgLy8uIFJldHVybnMgSnVzdCBhbGwgYnV0IHRoZSBsYXN0IE4gZWxlbWVudHMgb2YgdGhlIGdpdmVuIGNvbGxlY3Rpb25cbiAgLy8uIGlmIE4gaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHplcm8gYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGVcbiAgLy8uIGxlbmd0aCBvZiB0aGUgY29sbGVjdGlvbjsgTm90aGluZyBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmRyb3BMYXN0KDIsIFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10pXG4gIC8vLiBKdXN0KFsnYScsICdiJywgJ2MnXSlcbiAgLy8uXG4gIC8vLiA+IFMuZHJvcExhc3QoNCwgJ2FiY2RlZmcnKVxuICAvLy4gSnVzdCgnYWJjJylcbiAgLy8uXG4gIC8vLiA+IFMuZHJvcExhc3QoNCwgJ2FiYycpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZHJvcExhc3QobiwgeHMpIHtcbiAgICByZXR1cm4gbiA8IDAgfHwgbiA+IHhzLmxlbmd0aCA/IE5vdGhpbmcgOiBKdXN0KHhzLnNsaWNlKDAsIHhzLmxlbmd0aCAtIG4pKTtcbiAgfVxuICBTLmRyb3BMYXN0ID1cbiAgZGVmKCdkcm9wTGFzdCcsIHt9LCBbJC5JbnRlZ2VyLCBMaXN0KGEpLCAkTWF5YmUoTGlzdChhKSldLCBkcm9wTGFzdCk7XG5cbiAgLy8uICMjIyBBcnJheVxuXG4gIC8vIyBzaXplIDo6IEZvbGRhYmxlIGYgPT4gZiBhIC0+IEludGVnZXJcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHN0cnVjdHVyZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuc2l6ZShbXSlcbiAgLy8uIDBcbiAgLy8uXG4gIC8vLiA+IFMuc2l6ZShbJ2ZvbycsICdiYXInLCAnYmF6J10pXG4gIC8vLiAzXG4gIC8vLlxuICAvLy4gPiBTLnNpemUoTmlsKVxuICAvLy4gMFxuICAvLy5cbiAgLy8uID4gUy5zaXplKENvbnMoJ2ZvbycsIENvbnMoJ2JhcicsIENvbnMoJ2JheicsIE5pbCkpKSlcbiAgLy8uIDNcbiAgLy8uXG4gIC8vLiA+IFMuc2l6ZShTLk5vdGhpbmcpXG4gIC8vLiAwXG4gIC8vLlxuICAvLy4gPiBTLnNpemUoUy5KdXN0KCdxdXV4JykpXG4gIC8vLiAxXG4gIC8vLiBgYGBcbiAgUy5zaXplID0gZGVmKCdzaXplJywge2Y6IFtaLkZvbGRhYmxlXX0sIFtmKGEpLCAkLkludGVnZXJdLCBaLnNpemUpO1xuXG4gIC8vIyBhcHBlbmQgOjogKEFwcGxpY2F0aXZlIGYsIFNlbWlncm91cCAoZiBhKSkgPT4gYSAtPiBmIGEgLT4gZiBhXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFwcGVuZGluZyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHNlY29uZC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHByZXBlbmRgXSgjcHJlcGVuZCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmFwcGVuZCgzLCBbMSwgMl0pXG4gIC8vLiBbMSwgMiwgM11cbiAgLy8uXG4gIC8vLiA+IFMuYXBwZW5kKDMsIENvbnMoMSwgQ29ucygyLCBOaWwpKSlcbiAgLy8uIENvbnMoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKVxuICAvLy5cbiAgLy8uID4gUy5hcHBlbmQoWzFdLCBTLk5vdGhpbmcpXG4gIC8vLiBKdXN0KFsxXSlcbiAgLy8uXG4gIC8vLiA+IFMuYXBwZW5kKFszXSwgUy5KdXN0KFsxLCAyXSkpXG4gIC8vLiBKdXN0KFsxLCAyLCAzXSlcbiAgLy8uIGBgYFxuICBTLmFwcGVuZCA9XG4gIGRlZignYXBwZW5kJyxcbiAgICAgIHtmOiBbWi5BcHBsaWNhdGl2ZSwgWi5TZW1pZ3JvdXBdfSxcbiAgICAgIFthLCBmKGEpLCBmKGEpXSxcbiAgICAgIFouYXBwZW5kKTtcblxuICAvLyMgcHJlcGVuZCA6OiAoQXBwbGljYXRpdmUgZiwgU2VtaWdyb3VwIChmIGEpKSA9PiBhIC0+IGYgYSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgcHJlcGVuZGluZyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHNlY29uZC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGFwcGVuZGBdKCNhcHBlbmQpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5wcmVwZW5kKDEsIFsyLCAzXSlcbiAgLy8uIFsxLCAyLCAzXVxuICAvLy5cbiAgLy8uID4gUy5wcmVwZW5kKDEsIENvbnMoMiwgQ29ucygzLCBOaWwpKSlcbiAgLy8uIENvbnMoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKVxuICAvLy5cbiAgLy8uID4gUy5wcmVwZW5kKFsxXSwgUy5Ob3RoaW5nKVxuICAvLy4gSnVzdChbMV0pXG4gIC8vLlxuICAvLy4gPiBTLnByZXBlbmQoWzFdLCBTLkp1c3QoWzIsIDNdKSlcbiAgLy8uIEp1c3QoWzEsIDIsIDNdKVxuICAvLy4gYGBgXG4gIFMucHJlcGVuZCA9XG4gIGRlZigncHJlcGVuZCcsXG4gICAgICB7ZjogW1ouQXBwbGljYXRpdmUsIFouU2VtaWdyb3VwXX0sXG4gICAgICBbYSwgZihhKSwgZihhKV0sXG4gICAgICBaLnByZXBlbmQpO1xuXG4gIC8vIyBqb2luV2l0aCA6OiBTdHJpbmcgLT4gQXJyYXkgU3RyaW5nIC0+IFN0cmluZ1xuICAvLy5cbiAgLy8uIEpvaW5zIHRoZSBzdHJpbmdzIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQgc2VwYXJhdGVkIGJ5IHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgLy8uXG4gIC8vLiBQcm9wZXJ0aWVzOlxuICAvLy5cbiAgLy8uICAgLSBgZm9yYWxsIHMgOjogU3RyaW5nLCB0IDo6IFN0cmluZy4gUy5qb2luV2l0aChzLCBTLnNwbGl0T24ocywgdCkpID0gdGBcbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHNwbGl0T25gXSgjc3BsaXRPbikuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmpvaW5XaXRoKCc6JywgWydmb28nLCAnYmFyJywgJ2JheiddKVxuICAvLy4gJ2ZvbzpiYXI6YmF6J1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGpvaW5XaXRoKHNlcGFyYXRvciwgc3MpIHtcbiAgICByZXR1cm4gc3Muam9pbihzZXBhcmF0b3IpO1xuICB9XG4gIFMuam9pbldpdGggPVxuICBkZWYoJ2pvaW5XaXRoJywge30sIFskLlN0cmluZywgJC5BcnJheSgkLlN0cmluZyksICQuU3RyaW5nXSwgam9pbldpdGgpO1xuXG4gIC8vIyBlbGVtIDo6IChTZXRvaWQgYSwgRm9sZGFibGUgZikgPT4gYSAtPiBmIGEgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFRha2VzIGEgdmFsdWUgYW5kIGEgc3RydWN0dXJlIGFuZCByZXR1cm5zIGB0cnVlYCBbaWZmXVtdIHRoZSB2YWx1ZSBpcyBhblxuICAvLy4gZWxlbWVudCBvZiB0aGUgc3RydWN0dXJlLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZmluZGBdKCNmaW5kKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZWxlbSgnYycsIFsnYScsICdiJywgJ2MnXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMuZWxlbSgneCcsIFsnYScsICdiJywgJ2MnXSlcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBTLmVsZW0oMywge3g6IDEsIHk6IDIsIHo6IDN9KVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5lbGVtKDgsIHt4OiAxLCB5OiAyLCB6OiAzfSlcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBTLmVsZW0oMCwgUy5KdXN0KDApKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5lbGVtKDAsIFMuSnVzdCgxKSlcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBTLmVsZW0oMCwgUy5Ob3RoaW5nKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICBTLmVsZW0gPVxuICBkZWYoJ2VsZW0nLCB7YTogW1ouU2V0b2lkXSwgZjogW1ouRm9sZGFibGVdfSwgW2EsIGYoYSksICQuQm9vbGVhbl0sIFouZWxlbSk7XG5cbiAgLy8jIGZpbmQgOjogRm9sZGFibGUgZiA9PiAoYSAtPiBCb29sZWFuKSAtPiBmIGEgLT4gTWF5YmUgYVxuICAvLy5cbiAgLy8uIFRha2VzIGEgcHJlZGljYXRlIGFuZCBhIHN0cnVjdHVyZSBhbmQgcmV0dXJucyBKdXN0IHRoZSBsZWZ0bW9zdCBlbGVtZW50XG4gIC8vLiBvZiB0aGUgc3RydWN0dXJlIHdoaWNoIHNhdGlzZmllcyB0aGUgcHJlZGljYXRlOyBOb3RoaW5nIGlmIHRoZXJlIGlzIG5vXG4gIC8vLiBzdWNoIGVsZW1lbnQuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BlbGVtYF0oI2VsZW0pLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5maW5kKG4gPT4gbiA8IDAsIFsxLCAtMiwgMywgLTQsIDVdKVxuICAvLy4gSnVzdCgtMilcbiAgLy8uXG4gIC8vLiA+IFMuZmluZChuID0+IG4gPCAwLCBbMSwgMiwgMywgNCwgNV0pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZmluZChwcmVkLCB4cykge1xuICAgIHJldHVybiBaLnJlZHVjZShcbiAgICAgIGZ1bmN0aW9uKG0sIHgpIHsgcmV0dXJuIG0uaXNKdXN0ID8gbSA6IHByZWQoeCkgPyBKdXN0KHgpIDogTm90aGluZzsgfSxcbiAgICAgIE5vdGhpbmcsXG4gICAgICB4c1xuICAgICk7XG4gIH1cbiAgUy5maW5kID1cbiAgZGVmKCdmaW5kJywge2Y6IFtaLkZvbGRhYmxlXX0sIFskLlByZWRpY2F0ZShhKSwgZihhKSwgJE1heWJlKGEpXSwgZmluZCk7XG5cbiAgLy8jIHBsdWNrIDo6IEZ1bmN0b3IgZiA9PiBTdHJpbmcgLT4gZiBhIC0+IGYgYlxuICAvLy5cbiAgLy8uIENvbWJpbmVzIFtgbWFwYF0oI21hcCkgYW5kIFtgcHJvcGBdKCNwcm9wKS4gYHBsdWNrKGssIHhzKWAgaXMgZXF1aXZhbGVudFxuICAvLy4gdG8gYG1hcChwcm9wKGspLCB4cylgLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5wbHVjaygneCcsIFt7eDogMX0sIHt4OiAyfSwge3g6IDN9XSlcbiAgLy8uIFsxLCAyLCAzXVxuICAvLy5cbiAgLy8uID4gUy5wbHVjaygneCcsIFMuSnVzdCh7eDogMSwgeTogMiwgejogM30pKVxuICAvLy4gSnVzdCgxKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHBsdWNrKGtleSwgeHMpIHtcbiAgICByZXR1cm4gWi5tYXAoZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIG9iaiA9IHRvT2JqZWN0KHgpO1xuICAgICAgaWYgKGtleSBpbiBvYmopIHJldHVybiBvYmpba2V5XTtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ+KAmHBsdWNr4oCZIGV4cGVjdGVkIG9iamVjdCB0byBoYXZlIGEgcHJvcGVydHkgbmFtZWQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICfigJgnICsga2V5ICsgJ+KAmTsgJyArIFoudG9TdHJpbmcoeCkgKyAnIGRvZXMgbm90Jyk7XG4gICAgfSwgeHMpO1xuICB9XG4gIFMucGx1Y2sgPSBkZWYoJ3BsdWNrJywge2Y6IFtaLkZ1bmN0b3JdfSwgWyQuU3RyaW5nLCBmKGEpLCBmKGIpXSwgcGx1Y2spO1xuXG4gIC8vIyB1bmZvbGRyIDo6IChiIC0+IE1heWJlIChQYWlyIGEgYikpIC0+IGIgLT4gQXJyYXkgYVxuICAvLy5cbiAgLy8uIFRha2VzIGEgZnVuY3Rpb24gYW5kIGEgc2VlZCB2YWx1ZSwgYW5kIHJldHVybnMgYW4gYXJyYXkgZ2VuZXJhdGVkIGJ5XG4gIC8vLiBhcHBseWluZyB0aGUgZnVuY3Rpb24gcmVwZWF0ZWRseS4gVGhlIGFycmF5IGlzIGluaXRpYWxseSBlbXB0eS4gVGhlXG4gIC8vLiBmdW5jdGlvbiBpcyBpbml0aWFsbHkgYXBwbGllZCB0byB0aGUgc2VlZCB2YWx1ZS4gRWFjaCBhcHBsaWNhdGlvblxuICAvLy4gb2YgdGhlIGZ1bmN0aW9uIHNob3VsZCByZXN1bHQgaW4gZWl0aGVyOlxuICAvLy5cbiAgLy8uICAgLSBOb3RoaW5nLCBpbiB3aGljaCBjYXNlIHRoZSBhcnJheSBpcyByZXR1cm5lZDsgb3JcbiAgLy8uXG4gIC8vLiAgIC0gSnVzdCBhIHBhaXIsIGluIHdoaWNoIGNhc2UgdGhlIGZpcnN0IGVsZW1lbnQgaXMgYXBwZW5kZWQgdG9cbiAgLy8uICAgICB0aGUgYXJyYXkgYW5kIHRoZSBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIHRoZSBzZWNvbmQgZWxlbWVudC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMudW5mb2xkcihuID0+IG4gPCA1ID8gUy5KdXN0KFtuLCBuICsgMV0pIDogUy5Ob3RoaW5nLCAxKVxuICAvLy4gWzEsIDIsIDMsIDRdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gdW5mb2xkcihmLCB4KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIG0gPSBmKHgpOyBtLmlzSnVzdDsgbSA9IGYobS52YWx1ZVsxXSkpIHJlc3VsdC5wdXNoKG0udmFsdWVbMF0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgUy51bmZvbGRyID1cbiAgZGVmKCd1bmZvbGRyJywge30sIFtGbihiLCAkTWF5YmUoJC5QYWlyKGEsIGIpKSksIGIsICQuQXJyYXkoYSldLCB1bmZvbGRyKTtcblxuICAvLyMgcmFuZ2UgOjogSW50ZWdlciAtPiBJbnRlZ2VyIC0+IEFycmF5IEludGVnZXJcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGFuIGFycmF5IG9mIGNvbnNlY3V0aXZlIGludGVnZXJzIHN0YXJ0aW5nIHdpdGggdGhlIGZpcnN0IGFyZ3VtZW50XG4gIC8vLiBhbmQgZW5kaW5nIHdpdGggdGhlIHNlY29uZCBhcmd1bWVudCBtaW51cyBvbmUuIFJldHVybnMgYFtdYCBpZiB0aGUgc2Vjb25kXG4gIC8vLiBhcmd1bWVudCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5yYW5nZSgwLCAxMClcbiAgLy8uIFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XVxuICAvLy5cbiAgLy8uID4gUy5yYW5nZSgtNSwgMClcbiAgLy8uIFstNSwgLTQsIC0zLCAtMiwgLTFdXG4gIC8vLlxuICAvLy4gPiBTLnJhbmdlKDAsIC01KVxuICAvLy4gW11cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiByYW5nZShmcm9tLCB0bykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBuID0gZnJvbTsgbiA8IHRvOyBuICs9IDEpIHJlc3VsdC5wdXNoKG4pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgUy5yYW5nZSA9XG4gIGRlZigncmFuZ2UnLCB7fSwgWyQuSW50ZWdlciwgJC5JbnRlZ2VyLCAkLkFycmF5KCQuSW50ZWdlcildLCByYW5nZSk7XG5cbiAgLy8jIGdyb3VwQnkgOjogKGEgLT4gYSAtPiBCb29sZWFuKSAtPiBBcnJheSBhIC0+IEFycmF5IChBcnJheSBhKVxuICAvLy5cbiAgLy8uIFNwbGl0cyBpdHMgYXJyYXkgYXJndW1lbnQgaW50byBhbiBhcnJheSBvZiBhcnJheXMgb2YgZXF1YWwsXG4gIC8vLiBhZGphY2VudCBlbGVtZW50cy4gRXF1YWxpdHkgaXMgZGV0ZXJtaW5lZCBieSB0aGUgZnVuY3Rpb25cbiAgLy8uIHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudC4gSXRzIGJlaGF2aW91ciBjYW4gYmUgc3VycHJpc2luZ1xuICAvLy4gZm9yIGZ1bmN0aW9ucyB0aGF0IGFyZW4ndCByZWZsZXhpdmUsIHRyYW5zaXRpdmUsIGFuZCBzeW1tZXRyaWNcbiAgLy8uIChzZWUgW2VxdWl2YWxlbmNlXVtdIHJlbGF0aW9uKS5cbiAgLy8uXG4gIC8vLiBQcm9wZXJ0aWVzOlxuICAvLy5cbiAgLy8uICAgLSBgZm9yYWxsIGYgOjogYSAtPiBhIC0+IEJvb2xlYW4sIHhzIDo6IEFycmF5IGEuXG4gIC8vLiAgICAgIFMuam9pbihTLmdyb3VwQnkoZiwgeHMpKSA9IHhzYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5ncm91cEJ5KFMuZXF1YWxzLCBbMSwgMSwgMiwgMSwgMV0pXG4gIC8vLiBbWzEsIDFdLCBbMl0sIFsxLCAxXV1cbiAgLy8uXG4gIC8vLiA+IFMuZ3JvdXBCeSh4ID0+IHkgPT4geCArIHkgPT09IDAsIFsyLCAtMywgMywgMywgMywgNCwgLTQsIDRdKVxuICAvLy4gW1syXSwgWy0zLCAzLCAzLCAzXSwgWzQsIC00XSwgWzRdXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGdyb3VwQnkoZiwgeHMpIHtcbiAgICBpZiAoeHMubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG4gICAgdmFyIHgwID0geHNbMF07ICAgICAgICAgLy8gOjogYVxuICAgIHZhciBhY3RpdmUgPSBbeDBdOyAgICAgIC8vIDo6IEFycmF5IGFcbiAgICB2YXIgcmVzdWx0ID0gW2FjdGl2ZV07ICAvLyA6OiBBcnJheSAoQXJyYXkgYSlcbiAgICBmb3IgKHZhciBpZHggPSAxOyBpZHggPCB4cy5sZW5ndGg7IGlkeCArPSAxKSB7XG4gICAgICB2YXIgeCA9IHhzW2lkeF07XG4gICAgICBpZiAoZih4MCkoeCkpIGFjdGl2ZS5wdXNoKHgpOyBlbHNlIHJlc3VsdC5wdXNoKGFjdGl2ZSA9IFt4MCA9IHhdKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBTLmdyb3VwQnkgPVxuICBkZWYoJ2dyb3VwQnknLFxuICAgICAge30sXG4gICAgICBbRm4oYSwgJC5QcmVkaWNhdGUoYSkpLCAkLkFycmF5KGEpLCAkLkFycmF5KCQuQXJyYXkoYSkpXSxcbiAgICAgIGdyb3VwQnkpO1xuXG4gIC8vIyByZXZlcnNlIDo6IChBcHBsaWNhdGl2ZSBmLCBGb2xkYWJsZSBmLCBNb25vaWQgKGYgYSkpID0+IGYgYSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBSZXZlcnNlcyB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHN0cnVjdHVyZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucmV2ZXJzZShbMSwgMiwgM10pXG4gIC8vLiBbMywgMiwgMV1cbiAgLy8uXG4gIC8vLiA+IFMucmV2ZXJzZShDb25zKDEsIENvbnMoMiwgQ29ucygzLCBOaWwpKSkpXG4gIC8vLiBDb25zKDMsIENvbnMoMiwgQ29ucygxLCBOaWwpKSlcbiAgLy8uXG4gIC8vLiA+IFMucGlwZShbUy5zcGxpdE9uKCcnKSwgUy5yZXZlcnNlLCBTLmpvaW5XaXRoKCcnKV0sICdhYmMnKVxuICAvLy4gJ2NiYSdcbiAgLy8uIGBgYFxuICBTLnJldmVyc2UgPVxuICBkZWYoJ3JldmVyc2UnLFxuICAgICAge2Y6IFtaLkFwcGxpY2F0aXZlLCBaLkZvbGRhYmxlLCBaLk1vbm9pZF19LFxuICAgICAgW2YoYSksIGYoYSldLFxuICAgICAgWi5yZXZlcnNlKTtcblxuICAvLyMgc29ydCA6OiAoT3JkIGEsIEFwcGxpY2F0aXZlIG0sIEZvbGRhYmxlIG0sIE1vbm9pZCAobSBhKSkgPT4gbSBhIC0+IG0gYVxuICAvLy5cbiAgLy8uIFBlcmZvcm1zIGEgW3N0YWJsZSBzb3J0XVtdIG9mIHRoZSBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gc3RydWN0dXJlLCB1c2luZ1xuICAvLy4gW2BaLmx0ZWBdW10gZm9yIGNvbXBhcmlzb25zLlxuICAvLy5cbiAgLy8uIFByb3BlcnRpZXM6XG4gIC8vLlxuICAvLy4gICAtIGBTLnNvcnQoUy5zb3J0KG0pKSA9IFMuc29ydChtKWAgKGlkZW1wb3RlbmNlKVxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgc29ydEJ5YF0oI3NvcnRCeSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnNvcnQoWydmb28nLCAnYmFyJywgJ2JheiddKVxuICAvLy4gWydiYXInLCAnYmF6JywgJ2ZvbyddXG4gIC8vLlxuICAvLy4gPiBTLnNvcnQoW1MuTGVmdCg0KSwgUy5SaWdodCgzKSwgUy5MZWZ0KDIpLCBTLlJpZ2h0KDEpXSlcbiAgLy8uIFtMZWZ0KDIpLCBMZWZ0KDQpLCBSaWdodCgxKSwgUmlnaHQoMyldXG4gIC8vLiBgYGBcbiAgUy5zb3J0ID1cbiAgZGVmKCdzb3J0JyxcbiAgICAgIHthOiBbWi5PcmRdLCBtOiBbWi5BcHBsaWNhdGl2ZSwgWi5Gb2xkYWJsZSwgWi5Nb25vaWRdfSxcbiAgICAgIFttKGEpLCBtKGEpXSxcbiAgICAgIFouc29ydCk7XG5cbiAgLy8jIHNvcnRCeSA6OiAoT3JkIGIsIEFwcGxpY2F0aXZlIG0sIEZvbGRhYmxlIG0sIE1vbm9pZCAobSBhKSkgPT4gKGEgLT4gYikgLT4gbSBhIC0+IG0gYVxuICAvLy5cbiAgLy8uIFBlcmZvcm1zIGEgW3N0YWJsZSBzb3J0XVtdIG9mIHRoZSBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gc3RydWN0dXJlLCB1c2luZ1xuICAvLy4gW2BaLmx0ZWBdW10gdG8gY29tcGFyZSB0aGUgdmFsdWVzIHByb2R1Y2VkIGJ5IGFwcGx5aW5nIHRoZSBnaXZlbiBmdW5jdGlvblxuICAvLy4gdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBzdHJ1Y3R1cmUuXG4gIC8vLlxuICAvLy4gUHJvcGVydGllczpcbiAgLy8uXG4gIC8vLiAgIC0gYFMuc29ydEJ5KGYsIFMuc29ydEJ5KGYsIG0pKSA9IFMuc29ydEJ5KGYsIG0pYCAoaWRlbXBvdGVuY2UpXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2Bzb3J0YF0oI3NvcnQpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5zb3J0QnkoUy5wcm9wKCdyYW5rJyksIFtcbiAgLy8uIC4gICB7cmFuazogNywgc3VpdDogJ3NwYWRlcyd9LFxuICAvLy4gLiAgIHtyYW5rOiA1LCBzdWl0OiAnaGVhcnRzJ30sXG4gIC8vLiAuICAge3Jhbms6IDIsIHN1aXQ6ICdoZWFydHMnfSxcbiAgLy8uIC4gICB7cmFuazogNSwgc3VpdDogJ3NwYWRlcyd9LFxuICAvLy4gLiBdKVxuICAvLy4gWyB7cmFuazogMiwgc3VpdDogJ2hlYXJ0cyd9LFxuICAvLy4gLiB7cmFuazogNSwgc3VpdDogJ2hlYXJ0cyd9LFxuICAvLy4gLiB7cmFuazogNSwgc3VpdDogJ3NwYWRlcyd9LFxuICAvLy4gLiB7cmFuazogNywgc3VpdDogJ3NwYWRlcyd9IF1cbiAgLy8uXG4gIC8vLiA+IFMuc29ydEJ5KFMucHJvcCgnc3VpdCcpLCBbXG4gIC8vLiAuICAge3Jhbms6IDcsIHN1aXQ6ICdzcGFkZXMnfSxcbiAgLy8uIC4gICB7cmFuazogNSwgc3VpdDogJ2hlYXJ0cyd9LFxuICAvLy4gLiAgIHtyYW5rOiAyLCBzdWl0OiAnaGVhcnRzJ30sXG4gIC8vLiAuICAge3Jhbms6IDUsIHN1aXQ6ICdzcGFkZXMnfSxcbiAgLy8uIC4gXSlcbiAgLy8uIFsge3Jhbms6IDUsIHN1aXQ6ICdoZWFydHMnfSxcbiAgLy8uIC4ge3Jhbms6IDIsIHN1aXQ6ICdoZWFydHMnfSxcbiAgLy8uIC4ge3Jhbms6IDcsIHN1aXQ6ICdzcGFkZXMnfSxcbiAgLy8uIC4ge3Jhbms6IDUsIHN1aXQ6ICdzcGFkZXMnfSBdXG4gIC8vLiBgYGBcbiAgUy5zb3J0QnkgPVxuICBkZWYoJ3NvcnRCeScsXG4gICAgICB7YjogW1ouT3JkXSwgbTogW1ouQXBwbGljYXRpdmUsIFouRm9sZGFibGUsIFouTW9ub2lkXX0sXG4gICAgICBbRm4oYSwgYiksIG0oYSksIG0oYSldLFxuICAgICAgWi5zb3J0QnkpO1xuXG4gIC8vLiAjIyMgT2JqZWN0XG5cbiAgLy8jIHByb3AgOjogU3RyaW5nIC0+IGEgLT4gYlxuICAvLy5cbiAgLy8uIFRha2VzIGEgcHJvcGVydHkgbmFtZSBhbmQgYW4gb2JqZWN0IHdpdGgga25vd24gcHJvcGVydGllcyBhbmQgcmV0dXJuc1xuICAvLy4gdGhlIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkuIElmIGZvciBzb21lIHJlYXNvbiB0aGUgb2JqZWN0XG4gIC8vLiBsYWNrcyB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LCBhIHR5cGUgZXJyb3IgaXMgdGhyb3duLlxuICAvLy5cbiAgLy8uIEZvciBhY2Nlc3NpbmcgcHJvcGVydGllcyBvZiB1bmNlcnRhaW4gb2JqZWN0cywgdXNlIFtgZ2V0YF0oI2dldCkgaW5zdGVhZC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHBsdWNrYF0oI3BsdWNrKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucHJvcCgnYScsIHthOiAxLCBiOiAyfSlcbiAgLy8uIDFcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBwcm9wKGtleSwgeCkge1xuICAgIHZhciBvYmogPSB0b09iamVjdCh4KTtcbiAgICBpZiAoa2V5IGluIG9iaikgcmV0dXJuIG9ialtrZXldO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ+KAmHByb3DigJkgZXhwZWN0ZWQgb2JqZWN0IHRvIGhhdmUgYSBwcm9wZXJ0eSBuYW1lZCDigJgnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSArICfigJk7ICcgKyBaLnRvU3RyaW5nKHgpICsgJyBkb2VzIG5vdCcpO1xuICB9XG4gIFMucHJvcCA9IGRlZigncHJvcCcsIHt9LCBbJC5TdHJpbmcsIGEsIGJdLCBwcm9wKTtcblxuICAvLyMgcHJvcHMgOjogQXJyYXkgU3RyaW5nIC0+IGEgLT4gYlxuICAvLy5cbiAgLy8uIFRha2VzIGEgcHJvcGVydHkgcGF0aCAoYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMpIGFuZCBhbiBvYmplY3Qgd2l0aFxuICAvLy4ga25vd24gc3RydWN0dXJlIGFuZCByZXR1cm5zIHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gcGF0aC4gSWYgZm9yIHNvbWVcbiAgLy8uIHJlYXNvbiB0aGUgcGF0aCBkb2VzIG5vdCBleGlzdCwgYSB0eXBlIGVycm9yIGlzIHRocm93bi5cbiAgLy8uXG4gIC8vLiBGb3IgYWNjZXNzaW5nIHByb3BlcnR5IHBhdGhzIG9mIHVuY2VydGFpbiBvYmplY3RzLCB1c2UgW2BnZXRzYF0oI2dldHMpXG4gIC8vLiBpbnN0ZWFkLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5wcm9wcyhbJ2EnLCAnYicsICdjJ10sIHthOiB7Yjoge2M6IDF9fX0pXG4gIC8vLiAxXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcHJvcHMocGF0aCwgeCkge1xuICAgIHJldHVybiBwYXRoLnJlZHVjZShmdW5jdGlvbih4LCBrZXkpIHtcbiAgICAgIHZhciBvYmogPSB0b09iamVjdCh4KTtcbiAgICAgIGlmIChrZXkgaW4gb2JqKSByZXR1cm4gb2JqW2tleV07XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCfigJhwcm9wc+KAmSBleHBlY3RlZCBvYmplY3QgdG8gaGF2ZSBhIHByb3BlcnR5IGF0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBaLnRvU3RyaW5nKHBhdGgpICsgJzsgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFoudG9TdHJpbmcoeCkgKyAnIGRvZXMgbm90Jyk7XG4gICAgfSwgeCk7XG4gIH1cbiAgUy5wcm9wcyA9IGRlZigncHJvcHMnLCB7fSwgWyQuQXJyYXkoJC5TdHJpbmcpLCBhLCBiXSwgcHJvcHMpO1xuXG4gIC8vIyBnZXQgOjogKEFueSAtPiBCb29sZWFuKSAtPiBTdHJpbmcgLT4gYSAtPiBNYXliZSBiXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBwcmVkaWNhdGUsIGEgcHJvcGVydHkgbmFtZSwgYW5kIGFuIG9iamVjdCBhbmQgcmV0dXJucyBKdXN0IHRoZVxuICAvLy4gdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBvYmplY3QgcHJvcGVydHkgaWYgaXQgZXhpc3RzIGFuZCB0aGUgdmFsdWVcbiAgLy8uIHNhdGlzZmllcyB0aGUgZ2l2ZW4gcHJlZGljYXRlOyBOb3RoaW5nIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGdldHNgXSgjZ2V0cykgYW5kIFtgcHJvcGBdKCNwcm9wKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZ2V0KFMuaXMoTnVtYmVyKSwgJ3gnLCB7eDogMSwgeTogMn0pXG4gIC8vLiBKdXN0KDEpXG4gIC8vLlxuICAvLy4gPiBTLmdldChTLmlzKE51bWJlciksICd4Jywge3g6ICcxJywgeTogJzInfSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMuZ2V0KFMuaXMoTnVtYmVyKSwgJ3gnLCB7fSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMuZ2V0KCQudGVzdChbXSwgJC5BcnJheSgkLk51bWJlcikpLCAneCcsIHt4OiBbMSwgMiwgM119KVxuICAvLy4gSnVzdChbMSwgMiwgM10pXG4gIC8vLlxuICAvLy4gPiBTLmdldCgkLnRlc3QoW10sICQuQXJyYXkoJC5OdW1iZXIpKSwgJ3gnLCB7eDogWzEsIDIsIDMsIG51bGxdfSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBnZXQocHJlZCwga2V5LCB4KSB7XG4gICAgdmFyIG9iaiA9IHRvT2JqZWN0KHgpO1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICB2YXIgdmFsID0gb2JqW2tleV07XG4gICAgICBpZiAocHJlZCh2YWwpKSByZXR1cm4gSnVzdCh2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gTm90aGluZztcbiAgfVxuICBTLmdldCA9IGRlZignZ2V0Jywge30sIFskLlByZWRpY2F0ZSgkLkFueSksICQuU3RyaW5nLCBhLCAkTWF5YmUoYildLCBnZXQpO1xuXG4gIC8vIyBnZXRzIDo6IChBbnkgLT4gQm9vbGVhbikgLT4gQXJyYXkgU3RyaW5nIC0+IGEgLT4gTWF5YmUgYlxuICAvLy5cbiAgLy8uIFRha2VzIGEgcHJlZGljYXRlLCBhIHByb3BlcnR5IHBhdGggKGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzKSwgYW5kXG4gIC8vLiBhbiBvYmplY3QgYW5kIHJldHVybnMgSnVzdCB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBhdGggaWYgc3VjaCBhIHBhdGhcbiAgLy8uIGV4aXN0cyBhbmQgdGhlIHZhbHVlIHNhdGlzZmllcyB0aGUgZ2l2ZW4gcHJlZGljYXRlOyBOb3RoaW5nIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGdldGBdKCNnZXQpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5nZXRzKFMuaXMoTnVtYmVyKSwgWydhJywgJ2InLCAnYyddLCB7YToge2I6IHtjOiA0Mn19fSlcbiAgLy8uIEp1c3QoNDIpXG4gIC8vLlxuICAvLy4gPiBTLmdldHMoUy5pcyhOdW1iZXIpLCBbJ2EnLCAnYicsICdjJ10sIHthOiB7Yjoge2M6ICc0Mid9fX0pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLmdldHMoUy5pcyhOdW1iZXIpLCBbJ2EnLCAnYicsICdjJ10sIHt9KVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGdldHMocHJlZCwga2V5cywgeCkge1xuICAgIHJldHVybiBaLmZpbHRlcihwcmVkLCBaLnJlZHVjZShmdW5jdGlvbihtLCBrZXkpIHtcbiAgICAgIHJldHVybiBaLmNoYWluKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIG9iaiA9IHRvT2JqZWN0KHgpO1xuICAgICAgICByZXR1cm4ga2V5IGluIG9iaiA/IEp1c3Qob2JqW2tleV0pIDogTm90aGluZztcbiAgICAgIH0sIG0pO1xuICAgIH0sIEp1c3QoeCksIGtleXMpKTtcbiAgfVxuICBTLmdldHMgPVxuICBkZWYoJ2dldHMnLCB7fSwgWyQuUHJlZGljYXRlKCQuQW55KSwgJC5BcnJheSgkLlN0cmluZyksIGEsICRNYXliZShiKV0sIGdldHMpO1xuXG4gIC8vLiAjIyMgU3RyTWFwXG4gIC8vLlxuICAvLy4gU3RyTWFwIGlzIGFuIGFiYnJldmlhdGlvbiBvZiBfc3RyaW5nIG1hcF8uIEEgc3RyaW5nIG1hcCBpcyBhbiBvYmplY3QsXG4gIC8vLiBzdWNoIGFzIGB7Zm9vOiAxLCBiYXI6IDIsIGJhejogM31gLCB3aG9zZSB2YWx1ZXMgYXJlIGFsbCBtZW1iZXJzIG9mXG4gIC8vLiB0aGUgc2FtZSB0eXBlLiBGb3JtYWxseSwgYSB2YWx1ZSBpcyBhIG1lbWJlciBvZiB0eXBlIGBTdHJNYXAgYWAgaWYgaXRzXG4gIC8vLiBbdHlwZSBpZGVudGlmaWVyXVtdIGlzIGAnT2JqZWN0J2AgYW5kIHRoZSB2YWx1ZXMgb2YgaXRzIGVudW1lcmFibGUgb3duXG4gIC8vLiBwcm9wZXJ0aWVzIGFyZSBhbGwgbWVtYmVycyBvZiB0eXBlIGBhYC5cblxuICAvLyMgc2luZ2xldG9uIDo6IFN0cmluZyAtPiBhIC0+IFN0ck1hcCBhXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBzdHJpbmcgYW5kIGEgdmFsdWUgb2YgYW55IHR5cGUsIGFuZCByZXR1cm5zIGEgc3RyaW5nIG1hcCB3aXRoXG4gIC8vLiBhIHNpbmdsZSBlbnRyeSAobWFwcGluZyB0aGUga2V5IHRvIHRoZSB2YWx1ZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnNpbmdsZXRvbignZm9vJywgNDIpXG4gIC8vLiB7Zm9vOiA0Mn1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBzaW5nbGV0b24oa2V5LCB2YWwpIHtcbiAgICB2YXIgc3RyTWFwID0ge307XG4gICAgc3RyTWFwW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHN0ck1hcDtcbiAgfVxuICBTLnNpbmdsZXRvbiA9IGRlZignc2luZ2xldG9uJywge30sIFskLlN0cmluZywgYSwgJC5TdHJNYXAoYSldLCBzaW5nbGV0b24pO1xuXG4gIC8vIyBpbnNlcnQgOjogU3RyaW5nIC0+IGEgLT4gU3RyTWFwIGEgLT4gU3RyTWFwIGFcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHN0cmluZywgYSB2YWx1ZSBvZiBhbnkgdHlwZSwgYW5kIGEgc3RyaW5nIG1hcCwgYW5kIHJldHVybnMgYVxuICAvLy4gc3RyaW5nIG1hcCBjb21wcmlzaW5nIGFsbCB0aGUgZW50cmllcyBvZiB0aGUgZ2l2ZW4gc3RyaW5nIG1hcCBwbHVzIHRoZVxuICAvLy4gZW50cnkgc3BlY2lmaWVkIGJ5IHRoZSBmaXJzdCB0d28gYXJndW1lbnRzICh3aGljaCB0YWtlcyBwcmVjZWRlbmNlKS5cbiAgLy8uXG4gIC8vLiBFcXVpdmFsZW50IHRvIEhhc2tlbGwncyBgaW5zZXJ0YCBmdW5jdGlvbi4gU2ltaWxhciB0byBDbG9qdXJlJ3MgYGFzc29jYFxuICAvLy4gZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmluc2VydCgnYycsIDMsIHthOiAxLCBiOiAyfSlcbiAgLy8uIHthOiAxLCBiOiAyLCBjOiAzfVxuICAvLy5cbiAgLy8uID4gUy5pbnNlcnQoJ2EnLCA0LCB7YTogMSwgYjogMn0pXG4gIC8vLiB7YTogNCwgYjogMn1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBpbnNlcnQoa2V5LCB2YWwsIHN0ck1hcCkge1xuICAgIHJldHVybiBaLmNvbmNhdChzdHJNYXAsIHNpbmdsZXRvbihrZXksIHZhbCkpO1xuICB9XG4gIFMuaW5zZXJ0ID1cbiAgZGVmKCdpbnNlcnQnLCB7fSwgWyQuU3RyaW5nLCBhLCAkLlN0ck1hcChhKSwgJC5TdHJNYXAoYSldLCBpbnNlcnQpO1xuXG4gIC8vIyByZW1vdmUgOjogU3RyaW5nIC0+IFN0ck1hcCBhIC0+IFN0ck1hcCBhXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBzdHJpbmcgYW5kIGEgc3RyaW5nIG1hcCwgYW5kIHJldHVybnMgYSBzdHJpbmcgbWFwIGNvbXByaXNpbmcgYWxsXG4gIC8vLiB0aGUgZW50cmllcyBvZiB0aGUgZ2l2ZW4gc3RyaW5nIG1hcCBleGNlcHQgdGhlIG9uZSB3aG9zZSBrZXkgbWF0Y2hlcyB0aGVcbiAgLy8uIGdpdmVuIHN0cmluZyAoaWYgc3VjaCBhIGtleSBleGlzdHMpLlxuICAvLy5cbiAgLy8uIEVxdWl2YWxlbnQgdG8gSGFza2VsbCdzIGBkZWxldGVgIGZ1bmN0aW9uLiBTaW1pbGFyIHRvIENsb2p1cmUncyBgZGlzc29jYFxuICAvLy4gZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnJlbW92ZSgnYycsIHthOiAxLCBiOiAyLCBjOiAzfSlcbiAgLy8uIHthOiAxLCBiOiAyfVxuICAvLy5cbiAgLy8uID4gUy5yZW1vdmUoJ2MnLCB7fSlcbiAgLy8uIHt9XG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcmVtb3ZlKGtleSwgc3RyTWFwKSB7XG4gICAgdmFyIHJlc3VsdCA9IFouY29uY2F0KHN0ck1hcCwge30pO1xuICAgIGRlbGV0ZSByZXN1bHRba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIFMucmVtb3ZlID0gZGVmKCdyZW1vdmUnLCB7fSwgWyQuU3RyaW5nLCAkLlN0ck1hcChhKSwgJC5TdHJNYXAoYSldLCByZW1vdmUpO1xuXG4gIC8vIyBrZXlzIDo6IFN0ck1hcCBhIC0+IEFycmF5IFN0cmluZ1xuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIGtleXMgb2YgdGhlIGdpdmVuIHN0cmluZyBtYXAsIGluIGFyYml0cmFyeSBvcmRlci5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMua2V5cyh7YjogMiwgYzogMywgYTogMX0pLnNvcnQoKVxuICAvLy4gWydhJywgJ2InLCAnYyddXG4gIC8vLiBgYGBcbiAgUy5rZXlzID0gZGVmKCdrZXlzJywge30sIFskLlN0ck1hcChhKSwgJC5BcnJheSgkLlN0cmluZyldLCBPYmplY3Qua2V5cyk7XG5cbiAgLy8jIHZhbHVlcyA6OiBTdHJNYXAgYSAtPiBBcnJheSBhXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBzdHJpbmcgbWFwLCBpbiBhcmJpdHJhcnkgb3JkZXIuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnZhbHVlcyh7YTogMSwgYzogMywgYjogMn0pLnNvcnQoKVxuICAvLy4gWzEsIDIsIDNdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gdmFsdWVzKHN0ck1hcCkge1xuICAgIHJldHVybiBaLm1hcChmdW5jdGlvbihrKSB7IHJldHVybiBzdHJNYXBba107IH0sIE9iamVjdC5rZXlzKHN0ck1hcCkpO1xuICB9XG4gIFMudmFsdWVzID0gZGVmKCd2YWx1ZXMnLCB7fSwgWyQuU3RyTWFwKGEpLCAkLkFycmF5KGEpXSwgdmFsdWVzKTtcblxuICAvLyMgcGFpcnMgOjogU3RyTWFwIGEgLT4gQXJyYXkgKFBhaXIgU3RyaW5nIGEpXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUga2V54oCTdmFsdWUgcGFpcnMgb2YgdGhlIGdpdmVuIHN0cmluZyBtYXAsIGluIGFyYml0cmFyeSBvcmRlci5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucGFpcnMoe2I6IDIsIGE6IDEsIGM6IDN9KS5zb3J0KClcbiAgLy8uIFtbJ2EnLCAxXSwgWydiJywgMl0sIFsnYycsIDNdXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHBhaXJzKHN0ck1hcCkge1xuICAgIHJldHVybiBaLm1hcChmdW5jdGlvbihrKSB7IHJldHVybiBbaywgc3RyTWFwW2tdXTsgfSwgT2JqZWN0LmtleXMoc3RyTWFwKSk7XG4gIH1cbiAgUy5wYWlycyA9XG4gIGRlZigncGFpcnMnLCB7fSwgWyQuU3RyTWFwKGEpLCAkLkFycmF5KCQuUGFpcigkLlN0cmluZywgYSkpXSwgcGFpcnMpO1xuXG4gIC8vIyBmcm9tUGFpcnMgOjogRm9sZGFibGUgZiA9PiBmIChQYWlyIFN0cmluZyBhKSAtPiBTdHJNYXAgYVxuICAvLy5cbiAgLy8uIFJldHVybnMgYSBzdHJpbmcgbWFwIGNvbnRhaW5pbmcgdGhlIGtleeKAk3ZhbHVlIHBhaXJzIHNwZWNpZmllZCBieSB0aGVcbiAgLy8uIGdpdmVuIFtGb2xkYWJsZV1bXS4gSWYgYSBrZXkgYXBwZWFycyBpbiBtdWx0aXBsZSBwYWlycywgdGhlIHJpZ2h0bW9zdFxuICAvLy4gcGFpciB0YWtlcyBwcmVjZWRlbmNlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5mcm9tUGFpcnMoW1snYScsIDFdLCBbJ2InLCAyXSwgWydjJywgM11dKVxuICAvLy4ge2E6IDEsIGI6IDIsIGM6IDN9XG4gIC8vLlxuICAvLy4gPiBTLmZyb21QYWlycyhbWyd4JywgMV0sIFsneCcsIDJdXSlcbiAgLy8uIHt4OiAyfVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGZyb21QYWlycyhwYWlycykge1xuICAgIHJldHVybiBaLnJlZHVjZShmdW5jdGlvbihzdHJNYXAsIHBhaXIpIHtcbiAgICAgIHN0ck1hcFtwYWlyWzBdXSA9IHBhaXJbMV07XG4gICAgICByZXR1cm4gc3RyTWFwO1xuICAgIH0sIHt9LCBwYWlycyk7XG4gIH1cbiAgUy5mcm9tUGFpcnMgPVxuICBkZWYoJ2Zyb21QYWlycycsXG4gICAgICB7ZjogW1ouRm9sZGFibGVdfSxcbiAgICAgIFtmKCQuUGFpcigkLlN0cmluZywgYSkpLCAkLlN0ck1hcChhKV0sXG4gICAgICBmcm9tUGFpcnMpO1xuXG4gIC8vLiAjIyMgTnVtYmVyXG5cbiAgLy8jIG5lZ2F0ZSA6OiBWYWxpZE51bWJlciAtPiBWYWxpZE51bWJlclxuICAvLy5cbiAgLy8uIE5lZ2F0ZXMgaXRzIGFyZ3VtZW50LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5uZWdhdGUoMTIuNSlcbiAgLy8uIC0xMi41XG4gIC8vLlxuICAvLy4gPiBTLm5lZ2F0ZSgtNDIpXG4gIC8vLiA0MlxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG5lZ2F0ZShuKSB7XG4gICAgcmV0dXJuIC1uO1xuICB9XG4gIFMubmVnYXRlID0gZGVmKCduZWdhdGUnLCB7fSwgWyQuVmFsaWROdW1iZXIsICQuVmFsaWROdW1iZXJdLCBuZWdhdGUpO1xuXG4gIC8vIyBhZGQgOjogRmluaXRlTnVtYmVyIC0+IEZpbml0ZU51bWJlciAtPiBGaW5pdGVOdW1iZXJcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSBzdW0gb2YgdHdvIChmaW5pdGUpIG51bWJlcnMuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmFkZCgxLCAxKVxuICAvLy4gMlxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGFkZCh4LCB5KSB7XG4gICAgcmV0dXJuIHggKyB5O1xuICB9XG4gIFMuYWRkID1cbiAgZGVmKCdhZGQnLCB7fSwgWyQuRmluaXRlTnVtYmVyLCAkLkZpbml0ZU51bWJlciwgJC5GaW5pdGVOdW1iZXJdLCBhZGQpO1xuXG4gIC8vIyBzdW0gOjogRm9sZGFibGUgZiA9PiBmIEZpbml0ZU51bWJlciAtPiBGaW5pdGVOdW1iZXJcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGdpdmVuIGFycmF5IG9mIChmaW5pdGUpIG51bWJlcnMuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnN1bShbMSwgMiwgMywgNCwgNV0pXG4gIC8vLiAxNVxuICAvLy5cbiAgLy8uID4gUy5zdW0oW10pXG4gIC8vLiAwXG4gIC8vLlxuICAvLy4gPiBTLnN1bShTLkp1c3QoNDIpKVxuICAvLy4gNDJcbiAgLy8uXG4gIC8vLiA+IFMuc3VtKFMuTm90aGluZylcbiAgLy8uIDBcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBzdW0oZm9sZGFibGUpIHtcbiAgICByZXR1cm4gWi5yZWR1Y2UoYWRkLCAwLCBmb2xkYWJsZSk7XG4gIH1cbiAgUy5zdW0gPVxuICBkZWYoJ3N1bScsIHtmOiBbWi5Gb2xkYWJsZV19LCBbZigkLkZpbml0ZU51bWJlciksICQuRmluaXRlTnVtYmVyXSwgc3VtKTtcblxuICAvLyMgc3ViIDo6IEZpbml0ZU51bWJlciAtPiAoRmluaXRlTnVtYmVyIC0+IEZpbml0ZU51bWJlcilcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIGZpbml0ZSBudW1iZXIgYG5gIGFuZCByZXR1cm5zIHRoZSBfc3VidHJhY3QgYG5gXyBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHN1Yl9gXSgjc3ViXykuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1hcChTLnN1YigxKSwgWzEsIDIsIDNdKVxuICAvLy4gWzAsIDEsIDJdXG4gIC8vLiBgYGBcbiAgUy5zdWIgPVxuICBkZWYoJ3N1YicsXG4gICAgICB7fSxcbiAgICAgIFskLkZpbml0ZU51bWJlciwgRm4oJC5GaW5pdGVOdW1iZXIsICQuRmluaXRlTnVtYmVyKV0sXG4gICAgICBmbGlwJChzdWJfKSk7XG5cbiAgLy8jIHN1Yl8gOjogRmluaXRlTnVtYmVyIC0+IEZpbml0ZU51bWJlciAtPiBGaW5pdGVOdW1iZXJcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIChmaW5pdGUpIG51bWJlcnMuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BzdWJgXSgjc3ViKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuc3ViXyg0LCAyKVxuICAvLy4gMlxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHN1Yl8oeCwgeSkge1xuICAgIHJldHVybiB4IC0geTtcbiAgfVxuICBTLnN1Yl8gPVxuICBkZWYoJ3N1Yl8nLCB7fSwgWyQuRmluaXRlTnVtYmVyLCAkLkZpbml0ZU51bWJlciwgJC5GaW5pdGVOdW1iZXJdLCBzdWJfKTtcblxuICAvLyMgbXVsdCA6OiBGaW5pdGVOdW1iZXIgLT4gRmluaXRlTnVtYmVyIC0+IEZpbml0ZU51bWJlclxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdHdvIChmaW5pdGUpIG51bWJlcnMuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm11bHQoNCwgMilcbiAgLy8uIDhcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBtdWx0KHgsIHkpIHtcbiAgICByZXR1cm4geCAqIHk7XG4gIH1cbiAgUy5tdWx0ID1cbiAgZGVmKCdtdWx0Jywge30sIFskLkZpbml0ZU51bWJlciwgJC5GaW5pdGVOdW1iZXIsICQuRmluaXRlTnVtYmVyXSwgbXVsdCk7XG5cbiAgLy8jIHByb2R1Y3QgOjogRm9sZGFibGUgZiA9PiBmIEZpbml0ZU51bWJlciAtPiBGaW5pdGVOdW1iZXJcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoZSBnaXZlbiBhcnJheSBvZiAoZmluaXRlKSBudW1iZXJzLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5wcm9kdWN0KFsxLCAyLCAzLCA0LCA1XSlcbiAgLy8uIDEyMFxuICAvLy5cbiAgLy8uID4gUy5wcm9kdWN0KFtdKVxuICAvLy4gMVxuICAvLy5cbiAgLy8uID4gUy5wcm9kdWN0KFMuSnVzdCg0MikpXG4gIC8vLiA0MlxuICAvLy5cbiAgLy8uID4gUy5wcm9kdWN0KFMuTm90aGluZylcbiAgLy8uIDFcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBwcm9kdWN0KGZvbGRhYmxlKSB7XG4gICAgcmV0dXJuIFoucmVkdWNlKG11bHQsIDEsIGZvbGRhYmxlKTtcbiAgfVxuICBTLnByb2R1Y3QgPVxuICBkZWYoJ3Byb2R1Y3QnLFxuICAgICAge2Y6IFtaLkZvbGRhYmxlXX0sXG4gICAgICBbZigkLkZpbml0ZU51bWJlciksICQuRmluaXRlTnVtYmVyXSxcbiAgICAgIHByb2R1Y3QpO1xuXG4gIC8vIyBkaXYgOjogTm9uWmVyb0Zpbml0ZU51bWJlciAtPiAoRmluaXRlTnVtYmVyIC0+IEZpbml0ZU51bWJlcilcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIG5vbi16ZXJvIGZpbml0ZSBudW1iZXIgYG5gIGFuZCByZXR1cm5zIHRoZSBfZGl2aWRlIGJ5IGBuYF9cbiAgLy8uIGZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZGl2X2BdKCNkaXZfKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWFwKFMuZGl2KDIpLCBbMCwgMSwgMiwgM10pXG4gIC8vLiBbMCwgMC41LCAxLCAxLjVdXG4gIC8vLiBgYGBcbiAgUy5kaXYgPVxuICBkZWYoJ2RpdicsXG4gICAgICB7fSxcbiAgICAgIFskLk5vblplcm9GaW5pdGVOdW1iZXIsIEZuKCQuRmluaXRlTnVtYmVyLCAkLkZpbml0ZU51bWJlcildLFxuICAgICAgZmxpcCQoZGl2XykpO1xuXG4gIC8vIyBkaXZfIDo6IEZpbml0ZU51bWJlciAtPiBOb25aZXJvRmluaXRlTnVtYmVyIC0+IEZpbml0ZU51bWJlclxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIHJlc3VsdCBvZiBkaXZpZGluZyBpdHMgZmlyc3QgYXJndW1lbnQgKGEgZmluaXRlIG51bWJlcikgYnlcbiAgLy8uIGl0cyBzZWNvbmQgYXJndW1lbnQgKGEgbm9uLXplcm8gZmluaXRlIG51bWJlcikuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BkaXZgXSgjZGl2KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZGl2Xyg3LCAyKVxuICAvLy4gMy41XG4gIC8vLlxuICAvLy4gPiBTLm1hcChTLmRpdl8oMjQpLCBbMSwgMiwgMywgNF0pXG4gIC8vLiBbMjQsIDEyLCA4LCA2XVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGRpdl8oeCwgeSkge1xuICAgIHJldHVybiB4IC8geTtcbiAgfVxuICBTLmRpdl8gPVxuICBkZWYoJ2Rpdl8nLFxuICAgICAge30sXG4gICAgICBbJC5GaW5pdGVOdW1iZXIsICQuTm9uWmVyb0Zpbml0ZU51bWJlciwgJC5GaW5pdGVOdW1iZXJdLFxuICAgICAgZGl2Xyk7XG5cbiAgLy8jIHBvdyA6OiBGaW5pdGVOdW1iZXIgLT4gKEZpbml0ZU51bWJlciAtPiBGaW5pdGVOdW1iZXIpXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBmaW5pdGUgbnVtYmVyIGBuYCBhbmQgcmV0dXJucyB0aGUgX3Bvd2VyIG9mIGBuYF8gZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2Bwb3dfYF0oI3Bvd18pLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5tYXAoUy5wb3coMiksIFstMywgLTIsIC0xLCAwLCAxLCAyLCAzXSlcbiAgLy8uIFs5LCA0LCAxLCAwLCAxLCA0LCA5XVxuICAvLy5cbiAgLy8uID4gUy5tYXAoUy5wb3coMC41KSwgWzEsIDQsIDksIDE2LCAyNV0pXG4gIC8vLiBbMSwgMiwgMywgNCwgNV1cbiAgLy8uIGBgYFxuICBTLnBvdyA9XG4gIGRlZigncG93JyxcbiAgICAgIHt9LFxuICAgICAgWyQuRmluaXRlTnVtYmVyLCBGbigkLkZpbml0ZU51bWJlciwgJC5GaW5pdGVOdW1iZXIpXSxcbiAgICAgIGZsaXAkKE1hdGgucG93KSk7XG5cbiAgLy8jIHBvd18gOjogRmluaXRlTnVtYmVyIC0+IEZpbml0ZU51bWJlciAtPiBGaW5pdGVOdW1iZXJcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BNYXRoLnBvd2BdW10uXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2Bwb3dgXSgjcG93KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWFwKFMucG93XygxMCksIFstMywgLTIsIC0xLCAwLCAxLCAyLCAzXSlcbiAgLy8uIFswLjAwMSwgMC4wMSwgMC4xLCAxLCAxMCwgMTAwLCAxMDAwXVxuICAvLy4gYGBgXG4gIFMucG93XyA9XG4gIGRlZigncG93XycsIHt9LCBbJC5GaW5pdGVOdW1iZXIsICQuRmluaXRlTnVtYmVyLCAkLkZpbml0ZU51bWJlcl0sIE1hdGgucG93KTtcblxuICAvLyMgbWVhbiA6OiBGb2xkYWJsZSBmID0+IGYgRmluaXRlTnVtYmVyIC0+IE1heWJlIEZpbml0ZU51bWJlclxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIG1lYW4gb2YgdGhlIGdpdmVuIGFycmF5IG9mIChmaW5pdGUpIG51bWJlcnMuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1lYW4oWzEsIDIsIDMsIDQsIDVdKVxuICAvLy4gSnVzdCgzKVxuICAvLy5cbiAgLy8uID4gUy5tZWFuKFtdKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5tZWFuKFMuSnVzdCg0MikpXG4gIC8vLiBKdXN0KDQyKVxuICAvLy5cbiAgLy8uID4gUy5tZWFuKFMuTm90aGluZylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBtZWFuKGZvbGRhYmxlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFoucmVkdWNlKFxuICAgICAgZnVuY3Rpb24oYWNjLCBuKSB7XG4gICAgICAgIGFjYy50b3RhbCArPSBuO1xuICAgICAgICBhY2MuY291bnQgKz0gMTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sXG4gICAgICB7dG90YWw6IDAsIGNvdW50OiAwfSxcbiAgICAgIGZvbGRhYmxlXG4gICAgKTtcbiAgICByZXR1cm4gcmVzdWx0LmNvdW50ID4gMCA/IEp1c3QocmVzdWx0LnRvdGFsIC8gcmVzdWx0LmNvdW50KSA6IE5vdGhpbmc7XG4gIH1cbiAgUy5tZWFuID1cbiAgZGVmKCdtZWFuJyxcbiAgICAgIHtmOiBbWi5Gb2xkYWJsZV19LFxuICAgICAgW2YoJC5GaW5pdGVOdW1iZXIpLCAkTWF5YmUoJC5GaW5pdGVOdW1iZXIpXSxcbiAgICAgIG1lYW4pO1xuXG4gIC8vLiAjIyMgSW50ZWdlclxuXG4gIC8vIyBldmVuIDo6IEludGVnZXIgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBpbnRlZ2VyIGlzIGV2ZW47IGBmYWxzZWAgaWYgaXQgaXMgb2RkLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5ldmVuKDQyKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5ldmVuKDk5KVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBldmVuKG4pIHtcbiAgICByZXR1cm4gbiAlIDIgPT09IDA7XG4gIH1cbiAgUy5ldmVuID0gZGVmKCdldmVuJywge30sIFskLkludGVnZXIsICQuQm9vbGVhbl0sIGV2ZW4pO1xuXG4gIC8vIyBvZGQgOjogSW50ZWdlciAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGludGVnZXIgaXMgb2RkOyBgZmFsc2VgIGlmIGl0IGlzIGV2ZW4uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm9kZCg5OSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMub2RkKDQyKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBvZGQobikge1xuICAgIHJldHVybiBuICUgMiAhPT0gMDtcbiAgfVxuICBTLm9kZCA9IGRlZignb2RkJywge30sIFskLkludGVnZXIsICQuQm9vbGVhbl0sIG9kZCk7XG5cbiAgLy8uICMjIyBQYXJzZVxuXG4gIC8vIyBwYXJzZURhdGUgOjogU3RyaW5nIC0+IE1heWJlIFZhbGlkRGF0ZVxuICAvLy5cbiAgLy8uIFRha2VzIGEgc3RyaW5nIGFuZCByZXR1cm5zIEp1c3QgdGhlIGRhdGUgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZ1xuICAvLy4gaWYgaXQgZG9lcyBpbiBmYWN0IHJlcHJlc2VudCBhIGRhdGU7IE5vdGhpbmcgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5wYXJzZURhdGUoJzIwMTEtMDEtMTlUMTc6NDA6MDBaJylcbiAgLy8uIEp1c3QobmV3IERhdGUoJzIwMTEtMDEtMTlUMTc6NDA6MDAuMDAwWicpKVxuICAvLy5cbiAgLy8uID4gUy5wYXJzZURhdGUoJ3RvZGF5JylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBwYXJzZURhdGUocykge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUocyk7XG4gICAgcmV0dXJuIGlzTmFOKGRhdGUudmFsdWVPZigpKSA/IE5vdGhpbmcgOiBKdXN0KGRhdGUpO1xuICB9XG4gIFMucGFyc2VEYXRlID1cbiAgZGVmKCdwYXJzZURhdGUnLCB7fSwgWyQuU3RyaW5nLCAkTWF5YmUoJC5WYWxpZERhdGUpXSwgcGFyc2VEYXRlKTtcblxuICAvLyAgcmVxdWlyZWROb25DYXB0dXJpbmdHcm91cCA6OiBBcnJheSBTdHJpbmcgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIHJlcXVpcmVkTm9uQ2FwdHVyaW5nR3JvdXAoeHMpIHtcbiAgICByZXR1cm4gJyg/OicgKyB4cy5qb2luKCd8JykgKyAnKSc7XG4gIH1cblxuICAvLyAgb3B0aW9uYWxOb25DYXB0dXJpbmdHcm91cCA6OiBBcnJheSBTdHJpbmcgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIG9wdGlvbmFsTm9uQ2FwdHVyaW5nR3JvdXAoeHMpIHtcbiAgICByZXR1cm4gcmVxdWlyZWROb25DYXB0dXJpbmdHcm91cCh4cykgKyAnPyc7XG4gIH1cblxuICAvLyAgdmFsaWRGbG9hdFJlcHIgOjogUmVnRXhwXG4gIHZhciB2YWxpZEZsb2F0UmVwciA9IG5ldyBSZWdFeHAoXG4gICAgJ14nICsgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydC1vZi1zdHJpbmcgYW5jaG9yXG4gICAgJ1xcXFxzKicgKyAgICAgICAgICAgICAgICAgIC8vIGFueSBudW1iZXIgb2YgbGVhZGluZyB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcbiAgICAnWystXT8nICsgICAgICAgICAgICAgICAgIC8vIG9wdGlvbmFsIHNpZ25cbiAgICByZXF1aXJlZE5vbkNhcHR1cmluZ0dyb3VwKFtcbiAgICAgICdJbmZpbml0eScsICAgICAgICAgICAgIC8vIFwiSW5maW5pdHlcIlxuICAgICAgJ05hTicsICAgICAgICAgICAgICAgICAgLy8gXCJOYU5cIlxuICAgICAgcmVxdWlyZWROb25DYXB0dXJpbmdHcm91cChbXG4gICAgICAgICdbMC05XSsnLCAgICAgICAgICAgICAvLyBudW1iZXJcbiAgICAgICAgJ1swLTldK1suXVswLTldKycsICAgIC8vIG51bWJlciB3aXRoIGludGVyaW9yIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgJ1swLTldK1suXScsICAgICAgICAgIC8vIG51bWJlciB3aXRoIHRyYWlsaW5nIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgJ1suXVswLTldKycgICAgICAgICAgIC8vIG51bWJlciB3aXRoIGxlYWRpbmcgZGVjaW1hbCBwb2ludFxuICAgICAgXSkgK1xuICAgICAgb3B0aW9uYWxOb25DYXB0dXJpbmdHcm91cChbXG4gICAgICAgICdbRWVdJyArICAgICAgICAgICAgICAvLyBcIkVcIiBvciBcImVcIlxuICAgICAgICAnWystXT8nICsgICAgICAgICAgICAgLy8gb3B0aW9uYWwgc2lnblxuICAgICAgICAnWzAtOV0rJyAgICAgICAgICAgICAgLy8gZXhwb25lbnRcbiAgICAgIF0pXG4gICAgXSkgK1xuICAgICdcXFxccyonICsgICAgICAgICAgICAgICAgICAvLyBhbnkgbnVtYmVyIG9mIHRyYWlsaW5nIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuICAgICckJyAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyBhbmNob3JcbiAgKTtcblxuICAvLyMgcGFyc2VGbG9hdCA6OiBTdHJpbmcgLT4gTWF5YmUgTnVtYmVyXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBzdHJpbmcgYW5kIHJldHVybnMgSnVzdCB0aGUgbnVtYmVyIHJlcHJlc2VudGVkIGJ5IHRoZSBzdHJpbmdcbiAgLy8uIGlmIGl0IGRvZXMgaW4gZmFjdCByZXByZXNlbnQgYSBudW1iZXI7IE5vdGhpbmcgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5wYXJzZUZsb2F0KCctMTIzLjQ1JylcbiAgLy8uIEp1c3QoLTEyMy40NSlcbiAgLy8uXG4gIC8vLiA+IFMucGFyc2VGbG9hdCgnZm9vLmJhcicpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcGFyc2VGbG9hdF8ocykge1xuICAgIHJldHVybiB2YWxpZEZsb2F0UmVwci50ZXN0KHMpID8gSnVzdChwYXJzZUZsb2F0KHMpKSA6IE5vdGhpbmc7XG4gIH1cbiAgUy5wYXJzZUZsb2F0ID1cbiAgZGVmKCdwYXJzZUZsb2F0Jywge30sIFskLlN0cmluZywgJE1heWJlKCQuTnVtYmVyKV0sIHBhcnNlRmxvYXRfKTtcblxuICAvLyAgUmFkaXggOjogVHlwZVxuICB2YXIgUmFkaXggPSAkLk51bGxhcnlUeXBlKFxuICAgICdzYW5jdHVhcnkvUmFkaXgnLFxuICAgICcnLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuICQuSW50ZWdlci5fdGVzdCh4KSAmJiB4ID49IDIgJiYgeCA8PSAzNjsgfVxuICApO1xuXG4gIC8vIyBwYXJzZUludCA6OiBSYWRpeCAtPiBTdHJpbmcgLT4gTWF5YmUgSW50ZWdlclxuICAvLy5cbiAgLy8uIFRha2VzIGEgcmFkaXggKGFuIGludGVnZXIgYmV0d2VlbiAyIGFuZCAzNiBpbmNsdXNpdmUpIGFuZCBhIHN0cmluZyxcbiAgLy8uIGFuZCByZXR1cm5zIEp1c3QgdGhlIG51bWJlciByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nIGlmIGl0IGRvZXMgaW5cbiAgLy8uIGZhY3QgcmVwcmVzZW50IGEgbnVtYmVyIGluIHRoZSBiYXNlIHNwZWNpZmllZCBieSB0aGUgcmFkaXg7IE5vdGhpbmdcbiAgLy8uIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIHN0cmljdGVyIHRoYW4gW2BwYXJzZUludGBdW3BhcnNlSW50XTogYSBzdHJpbmdcbiAgLy8uIGlzIGNvbnNpZGVyZWQgdG8gcmVwcmVzZW50IGFuIGludGVnZXIgb25seSBpZiBhbGwgaXRzIG5vbi1wcmVmaXhcbiAgLy8uIGNoYXJhY3RlcnMgYXJlIG1lbWJlcnMgb2YgdGhlIGNoYXJhY3RlciBzZXQgc3BlY2lmaWVkIGJ5IHRoZSByYWRpeC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucGFyc2VJbnQoMTAsICctNDInKVxuICAvLy4gSnVzdCgtNDIpXG4gIC8vLlxuICAvLy4gPiBTLnBhcnNlSW50KDE2LCAnMHhGRicpXG4gIC8vLiBKdXN0KDI1NSlcbiAgLy8uXG4gIC8vLiA+IFMucGFyc2VJbnQoMTYsICcweEdHJylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBwYXJzZUludF8ocmFkaXgsIHMpIHtcbiAgICB2YXIgY2hhcnNldCA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonLnNsaWNlKDAsIHJhZGl4KTtcbiAgICB2YXIgcGF0dGVybiA9IG5ldyBSZWdFeHAoJ15bJyArIGNoYXJzZXQgKyAnXSskJywgJ2knKTtcblxuICAgIHZhciB0ID0gcy5yZXBsYWNlKC9eWystXS8sICcnKTtcbiAgICBpZiAocGF0dGVybi50ZXN0KHJhZGl4ID09PSAxNiA/IHQucmVwbGFjZSgvXjB4L2ksICcnKSA6IHQpKSB7XG4gICAgICB2YXIgbiA9IHBhcnNlSW50KHMsIHJhZGl4KTtcbiAgICAgIGlmICgkLkludGVnZXIuX3Rlc3QobikpIHJldHVybiBKdXN0KG4pO1xuICAgIH1cbiAgICByZXR1cm4gTm90aGluZztcbiAgfVxuICBTLnBhcnNlSW50ID1cbiAgZGVmKCdwYXJzZUludCcsIHt9LCBbUmFkaXgsICQuU3RyaW5nLCAkTWF5YmUoJC5JbnRlZ2VyKV0sIHBhcnNlSW50Xyk7XG5cbiAgLy8jIHBhcnNlSnNvbiA6OiAoQW55IC0+IEJvb2xlYW4pIC0+IFN0cmluZyAtPiBNYXliZSBhXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBwcmVkaWNhdGUgYW5kIGEgc3RyaW5nIHdoaWNoIG1heSBvciBtYXkgbm90IGJlIHZhbGlkIEpTT04sIGFuZFxuICAvLy4gcmV0dXJucyBKdXN0IHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYEpTT04ucGFyc2VgIHRvIHRoZSBzdHJpbmcgKmlmKiB0aGVcbiAgLy8uIHJlc3VsdCBzYXRpc2ZpZXMgdGhlIHByZWRpY2F0ZTsgTm90aGluZyBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnBhcnNlSnNvbigkLnRlc3QoW10sICQuQXJyYXkoJC5JbnRlZ2VyKSksICdbJylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMucGFyc2VKc29uKCQudGVzdChbXSwgJC5BcnJheSgkLkludGVnZXIpKSwgJ1tcIjFcIixcIjJcIixcIjNcIl0nKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5wYXJzZUpzb24oJC50ZXN0KFtdLCAkLkFycmF5KCQuSW50ZWdlcikpLCAnWzAsMS41LDMsNC41XScpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLnBhcnNlSnNvbigkLnRlc3QoW10sICQuQXJyYXkoJC5JbnRlZ2VyKSksICdbMSwyLDNdJylcbiAgLy8uIEp1c3QoWzEsIDIsIDNdKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHBhcnNlSnNvbihwcmVkLCBzKSB7XG4gICAgcmV0dXJuIFouZmlsdGVyKHByZWQsIGVuY2FzZShKU09OLnBhcnNlLCBzKSk7XG4gIH1cbiAgUy5wYXJzZUpzb24gPVxuICBkZWYoJ3BhcnNlSnNvbicsIHt9LCBbJC5QcmVkaWNhdGUoJC5BbnkpLCAkLlN0cmluZywgJE1heWJlKGEpXSwgcGFyc2VKc29uKTtcblxuICAvLy4gIyMjIFJlZ0V4cFxuXG4gIC8vICBNYXRjaCA6OiBUeXBlXG4gIHZhciBNYXRjaCA9ICQuUmVjb3JkVHlwZSh7XG4gICAgbWF0Y2g6ICQuU3RyaW5nLFxuICAgIGdyb3VwczogJC5BcnJheSgkTWF5YmUoJC5TdHJpbmcpKVxuICB9KTtcblxuICAvLyAgdG9NYXRjaCA6OiBBcnJheSBTdHJpbmc/IC0+IE1hdGNoXG4gIGZ1bmN0aW9uIHRvTWF0Y2goc3MpIHtcbiAgICByZXR1cm4ge21hdGNoOiBzc1swXSwgZ3JvdXBzOiBzcy5zbGljZSgxKS5tYXAodG9NYXliZSl9O1xuICB9XG5cbiAgLy8gIHdpdGhSZWdleCA6OiAoUmVnRXhwLCAoKSAtPiBhKSAtPiBhXG4gIGZ1bmN0aW9uIHdpdGhSZWdleChwYXR0ZXJuLCB0aHVuaykge1xuICAgIHZhciBsYXN0SW5kZXggPSBwYXR0ZXJuLmxhc3RJbmRleDtcbiAgICB2YXIgcmVzdWx0ID0gdGh1bmsoKTtcbiAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8jIHJlZ2V4IDo6IFJlZ2V4RmxhZ3MgLT4gU3RyaW5nIC0+IFJlZ0V4cFxuICAvLy5cbiAgLy8uIFRha2VzIGEgW1JlZ2V4RmxhZ3NdW10gYW5kIGEgcGF0dGVybiwgYW5kIHJldHVybnMgYSBSZWdFeHAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnJlZ2V4KCdnJywgJzpcXFxcZCs6JylcbiAgLy8uIC86XFxkKzovZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHJlZ2V4KGZsYWdzLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChzb3VyY2UsIGZsYWdzKTtcbiAgfVxuICBTLnJlZ2V4ID0gZGVmKCdyZWdleCcsIHt9LCBbJC5SZWdleEZsYWdzLCAkLlN0cmluZywgJC5SZWdFeHBdLCByZWdleCk7XG5cbiAgLy8jIHJlZ2V4RXNjYXBlIDo6IFN0cmluZyAtPiBTdHJpbmdcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHN0cmluZyB3aGljaCBtYXkgY29udGFpbiByZWd1bGFyIGV4cHJlc3Npb24gbWV0YWNoYXJhY3RlcnMsXG4gIC8vLiBhbmQgcmV0dXJucyBhIHN0cmluZyB3aXRoIHRob3NlIG1ldGFjaGFyYWN0ZXJzIGVzY2FwZWQuXG4gIC8vLlxuICAvLy4gUHJvcGVydGllczpcbiAgLy8uXG4gIC8vLiAgIC0gYGZvcmFsbCBzIDo6IFN0cmluZy4gUy50ZXN0KFMucmVnZXgoJycsIFMucmVnZXhFc2NhcGUocykpLCBzKSA9IHRydWVgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnJlZ2V4RXNjYXBlKCctPSp7WFlafSo9LScpXG4gIC8vLiAnXFxcXC09XFxcXCpcXFxce1hZWlxcXFx9XFxcXCo9XFxcXC0nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcmVnZXhFc2NhcGUocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4gIH1cbiAgUy5yZWdleEVzY2FwZSA9IGRlZigncmVnZXhFc2NhcGUnLCB7fSwgWyQuU3RyaW5nLCAkLlN0cmluZ10sIHJlZ2V4RXNjYXBlKTtcblxuICAvLyMgdGVzdCA6OiBSZWdFeHAgLT4gU3RyaW5nIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHBhdHRlcm4gYW5kIGEgc3RyaW5nLCBhbmQgcmV0dXJucyBgdHJ1ZWAgW2lmZl1bXSB0aGUgcGF0dGVyblxuICAvLy4gbWF0Y2hlcyB0aGUgc3RyaW5nLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy50ZXN0KC9eYS8sICdhYmFjdXMnKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy50ZXN0KC9eYS8sICdiYW5hbmEnKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiB0ZXN0KHBhdHRlcm4sIHMpIHtcbiAgICByZXR1cm4gd2l0aFJlZ2V4KHBhdHRlcm4sIGZ1bmN0aW9uKCkgeyByZXR1cm4gcGF0dGVybi50ZXN0KHMpOyB9KTtcbiAgfVxuICBTLnRlc3QgPSBkZWYoJ3Rlc3QnLCB7fSwgWyQuUmVnRXhwLCAkLlN0cmluZywgJC5Cb29sZWFuXSwgdGVzdCk7XG5cbiAgLy8jIG1hdGNoIDo6IE5vbkdsb2JhbFJlZ0V4cCAtPiBTdHJpbmcgLT4gTWF5YmUgeyBtYXRjaCA6OiBTdHJpbmcsIGdyb3VwcyA6OiBBcnJheSAoTWF5YmUgU3RyaW5nKSB9XG4gIC8vLlxuICAvLy4gVGFrZXMgYSBwYXR0ZXJuIGFuZCBhIHN0cmluZywgYW5kIHJldHVybnMgSnVzdCBhIG1hdGNoIHJlY29yZCBpZiB0aGVcbiAgLy8uIHBhdHRlcm4gbWF0Y2hlcyB0aGUgc3RyaW5nOyBOb3RoaW5nIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBgZ3JvdXBzIDo6IEFycmF5IChNYXliZSBTdHJpbmcpYCBhY2tub3dsZWRnZXMgdGhlIGV4aXN0ZW5jZSBvZiBvcHRpb25hbFxuICAvLy4gY2FwdHVyaW5nIGdyb3Vwcy5cbiAgLy8uXG4gIC8vLiBQcm9wZXJ0aWVzOlxuICAvLy5cbiAgLy8uICAgLSBgZm9yYWxsIHAgOjogUGF0dGVybiwgcyA6OiBTdHJpbmcuXG4gIC8vLiAgICAgIFMuaGVhZChTLm1hdGNoQWxsKFMucmVnZXgoJ2cnLCBwKSwgcykpID0gUy5tYXRjaChTLnJlZ2V4KCcnLCBwKSwgcylgXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BtYXRjaEFsbGBdKCNtYXRjaEFsbCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1hdGNoKC8oZ29vZCk/YnllLywgJ2dvb2RieWUnKVxuICAvLy4gSnVzdCh7bWF0Y2g6ICdnb29kYnllJywgZ3JvdXBzOiBbSnVzdCgnZ29vZCcpXX0pXG4gIC8vLlxuICAvLy4gPiBTLm1hdGNoKC8oZ29vZCk/YnllLywgJ2J5ZScpXG4gIC8vLiBKdXN0KHttYXRjaDogJ2J5ZScsIGdyb3VwczogW05vdGhpbmddfSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBtYXRjaChwYXR0ZXJuLCBzKSB7XG4gICAgcmV0dXJuIFoubWFwKHRvTWF0Y2gsIHRvTWF5YmUocy5tYXRjaChwYXR0ZXJuKSkpO1xuICB9XG4gIFMubWF0Y2ggPVxuICBkZWYoJ21hdGNoJywge30sIFskLk5vbkdsb2JhbFJlZ0V4cCwgJC5TdHJpbmcsICRNYXliZShNYXRjaCldLCBtYXRjaCk7XG5cbiAgLy8jIG1hdGNoQWxsIDo6IEdsb2JhbFJlZ0V4cCAtPiBTdHJpbmcgLT4gQXJyYXkgeyBtYXRjaCA6OiBTdHJpbmcsIGdyb3VwcyA6OiBBcnJheSAoTWF5YmUgU3RyaW5nKSB9XG4gIC8vLlxuICAvLy4gVGFrZXMgYSBwYXR0ZXJuIGFuZCBhIHN0cmluZywgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2ggcmVjb3Jkcy5cbiAgLy8uXG4gIC8vLiBgZ3JvdXBzIDo6IEFycmF5IChNYXliZSBTdHJpbmcpYCBhY2tub3dsZWRnZXMgdGhlIGV4aXN0ZW5jZSBvZiBvcHRpb25hbFxuICAvLy4gY2FwdHVyaW5nIGdyb3Vwcy5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYG1hdGNoYF0oI21hdGNoKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWF0Y2hBbGwoL0AoW2Etel0rKS9nLCAnSGVsbG8sIHdvcmxkIScpXG4gIC8vLiBbXVxuICAvLy5cbiAgLy8uID4gUy5tYXRjaEFsbCgvQChbYS16XSspL2csICdIZWxsbywgQGZvbyEgSGVsbG8sIEBiYXIhIEhlbGxvLCBAYmF6IScpXG4gIC8vLiBbIHttYXRjaDogJ0Bmb28nLCBncm91cHM6IFtKdXN0KCdmb28nKV19LFxuICAvLy4gLiB7bWF0Y2g6ICdAYmFyJywgZ3JvdXBzOiBbSnVzdCgnYmFyJyldfSxcbiAgLy8uIC4ge21hdGNoOiAnQGJheicsIGdyb3VwczogW0p1c3QoJ2JheicpXX0gXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG1hdGNoQWxsKHBhdHRlcm4sIHMpIHtcbiAgICByZXR1cm4gd2l0aFJlZ2V4KHBhdHRlcm4sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHVuZm9sZHIoZnVuY3Rpb24oXykge1xuICAgICAgICByZXR1cm4gWi5tYXAoZnVuY3Rpb24oc3MpIHtcbiAgICAgICAgICByZXR1cm4gW3RvTWF0Y2goc3MpLCBudWxsXTtcbiAgICAgICAgfSwgdG9NYXliZShwYXR0ZXJuLmV4ZWMocykpKTtcbiAgICAgIH0sIFtdKTtcbiAgICB9KTtcbiAgfVxuICBTLm1hdGNoQWxsID1cbiAgZGVmKCdtYXRjaEFsbCcsIHt9LCBbJC5HbG9iYWxSZWdFeHAsICQuU3RyaW5nLCAkLkFycmF5KE1hdGNoKV0sIG1hdGNoQWxsKTtcblxuICAvLy4gIyMjIFN0cmluZ1xuXG4gIC8vIyB0b1VwcGVyIDo6IFN0cmluZyAtPiBTdHJpbmdcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSB1cHBlci1jYXNlIGVxdWl2YWxlbnQgb2YgaXRzIGFyZ3VtZW50LlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgdG9Mb3dlcmBdKCN0b0xvd2VyKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMudG9VcHBlcignQUJDIGRlZiAxMjMnKVxuICAvLy4gJ0FCQyBERUYgMTIzJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHRvVXBwZXIocykge1xuICAgIHJldHVybiBzLnRvVXBwZXJDYXNlKCk7XG4gIH1cbiAgUy50b1VwcGVyID0gZGVmKCd0b1VwcGVyJywge30sIFskLlN0cmluZywgJC5TdHJpbmddLCB0b1VwcGVyKTtcblxuICAvLyMgdG9Mb3dlciA6OiBTdHJpbmcgLT4gU3RyaW5nXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgbG93ZXItY2FzZSBlcXVpdmFsZW50IG9mIGl0cyBhcmd1bWVudC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHRvVXBwZXJgXSgjdG9VcHBlcikuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRvTG93ZXIoJ0FCQyBkZWYgMTIzJylcbiAgLy8uICdhYmMgZGVmIDEyMydcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiB0b0xvd2VyKHMpIHtcbiAgICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIFMudG9Mb3dlciA9IGRlZigndG9Mb3dlcicsIHt9LCBbJC5TdHJpbmcsICQuU3RyaW5nXSwgdG9Mb3dlcik7XG5cbiAgLy8jIHRyaW0gOjogU3RyaW5nIC0+IFN0cmluZ1xuICAvLy5cbiAgLy8uIFN0cmlwcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRyaW0oJ1xcdFxcdCBmb28gYmFyIFxcbicpXG4gIC8vLiAnZm9vIGJhcidcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiB0cmltKHMpIHtcbiAgICByZXR1cm4gcy50cmltKCk7XG4gIH1cbiAgUy50cmltID0gZGVmKCd0cmltJywge30sIFskLlN0cmluZywgJC5TdHJpbmddLCB0cmltKTtcblxuICAvLyMgc3RyaXBQcmVmaXggOjogU3RyaW5nIC0+IFN0cmluZyAtPiBNYXliZSBTdHJpbmdcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIEp1c3QgdGhlIHBvcnRpb24gb2YgdGhlIGdpdmVuIHN0cmluZyAodGhlIHNlY29uZCBhcmd1bWVudCkgbGVmdFxuICAvLy4gYWZ0ZXIgcmVtb3ZpbmcgdGhlIGdpdmVuIHByZWZpeCAodGhlIGZpcnN0IGFyZ3VtZW50KSBpZiB0aGUgc3RyaW5nIHN0YXJ0c1xuICAvLy4gd2l0aCB0aGUgcHJlZml4OyBOb3RoaW5nIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHN0cmlwU3VmZml4YF0oI3N0cmlwU3VmZml4KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuc3RyaXBQcmVmaXgoJ2h0dHBzOi8vJywgJ2h0dHBzOi8vc2FuY3R1YXJ5LmpzLm9yZycpXG4gIC8vLiBKdXN0KCdzYW5jdHVhcnkuanMub3JnJylcbiAgLy8uXG4gIC8vLiA+IFMuc3RyaXBQcmVmaXgoJ2h0dHBzOi8vJywgJ2h0dHA6Ly9zYW5jdHVhcnkuanMub3JnJylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBzdHJpcFByZWZpeChwcmVmaXgsIHMpIHtcbiAgICB2YXIgaWR4ID0gcHJlZml4Lmxlbmd0aDtcbiAgICByZXR1cm4gcy5zbGljZSgwLCBpZHgpID09PSBwcmVmaXggPyBKdXN0KHMuc2xpY2UoaWR4KSkgOiBOb3RoaW5nO1xuICB9XG4gIFMuc3RyaXBQcmVmaXggPVxuICBkZWYoJ3N0cmlwUHJlZml4Jywge30sIFskLlN0cmluZywgJC5TdHJpbmcsICRNYXliZSgkLlN0cmluZyldLCBzdHJpcFByZWZpeCk7XG5cbiAgLy8jIHN0cmlwU3VmZml4IDo6IFN0cmluZyAtPiBTdHJpbmcgLT4gTWF5YmUgU3RyaW5nXG4gIC8vLlxuICAvLy4gUmV0dXJucyBKdXN0IHRoZSBwb3J0aW9uIG9mIHRoZSBnaXZlbiBzdHJpbmcgKHRoZSBzZWNvbmQgYXJndW1lbnQpIGxlZnRcbiAgLy8uIGFmdGVyIHJlbW92aW5nIHRoZSBnaXZlbiBzdWZmaXggKHRoZSBmaXJzdCBhcmd1bWVudCkgaWYgdGhlIHN0cmluZyBlbmRzXG4gIC8vLiB3aXRoIHRoZSBzdWZmaXg7IE5vdGhpbmcgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgc3RyaXBQcmVmaXhgXSgjc3RyaXBQcmVmaXgpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5zdHJpcFN1ZmZpeCgnLm1kJywgJ1JFQURNRS5tZCcpXG4gIC8vLiBKdXN0KCdSRUFETUUnKVxuICAvLy5cbiAgLy8uID4gUy5zdHJpcFN1ZmZpeCgnLm1kJywgJ1JFQURNRScpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gc3RyaXBTdWZmaXgoc3VmZml4LCBzKSB7XG4gICAgdmFyIGlkeCA9IHMubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aDsgIC8vIHZhbHVlIG1heSBiZSBuZWdhdGl2ZVxuICAgIHJldHVybiBzLnNsaWNlKGlkeCkgPT09IHN1ZmZpeCA/IEp1c3Qocy5zbGljZSgwLCBpZHgpKSA6IE5vdGhpbmc7XG4gIH1cbiAgUy5zdHJpcFN1ZmZpeCA9XG4gIGRlZignc3RyaXBTdWZmaXgnLCB7fSwgWyQuU3RyaW5nLCAkLlN0cmluZywgJE1heWJlKCQuU3RyaW5nKV0sIHN0cmlwU3VmZml4KTtcblxuICAvLyMgd29yZHMgOjogU3RyaW5nIC0+IEFycmF5IFN0cmluZ1xuICAvLy5cbiAgLy8uIFRha2VzIGEgc3RyaW5nIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiB3b3JkcyB0aGUgc3RyaW5nIGNvbnRhaW5zXG4gIC8vLiAod29yZHMgYXJlIGRlbGltaXRlZCBieSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgdW53b3Jkc2BdKCN1bndvcmRzKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMud29yZHMoJyBmb28gYmFyIGJheiAnKVxuICAvLy4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gd29yZHMocykge1xuICAgIHZhciB3b3JkcyA9IHMuc3BsaXQoL1xccysvKTtcbiAgICByZXR1cm4gd29yZHMuc2xpY2Uod29yZHNbMF0gPT09ICcnID8gMSA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgIHdvcmRzW3dvcmRzLmxlbmd0aCAtIDFdID09PSAnJyA/IC0xIDogSW5maW5pdHkpO1xuICB9XG4gIFMud29yZHMgPSBkZWYoJ3dvcmRzJywge30sIFskLlN0cmluZywgJC5BcnJheSgkLlN0cmluZyldLCB3b3Jkcyk7XG5cbiAgLy8jIHVud29yZHMgOjogQXJyYXkgU3RyaW5nIC0+IFN0cmluZ1xuICAvLy5cbiAgLy8uIFRha2VzIGFuIGFycmF5IG9mIHdvcmRzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2Ygam9pbmluZyB0aGUgd29yZHNcbiAgLy8uIHdpdGggc2VwYXJhdGluZyBzcGFjZXMuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2B3b3Jkc2BdKCN3b3JkcykuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnVud29yZHMoWydmb28nLCAnYmFyJywgJ2JheiddKVxuICAvLy4gJ2ZvbyBiYXIgYmF6J1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHVud29yZHMoeHMpIHtcbiAgICByZXR1cm4geHMuam9pbignICcpO1xuICB9XG4gIFMudW53b3JkcyA9IGRlZigndW53b3JkcycsIHt9LCBbJC5BcnJheSgkLlN0cmluZyksICQuU3RyaW5nXSwgdW53b3Jkcyk7XG5cbiAgLy8jIGxpbmVzIDo6IFN0cmluZyAtPiBBcnJheSBTdHJpbmdcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHN0cmluZyBhbmQgcmV0dXJucyB0aGUgYXJyYXkgb2YgbGluZXMgdGhlIHN0cmluZyBjb250YWluc1xuICAvLy4gKGxpbmVzIGFyZSBkZWxpbWl0ZWQgYnkgbmV3bGluZXM6IGAnXFxuJ2Agb3IgYCdcXHJcXG4nYCBvciBgJ1xccidgKS5cbiAgLy8uIFRoZSByZXN1bHRpbmcgc3RyaW5ncyBkbyBub3QgY29udGFpbiBuZXdsaW5lcy5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHVubGluZXNgXSgjdW5saW5lcykuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmxpbmVzKCdmb29cXG5iYXJcXG5iYXpcXG4nKVxuICAvLy4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbGluZXMocykge1xuICAgIHZhciBtYXRjaCA9IHMucmVwbGFjZSgvXFxyXFxuPy9nLCAnXFxuJykubWF0Y2goL14oPz1bXFxzXFxTXSkuKi9nbSk7XG4gICAgcmV0dXJuIG1hdGNoID09IG51bGwgPyBbXSA6IG1hdGNoO1xuICB9XG4gIFMubGluZXMgPSBkZWYoJ2xpbmVzJywge30sIFskLlN0cmluZywgJC5BcnJheSgkLlN0cmluZyldLCBsaW5lcyk7XG5cbiAgLy8jIHVubGluZXMgOjogQXJyYXkgU3RyaW5nIC0+IFN0cmluZ1xuICAvLy5cbiAgLy8uIFRha2VzIGFuIGFycmF5IG9mIGxpbmVzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2Ygam9pbmluZyB0aGUgbGluZXNcbiAgLy8uIGFmdGVyIGFwcGVuZGluZyBhIHRlcm1pbmF0aW5nIGxpbmUgZmVlZCAoYCdcXG4nYCkgdG8gZWFjaC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGxpbmVzYF0oI2xpbmVzKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMudW5saW5lcyhbJ2ZvbycsICdiYXInLCAnYmF6J10pXG4gIC8vLiAnZm9vXFxuYmFyXFxuYmF6XFxuJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHVubGluZXMoeHMpIHtcbiAgICByZXR1cm4gWi5yZWR1Y2UoZnVuY3Rpb24ocywgeCkgeyByZXR1cm4gcyArIHggKyAnXFxuJzsgfSwgJycsIHhzKTtcbiAgfVxuICBTLnVubGluZXMgPSBkZWYoJ3VubGluZXMnLCB7fSwgWyQuQXJyYXkoJC5TdHJpbmcpLCAkLlN0cmluZ10sIHVubGluZXMpO1xuXG4gIC8vIyBzcGxpdE9uIDo6IFN0cmluZyAtPiBTdHJpbmcgLT4gQXJyYXkgU3RyaW5nXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgc3Vic3RyaW5ncyBvZiBpdHMgc2Vjb25kIGFyZ3VtZW50IHNlcGFyYXRlZCBieSBvY2N1cnJlbmNlc1xuICAvLy4gb2YgaXRzIGZpcnN0IGFyZ3VtZW50LlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgam9pbldpdGhgXSgjam9pbldpdGgpIGFuZCBbYHNwbGl0T25SZWdleGBdKCNzcGxpdE9uUmVnZXgpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5zcGxpdE9uKCc6OicsICdmb286OmJhcjo6YmF6JylcbiAgLy8uIFsnZm9vJywgJ2JhcicsICdiYXonXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHNwbGl0T24oc2VwYXJhdG9yLCBzKSB7XG4gICAgcmV0dXJuIHMuc3BsaXQoc2VwYXJhdG9yKTtcbiAgfVxuICBTLnNwbGl0T24gPVxuICBkZWYoJ3NwbGl0T24nLCB7fSwgWyQuU3RyaW5nLCAkLlN0cmluZywgJC5BcnJheSgkLlN0cmluZyldLCBzcGxpdE9uKTtcblxuICAvLyMgc3BsaXRPblJlZ2V4IDo6IEdsb2JhbFJlZ0V4cCAtPiBTdHJpbmcgLT4gQXJyYXkgU3RyaW5nXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBwYXR0ZXJuIGFuZCBhIHN0cmluZywgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBvZiBzcGxpdHRpbmcgdGhlXG4gIC8vLiBzdHJpbmcgYXQgZXZlcnkgbm9uLW92ZXJsYXBwaW5nIG9jY3VycmVuY2Ugb2YgdGhlIHBhdHRlcm4uXG4gIC8vLlxuICAvLy4gUHJvcGVydGllczpcbiAgLy8uXG4gIC8vLiAgIC0gYGZvcmFsbCBzIDo6IFN0cmluZywgdCA6OiBTdHJpbmcuXG4gIC8vLiAgICAgIFMuam9pbldpdGgocywgUy5zcGxpdE9uUmVnZXgoUy5yZWdleCgnZycsIFMucmVnZXhFc2NhcGUocykpLCB0KSlcbiAgLy8uICAgICAgPSB0YFxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgc3BsaXRPbmBdKCNzcGxpdE9uKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuc3BsaXRPblJlZ2V4KC9bLDtdWyBdKi9nLCAnZm9vLCBiYXIsIGJheicpXG4gIC8vLiBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAgLy8uXG4gIC8vLiA+IFMuc3BsaXRPblJlZ2V4KC9bLDtdWyBdKi9nLCAnZm9vO2JhcjtiYXonKVxuICAvLy4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gc3BsaXRPblJlZ2V4KHBhdHRlcm4sIHMpIHtcbiAgICByZXR1cm4gd2l0aFJlZ2V4KHBhdHRlcm4sIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgbWF0Y2g7XG4gICAgICB3aGlsZSAoKG1hdGNoID0gcGF0dGVybi5leGVjKHMpKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuLmxhc3RJbmRleCA9PT0gbGFzdEluZGV4ICYmIG1hdGNoWzBdID09PSAnJykge1xuICAgICAgICAgIGlmIChwYXR0ZXJuLmxhc3RJbmRleCA9PT0gcy5sZW5ndGgpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggKz0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChzLnNsaWNlKGxhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2gocy5zbGljZShsYXN0SW5kZXgpKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gIH1cbiAgUy5zcGxpdE9uUmVnZXggPVxuICBkZWYoJ3NwbGl0T25SZWdleCcsXG4gICAgICB7fSxcbiAgICAgIFskLkdsb2JhbFJlZ0V4cCwgJC5TdHJpbmcsICQuQXJyYXkoJC5TdHJpbmcpXSxcbiAgICAgIHNwbGl0T25SZWdleCk7XG5cbiAgcmV0dXJuIFM7XG5cbiAgLyogZXNsaW50LWVuYWJsZSBpbmRlbnQgKi9cblxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZVNhbmN0dWFyeSh7Y2hlY2tUeXBlczogdHJ1ZSwgZW52OiBkZWZhdWx0RW52fSk7XG5cbn0pKTtcblxuLy8uIFskLkFycmF5XTogICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LWRlZiNBcnJheVxuLy8uIFskLlN0cmluZ106ICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LWRlZiNTdHJpbmdcbi8vLiBbQWx0XTogICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FsdFxuLy8uIFtBbHRlcm5hdGl2ZV06ICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYWx0ZXJuYXRpdmVcbi8vLiBbQXBwbGljYXRpdmVdOiAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FwcGxpY2F0aXZlXG4vLy4gW0FwcGx5XTogICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhcHBseVxuLy8uIFtCaWZ1bmN0b3JdOiAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYmlmdW5jdG9yXG4vLy4gW0JpbmFyeVR5cGVdOiAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktZGVmI0JpbmFyeVR5cGVcbi8vLiBbRWl0aGVyXTogICAgICAgICAgICNlaXRoZXItdHlwZVxuLy8uIFtFeHRlbmRdOiAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZXh0ZW5kXG4vLy4gW0ZhbnRhc3kgTGFuZF06ICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZFxuLy8uIFtGb2xkYWJsZV06ICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZm9sZGFibGVcbi8vLiBbSGFza2VsbF06ICAgICAgICAgIGh0dHBzOi8vd3d3Lmhhc2tlbGwub3JnL1xuLy8uIFtNYXliZV06ICAgICAgICAgICAgI21heWJlLXR5cGVcbi8vLiBbTW9uYWRdOiAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI21vbmFkXG4vLy4gW01vbm9pZF06ICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNtb25vaWRcbi8vLiBbTnVsbGFibGVdOiAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS1kZWYjTnVsbGFibGVcbi8vLiBbT3JkXTogICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI29yZFxuLy8uIFtQdXJlU2NyaXB0XTogICAgICAgaHR0cDovL3d3dy5wdXJlc2NyaXB0Lm9yZy9cbi8vLiBbUmFtZGFdOiAgICAgICAgICAgIGh0dHA6Ly9yYW1kYWpzLmNvbS9cbi8vLiBbUmVnZXhGbGFnc106ICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS1kZWYjUmVnZXhGbGFnc1xuLy8uIFtTZW1pZ3JvdXBdOiAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjc2VtaWdyb3VwXG4vLy4gW1NlbWlncm91cG9pZF06ICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNzZW1pZ3JvdXBvaWRcbi8vLiBbVHJhdmVyc2FibGVdOiAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3RyYXZlcnNhYmxlXG4vLy4gW1VuYXJ5VHlwZV06ICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktZGVmI1VuYXJ5VHlwZVxuLy8uIFtgTWF0aC5wb3dgXTogICAgICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9wb3dcbi8vLiBbYFouYWx0YF06ICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjYWx0XG4vLy4gW2BaLmFwYF06ICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2FwXG4vLy4gW2BaLmFwRmlyc3RgXTogICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2FwRmlyc3Rcbi8vLiBbYFouYXBTZWNvbmRgXTogICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjYXBTZWNvbmRcbi8vLiBbYFouYmltYXBgXTogICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjYmltYXBcbi8vLiBbYFouY2hhaW5gXTogICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjY2hhaW5cbi8vLiBbYFouY2hhaW5SZWNgXTogICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjY2hhaW5SZWNcbi8vLiBbYFouY29tcG9zZWBdOiAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjY29tcG9zZVxuLy8uIFtgWi5jb25jYXRgXTogICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNjb25jYXRcbi8vLiBbYFouY29udHJhbWFwYF06ICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjY29udHJhbWFwXG4vLy4gW2BaLmVtcHR5YF06ICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2VtcHR5XG4vLy4gW2BaLmVxdWFsc2BdOiAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2VxdWFsc1xuLy8uIFtgWi5leHRlbmRgXTogICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNleHRlbmRcbi8vLiBbYFouZXh0cmFjdGBdOiAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjZXh0cmFjdFxuLy8uIFtgWi5maWx0ZXJgXTogICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNmaWx0ZXJcbi8vLiBbYFouZmlsdGVyTWBdOiAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjZmlsdGVyTVxuLy8uIFtgWi5ndGBdOiAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNndFxuLy8uIFtgWi5ndGVgXTogICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNndGVcbi8vLiBbYFouaWRgXTogICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjaWRcbi8vLiBbYFouaW52ZXJ0YF06ICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjaW52ZXJ0XG4vLy4gW2BaLmpvaW5gXTogICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2pvaW5cbi8vLiBbYFoubHRgXTogICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjbHRcbi8vLiBbYFoubHRlYF06ICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjbHRlXG4vLy4gW2BaLm1hcGBdOiAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI21hcFxuLy8uIFtgWi5vZmBdOiAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNvZlxuLy8uIFtgWi5wcm9tYXBgXTogICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNwcm9tYXBcbi8vLiBbYFouc2VxdWVuY2VgXTogICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjc2VxdWVuY2Vcbi8vLiBbYFoudG9TdHJpbmdgXTogICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjdG9TdHJpbmdcbi8vLiBbYFoudHJhdmVyc2VgXTogICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjdHJhdmVyc2Vcbi8vLiBbYFouemVyb2BdOiAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjemVyb1xuLy8uIFtgb2ZgXTogICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjb2YtbWV0aG9kXG4vLy4gW2VxdWl2YWxlbmNlXTogICAgICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FcXVpdmFsZW5jZV9yZWxhdGlvblxuLy8uIFtpZmZdOiAgICAgICAgICAgICAgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSWZfYW5kX29ubHlfaWZcbi8vLiBbcGFyc2VJbnRdOiAgICAgICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL3BhcnNlSW50XG4vLy4gW3NhbmN0dWFyeS1kZWZdOiAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktZGVmXG4vLy4gW3N0YWJsZSBzb3J0XTogICAgICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Tb3J0aW5nX2FsZ29yaXRobSNTdGFiaWxpdHlcbi8vLiBbdGhydXNoXTogICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWdhbndhbGQtZGVwcmVjYXRlZC9ob21vaWNvbmljL2Jsb2IvbWFzdGVyLzIwMDgtMTAtMzAvdGhydXNoLm1hcmtkb3duXG4vLy4gW3R5cGUgaWRlbnRpZmllcl06ICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1pZGVudGlmaWVyc1xuLy8uXG4vLy4gW2BFaXRoZXIjZmFudGFzeS1sYW5kL2JpbWFwYF06ICAgICAgI0VpdGhlci5wcm90b3R5cGUuZmFudGFzeS1sYW5kL2JpbWFwXG4vLy4gW2BFaXRoZXIjZmFudGFzeS1sYW5kL21hcGBdOiAgICAgICAgI0VpdGhlci5wcm90b3R5cGUuZmFudGFzeS1sYW5kL21hcFxuLy8uIFtgRWl0aGVyI3RvU3RyaW5nYF06ICAgICAgICAgICAgICAgICNFaXRoZXIucHJvdG90eXBlLnRvU3RyaW5nXG4vLy4gW2BNYXliZSN0b1N0cmluZ2BdOiAgICAgICAgICAgICAgICAgI01heWJlLnByb3RvdHlwZS50b1N0cmluZ1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5L2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///29\n");

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {(function(global, f){\n\n  'use strict';\n\n  /*istanbul ignore next*/\n  if(module && typeof module.exports !== 'undefined'){\n    module.exports = f(\n      __webpack_require__(9),\n      __webpack_require__(3),\n      __webpack_require__(1)\n    );\n  }else{\n    global.flutureSanctuaryTypes = f(\n      global.Fluture,\n      global.sanctuaryDef,\n      global.sanctuaryTypeIdentifiers\n    );\n  }\n\n}(/*istanbul ignore next*/(global || window || this), function(Future, $, type){\n\n  'use strict';\n\n  //  $$type :: String\n  var $$type = '@@type';\n\n  //  FutureType :: (Type, Type) -> Type\n  var FutureType = $.BinaryType(\n    type.parse(Future[$$type]).name,\n    'https://github.com/fluture-js/Fluture#readme',\n    Future.isFuture,\n    Future.extractLeft,\n    Future.extractRight\n  );\n\n  //  ConcurrentFutureType :: (Type, Type) -> Type\n  var ConcurrentFutureType = $.BinaryType(\n    type.parse(Future.Par[$$type]).name,\n    'https://github.com/fluture-js/Fluture#concurrentfuture',\n    function(x){ return type(x) === Future.Par[$$type] },\n    function(f){ return Future.seq(f).extractLeft() },\n    function(f){ return Future.seq(f).extractRight() }\n  );\n\n  var env = [\n    FutureType($.Unknown, $.Unknown),\n    ConcurrentFutureType($.Unknown, $.Unknown)\n  ];\n\n  return {\n    FutureType: FutureType,\n    ConcurrentFutureType: ConcurrentFutureType,\n    env: env\n  };\n\n}));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10), __webpack_require__(5)(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmx1dHVyZS1zYW5jdHVhcnktdHlwZXMvaW5kZXguanM/NWNlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oZ2xvYmFsLCBmKXtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgbmV4dCovXG4gIGlmKG1vZHVsZSAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09ICd1bmRlZmluZWQnKXtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGYoXG4gICAgICByZXF1aXJlKCdmbHV0dXJlJyksXG4gICAgICByZXF1aXJlKCdzYW5jdHVhcnktZGVmJyksXG4gICAgICByZXF1aXJlKCdzYW5jdHVhcnktdHlwZS1pZGVudGlmaWVycycpXG4gICAgKTtcbiAgfWVsc2V7XG4gICAgZ2xvYmFsLmZsdXR1cmVTYW5jdHVhcnlUeXBlcyA9IGYoXG4gICAgICBnbG9iYWwuRmx1dHVyZSxcbiAgICAgIGdsb2JhbC5zYW5jdHVhcnlEZWYsXG4gICAgICBnbG9iYWwuc2FuY3R1YXJ5VHlwZUlkZW50aWZpZXJzXG4gICAgKTtcbiAgfVxuXG59KC8qaXN0YW5idWwgaWdub3JlIG5leHQqLyhnbG9iYWwgfHwgd2luZG93IHx8IHRoaXMpLCBmdW5jdGlvbihGdXR1cmUsICQsIHR5cGUpe1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyAgJCR0eXBlIDo6IFN0cmluZ1xuICB2YXIgJCR0eXBlID0gJ0BAdHlwZSc7XG5cbiAgLy8gIEZ1dHVyZVR5cGUgOjogKFR5cGUsIFR5cGUpIC0+IFR5cGVcbiAgdmFyIEZ1dHVyZVR5cGUgPSAkLkJpbmFyeVR5cGUoXG4gICAgdHlwZS5wYXJzZShGdXR1cmVbJCR0eXBlXSkubmFtZSxcbiAgICAnaHR0cHM6Ly9naXRodWIuY29tL2ZsdXR1cmUtanMvRmx1dHVyZSNyZWFkbWUnLFxuICAgIEZ1dHVyZS5pc0Z1dHVyZSxcbiAgICBGdXR1cmUuZXh0cmFjdExlZnQsXG4gICAgRnV0dXJlLmV4dHJhY3RSaWdodFxuICApO1xuXG4gIC8vICBDb25jdXJyZW50RnV0dXJlVHlwZSA6OiAoVHlwZSwgVHlwZSkgLT4gVHlwZVxuICB2YXIgQ29uY3VycmVudEZ1dHVyZVR5cGUgPSAkLkJpbmFyeVR5cGUoXG4gICAgdHlwZS5wYXJzZShGdXR1cmUuUGFyWyQkdHlwZV0pLm5hbWUsXG4gICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mbHV0dXJlLWpzL0ZsdXR1cmUjY29uY3VycmVudGZ1dHVyZScsXG4gICAgZnVuY3Rpb24oeCl7IHJldHVybiB0eXBlKHgpID09PSBGdXR1cmUuUGFyWyQkdHlwZV0gfSxcbiAgICBmdW5jdGlvbihmKXsgcmV0dXJuIEZ1dHVyZS5zZXEoZikuZXh0cmFjdExlZnQoKSB9LFxuICAgIGZ1bmN0aW9uKGYpeyByZXR1cm4gRnV0dXJlLnNlcShmKS5leHRyYWN0UmlnaHQoKSB9XG4gICk7XG5cbiAgdmFyIGVudiA9IFtcbiAgICBGdXR1cmVUeXBlKCQuVW5rbm93biwgJC5Vbmtub3duKSxcbiAgICBDb25jdXJyZW50RnV0dXJlVHlwZSgkLlVua25vd24sICQuVW5rbm93bilcbiAgXTtcblxuICByZXR1cm4ge1xuICAgIEZ1dHVyZVR5cGU6IEZ1dHVyZVR5cGUsXG4gICAgQ29uY3VycmVudEZ1dHVyZVR5cGU6IENvbmN1cnJlbnRGdXR1cmVUeXBlLFxuICAgIGVudjogZW52XG4gIH07XG5cbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZsdXR1cmUtc2FuY3R1YXJ5LXR5cGVzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///30\n");

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SourceLink = exports.Pic = exports.LoadingSpinner = exports.Main = exports.Arrow = exports.ArrowButtons = exports.Nav = exports.LetterButton = undefined;\n\nvar _preact = __webpack_require__(2);\n\nvar _preactEmotion = __webpack_require__(32);\n\nvar _preactEmotion2 = _interopRequireDefault(_preactEmotion);\n\nvar _polished = __webpack_require__(17);\n\nvar P = _interopRequireWildcard(_polished);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(0, _preactEmotion.injectGlobal)(\"*{font-family:BlinkMacSystemFont,\\\"Segoe UI\\\",Helvetica,sans-serif;box-sizing:border-box;margin:0;padding:0;}\");\n\nvar LetterButton = /*#__PURE__*/exports.LetterButton = (0, _preactEmotion2.default)(\"button\", {\n  target: \"css-16o68ge0\"\n})(\"display:flex;min-width:10px;border-radius:3px;font-size:1rem;text-transform:uppercase;padding:5px;margin:5px;border:2px solid black;background:\", function (_ref) {\n  var active = _ref.active,\n      color = _ref.color;\n  return active ? P.darken(0.2, color) : \"white\";\n}, \";\");\n\nvar Nav = /*#__PURE__*/exports.Nav = (0, _preactEmotion2.default)(\"nav\", {\n  target: \"css-16o68ge1\"\n})(\"display:flex;justify-content:center;align-items:space-around;\");\n\nvar ArrowButtons = /*#__PURE__*/exports.ArrowButtons = (0, _preactEmotion2.default)(\"div\", {\n  target: \"css-16o68ge2\"\n})(\"display:flex;justify-content:center;align-items:space-around;button:last-of-type{margin-left:3px;}padding-top:10px;\");\n\nvar Arrow = /*#__PURE__*/exports.Arrow = (0, _preactEmotion2.default)(\"button\", {\n  target: \"css-16o68ge3\"\n})(\"padding:5px 14px;font-size:1.5rem;border:2px solid black;border-radius:3px;background:#fff;\");\n\nvar Main = /*#__PURE__*/exports.Main = (0, _preactEmotion2.default)(\"main\", {\n  target: \"css-16o68ge4\"\n})(\"display:grid;grid-gap:10px;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));padding:20px;\");\n\nvar loading = /*#__PURE__*/(0, _preactEmotion.keyframes)(\"to{transform:rotate(360deg);}}\");\n\nvar Spinner = /*#__PURE__*/(0, _preactEmotion2.default)(\"div\", {\n  target: \"css-16o68ge5\"\n})(\"width:40px;height:40px;border-radius:50%;background:\", function (_ref2) {\n  var color = _ref2.color;\n  return P.lighten(0.1, color);\n}, \";border-top:4px solid #fff;border-right:4px solid #fff;border-bottom:4px solid \", function (_ref3) {\n  var color = _ref3.color;\n  return P.darken(0.2, color);\n}, \";border-left:4px solid \", function (_ref4) {\n  var color = _ref4.color;\n  return P.darken(0.2, color);\n}, \";animation:\", loading, \" 1.2s infinite linear;\");\n\nvar SpinnerWrapper = /*#__PURE__*/(0, _preactEmotion2.default)(\"div\", {\n  target: \"css-16o68ge6\"\n})(\"position:absolute;top:25%;left:50%;margin:-20px 0 0 -20px;background:\", function (_ref5) {\n  var color = _ref5.color;\n  return P.lighten(0.1, color);\n}, \";\");\n\nvar LoadingSpinner = exports.LoadingSpinner = function LoadingSpinner(_ref6) {\n  var color = _ref6.color;\n  return (0, _preact.h)(\n    SpinnerWrapper,\n    { color: color },\n    (0, _preact.h)(Spinner, { color: color })\n  );\n};\n\nvar Img = /*#__PURE__*/(0, _preactEmotion2.default)(\"img\", {\n  target: \"css-16o68ge7\"\n})(\"width:300px;height:300px;border:3px solid black;border-radius:3px;\");\n\nvar PicWrapper = /*#__PURE__*/(0, _preactEmotion2.default)(\"div\", {\n  target: \"css-16o68ge8\"\n})(\"display:flex;flex-direction:column;flex-wrap:no-wrap;justify-content:center;align-content:flex-start;align-items:center;h3{font-weight:400;text-transform:uppercase;}\");\n\nvar Pic = exports.Pic = function Pic(_ref7) {\n  var name = _ref7.name,\n      src = _ref7.src;\n  return (0, _preact.h)(\n    PicWrapper,\n    null,\n    (0, _preact.h)(\n      \"h3\",\n      null,\n      name\n    ),\n    (0, _preact.h)(Img, { src: src, alt: name })\n  );\n};\n\nvar LinkWrapper = /*#__PURE__*/(0, _preactEmotion2.default)(\"div\", {\n  target: \"css-16o68ge9\"\n})(\"display:flex;justify-content:center;align-items:center;\");\n\nvar Link = /*#__PURE__*/(0, _preactEmotion2.default)(\"a\", {\n  target: \"css-16o68ge10\"\n})(\"margin-top:20px;padding:1em 2.5em;border-radius:3px;background-color:\", function (_ref8) {\n  var color = _ref8.color;\n  return P.darken(0.4, color);\n}, \";;color:#fff;font-size:1rem;text-decoration:none;\");\n\nvar SourceLink = exports.SourceLink = function SourceLink(_ref9) {\n  var color = _ref9.color;\n  return (0, _preact.h)(\n    LinkWrapper,\n    null,\n    (0, _preact.h)(\n      Link,\n      { href: \"https://glitch.com/edit/#!/handsomely-twister\", color: color },\n      \"SOURCE\"\n    )\n  );\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMuanM/MzQ0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHN0eWxlZCwgeyBrZXlmcmFtZXMsIGluamVjdEdsb2JhbCB9IGZyb20gXCJwcmVhY3QtZW1vdGlvblwiO1xuaW1wb3J0ICogYXMgUCBmcm9tIFwicG9saXNoZWRcIjtcblxuaW5qZWN0R2xvYmFsYFxuICAqIHtcbiAgICBmb250LWZhbWlseTogQmxpbmtNYWNTeXN0ZW1Gb250LCBcIlNlZ29lIFVJXCIsIEhlbHZldGljYSwgc2Fucy1zZXJpZjtcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIG1hcmdpbjogMDtcbiAgICBwYWRkaW5nOiAwO1xuICB9XG5gO1xuXG5leHBvcnQgY29uc3QgTGV0dGVyQnV0dG9uID0gc3R5bGVkKFwiYnV0dG9uXCIpYFxuICBkaXNwbGF5OiBmbGV4O1xuICBtaW4td2lkdGg6IDEwcHg7XG4gIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgZm9udC1zaXplOiAxcmVtO1xuICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICBwYWRkaW5nOiA1cHg7XG4gIG1hcmdpbjogNXB4O1xuICBib3JkZXI6IDJweCBzb2xpZCBibGFjaztcbiAgYmFja2dyb3VuZDogJHsoeyBhY3RpdmUsIGNvbG9yIH0pID0+XG4gICAgYWN0aXZlID8gUC5kYXJrZW4oMC4yLCBjb2xvcikgOiBcIndoaXRlXCJ9O1xuYDtcblxuZXhwb3J0IGNvbnN0IE5hdiA9IHN0eWxlZChcIm5hdlwiKWBcbiAgZGlzcGxheTogZmxleDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIGFsaWduLWl0ZW1zOiBzcGFjZS1hcm91bmQ7XG5gO1xuXG5leHBvcnQgY29uc3QgQXJyb3dCdXR0b25zID0gc3R5bGVkKFwiZGl2XCIpYFxuICBkaXNwbGF5OiBmbGV4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgYWxpZ24taXRlbXM6IHNwYWNlLWFyb3VuZDtcbiAgYnV0dG9uOmxhc3Qtb2YtdHlwZSB7XG4gICAgbWFyZ2luLWxlZnQ6IDNweDtcbiAgfVxuICBwYWRkaW5nLXRvcDogMTBweDtcbmA7XG5cbmV4cG9ydCBjb25zdCBBcnJvdyA9IHN0eWxlZChcImJ1dHRvblwiKWBcbiAgcGFkZGluZzogNXB4IDE0cHg7XG4gIGZvbnQtc2l6ZTogMS41cmVtO1xuICBib3JkZXI6IDJweCBzb2xpZCBibGFjaztcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xuICBiYWNrZ3JvdW5kOiAjZmZmO1xuYDtcblxuZXhwb3J0IGNvbnN0IE1haW4gPSBzdHlsZWQoXCJtYWluXCIpYFxuICBkaXNwbGF5OiBncmlkO1xuICBncmlkLWdhcDogMTBweDtcbiAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoYXV0by1maXQsIG1pbm1heCgzMDBweCwgMWZyKSk7XG4gIHBhZGRpbmc6IDIwcHg7XG5gO1xuXG5jb25zdCBsb2FkaW5nID0ga2V5ZnJhbWVzYFxuXHR0byB7IHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH1cbn1cbmA7XG5cbmNvbnN0IFNwaW5uZXIgPSBzdHlsZWQoXCJkaXZcIilgXG4gIHdpZHRoOiA0MHB4O1xuICBoZWlnaHQ6IDQwcHg7XG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgYmFja2dyb3VuZDogJHsoeyBjb2xvciB9KSA9PiBQLmxpZ2h0ZW4oMC4xLCBjb2xvcil9O1xuXG4gIGJvcmRlci10b3A6IDRweCBzb2xpZCAjZmZmO1xuICBib3JkZXItcmlnaHQ6IDRweCBzb2xpZCAjZmZmO1xuICBib3JkZXItYm90dG9tOiA0cHggc29saWQgJHsoeyBjb2xvciB9KSA9PiBQLmRhcmtlbigwLjIsIGNvbG9yKX07XG4gIGJvcmRlci1sZWZ0OiA0cHggc29saWQgJHsoeyBjb2xvciB9KSA9PiBQLmRhcmtlbigwLjIsIGNvbG9yKX07XG5cbiAgYW5pbWF0aW9uOiAke2xvYWRpbmd9IDEuMnMgaW5maW5pdGUgbGluZWFyO1xuYDtcblxuY29uc3QgU3Bpbm5lcldyYXBwZXIgPSBzdHlsZWQoXCJkaXZcIilgXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAyNSU7XG4gIGxlZnQ6IDUwJTtcbiAgbWFyZ2luOiAtMjBweCAwIDAgLTIwcHg7XG4gIGJhY2tncm91bmQ6ICR7KHsgY29sb3IgfSkgPT4gUC5saWdodGVuKDAuMSwgY29sb3IpfTtcbmA7XG5cbmV4cG9ydCBjb25zdCBMb2FkaW5nU3Bpbm5lciA9ICh7IGNvbG9yIH0pID0+IChcbiAgPFNwaW5uZXJXcmFwcGVyIGNvbG9yPXtjb2xvcn0+XG4gICAgPFNwaW5uZXIgY29sb3I9e2NvbG9yfSAvPlxuICA8L1NwaW5uZXJXcmFwcGVyPlxuKTtcblxuY29uc3QgSW1nID0gc3R5bGVkKFwiaW1nXCIpYFxuICB3aWR0aDogMzAwcHg7XG4gIGhlaWdodDogMzAwcHg7XG4gIGJvcmRlcjogM3B4IHNvbGlkIGJsYWNrO1xuICBib3JkZXItcmFkaXVzOiAzcHg7XG5gO1xuXG5jb25zdCBQaWNXcmFwcGVyID0gc3R5bGVkKFwiZGl2XCIpYFxuICBkaXNwbGF5OmZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGZsZXgtd3JhcDogbm8td3JhcDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIGFsaWduLWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGgzIHtcbiAgICBmb250LXdlaWdodDogNDAwO1xuICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG4gIH1cbmA7XG5cbmV4cG9ydCBjb25zdCBQaWMgPSAoeyBuYW1lLCBzcmMgfSkgPT4gKFxuICA8UGljV3JhcHBlcj5cbiAgICA8aDM+e25hbWV9PC9oMz5cbiAgICA8SW1nIHNyYz17c3JjfSBhbHQ9e25hbWV9IC8+XG4gIDwvUGljV3JhcHBlcj5cbik7XG5cbmNvbnN0IExpbmtXcmFwcGVyID0gc3R5bGVkKFwiZGl2XCIpYFxuICBkaXNwbGF5OiBmbGV4O1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbmA7XG5cbmNvbnN0IExpbmsgPSBzdHlsZWQoXCJhXCIpYFxuICBtYXJnaW4tdG9wOiAyMHB4O1xuICBwYWRkaW5nOiAxZW0gMi41ZW07XG4gIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgYmFja2dyb3VuZC1jb2xvcjogJHsoeyBjb2xvciB9KSA9PiBQLmRhcmtlbigwLjQsIGNvbG9yKX07O1xuICBjb2xvcjogI2ZmZjtcbiAgZm9udC1zaXplOiAxcmVtO1xuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XG5gO1xuXG5leHBvcnQgY29uc3QgU291cmNlTGluayA9ICh7Y29sb3J9KSA9PiAoXG4gIDxMaW5rV3JhcHBlcj5cbiAgICA8TGluayBocmVmPVwiaHR0cHM6Ly9nbGl0Y2guY29tL2VkaXQvIyEvaGFuZHNvbWVseS10d2lzdGVyXCIgY29sb3I9e2NvbG9yfT5TT1VSQ0U8L0xpbms+XG4gIDwvTGlua1dyYXBwZXI+XG4pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9jb21wb25lbnRzLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7QUFEQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFRQTtBQUFBO0FBQUE7QUFTQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFLQTtBQUFBO0FBQUE7QUFDQTtBQVNBO0FBQUE7QUFBQTtBQUNBO0FBT0E7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBSUE7QUFBQTtBQUFBO0FBSUE7QUFBQTtBQUFBO0FBSUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFJQTtBQUFBO0FBQUE7QUFLQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBREE7QUFDQTtBQUtBO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFBQTtBQUFBO0FBQ0E7QUFZQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFGQTtBQURBO0FBQ0E7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQUtBO0FBQUE7QUFBQTtBQUlBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFEQTtBQURBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///31\n");

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_preact__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_emotion_utils__ = __webpack_require__(18);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_emotion__ = __webpack_require__(19);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types__ = __webpack_require__(34);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_prop_types__);\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"sheet\", function() { return __WEBPACK_IMPORTED_MODULE_2_emotion__[\"l\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"useStylisPlugin\", function() { return __WEBPACK_IMPORTED_MODULE_2_emotion__[\"m\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"registered\", function() { return __WEBPACK_IMPORTED_MODULE_2_emotion__[\"k\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"inserted\", function() { return __WEBPACK_IMPORTED_MODULE_2_emotion__[\"h\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"css\", function() { return __WEBPACK_IMPORTED_MODULE_2_emotion__[\"a\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"keyframes\", function() { return __WEBPACK_IMPORTED_MODULE_2_emotion__[\"i\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"injectGlobal\", function() { return __WEBPACK_IMPORTED_MODULE_2_emotion__[\"g\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"fontFace\", function() { return __WEBPACK_IMPORTED_MODULE_2_emotion__[\"d\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"getRegisteredStyles\", function() { return __WEBPACK_IMPORTED_MODULE_2_emotion__[\"e\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"merge\", function() { return __WEBPACK_IMPORTED_MODULE_2_emotion__[\"j\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"cx\", function() { return __WEBPACK_IMPORTED_MODULE_2_emotion__[\"b\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"hydrate\", function() { return __WEBPACK_IMPORTED_MODULE_2_emotion__[\"f\"]; });\n/* harmony namespace reexport (by provided) */ __webpack_require__.d(__webpack_exports__, \"flush\", function() { return __WEBPACK_IMPORTED_MODULE_2_emotion__[\"c\"]; });\n\n\n\n\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar _contextTypes;\n\nvar channel = '__EMOTION_THEMING__';\nvar contextTypes = (_contextTypes = {}, _contextTypes[channel] = __WEBPACK_IMPORTED_MODULE_3_prop_types___default.a.object, _contextTypes);\n\n/* global codegen */\nfunction setTheme(theme) {\n  this.setState({\n    theme: theme\n  });\n}\n\nfunction componentWillMount() {\n  if (this.context[channel] !== undefined) {\n    this.unsubscribe = this.context[channel].subscribe(setTheme.bind(this));\n  }\n}\n\nfunction componentWillUnmount() {\n  if (this.unsubscribe !== undefined) {\n    this.context[channel].unsubscribe(this.unsubscribe);\n  }\n}\n\nvar reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|accept|acceptCharset|accessKey|action|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|default|defer|dir|disabled|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|itemProp|itemScope|itemType|itemID|itemRef|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan)|(on[A-Z].*)|((data|aria)-.*))$/;\nvar testOmitPropsOnStringTag = Object(__WEBPACK_IMPORTED_MODULE_1_emotion_utils__[\"e\" /* memoize */])(function (key) {\n  return reactPropsRegex.test(key);\n});\n\nvar testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {\n  return key !== 'theme' && key !== 'innerRef';\n};\n\nvar testAlwaysTrue = function testAlwaysTrue() {\n  return true;\n};\n\nvar omitAssign = function omitAssign(testFn, target) {\n  var i = 2;\n  var length = arguments.length;\n\n  for (; i < length; i++) {\n    var source = arguments[i];\n    var key = void 0;\n\n    for (key in source) {\n      if (testFn(key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar createStyled = function createStyled(tag, options) {\n  if (true) {\n    if (tag === undefined) {\n      throw new Error('You are trying to create a styled element with an undefined component.\\nYou may have forgotten to import it.');\n    }\n  }\n\n  var identifierName;\n  var stableClassName;\n  var staticClassName;\n\n  if (options !== undefined) {\n    identifierName = options.label;\n    stableClassName = options.target;\n    staticClassName = options.e;\n  }\n\n  var isReal = tag.__emotion_real === tag;\n  var baseTag = staticClassName === undefined ? isReal && tag.__emotion_base || tag : tag;\n  var omitFn = typeof baseTag === 'string' && baseTag.charAt(0) === baseTag.charAt(0).toLowerCase() ? testOmitPropsOnStringTag : testOmitPropsOnComponent;\n  return function (strings) {\n    var styles = isReal && tag[__WEBPACK_IMPORTED_MODULE_1_emotion_utils__[\"a\" /* STYLES_KEY */]] || [];\n\n    if (identifierName !== undefined) {\n      styles = styles.concat(\"label:\" + identifierName + \";\");\n    }\n\n    if (staticClassName === undefined) {\n      for (var _len = arguments.length, interpolations = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        interpolations[_key - 1] = arguments[_key];\n      }\n\n      if (strings == null || strings.raw === undefined) {\n        styles = styles.concat(strings, interpolations);\n      } else {\n        styles = interpolations.reduce(function (array, interp, i) {\n          return array.concat(interp, strings[i + 1]);\n        }, styles.concat(strings[0]));\n      }\n    }\n\n    var Styled =\n    /*#__PURE__*/\n    function (_Component) {\n      _inheritsLoose(Styled, _Component);\n\n      function Styled() {\n        return _Component.apply(this, arguments) || this;\n      }\n\n      var _proto = Styled.prototype;\n\n      _proto.render = function render() {\n        var props = this.props,\n            state = this.state;\n        this.mergedProps = omitAssign(testAlwaysTrue, {}, props, {\n          theme: state !== null && state.theme || props.theme || {}\n        });\n        var className = '';\n        var classInterpolations = [];\n\n        if (props.className) {\n          if (staticClassName === undefined) {\n            className += Object(__WEBPACK_IMPORTED_MODULE_2_emotion__[\"e\" /* getRegisteredStyles */])(classInterpolations, props.className);\n          } else {\n            className += props.className + \" \";\n          }\n        }\n\n        if (staticClassName === undefined) {\n          className += __WEBPACK_IMPORTED_MODULE_2_emotion__[\"a\" /* css */].apply(this, styles.concat(classInterpolations));\n        } else {\n          className += staticClassName;\n        }\n\n        if (stableClassName !== undefined) {\n          className += \" \" + stableClassName;\n        }\n\n        return Object(__WEBPACK_IMPORTED_MODULE_0_preact__[\"createElement\"])(baseTag, omitAssign(omitFn, {}, props, {\n          className: className,\n          ref: props.innerRef\n        }));\n      };\n\n      return Styled;\n    }(__WEBPACK_IMPORTED_MODULE_0_preact__[\"Component\"]);\n\n    Styled.prototype.componentWillMount = componentWillMount;\n    Styled.prototype.componentWillUnmount = componentWillUnmount;\n    Styled.displayName = identifierName !== undefined ? identifierName : \"Styled(\" + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + \")\";\n    Styled.contextTypes = contextTypes;\n    Styled[__WEBPACK_IMPORTED_MODULE_1_emotion_utils__[\"a\" /* STYLES_KEY */]] = styles;\n    Styled.__emotion_base = baseTag;\n    Styled.__emotion_real = Styled;\n    Styled[__WEBPACK_IMPORTED_MODULE_1_emotion_utils__[\"c\" /* TARGET_KEY */]] = stableClassName;\n\n    Styled.withComponent = function (nextTag, nextOptions) {\n      return createStyled(nextTag, nextOptions !== undefined ? omitAssign(testAlwaysTrue, {}, options, nextOptions) : options)(styles);\n    };\n\n    return Styled;\n  };\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (createStyled);\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJlYWN0LWVtb3Rpb24vZGlzdC9pbmRleC5lcy5qcz85MTg1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBTVFlMRVNfS0VZLCBUQVJHRVRfS0VZLCBtZW1vaXplIH0gZnJvbSAnZW1vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBjc3MsIGdldFJlZ2lzdGVyZWRTdHlsZXMgfSBmcm9tICdlbW90aW9uJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIF9jb250ZXh0VHlwZXM7XG5cbnZhciBjaGFubmVsID0gJ19fRU1PVElPTl9USEVNSU5HX18nO1xudmFyIGNvbnRleHRUeXBlcyA9IChfY29udGV4dFR5cGVzID0ge30sIF9jb250ZXh0VHlwZXNbY2hhbm5lbF0gPSBQcm9wVHlwZXMub2JqZWN0LCBfY29udGV4dFR5cGVzKTtcblxuLyogZ2xvYmFsIGNvZGVnZW4gKi9cbmZ1bmN0aW9uIHNldFRoZW1lKHRoZW1lKSB7XG4gIHRoaXMuc2V0U3RhdGUoe1xuICAgIHRoZW1lOiB0aGVtZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICBpZiAodGhpcy5jb250ZXh0W2NoYW5uZWxdICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gdGhpcy5jb250ZXh0W2NoYW5uZWxdLnN1YnNjcmliZShzZXRUaGVtZS5iaW5kKHRoaXMpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgaWYgKHRoaXMudW5zdWJzY3JpYmUgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuY29udGV4dFtjaGFubmVsXS51bnN1YnNjcmliZSh0aGlzLnVuc3Vic2NyaWJlKTtcbiAgfVxufVxuXG52YXIgcmVhY3RQcm9wc1JlZ2V4ID0gL14oKGNoaWxkcmVufGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MfGtleXxyZWZ8YXV0b0ZvY3VzfGRlZmF1bHRWYWx1ZXxkZWZhdWx0Q2hlY2tlZHxpbm5lckhUTUx8c3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nfGFjY2VwdHxhY2NlcHRDaGFyc2V0fGFjY2Vzc0tleXxhY3Rpb258YWxsb3dGdWxsU2NyZWVufGFsbG93VHJhbnNwYXJlbmN5fGFsdHxhc3luY3xhdXRvQ29tcGxldGV8YXV0b1BsYXl8Y2FwdHVyZXxjZWxsUGFkZGluZ3xjZWxsU3BhY2luZ3xjaGFyU2V0fGNoZWNrZWR8Y2l0ZXxjbGFzc0lEfGNsYXNzTmFtZXxjb2xzfGNvbFNwYW58Y29udGVudHxjb250ZW50RWRpdGFibGV8Y29udGV4dE1lbnV8Y29udHJvbHN8Y29udHJvbHNMaXN0fGNvb3Jkc3xjcm9zc09yaWdpbnxkYXRhfGRhdGVUaW1lfGRlZmF1bHR8ZGVmZXJ8ZGlyfGRpc2FibGVkfGRvd25sb2FkfGRyYWdnYWJsZXxlbmNUeXBlfGZvcm18Zm9ybUFjdGlvbnxmb3JtRW5jVHlwZXxmb3JtTWV0aG9kfGZvcm1Ob1ZhbGlkYXRlfGZvcm1UYXJnZXR8ZnJhbWVCb3JkZXJ8aGVhZGVyc3xoZWlnaHR8aGlkZGVufGhpZ2h8aHJlZnxocmVmTGFuZ3xodG1sRm9yfGh0dHBFcXVpdnxpZHxpbnB1dE1vZGV8aW50ZWdyaXR5fGlzfGtleVBhcmFtc3xrZXlUeXBlfGtpbmR8bGFiZWx8bGFuZ3xsaXN0fGxvb3B8bG93fG1hcmdpbkhlaWdodHxtYXJnaW5XaWR0aHxtYXh8bWF4TGVuZ3RofG1lZGlhfG1lZGlhR3JvdXB8bWV0aG9kfG1pbnxtaW5MZW5ndGh8bXVsdGlwbGV8bXV0ZWR8bmFtZXxub25jZXxub1ZhbGlkYXRlfG9wZW58b3B0aW11bXxwYXR0ZXJufHBsYWNlaG9sZGVyfHBsYXlzSW5saW5lfHBvc3RlcnxwcmVsb2FkfHByb2ZpbGV8cmFkaW9Hcm91cHxyZWFkT25seXxyZWZlcnJlclBvbGljeXxyZWx8cmVxdWlyZWR8cmV2ZXJzZWR8cm9sZXxyb3dzfHJvd1NwYW58c2FuZGJveHxzY29wZXxzY29wZWR8c2Nyb2xsaW5nfHNlYW1sZXNzfHNlbGVjdGVkfHNoYXBlfHNpemV8c2l6ZXN8c2xvdHxzcGFufHNwZWxsQ2hlY2t8c3JjfHNyY0RvY3xzcmNMYW5nfHNyY1NldHxzdGFydHxzdGVwfHN0eWxlfHN1bW1hcnl8dGFiSW5kZXh8dGFyZ2V0fHRpdGxlfHR5cGV8dXNlTWFwfHZhbHVlfHdpZHRofHdtb2RlfHdyYXB8YWJvdXR8ZGF0YXR5cGV8aW5saXN0fHByZWZpeHxwcm9wZXJ0eXxyZXNvdXJjZXx0eXBlb2Z8dm9jYWJ8YXV0b0NhcGl0YWxpemV8YXV0b0NvcnJlY3R8YXV0b1NhdmV8Y29sb3J8aXRlbVByb3B8aXRlbVNjb3BlfGl0ZW1UeXBlfGl0ZW1JRHxpdGVtUmVmfHJlc3VsdHN8c2VjdXJpdHl8dW5zZWxlY3RhYmxlfGFjY2VudEhlaWdodHxhY2N1bXVsYXRlfGFkZGl0aXZlfGFsaWdubWVudEJhc2VsaW5lfGFsbG93UmVvcmRlcnxhbHBoYWJldGljfGFtcGxpdHVkZXxhcmFiaWNGb3JtfGFzY2VudHxhdHRyaWJ1dGVOYW1lfGF0dHJpYnV0ZVR5cGV8YXV0b1JldmVyc2V8YXppbXV0aHxiYXNlRnJlcXVlbmN5fGJhc2VsaW5lU2hpZnR8YmFzZVByb2ZpbGV8YmJveHxiZWdpbnxiaWFzfGJ5fGNhbGNNb2RlfGNhcEhlaWdodHxjbGlwfGNsaXBQYXRoVW5pdHN8Y2xpcFBhdGh8Y2xpcFJ1bGV8Y29sb3JJbnRlcnBvbGF0aW9ufGNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnN8Y29sb3JQcm9maWxlfGNvbG9yUmVuZGVyaW5nfGNvbnRlbnRTY3JpcHRUeXBlfGNvbnRlbnRTdHlsZVR5cGV8Y3Vyc29yfGN4fGN5fGR8ZGVjZWxlcmF0ZXxkZXNjZW50fGRpZmZ1c2VDb25zdGFudHxkaXJlY3Rpb258ZGlzcGxheXxkaXZpc29yfGRvbWluYW50QmFzZWxpbmV8ZHVyfGR4fGR5fGVkZ2VNb2RlfGVsZXZhdGlvbnxlbmFibGVCYWNrZ3JvdW5kfGVuZHxleHBvbmVudHxleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkfGZpbGx8ZmlsbE9wYWNpdHl8ZmlsbFJ1bGV8ZmlsdGVyfGZpbHRlclJlc3xmaWx0ZXJVbml0c3xmbG9vZENvbG9yfGZsb29kT3BhY2l0eXxmb2N1c2FibGV8Zm9udEZhbWlseXxmb250U2l6ZXxmb250U2l6ZUFkanVzdHxmb250U3RyZXRjaHxmb250U3R5bGV8Zm9udFZhcmlhbnR8Zm9udFdlaWdodHxmb3JtYXR8ZnJvbXxmcnxmeHxmeXxnMXxnMnxnbHlwaE5hbWV8Z2x5cGhPcmllbnRhdGlvbkhvcml6b250YWx8Z2x5cGhPcmllbnRhdGlvblZlcnRpY2FsfGdseXBoUmVmfGdyYWRpZW50VHJhbnNmb3JtfGdyYWRpZW50VW5pdHN8aGFuZ2luZ3xob3JpekFkdlh8aG9yaXpPcmlnaW5YfGlkZW9ncmFwaGljfGltYWdlUmVuZGVyaW5nfGlufGluMnxpbnRlcmNlcHR8a3xrMXxrMnxrM3xrNHxrZXJuZWxNYXRyaXh8a2VybmVsVW5pdExlbmd0aHxrZXJuaW5nfGtleVBvaW50c3xrZXlTcGxpbmVzfGtleVRpbWVzfGxlbmd0aEFkanVzdHxsZXR0ZXJTcGFjaW5nfGxpZ2h0aW5nQ29sb3J8bGltaXRpbmdDb25lQW5nbGV8bG9jYWx8bWFya2VyRW5kfG1hcmtlck1pZHxtYXJrZXJTdGFydHxtYXJrZXJIZWlnaHR8bWFya2VyVW5pdHN8bWFya2VyV2lkdGh8bWFza3xtYXNrQ29udGVudFVuaXRzfG1hc2tVbml0c3xtYXRoZW1hdGljYWx8bW9kZXxudW1PY3RhdmVzfG9mZnNldHxvcGFjaXR5fG9wZXJhdG9yfG9yZGVyfG9yaWVudHxvcmllbnRhdGlvbnxvcmlnaW58b3ZlcmZsb3d8b3ZlcmxpbmVQb3NpdGlvbnxvdmVybGluZVRoaWNrbmVzc3xwYW5vc2UxfHBhaW50T3JkZXJ8cGF0aExlbmd0aHxwYXR0ZXJuQ29udGVudFVuaXRzfHBhdHRlcm5UcmFuc2Zvcm18cGF0dGVyblVuaXRzfHBvaW50ZXJFdmVudHN8cG9pbnRzfHBvaW50c0F0WHxwb2ludHNBdFl8cG9pbnRzQXRafHByZXNlcnZlQWxwaGF8cHJlc2VydmVBc3BlY3RSYXRpb3xwcmltaXRpdmVVbml0c3xyfHJhZGl1c3xyZWZYfHJlZll8cmVuZGVyaW5nSW50ZW50fHJlcGVhdENvdW50fHJlcGVhdER1cnxyZXF1aXJlZEV4dGVuc2lvbnN8cmVxdWlyZWRGZWF0dXJlc3xyZXN0YXJ0fHJlc3VsdHxyb3RhdGV8cnh8cnl8c2NhbGV8c2VlZHxzaGFwZVJlbmRlcmluZ3xzbG9wZXxzcGFjaW5nfHNwZWN1bGFyQ29uc3RhbnR8c3BlY3VsYXJFeHBvbmVudHxzcGVlZHxzcHJlYWRNZXRob2R8c3RhcnRPZmZzZXR8c3RkRGV2aWF0aW9ufHN0ZW1ofHN0ZW12fHN0aXRjaFRpbGVzfHN0b3BDb2xvcnxzdG9wT3BhY2l0eXxzdHJpa2V0aHJvdWdoUG9zaXRpb258c3RyaWtldGhyb3VnaFRoaWNrbmVzc3xzdHJpbmd8c3Ryb2tlfHN0cm9rZURhc2hhcnJheXxzdHJva2VEYXNob2Zmc2V0fHN0cm9rZUxpbmVjYXB8c3Ryb2tlTGluZWpvaW58c3Ryb2tlTWl0ZXJsaW1pdHxzdHJva2VPcGFjaXR5fHN0cm9rZVdpZHRofHN1cmZhY2VTY2FsZXxzeXN0ZW1MYW5ndWFnZXx0YWJsZVZhbHVlc3x0YXJnZXRYfHRhcmdldFl8dGV4dEFuY2hvcnx0ZXh0RGVjb3JhdGlvbnx0ZXh0UmVuZGVyaW5nfHRleHRMZW5ndGh8dG98dHJhbnNmb3JtfHUxfHUyfHVuZGVybGluZVBvc2l0aW9ufHVuZGVybGluZVRoaWNrbmVzc3x1bmljb2RlfHVuaWNvZGVCaWRpfHVuaWNvZGVSYW5nZXx1bml0c1BlckVtfHZBbHBoYWJldGljfHZIYW5naW5nfHZJZGVvZ3JhcGhpY3x2TWF0aGVtYXRpY2FsfHZhbHVlc3x2ZWN0b3JFZmZlY3R8dmVyc2lvbnx2ZXJ0QWR2WXx2ZXJ0T3JpZ2luWHx2ZXJ0T3JpZ2luWXx2aWV3Qm94fHZpZXdUYXJnZXR8dmlzaWJpbGl0eXx3aWR0aHN8d29yZFNwYWNpbmd8d3JpdGluZ01vZGV8eHx4SGVpZ2h0fHgxfHgyfHhDaGFubmVsU2VsZWN0b3J8eGxpbmtBY3R1YXRlfHhsaW5rQXJjcm9sZXx4bGlua0hyZWZ8eGxpbmtSb2xlfHhsaW5rU2hvd3x4bGlua1RpdGxlfHhsaW5rVHlwZXx4bWxCYXNlfHhtbG5zfHhtbG5zWGxpbmt8eG1sTGFuZ3x4bWxTcGFjZXx5fHkxfHkyfHlDaGFubmVsU2VsZWN0b3J8enx6b29tQW5kUGFuKXwob25bQS1aXS4qKXwoKGRhdGF8YXJpYSktLiopKSQvO1xudmFyIHRlc3RPbWl0UHJvcHNPblN0cmluZ1RhZyA9IG1lbW9pemUoZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gcmVhY3RQcm9wc1JlZ2V4LnRlc3Qoa2V5KTtcbn0pO1xuXG52YXIgdGVzdE9taXRQcm9wc09uQ29tcG9uZW50ID0gZnVuY3Rpb24gdGVzdE9taXRQcm9wc09uQ29tcG9uZW50KGtleSkge1xuICByZXR1cm4ga2V5ICE9PSAndGhlbWUnICYmIGtleSAhPT0gJ2lubmVyUmVmJztcbn07XG5cbnZhciB0ZXN0QWx3YXlzVHJ1ZSA9IGZ1bmN0aW9uIHRlc3RBbHdheXNUcnVlKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBvbWl0QXNzaWduID0gZnVuY3Rpb24gb21pdEFzc2lnbih0ZXN0Rm4sIHRhcmdldCkge1xuICB2YXIgaSA9IDI7XG4gIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgIHZhciBrZXkgPSB2b2lkIDA7XG5cbiAgICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmICh0ZXN0Rm4oa2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgY3JlYXRlU3R5bGVkID0gZnVuY3Rpb24gY3JlYXRlU3R5bGVkKHRhZywgb3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICh0YWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIHRyeWluZyB0byBjcmVhdGUgYSBzdHlsZWQgZWxlbWVudCB3aXRoIGFuIHVuZGVmaW5lZCBjb21wb25lbnQuXFxuWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBpbXBvcnQgaXQuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGlkZW50aWZpZXJOYW1lO1xuICB2YXIgc3RhYmxlQ2xhc3NOYW1lO1xuICB2YXIgc3RhdGljQ2xhc3NOYW1lO1xuXG4gIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZGVudGlmaWVyTmFtZSA9IG9wdGlvbnMubGFiZWw7XG4gICAgc3RhYmxlQ2xhc3NOYW1lID0gb3B0aW9ucy50YXJnZXQ7XG4gICAgc3RhdGljQ2xhc3NOYW1lID0gb3B0aW9ucy5lO1xuICB9XG5cbiAgdmFyIGlzUmVhbCA9IHRhZy5fX2Vtb3Rpb25fcmVhbCA9PT0gdGFnO1xuICB2YXIgYmFzZVRhZyA9IHN0YXRpY0NsYXNzTmFtZSA9PT0gdW5kZWZpbmVkID8gaXNSZWFsICYmIHRhZy5fX2Vtb3Rpb25fYmFzZSB8fCB0YWcgOiB0YWc7XG4gIHZhciBvbWl0Rm4gPSB0eXBlb2YgYmFzZVRhZyA9PT0gJ3N0cmluZycgJiYgYmFzZVRhZy5jaGFyQXQoMCkgPT09IGJhc2VUYWcuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgPyB0ZXN0T21pdFByb3BzT25TdHJpbmdUYWcgOiB0ZXN0T21pdFByb3BzT25Db21wb25lbnQ7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5ncykge1xuICAgIHZhciBzdHlsZXMgPSBpc1JlYWwgJiYgdGFnW1NUWUxFU19LRVldIHx8IFtdO1xuXG4gICAgaWYgKGlkZW50aWZpZXJOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0eWxlcyA9IHN0eWxlcy5jb25jYXQoXCJsYWJlbDpcIiArIGlkZW50aWZpZXJOYW1lICsgXCI7XCIpO1xuICAgIH1cblxuICAgIGlmIChzdGF0aWNDbGFzc05hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGludGVycG9sYXRpb25zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgaW50ZXJwb2xhdGlvbnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RyaW5ncyA9PSBudWxsIHx8IHN0cmluZ3MucmF3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3R5bGVzID0gc3R5bGVzLmNvbmNhdChzdHJpbmdzLCBpbnRlcnBvbGF0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZXMgPSBpbnRlcnBvbGF0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKGFycmF5LCBpbnRlcnAsIGkpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkuY29uY2F0KGludGVycCwgc3RyaW5nc1tpICsgMV0pO1xuICAgICAgICB9LCBzdHlsZXMuY29uY2F0KHN0cmluZ3NbMF0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgU3R5bGVkID1cbiAgICAvKiNfX1BVUkVfXyovXG4gICAgZnVuY3Rpb24gKF9Db21wb25lbnQpIHtcbiAgICAgIF9pbmhlcml0c0xvb3NlKFN0eWxlZCwgX0NvbXBvbmVudCk7XG5cbiAgICAgIGZ1bmN0aW9uIFN0eWxlZCgpIHtcbiAgICAgICAgcmV0dXJuIF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3RvID0gU3R5bGVkLnByb3RvdHlwZTtcblxuICAgICAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdGhpcy5tZXJnZWRQcm9wcyA9IG9taXRBc3NpZ24odGVzdEFsd2F5c1RydWUsIHt9LCBwcm9wcywge1xuICAgICAgICAgIHRoZW1lOiBzdGF0ZSAhPT0gbnVsbCAmJiBzdGF0ZS50aGVtZSB8fCBwcm9wcy50aGVtZSB8fCB7fVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICcnO1xuICAgICAgICB2YXIgY2xhc3NJbnRlcnBvbGF0aW9ucyA9IFtdO1xuXG4gICAgICAgIGlmIChwcm9wcy5jbGFzc05hbWUpIHtcbiAgICAgICAgICBpZiAoc3RhdGljQ2xhc3NOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSArPSBnZXRSZWdpc3RlcmVkU3R5bGVzKGNsYXNzSW50ZXJwb2xhdGlvbnMsIHByb3BzLmNsYXNzTmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSArPSBwcm9wcy5jbGFzc05hbWUgKyBcIiBcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGljQ2xhc3NOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbGFzc05hbWUgKz0gY3NzLmFwcGx5KHRoaXMsIHN0eWxlcy5jb25jYXQoY2xhc3NJbnRlcnBvbGF0aW9ucykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsYXNzTmFtZSArPSBzdGF0aWNDbGFzc05hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhYmxlQ2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbGFzc05hbWUgKz0gXCIgXCIgKyBzdGFibGVDbGFzc05hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChiYXNlVGFnLCBvbWl0QXNzaWduKG9taXRGbiwge30sIHByb3BzLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgICAgcmVmOiBwcm9wcy5pbm5lclJlZlxuICAgICAgICB9KSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gU3R5bGVkO1xuICAgIH0oQ29tcG9uZW50KTtcblxuICAgIFN0eWxlZC5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gY29tcG9uZW50V2lsbE1vdW50O1xuICAgIFN0eWxlZC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBjb21wb25lbnRXaWxsVW5tb3VudDtcbiAgICBTdHlsZWQuZGlzcGxheU5hbWUgPSBpZGVudGlmaWVyTmFtZSAhPT0gdW5kZWZpbmVkID8gaWRlbnRpZmllck5hbWUgOiBcIlN0eWxlZChcIiArICh0eXBlb2YgYmFzZVRhZyA9PT0gJ3N0cmluZycgPyBiYXNlVGFnIDogYmFzZVRhZy5kaXNwbGF5TmFtZSB8fCBiYXNlVGFnLm5hbWUgfHwgJ0NvbXBvbmVudCcpICsgXCIpXCI7XG4gICAgU3R5bGVkLmNvbnRleHRUeXBlcyA9IGNvbnRleHRUeXBlcztcbiAgICBTdHlsZWRbU1RZTEVTX0tFWV0gPSBzdHlsZXM7XG4gICAgU3R5bGVkLl9fZW1vdGlvbl9iYXNlID0gYmFzZVRhZztcbiAgICBTdHlsZWQuX19lbW90aW9uX3JlYWwgPSBTdHlsZWQ7XG4gICAgU3R5bGVkW1RBUkdFVF9LRVldID0gc3RhYmxlQ2xhc3NOYW1lO1xuXG4gICAgU3R5bGVkLndpdGhDb21wb25lbnQgPSBmdW5jdGlvbiAobmV4dFRhZywgbmV4dE9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVTdHlsZWQobmV4dFRhZywgbmV4dE9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9taXRBc3NpZ24odGVzdEFsd2F5c1RydWUsIHt9LCBvcHRpb25zLCBuZXh0T3B0aW9ucykgOiBvcHRpb25zKShzdHlsZXMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3R5bGVkO1xuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlU3R5bGVkO1xuZXhwb3J0ICogZnJvbSAnZW1vdGlvbic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3ByZWFjdC1lbW90aW9uL2Rpc3QvaW5kZXguZXMuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///32\n");

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (factory) {\n\t true ? (module['exports'] = factory()) :\n\t\ttypeof define === 'function' && define['amd'] ? define(factory()) :\n\t\t\t(window['stylisRuleSheet'] = factory())\n}(function () {\n\n\t'use strict'\n\n\treturn function (insertRule) {\n\t\tvar delimiter = '/*|*/'\n\t\tvar needle = delimiter+'}'\n\n\t\tfunction toSheet (block) {\n\t\t\tif (block)\n\t\t\t\ttry {\n\t\t\t\t\tinsertRule(block + '}')\n\t\t\t\t} catch (e) {}\n\t\t}\n\n\t\treturn function ruleSheet (context, content, selectors, parents, line, column, length, at, depth) {\n\t\t\tswitch (context) {\n\t\t\t\t// property\n\t\t\t\tcase 1:\n\t\t\t\t\t// @import\n\t\t\t\t\tif (depth === 0 && content.charCodeAt(0) === 64)\n\t\t\t\t\t\tinsertRule(content)\n\t\t\t\t\tbreak\n\t\t\t\t// selector\n\t\t\t\tcase 2:\n\t\t\t\t\tif (at === 0)\n\t\t\t\t\t\treturn content + delimiter\n\t\t\t\t\tbreak\n\t\t\t\t// at-rule\n\t\t\t\tcase 3:\n\t\t\t\t\tswitch (at) {\n\t\t\t\t\t\t// @font-face, @page\n\t\t\t\t\t\tcase 102:\n\t\t\t\t\t\tcase 112:\n\t\t\t\t\t\t\treturn insertRule(selectors[0]+content), ''\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn content + delimiter\n\t\t\t\t\t}\n\t\t\t\tcase -2:\n\t\t\t\t\tcontent.split(needle).forEach(toSheet)\n\t\t\t}\n\t\t}\n\t}\n}))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGlzLXJ1bGUtc2hlZXQvaW5kZXguanM/MjBjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gKG1vZHVsZVsnZXhwb3J0cyddID0gZmFjdG9yeSgpKSA6XG5cdFx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbJ2FtZCddID8gZGVmaW5lKGZhY3RvcnkoKSkgOlxuXHRcdFx0KHdpbmRvd1snc3R5bGlzUnVsZVNoZWV0J10gPSBmYWN0b3J5KCkpXG59KGZ1bmN0aW9uICgpIHtcblxuXHQndXNlIHN0cmljdCdcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluc2VydFJ1bGUpIHtcblx0XHR2YXIgZGVsaW1pdGVyID0gJy8qfCovJ1xuXHRcdHZhciBuZWVkbGUgPSBkZWxpbWl0ZXIrJ30nXG5cblx0XHRmdW5jdGlvbiB0b1NoZWV0IChibG9jaykge1xuXHRcdFx0aWYgKGJsb2NrKVxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGluc2VydFJ1bGUoYmxvY2sgKyAnfScpXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJ1bGVTaGVldCAoY29udGV4dCwgY29udGVudCwgc2VsZWN0b3JzLCBwYXJlbnRzLCBsaW5lLCBjb2x1bW4sIGxlbmd0aCwgYXQsIGRlcHRoKSB7XG5cdFx0XHRzd2l0Y2ggKGNvbnRleHQpIHtcblx0XHRcdFx0Ly8gcHJvcGVydHlcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRcdC8vIEBpbXBvcnRcblx0XHRcdFx0XHRpZiAoZGVwdGggPT09IDAgJiYgY29udGVudC5jaGFyQ29kZUF0KDApID09PSA2NClcblx0XHRcdFx0XHRcdGluc2VydFJ1bGUoY29udGVudClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHQvLyBzZWxlY3RvclxuXHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0aWYgKGF0ID09PSAwKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGNvbnRlbnQgKyBkZWxpbWl0ZXJcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHQvLyBhdC1ydWxlXG5cdFx0XHRcdGNhc2UgMzpcblx0XHRcdFx0XHRzd2l0Y2ggKGF0KSB7XG5cdFx0XHRcdFx0XHQvLyBAZm9udC1mYWNlLCBAcGFnZVxuXHRcdFx0XHRcdFx0Y2FzZSAxMDI6XG5cdFx0XHRcdFx0XHRjYXNlIDExMjpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGluc2VydFJ1bGUoc2VsZWN0b3JzWzBdK2NvbnRlbnQpLCAnJ1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGNvbnRlbnQgKyBkZWxpbWl0ZXJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgLTI6XG5cdFx0XHRcdFx0Y29udGVudC5zcGxpdChuZWVkbGUpLmZvckVhY2godG9TaGVldClcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0pKVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGlzLXJ1bGUtc2hlZXQvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///33\n");

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&\n    Symbol.for &&\n    Symbol.for('react.element')) ||\n    0xeac7;\n\n  var isValidElement = function(object) {\n    return typeof object === 'object' &&\n      object !== null &&\n      object.$$typeof === REACT_ELEMENT_TYPE;\n  };\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(35)(isValidElement, throwOnDirectAccess);\n} else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = require('./factoryWithThrowingShims')();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcz8yOTIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgU3ltYm9sLmZvciAmJlxuICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAweGVhYzc7XG5cbiAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9O1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///34\n");

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar emptyFunction = __webpack_require__(20);\nvar invariant = __webpack_require__(21);\nvar warning = __webpack_require__(22);\nvar assign = __webpack_require__(36);\n\nvar ReactPropTypesSecret = __webpack_require__(23);\nvar checkPropTypes = __webpack_require__(37);\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message) {\n    this.message = message;\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          invariant(\n            false,\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n        } else if (\"development\" !== 'production' && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            warning(\n              false,\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `%s` prop on `%s`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',\n              propFullName,\n              componentName\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunction.thatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n       true ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;\n      return emptyFunction.thatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues);\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (propValue.hasOwnProperty(key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;\n      return emptyFunction.thatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        warning(\n          false,\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received %s at index %s.',\n          getPostfixForTypeWarning(checker),\n          i\n        );\n        return emptyFunction.thatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n          return null;\n        }\n      }\n\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          continue;\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from\n      // props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcz8yNmQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCVzYCBwcm9wIG9uIGAlc2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nLFxuICAgICAgICAgICAgICBwcm9wRnVsbE5hbWUsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAlcyBhdCBpbmRleCAlcy4nLFxuICAgICAgICAgIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///35\n");

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcz8wNDQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///36\n");

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  var invariant = __webpack_require__(21);\n  var warning = __webpack_require__(22);\n  var ReactPropTypesSecret = __webpack_require__(23);\n  var loggedTypeFailures = {};\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (typeSpecs.hasOwnProperty(typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcz8yMWVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG4gIHZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGludmFyaWFudCh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAndGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCVzYC4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSk7XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcik7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///37\n");

/***/ })
/******/ ]);